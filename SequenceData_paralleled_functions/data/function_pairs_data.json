{"data": [{"ghidra": ["\n", "int tenpow(int exponent)\n", "\n", "{\n", "  int i;\n", "  int output;\n", "  \n", "  output = 1;\n", "  i = 0;\n", "  while (i < exponent) {\n", "    output = output * 10;\n", "    i = i + 1;\n", "  }\n", "  return output;\n", "}\n", "\n"], "c": ["int tenpow(int exponent) {\n", "    int output = 1;\n", "    for(int i=0; i < exponent; i++)\n", "        output *= 10;\n", "    return output;\n", "}"]}, {"ghidra": ["\n", "void save_score(int time_taken)\n", "\n", "{\n", "  char cVar1;\n", "  int iVar2;\n", "  __uid_t __uid;\n", "  tm *__tp;\n", "  char *__src;\n", "  size_t sVar3;\n", "  size_t sVar4;\n", "  char *msg;\n", "  int *piVar5;\n", "  DIR *pDVar6;\n", "  passwd *ppVar7;\n", "  ulong uVar8;\n", "  byte bVar9;\n", "  undefined4 local_10ec;\n", "  char appdata_dir [4096];\n", "  char tmpbuffer [129];\n", "  time_t tm;\n", "  passwd *pwd;\n", "  int ret;\n", "  DIR *dp;\n", "  char *scorefile;\n", "  char *score_filename;\n", "  tm *today;\n", "  FILE *sfp;\n", "  \n", "  bVar9 = 0;\n", "  local_10ec = time_taken;\n", "  tm = time((time_t *)0x0);\n", "  localtime(&tm);\n", "  __tp = localtime(&tm);\n", "  __src = getenv(\"HOME\");\n", "  strcpy(appdata_dir,__src);\n", "  uVar8 = 0xffffffffffffffff;\n", "  __src = appdata_dir;\n", "  do {\n", "    if (uVar8 == 0) break;\n", "    uVar8 = uVar8 - 1;\n", "    cVar1 = *__src;\n", "    __src = __src + (ulong)bVar9 * -2 + 1;\n", "  } while (cVar1 != '\\0');\n", "  uVar8 = ~uVar8;\n", "  *(undefined8 *)(&local_10ec + uVar8 + 3) = 0x7469676964342e2f;\n", "  *(undefined2 *)(appdata_dir + uVar8 + 7) = 0x2f73;\n", "  appdata_dir[uVar8 + 9] = '\\0';\n", "  sVar3 = strlen(appdata_dir);\n", "  sVar4 = strlen(\"4digits.4digits.scores\");\n", "  __src = (char *)malloc(sVar4 + sVar3 + 1);\n", "  if (__src == (char *)0x0) {\n", "    msg = (char *)gettext(\"Memory allocation error.\\n\");\n", "    err_exit(msg);\n", "  }\n", "  strcpy(__src,appdata_dir);\n", "  strcat(__src,\"4digits.4digits.scores\");\n", "  sfp = (FILE *)fopen(__src,\"a+\");\n", "  if (sfp == (FILE *)0x0) {\n", "    piVar5 = __errno_location();\n", "    if (*piVar5 == 2) {\n", "      pDVar6 = opendir(appdata_dir);\n", "      if ((pDVar6 == (DIR *)0x0) && (piVar5 = __errno_location(), *piVar5 == 2)) {\n", "        iVar2 = mkdir(appdata_dir,0x1c0);\n", "        if (iVar2 == -1) {\n", "          msg = (char *)gettext(\"Cannot open score file.\\n\");\n", "          err_exit(msg);\n", "        }\n", "        sfp = (FILE *)fopen(__src,\"a+\");\n", "      }\n", "    }\n", "    else {\n", "      msg = (char *)gettext(\"Cannot open score file.\\n\");\n", "      err_exit(msg);\n", "    }\n", "  }\n", "  strftime(tmpbuffer,0x80,\"%a %b %d %H:%M:%S %Y\",__tp);\n", "  __uid = geteuid();\n", "  ppVar7 = getpwuid(__uid);\n", "  fprintf((FILE *)sfp,\"%s %ds %s\\n\",ppVar7->pw_name,(ulong)local_10ec,tmpbuffer);\n", "  free(__src);\n", "  return;\n", "}\n", "\n"], "c": ["void save_score(const int time_taken) {\n", "    time_t tm = time(NULL);\n", "    struct tm *today = localtime(&tm);\n", "    char tmpbuffer[129];\n", "    today = localtime(&tm);\n", "    char appdata_dir[4096]; //XXX why _PC_PATH_MAX is only 4?\n", "    const char *score_filename = \"4digits.4digits.scores\";\n", "    strcpy(appdata_dir, getenv(\"HOME\"));\n", "    strcat(appdata_dir, \"/.4digits/\");\n", "    char *scorefile = (char*)malloc(strlen(appdata_dir) + strlen(score_filename) + 1);\n", "    if(!scorefile)\n", "        err_exit(_(\"Memory allocation error.\\n\"));\n", "    strcpy(scorefile, appdata_dir);\n", "    strcat(scorefile, score_filename);\n", "\n", "    FILE *sfp = fopen(scorefile, \"a+\");\n", "    if (!sfp) {\n", "        if (errno == ENOENT) {\n", "            DIR *dp = opendir(appdata_dir);\n", "            if(!dp)\n", "                if (errno == ENOENT) {\n", "                    int ret = mkdir(appdata_dir, 0700);\n", "                    if (ret == -1)\n", "                        err_exit(_(\"Cannot open score file.\\n\"));\n", "                    sfp = fopen(scorefile, \"a+\");\n", "                }\n", "        }\n", "        else\n", "            err_exit(_(\"Cannot open score file.\\n\"));\n", "    }\n", "\n", "    strftime(tmpbuffer, 128, \"%a %b %d %H:%M:%S %Y\", today);\n", "    struct passwd *pwd;\n", "    pwd = getpwuid(geteuid());\n", "    // but getenv(\"USERNAME\") conforms to C99 thus is more portable.\n", "    fprintf(sfp, \"%s %ds %s\\n\", pwd->pw_name, time_taken, tmpbuffer);\n", "    free(scorefile);\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  int iVar1;\n", "  undefined8 uVar2;\n", "  undefined8 uVar3;\n", "  char *msg;\n", "  time_t tVar4;\n", "  uint time_taken;\n", "  int in_digits [4];\n", "  int B;\n", "  int A;\n", "  int guessed [8];\n", "  int ans_digits [4];\n", "  int longIndex;\n", "  int score;\n", "  time_t toc;\n", "  int input;\n", "  time_t tic;\n", "  time_t temp;\n", "  int i_2;\n", "  int i_1;\n", "  int num_guess;\n", "  _Bool dup;\n", "  int i;\n", "  int opt;\n", "  \n", "  longIndex = 0;\n", "  globalArgs = (char *)0x0;\n", "  setlocale(6,\"\");\n", "  bindtextdomain(\"4digits\",\"/usr/share/locale/\");\n", "  textdomain(\"4digits\");\n", "  opt = getopt_long((ulong)(uint)argc,argv,optString,longOpts,&longIndex);\n", "  while (opt != -1) {\n", "    if (opt == 0x3f) {\n", "      msg = (char *)gettext(\n", "                           \"Usage: 4digits [OPTION]...\\nTry `4digits --help\\' for more information.\"\n", "                           );\n", "      err_exit(msg);\n", "    }\n", "    else {\n", "      if (opt < 0x40) {\n", "        if (opt == 0) {\n", "          strcmp(\"version\",longOpts[longIndex].name);\n", "        }\n", "      }\n", "      else {\n", "        if (opt == 0x68) {\n", "          msg = (char *)gettext(\n", "                               \"4digits, a guess-the-number game.\\nUsage: 4digits [OPTION] ...\\n\\nYou are given eight times to guess a four-digit number. You get\\none A if its value and position are both correct, and you get one\\nB if only its value is correct. You win the game when you get 4A0B.\\n\\n-v, --version \\t display the version of 4digits and exit.\\n-h, -?, --help \\t print this help.\\n\\nReport bugs at <https://github.com/fossilet/4digits/issues>.\"\n", "                               );\n", "          err_exit(msg);\n", "        }\n", "        else {\n", "          if (opt == 0x76) {\n", "            globalArgs = \"1.1.4\";\n", "            uVar2 = gettext(\"Written by Pan Yongzhi.\\n\");\n", "            uVar3 = gettext(\n", "                           \"4digits comes with NO WARRANTY to the extent permitted by law.\\nThis program is free software; you can redistribute it and/or\\nmodify it under the terms of the GNU General Public License as\\npublished by the Free Software Foundation - version 2. For more\\ninformation about these matters, see the file named COPYING.\\n\"\n", "                           );\n", "            printf(\"%s\\n%s\\n%s\",\"4digits 1.1.4\",uVar3,uVar2);\n", "                    /* WARNING: Subroutine does not return */\n", "            exit(1);\n", "          }\n", "        }\n", "      }\n", "    }\n", "    opt = getopt_long((ulong)(uint)argc,argv,optString,longOpts,&longIndex);\n", "  }\n", "  gen_rand(ans_digits);\n", "  tic = time((time_t *)0x0);\n", "  guessed._0_8_ = 0;\n", "  guessed._8_8_ = 0;\n", "  guessed._16_8_ = 0;\n", "  guessed._24_8_ = 0;\n", "  dup = false;\n", "  num_guess = 0;\n", "  do {\n", "    if (7 < num_guess) {\n", "      msg = (char *)gettext(\"\\nHaha, you lose. It is \");\n", "      printf(msg);\n", "      i_2 = 0;\n", "      while (i_2 < 4) {\n", "        printf(\"%d\",(ulong)(uint)ans_digits[i_2]);\n", "        i_2 = i_2 + 1;\n", "      }\n", "      puts(\".\");\n", "      return 0;\n", "    }\n", "    A = 0;\n", "    B = 0;\n", "    input = enter_number();\n", "    i_1 = 0;\n", "    while (i_1 < num_guess) {\n", "      if (guessed[i_1] == input) {\n", "        msg = (char *)gettext(\"You\\'ve already guessed it.\\n\");\n", "        fprintf(stderr,msg);\n", "        num_guess = num_guess + -1;\n", "        dup = true;\n", "        break;\n", "      }\n", "      i_1 = i_1 + 1;\n", "    }\n", "    if (dup == false) {\n", "      i = 0;\n", "      while (i < 4) {\n", "        iVar1 = tenpow(3 - i);\n", "        in_digits[i] = (input / iVar1) % 10;\n", "        i = i + 1;\n", "      }\n", "      compare(in_digits,ans_digits,&A,&B);\n", "      printf(\"%dA%dB    \",(ulong)(uint)A,(ulong)(uint)B);\n", "      if (num_guess != 7) {\n", "        msg = (char *)ngettext(\"\\t %d time left.\\n\",\"\\t %d times left.\\n\",(long)(7 - num_guess));\n", "        printf(msg,(ulong)(7 - num_guess));\n", "      }\n", "      guessed[num_guess] = input;\n", "      if (A == 4) {\n", "        tVar4 = time((time_t *)0x0);\n", "        time_taken = (int)tVar4 - (int)tic;\n", "        msg = (char *)gettext(\"You win! :) Used %d sec.\\n\");\n", "        printf(msg,(ulong)time_taken);\n", "        save_score(time_taken);\n", "        return 0;\n", "      }\n", "    }\n", "    else {\n", "      dup = false;\n", "    }\n", "    num_guess = num_guess + 1;\n", "  } while( true );\n", "}\n", "\n"], "c": ["int main(int argc, char *argv[]) {\n", "    int opt = 0;\n", "    int longIndex = 0;\n", "\n", "    /* Initialize globalArgs before we get to work. */\n", "    globalArgs.version = NULL;    /* false */\n", "\n", "\t//prepare i18n\n", "\tsetlocale(LC_ALL, \"\");\n", "\tbindtextdomain(\"4digits\", LOCALE_PATH);\n", "\ttextdomain(\"4digits\");\n", "\n", "    // Process the arguments with getopt_long(), then populate globalArgs\n", "    opt = getopt_long(argc, argv, optString, longOpts, &longIndex);\n", "    while(opt != -1) {\n", "        switch(opt) {\n", "            case 'v':\n", "                globalArgs.version = VERSION_STRING;\n", "                printf(\"%s\\n%s\\n%s\", VERSION, _(COPYRIGHT), _(AUTHOR));\n", "                exit(1);\n", "            case 'h':\n", "                err_exit(_(HELP));\n", "                break;\n", "            case '?': /* fall-through is intentional */\n", "                err_exit(_(\"Usage: 4digits [OPTION]...\\n\"\n", "                        \"Try `4digits --help' for more information.\"));\n", "                break;\n", "            case 0:    /* long option without a short arg */\n", "                if(strcmp(\"version\", longOpts[longIndex].name) == 0)\n", "                    break;\n", "                break;\n", "            default:\n", "                /* You won't actually get here. */\n", "                break;\n", "        }\n", "        opt = getopt_long(argc, argv, optString, longOpts, &longIndex);\n", "    }\n", "\n", "    int ans_digits[4];\n", "    gen_rand(ans_digits); /* array for the 4 digits of n*/\n", "    time_t temp = time(NULL);\n", "    time_t tic = temp;\n", "    int guessed[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n", "    int i;\n", "    bool dup = false;\n", "\n", "    for (int num_guess = 0; num_guess < 8; num_guess++) {\n", "        int A = 0, B = 0;\n", "        int input = enter_number();\n", "\n", "        for(int i=0; i < num_guess; i++)\n", "            // duplicated input\n", "            if (input == guessed[i]) {\n", "                fprintf(stderr, _(\"You've already guessed it.\\n\"));\n", "                --num_guess;\n", "                dup = true;\n", "                break;\n", "            }\n", "\n", "        if (dup == true) {\n", "            dup = false;\n", "            continue;\n", "        }\n", "\n", "        int in_digits[4]; /* arrays for the 4 digits of input*/\n", "        for(i=0; i<4; i++) {\n", "            in_digits[i]=(int) (input / tenpow(3-i) )%10;\n", "        }\n", "\n", "        compare(in_digits, ans_digits, &A, &B);\n", "        printf(\"%dA%dB    \", A, B);\n", "        if (num_guess != 7)\n", "            printf(ngettext(\"\\t %d time left.\\n\", \"\\t %d times left.\\n\", 7-num_guess), 7-num_guess);\n", "        guessed[num_guess] = input;\n", "\n", "        if(A == 4) {\n", "            time_t toc = time(NULL);\n", "            int score = (int)(toc-tic);\n", "            printf(_(\"You win! :) Used %d sec.\\n\"), score);\n", "            save_score(score); /* save score in the score file */\n", "            return 0;\n", "        }\n", "    }\n", "    printf(_(\"\\nHaha, you lose. It is \"));\n", "    for(int i = 0; i < 4; i++)\n", "        printf(\"%d\", ans_digits[i]);\n", "    printf(\".\\n\");\n", "    return 0;\n", "}"]}, {"ghidra": ["\n", "void err_exit(char *msg)\n", "\n", "{\n", "  fprintf(stderr,\"%s\\n\",msg);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(1);\n", "}\n", "\n"], "c": ["void err_exit(const char* msg) {\n", "    fprintf(stderr, \"%s\\n\", msg);\n", "    exit(EXIT_FAILURE);\n", "}"]}, {"ghidra": ["\n", "int enter_number(void)\n", "\n", "{\n", "  bool bVar1;\n", "  int iVar2;\n", "  char *__format;\n", "  int in_digits [4];\n", "  char mstr [5];\n", "  int c;\n", "  int i;\n", "  _Bool flag;\n", "  _Bool reinput;\n", "  int input;\n", "  \n", "  mstr[0] = '\\0';\n", "  mstr[1] = '\\0';\n", "  mstr[2] = '\\0';\n", "  mstr[3] = '\\0';\n", "  mstr[4] = '\\0';\n", "  in_digits[0] = 0;\n", "  in_digits[1] = 0;\n", "  in_digits[2] = 0;\n", "  in_digits[3] = 0;\n", "  do {\n", "    reinput = false;\n", "    __format = (char *)gettext(\"Input a 4-digit number:\");\n", "    printf(__format);\n", "    __format = fgets(mstr,5,stdin);\n", "    if (__format == (char *)0x0) {\n", "      __format = (char *)gettext(\"Something\\'s got wrong, I\\'d better quit...\\n\");\n", "      err_exit(__format);\n", "    }\n", "    bVar1 = false;\n", "    if ((((mstr[0] != '\\n') && (mstr[1] != '\\n')) && (mstr[2] != '\\n')) && (mstr[3] != '\\n')) {\n", "      while ((iVar2 = getchar(), iVar2 != 10 && (iVar2 != -1))) {\n", "        bVar1 = true;\n", "      }\n", "    }\n", "    if (bVar1) {\n", "      __format = (char *)gettext(\"Input too long!\\n\");\n", "      fprintf(stderr,__format);\n", "      reinput = true;\n", "    }\n", "    else {\n", "      input = atoi(mstr);\n", "      if ((input < 1000) || (9999 < input)) {\n", "        __format = (char *)gettext(\"Must be a number between 1000 and 9999!\\n\");\n", "        fprintf(stderr,__format);\n", "        reinput = true;\n", "      }\n", "      else {\n", "        i = 0;\n", "        while (i < 4) {\n", "          iVar2 = tenpow(3 - i);\n", "          in_digits[i] = (input / iVar2) % 10;\n", "          i = i + 1;\n", "        }\n", "        if (((((in_digits[0] == in_digits[1]) || (in_digits[1] == in_digits[2])) ||\n", "             (in_digits[2] == in_digits[3])) ||\n", "            ((in_digits[0] == in_digits[2] || (in_digits[0] == in_digits[3])))) ||\n", "           (in_digits[1] == in_digits[3])) {\n", "          __format = (char *)gettext(\"Four digits must be unique.\\n\");\n", "          fprintf(stderr,__format);\n", "          reinput = true;\n", "        }\n", "      }\n", "    }\n", "  } while (reinput != false);\n", "  return input;\n", "}\n", "\n"], "c": ["int enter_number() {\n", "    char mstr[5]={'\\0','\\0','\\0','\\0','\\0'};\n", "    int c;\n", "    int input;\n", "    int in_digits[4]={0,0,0,0}; /* arrays for the 4 digits of input*/\n", "    bool reinput;\n", "    do {\n", "        reinput = false;\n", "        printf(_(\"Input a 4-digit number:\"));\n", "        if(fgets(mstr, sizeof mstr, stdin) == NULL)\n", "            err_exit(_(\"Something's got wrong, I'd better quit...\\n\"));\n", "        // fgets appends the newline entered, if it appears in the first 4\n", "        // elements of mstr, then it's sure less than 4 digits are entered\n", "        bool flag = false;\n", "        if(mstr[0]!='\\n'&& mstr[1]!='\\n'&& mstr[2]!='\\n' &&mstr[3]!='\\n')\n", "            /* discard the character */\n", "            while((c = getchar()) != '\\n' && c != EOF)\n", "                flag = true;\n", "        if (flag == true) {\n", "            fprintf(stderr, _(\"Input too long!\\n\"));\n", "            reinput = true;\n", "            continue;\n", "        }\n", "        input = atoi(mstr);\n", "        if (input < 1000 || input > 9999) {\n", "            fprintf(stderr, _(\"Must be a number between 1000 and 9999!\\n\"));\n", "            reinput = true;\n", "            continue;\n", "        }\n", "        for(int i=0; i<4; i++)\n", "            in_digits[i]=(int) (input / tenpow(3-i) )%10;\n", "        if(in_digits[0]==in_digits[1] || in_digits[1]==in_digits[2]\n", "                || in_digits[2]==in_digits[3] || in_digits[0]==in_digits[2]\n", "                || in_digits[0]==in_digits[3] || in_digits[1]==in_digits[3])\n", "        {\n", "            fprintf(stderr, _(\"Four digits must be unique.\\n\"));\n", "            reinput = true;\n", "            continue;\n", "        }\n", "    }while(reinput);\n", "    return input;\n", "}"]}, {"ghidra": ["\n", "void compare(int *in_digits,int *ans_digits,int *a,int *b)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  \n", "  iVar1 = 0;\n", "  while (iVar1 < 4) {\n", "    iVar2 = 0;\n", "    while (iVar2 < 4) {\n", "      if (in_digits[iVar1] == ans_digits[iVar2]) {\n", "        if (iVar1 == iVar2) {\n", "          *a = *a + 1;\n", "        }\n", "        else {\n", "          *b = *b + 1;\n", "        }\n", "      }\n", "      iVar2 = iVar2 + 1;\n", "    }\n", "    iVar1 = iVar1 + 1;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void compare(const int *in_digits, const int *ans_digits, int *a, int *b) {\n", "    for(register int i=0 ; i<4; i++)\n", "        for(register int j=0 ; j<4; j++)\n", "            if(in_digits[i] == ans_digits[j])\n", "                (i == j) ? (*a)++ : (*b)++;\n", "}"]}, {"ghidra": ["\n", "void gen_rand(int *ans_digits)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  time_t tVar3;\n", "  int ans;\n", "  int i_1;\n", "  int i;\n", "  \n", "  tVar3 = time((time_t *)0x0);\n", "  srand((uint)tVar3);\n", "  iVar1 = rand();\n", "  i = 0;\n", "  while (i < 4) {\n", "    iVar2 = tenpow(3 - i);\n", "    ans_digits[i] =\n", "         (((int)(((double)iVar1 * 8999.00000000) / 2147483647.00000000) + 1000) / iVar2) % 10;\n", "    i = i + 1;\n", "  }\n", "  while ((((*ans_digits == ans_digits[1] || (ans_digits[1] == ans_digits[2])) ||\n", "          (ans_digits[2] == ans_digits[3])) ||\n", "         (((*ans_digits == ans_digits[2] || (*ans_digits == ans_digits[3])) ||\n", "          (ans_digits[1] == ans_digits[3]))))) {\n", "    iVar1 = rand();\n", "    i_1 = 0;\n", "    while (i_1 < 4) {\n", "      iVar2 = tenpow(3 - i_1);\n", "      ans_digits[i_1] =\n", "           (((int)(((double)iVar1 / 2147483647.00000000) * 8999.00000000) + 1000) / iVar2) % 10;\n", "      i_1 = i_1 + 1;\n", "    }\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void gen_rand(int ans_digits[]) {\n", "    srand((unsigned)time(NULL));\n", "    int ans = 1000 + (int)(8999.0*rand()/RAND_MAX);\n", "    for(int i=0; i<4; i++)\n", "        ans_digits[i] = (int)(ans/tenpow(3-i)) % 10;\n", "\n", "    /* if 4 digits is not different from each other, regenerate it*/\n", "    while(ans_digits[0]==ans_digits[1] || ans_digits[1]==ans_digits[2]\n", "            || ans_digits[2]==ans_digits[3] || ans_digits[0]==ans_digits[2]\n", "            || ans_digits[0]==ans_digits[3] || ans_digits[1]==ans_digits[3])\n", "    {\n", "        ans = 1000 + (int)(8999.0 * ((double)rand()/RAND_MAX));\n", "        for(int i=0; i<4; i++)\n", "            ans_digits[i] = (int)(ans / tenpow(3-i))%10;\n", "    }\n", "#ifdef DEBUG\n", "    printf(\"%d\\n\", ans);\n", "#endif\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  return 0;\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\n", "  return 0;\n", "}"]}, {"ghidra": ["\n", "int next_tok(void)\n", "\n", "{\n", "  char *pcVar1;\n", "  uint uVar2;\n", "  bool bVar3;\n", "  int unget;\n", "  uint uVar4;\n", "  uint uVar5;\n", "  char cVar6;\n", "  char *pcVar7;\n", "  \n", "  bVar3 = false;\n", "  uVar5 = 0;\n", "  pcVar7 = tok;\n", "  do {\n", "    do {\n", "      uVar4 = unget;\n", "      if (unget == 0) {\n", "        uVar4 = lgetc(yyin);\n", "      }\n", "      unget = 0;\n", "      uVar2 = ascii_tab[uVar4 & 0x7f].flags;\n", "      if (tok + 0x3fe < pcVar7) {\n", "        return 300;\n", "      }\n", "    } while (10 < uVar5);\n", "    cVar6 = (char)uVar4;\n", "    switch(uVar5) {\n", "    case 0:\n", "      if (uVar4 == 0xffffffff) {\n", "        return -1;\n", "      }\n", "      if ((uVar2 & 8) == 0) {\n", "        if ((uVar2 & 2) == 0) {\n", "          if ((uVar4 == 0x2e) || ((uVar2 & 1) != 0)) {\n", "            uVar5 = 2;\n", "            unget = uVar4;\n", "          }\n", "          else {\n", "            switch(uVar4) {\n", "            case 10:\n", "              return 0x12a;\n", "            case 0x22:\n", "              uVar5 = 8;\n", "              break;\n", "            case 0x24:\n", "              uVar5 = 1;\n", "              break;\n", "            case 0x27:\n", "              uVar5 = 4;\n", "              break;\n", "            case 0x3b:\n", "              uVar5 = 6;\n", "              break;\n", "            case 0x3c:\n", "              uVar5 = 9;\n", "              break;\n", "            case 0x3e:\n", "              uVar5 = 10;\n", "              break;\n", "            case 0x40:\n", "              uVar4 = 299;\n", "            default:\n", "              goto LAB_004077f0;\n", "            }\n", "          }\n", "        }\n", "        else {\n", "          *pcVar7 = cVar6;\n", "          uVar5 = 3;\n", "          pcVar7 = pcVar7 + 1;\n", "        }\n", "      }\n", "      break;\n", "    case 1:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x102;\n", "      }\n", "      if ((uVar2 & 4) == 0) {\n", "        *pcVar7 = '\\0';\n", "        return 0x102;\n", "      }\n", "      *pcVar7 = cVar6;\n", "      pcVar7 = pcVar7 + 1;\n", "      break;\n", "    case 2:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x104 - (uint)!bVar3;\n", "      }\n", "      if (((uVar2 & 1) == 0) && ((uVar4 != 0x2e || (bVar3)))) {\n", "        *pcVar7 = '\\0';\n", "        return 0x104 - (uint)!bVar3;\n", "      }\n", "      *pcVar7 = cVar6;\n", "      pcVar7 = pcVar7 + 1;\n", "      if (uVar4 == 0x2e) {\n", "        bVar3 = true;\n", "      }\n", "      break;\n", "    case 3:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x112;\n", "      }\n", "      if (uVar4 == 0x3a) {\n", "        *pcVar7 = ':';\n", "        pcVar7[1] = '\\0';\n", "        return 0x112;\n", "      }\n", "      if ((uVar2 & 3) == 0) {\n", "        *pcVar7 = '\\0';\n", "        return 0x112;\n", "      }\n", "      *pcVar7 = cVar6;\n", "      pcVar7 = pcVar7 + 1;\n", "      break;\n", "    case 4:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x114;\n", "      }\n", "      if (uVar4 == 0x5c) {\n", "        uVar5 = 5;\n", "      }\n", "      else {\n", "        if (uVar4 == 0x27) {\n", "          *pcVar7 = '\\0';\n", "          return 0x114;\n", "        }\n", "        pcVar1 = pcVar7 + 1;\n", "        *pcVar7 = cVar6;\n", "        pcVar7 = pcVar1;\n", "        if (tok + 1 < pcVar1) {\n", "          uVar5 = 7;\n", "        }\n", "      }\n", "      break;\n", "    case 5:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x114;\n", "      }\n", "      if (uVar4 == 0x66) {\n", "        *pcVar7 = '\\f';\n", "        break;\n", "      }\n", "      if ((int)uVar4 < 0x67) {\n", "        if (uVar4 == 0x5c) {\n", "          *pcVar7 = '\\\\';\n", "          break;\n", "        }\n", "        if (uVar4 == 0x62) {\n", "          *pcVar7 = '\\b';\n", "          break;\n", "        }\n", "        if (uVar4 == 0x27) {\n", "          *pcVar7 = '\\0';\n", "          return 0x114;\n", "        }\n", "      }\n", "      else {\n", "        if (uVar4 == 0x72) {\n", "          *pcVar7 = '\\r';\n", "          break;\n", "        }\n", "        if (uVar4 == 0x74) {\n", "          *pcVar7 = '\\t';\n", "          break;\n", "        }\n", "        if (uVar4 == 0x6e) {\n", "          *pcVar7 = '\\n';\n", "          break;\n", "        }\n", "      }\n", "      *pcVar7 = cVar6;\n", "      uVar5 = 7;\n", "      pcVar7 = pcVar7 + 1;\n", "      break;\n", "    case 6:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x12a;\n", "      }\n", "      if (uVar4 == 10) {\n", "        uVar4 = 0x12a;\n", "LAB_004077f0:\n", "        return (int)uVar4;\n", "      }\n", "      break;\n", "    case 7:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x113;\n", "      }\n", "      if (uVar4 == 0x27) {\n", "        *pcVar7 = '\\0';\n", "        return 0x113;\n", "      }\n", "      *pcVar7 = cVar6;\n", "      pcVar7 = pcVar7 + 1;\n", "      break;\n", "    case 8:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x113;\n", "      }\n", "      if (uVar4 == 0x22) {\n", "        *pcVar7 = '\\0';\n", "        return 0x113;\n", "      }\n", "      *pcVar7 = cVar6;\n", "      pcVar7 = pcVar7 + 1;\n", "      break;\n", "    case 9:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x3c;\n", "      }\n", "      if (uVar4 == 0x3c) {\n", "        return 0x174;\n", "      }\n", "      return 0x3c;\n", "    case 10:\n", "      if (uVar4 == 0xffffffff) {\n", "        *pcVar7 = '\\0';\n", "        return 0x3e;\n", "      }\n", "      if (uVar4 == 0x3e) {\n", "        return 0x175;\n", "      }\n", "      return 0x3e;\n", "    }\n", "  } while( true );\n", "}\n", "\n"], "c": ["int next_tok()\n", "{\n", "\tchar *tp = tok;\n", "\tenum {S_TOP, S_HEXNUM, S_NUM, S_ALNUM, S_CHAR, S_ESC_CHAR, S_COMMENT,\n", "\t\tS_SQ_STRING, S_DQ_STRING, S_SHL, S_SHR} state = S_TOP;\n", "\tstatic int unget = 0;\n", "\tBOOL dot_seen = FALSE;\n", "\n", "\tfor(;;) {\n", "\t\tint c = unget ? unget : lgetc(yyin);\n", "\t\tint flags;\n", "\t\tunget = 0;\n", "\t\tflags = ascii_tab[c & 0x7F].flags;\n", "\t\tif(tp > tok + MAX_TOK - 2) return LEXBAD;\n", "\t\tswitch(state) {\n", "\t\tcase S_TOP:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\treturn EOF;\n", "\t\t\t} else if(flags & IS_WHITE) {\n", "\t\t\t\t/* ignore */ ;\n", "\t\t\t} else if(flags & IS_ALPHA) {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t\tstate = S_ALNUM;\n", "\t\t\t} else if((flags & IS_NUM) || c == '.') {\n", "\t\t\t\tunget = c;\n", "\t\t\t\tstate = S_NUM;\n", "\t\t\t} else {\n", "\t\t\t\tswitch(c) {\n", "\t\t\t\tcase '$': state = S_HEXNUM; break;\n", "\t\t\t\tcase '\"': state = S_DQ_STRING; break;\n", "\t\t\t\tcase '\\'': state = S_CHAR; break;\n", "\t\t\t\tcase '>': state = S_SHR; break;\n", "\t\t\t\tcase '<': state = S_SHL; break;\n", "\t\t\t\tcase ';': state = S_COMMENT; break;\n", "\t\t\t\tcase '\\n': return EOL;\n", "\t\t\t\tcase '@': return EOS;\n", "\t\t\t\tdefault: return c;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_COMMENT:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn EOL;\n", "\t\t\t} else if(c == '\\n') {\n", "\t\t\t\treturn EOL;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_SHR:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn '>';\n", "\t\t\t} else if(c == '>') {\n", "\t\t\t\treturn SHR;\n", "\t\t\t} else {\n", "\t\t\t\tunget = c;\n", "\t\t\t\treturn '>';\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_SHL:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn '<';\n", "\t\t\t} else if(c == '<') {\n", "\t\t\t\treturn SHL;\n", "\t\t\t} else {\n", "\t\t\t\tunget = c;\n", "\t\t\t\treturn '<';\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_HEXNUM:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn CHEX;\n", "\t\t\t} else if(flags & IS_HEX) {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t\tbreak;\n", "\t\t\t} else {\n", "\t\t\t\tunget = c;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn CHEX;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_ALNUM:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn SYM;\n", "\t\t\t} else if(c == ':') {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn SYM;\n", "\t\t\t\tbreak;\n", "\t\t\t} else if(flags & (IS_ALPHA|IS_NUM)) {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t\tbreak;\n", "\t\t\t} else {\n", "\t\t\t\tunget = c;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn SYM;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_NUM:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn dot_seen ? FRAC : CDEC;\n", "\t\t\t} else if((flags & IS_NUM) || (c == '.' && NOT dot_seen)) {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t\tif(c == '.') dot_seen = TRUE;\n", "\t\t\t\tbreak;\n", "\t\t\t} else {\n", "\t\t\t\tunget = c;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn dot_seen ? FRAC : CDEC;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_CHAR:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn CHAR;\n", "\t\t\t} else if(c == '\\\\') {\n", "\t\t\t\tstate = S_ESC_CHAR;\n", "\t\t\t} else if(c == '\\'') {\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn CHAR;\n", "\t\t\t} else {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t\tif(tp > tok + 1)\n", "\t\t\t\t\tstate = S_SQ_STRING;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_ESC_CHAR:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn CHAR;\n", "\t\t\t}\n", "\t\t\tswitch(c) {\n", "\t\t\tcase 'b': *tp = '\\b'; break;\n", "\t\t\tcase 'f': *tp = '\\f'; break;\n", "\t\t\tcase 'n': *tp = '\\n'; break;\n", "\t\t\tcase 'r': *tp = '\\r'; break;\n", "\t\t\tcase 't': *tp = '\\t'; break;\n", "\t\t\tcase '\\\\': *tp = '\\\\'; break;\n", "\t\t\tcase '\\'':\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn CHAR;\n", "\t\t\t\tbreak;\n", "\t\t\tdefault:\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t\tstate = S_SQ_STRING;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_SQ_STRING:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn STRING;\n", "\t\t\t} else if(c == '\\'') {\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn STRING;\n", "\t\t\t} else {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase S_DQ_STRING:\n", "\t\t\tif(c == EOF) {\n", "\t\t\t\tunget = EOF;\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn STRING;\n", "\t\t\t} else if(c == '\"') {\n", "\t\t\t\t*tp = '\\0';\n", "\t\t\t\treturn STRING;\n", "\t\t\t} else {\n", "\t\t\t\t*tp++ = c;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\t} /* switch(state) */\n", "\t} /* for(;;) */\n", "}"]}, {"ghidra": ["\n", "Formal * formallist(Symbol *formal,Formal *list)\n", "\n", "{\n", "  Formal *pFVar1;\n", "  \n", "  pFVar1 = (Formal *)p9malloc(0x18);\n", "  if (pFVar1 == (Formal *)0x0) {\n", "    emalloc();\n", "  }\n", "  pFVar1->sym = formal;\n", "  pFVar1->save = (Saveval *)0x0;\n", "  pFVar1->next = list;\n", "  return pFVar1;\n", "}\n", "\n"], "c": ["Formal*\n", "formallist(Symbol *formal, Formal *list)\t/* add formal to list */\n", "{\n", "\tFormal *f;\n", "\n", "\tf = emalloc(sizeof(Formal));\n", "\tf->sym = formal;\n", "\tf->save = 0;\n", "\tf->next = list;\n", "\treturn f;\n", "}"]}, {"ghidra": ["\n", "void p9free(void *v)\n", "\n", "{\n", "  if (v != (void *)0x0) {\n", "    lock(&malloclock);\n", "    free(v);\n", "    unlock(&malloclock);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "p9free(void *v)\n", "{\n", "\tif(v == nil)\n", "\t\treturn;\n", "\tlock(&malloclock);\n", "\tfree(v);\n", "\tunlock(&malloclock);\n", "}"]}, {"ghidra": ["\n", "void p9longjmp(long *buf,int val)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  __longjmp_chk();\n", "}\n", "\n"], "c": ["void\n", "p9longjmp(p9jmp_buf buf, int val)\n", "{\n", "\tsiglongjmp((void*)buf, val);\n", "}"]}, {"ghidra": ["\n", "void p9notejmp(void *x,long *buf,int val)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  __longjmp_chk(buf,(ulong)(uint)val);\n", "}\n", "\n"], "c": ["void\n", "p9notejmp(void *x, p9jmp_buf buf, int val)\n", "{\n", "\tUSED(x);\n", "\tsiglongjmp((void*)buf, val);\n", "}"]}, {"ghidra": ["\n", "int p9open(char *name,int mode)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  uVar2 = mode & 0xffffdf9c;\n", "  if ((mode & 0x10U) != 0) {\n", "    uVar2 = uVar2 ^ 0x10;\n", "  }\n", "  if ((uVar2 & 0x80) != 0) {\n", "    uVar2 = uVar2 ^ 0x80;\n", "  }\n", "  if ((uVar2 & 0x100) != 0) {\n", "    uVar2 = uVar2 ^ 0x100;\n", "  }\n", "  if ((uVar2 & 0x4000) != 0) {\n", "    uVar2 = uVar2 ^ 0x4000;\n", "  }\n", "  if (uVar2 == 0) {\n", "    __fd = __open64_2();\n", "    iVar4 = __fd;\n", "    if (-1 < __fd) {\n", "      if ((mode & 0x2000U) != 0) {\n", "        fl.l_type = ZEXT12((mode & 3U) != 0);\n", "        fl.l_start = 0;\n", "        fl.l_whence = 0;\n", "        fl.l_len = 0;\n", "        iVar3 = fcntl(__fd,6,&fl);\n", "        if (iVar3 < 0) {\n", "          iVar4 = -1;\n", "          close(__fd);\n", "          werrstr(\"lock: %r\");\n", "          goto LAB_00404f8d;\n", "        }\n", "      }\n", "      if ((mode & 0x20U) != 0) {\n", "        fcntl(__fd,2,1);\n", "      }\n", "      if ((mode & 0x40U) != 0) {\n", "        remove(name);\n", "      }\n", "    }\n", "  }\n", "  else {\n", "    werrstr(\"mode 0x%x not supported\",(ulong)uVar2);\n", "    iVar4 = -1;\n", "  }\n", "LAB_00404f8d:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9open(char *name, int mode)\n", "{\n", "\tint cexec, rclose;\n", "\tint fd, umode, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tumode = rdwr;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tlock = mode&OLOCK;\n", "\tmode &= ~(3|OCEXEC|ORCLOSE|OLOCK);\n", "\tif(mode&OTRUNC){\n", "\t\tumode |= O_TRUNC;\n", "\t\tmode ^= OTRUNC;\n", "\t}\n", "\tif(mode&ODIRECT){\n", "\t\tumode |= O_DIRECT;\n", "\t\tmode ^= ODIRECT;\n", "\t}\n", "\tif(mode&ONONBLOCK){\n", "\t\tumode |= O_NONBLOCK;\n", "\t\tmode ^= ONONBLOCK;\n", "\t}\n", "\tif(mode&OAPPEND){\n", "\t\tumode |= O_APPEND;\n", "\t\tmode ^= OAPPEND;\n", "\t}\n", "\tif(mode){\n", "\t\twerrstr(\"mode 0x%x not supported\", mode);\n", "\t\treturn -1;\n", "\t}\n", "\tfd = open(name, umode);\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(name);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "void rlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\t(*_rlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers++;\n", "}"]}, {"ghidra": ["\n", "long p9write(int f,void *av,long n)\n", "\n", "{\n", "  ssize_t sVar1;\n", "  long lVar2;\n", "  \n", "  if (n < 1) {\n", "    lVar2 = 0;\n", "  }\n", "  else {\n", "    lVar2 = 0;\n", "    do {\n", "      sVar1 = write(f,(void *)((long)av + lVar2),n - lVar2);\n", "      if (sVar1 < 1) {\n", "        if (lVar2 != 0) {\n", "          return lVar2;\n", "        }\n", "        return sVar1;\n", "      }\n", "      lVar2 = lVar2 + sVar1;\n", "    } while (lVar2 < n);\n", "  }\n", "  return lVar2;\n", "}\n", "\n"], "c": ["long\n", "p9write(int f, void *av, long n)\n", "{\n", "\tchar *a;\n", "\tlong m, t;\n", "\n", "\ta = av;\n", "\tt = 0;\n", "\twhile(t < n){\n", "\t\tm = write(f, a+t, n-t);\n", "\t\tif(m <= 0){\n", "\t\t\tif(t == 0)\n", "\t\t\t\treturn m;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tt += m;\n", "\t}\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "int rwakeup(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeup(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 0, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int canwlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->writer == (_Thread *)0x0) && (l->readers == 0)) {\n", "      l->writer = (_Thread *)0x1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canwlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\treturn (*_wlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer || l->readers)\n", "\t\t\treturn 0;\n", "\t\tl->writer = (void*)1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void * p9calloc(ulong a,ulong b)\n", "\n", "{\n", "  void *pvVar1;\n", "  size_t __nmemb;\n", "  \n", "  __nmemb = a * b;\n", "  if (__nmemb == 0) {\n", "    __nmemb = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = calloc(__nmemb,1);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9calloc(ulong a, ulong b)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(a*b == 0)\n", "\t\ta = b = 1;\n", "\n", "\tlock(&malloclock);\n", "\tv = calloc(a*b, 1);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void werrstr(char *fmt,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list arg;\n", "  char buf [128];\n", "  char local_c8 [8];\n", "  long local_c0;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n", "  arg[0].overflow_arg_area = &stack0x00000008;\n", "  arg[0].reg_save_area = local_b8;\n", "  arg[0].gp_offset = 8;\n", "  arg[0].fp_offset = 0x30;\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  vseprint(buf,local_c8,fmt,arg);\n", "  errstr(buf,0x80);\n", "  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "werrstr(char *fmt, ...)\n", "{\n", "\tva_list arg;\n", "\tchar buf[ERRMAX];\n", "\n", "\tva_start(arg, fmt);\n", "\tvseprint(buf, buf+ERRMAX, fmt, arg);\n", "\tva_end(arg);\n", "\terrstr(buf, ERRMAX);\n", "}"]}, {"ghidra": ["\n", "void exits(char *s)\n", "\n", "{\n", "  anon_subr_void_for_f *paVar1;\n", "  __pid_t _Var2;\n", "  int __status;\n", "  anon_struct_conflict2 *paVar3;\n", "  \n", "  paVar3 = onex + 0x20;\n", "  _Var2 = getpid();\n", "  do {\n", "    while ((paVar1 = paVar3->f, paVar1 != (anon_subr_void_for_f *)0x0 && (paVar3->pid == _Var2))) {\n", "      paVar3->f = (anon_subr_void_for_f *)0x0;\n", "      paVar3 = paVar3 + -1;\n", "      (*paVar1)();\n", "      if (paVar3 == (anon_struct_conflict2 *)&DAT_00612030) goto LAB_00404930;\n", "    }\n", "    paVar3 = paVar3 + -1;\n", "  } while (paVar3 != (anon_struct_conflict2 *)&DAT_00612030);\n", "LAB_00404930:\n", "  if ((s != (char *)0x0) && (*s != '\\0')) {\n", "    __status = exitcode(s);\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(__status);\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(0);\n", "}\n", "\n"], "c": ["void\n", "exits(char *s)\n", "{\n", "\tint i, pid;\n", "\tvoid (*f)(void);\n", "\n", "\tpid = getpid();\n", "\tfor(i = NEXIT-1; i >= 0; i--)\n", "\t\tif((f = onex[i].f) && pid == onex[i].pid) {\n", "\t\t\tonex[i].f = 0;\n", "\t\t\t(*f)();\n", "\t\t}\n", "\tif(s == 0 || *s == 0)\n", "\t\texit(0);\n", "\texit(exitcode(s));\n", "}"]}, {"ghidra": ["\n", "void runlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _runlock;\n", "  if (_runlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + -1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "runlock(RWLock *l)\n", "{\n", "\tif(_runlock)\n", "\t\t(*_runlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers--;\n", "}"]}, {"ghidra": ["\n", "int p9create(char *path,int mode,ulong perm)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  uint __oflag;\n", "  uint uVar5;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  uVar5 = mode & 3;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if ((perm & 0x80000000) == 0) {\n", "    if ((mode & 0x80U) == 0) {\n", "      __oflag = uVar5 | 0x240;\n", "      uVar2 = mode & 0xffffdf8c;\n", "    }\n", "    else {\n", "      __oflag = uVar5 | 0x4240;\n", "      uVar2 = mode & 0xffffdf0c;\n", "    }\n", "    if ((uVar2 & 0x1000) != 0) {\n", "      __oflag = __oflag | 0x80;\n", "      uVar2 = uVar2 & 0xffffefff;\n", "    }\n", "    if ((uVar2 & 0x4000) != 0) {\n", "      __oflag = __oflag | 0x400;\n", "      uVar2 = uVar2 & 0xffffbfff;\n", "    }\n", "    if (uVar2 == 0) {\n", "      __fd = open64(path,__oflag);\n", "out:\n", "      iVar4 = __fd;\n", "      if (-1 < __fd) {\n", "        if ((mode & 0x2000U) != 0) {\n", "          fl.l_type = ZEXT12(uVar5 != 0);\n", "          fl.l_start = 0;\n", "          fl.l_whence = 0;\n", "          fl.l_len = 0;\n", "          iVar3 = fcntl(__fd,6,&fl);\n", "          if (iVar3 < 0) {\n", "            iVar4 = -1;\n", "            close(__fd);\n", "            werrstr(\"lock: %r\");\n", "            goto LAB_004049a9;\n", "          }\n", "        }\n", "        if ((mode & 0x20U) != 0) {\n", "          fcntl(__fd,2,1);\n", "        }\n", "        if ((mode & 0x40U) != 0) {\n", "          remove(path);\n", "        }\n", "      }\n", "      goto LAB_004049a9;\n", "    }\n", "    werrstr(\"unsupported mode in create\");\n", "  }\n", "  else {\n", "    if ((mode & 0xffffdf9fU) == 0) {\n", "      __fd = mkdir(path,(uint)perm & 0x1ff);\n", "      if (-1 < __fd) {\n", "        __fd = open64(path,0);\n", "        goto out;\n", "      }\n", "    }\n", "    else {\n", "      werrstr(\"bad mode in directory create\");\n", "    }\n", "  }\n", "  iVar4 = -1;\n", "LAB_004049a9:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9create(char *path, int mode, ulong perm)\n", "{\n", "\tint fd, cexec, umode, rclose, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tlock = mode&OLOCK;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tmode &= ~(ORCLOSE|OCEXEC|OLOCK);\n", "\n", "\t/* XXX should get mode mask right? */\n", "\tfd = -1;\n", "\tif(perm&DMDIR){\n", "\t\tif(mode != OREAD){\n", "\t\t\twerrstr(\"bad mode in directory create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tif(mkdir(path, perm&0777) < 0)\n", "\t\t\tgoto out;\n", "\t\tfd = open(path, O_RDONLY);\n", "\t}else{\n", "\t\tumode = (mode&3)|O_CREAT|O_TRUNC;\n", "\t\tmode &= ~(3|OTRUNC);\n", "\t\tif(mode&ODIRECT){\n", "\t\t\tumode |= O_DIRECT;\n", "\t\t\tmode &= ~ODIRECT;\n", "\t\t}\n", "\t\tif(mode&OEXCL){\n", "\t\t\tumode |= O_EXCL;\n", "\t\t\tmode &= ~OEXCL;\n", "\t\t}\n", "\t\tif(mode&OAPPEND){\n", "\t\t\tumode |= O_APPEND;\n", "\t\t\tmode &= ~OAPPEND;\n", "\t\t}\n", "\t\tif(mode){\n", "\t\t\twerrstr(\"unsupported mode in create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tfd = open(path, umode, perm);\n", "\t}\n", "out:\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(path);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "int init(EVP_PKEY_CTX *ctx)\n", "\n", "{\n", "  Symbol *pSVar1;\n", "  int *piVar2;\n", "  double *pdVar3;\n", "  anon_subr_double_double_for_func **ppaVar4;\n", "  char *s;\n", "  anon_subr_double_double_for_func *s_00;\n", "  \n", "  s = \"proc\";\n", "  piVar2 = &keywords[0].kval;\n", "  do {\n", "    install(s,*piVar2,0.00000000);\n", "    s = *(char **)(piVar2 + 2);\n", "    piVar2 = piVar2 + 4;\n", "  } while (s != (char *)0x0);\n", "  s = \"PI\";\n", "  pdVar3 = &consts[0].cval;\n", "  do {\n", "    install(s,0xe005,*pdVar3);\n", "    s = (char *)pdVar3[1];\n", "    pdVar3 = pdVar3 + 2;\n", "  } while (s != (char *)0x0);\n", "  s_00 = (anon_subr_double_double_for_func *)&DAT_0040aa42;\n", "  ppaVar4 = &builtins[0].func;\n", "  do {\n", "    pSVar1 = install((char *)s_00,0xe006,0.00000000);\n", "    *(anon_subr_double_double_for_func **)&pSVar1->u = *ppaVar4;\n", "    s_00 = ppaVar4[1];\n", "    ppaVar4 = ppaVar4 + 2;\n", "  } while (s_00 != (anon_subr_double_double_for_func *)0x0);\n", "  return (int)pSVar1;\n", "}\n", "\n"], "c": ["void\n", "init(void)\t/* install constants and built-ins in table */\n", "{\n", "\tint i;\n", "\tSymbol *s;\n", "\tfor (i = 0; keywords[i].name; i++)\n", "\t\tinstall(keywords[i].name, keywords[i].kval, 0.0);\n", "\tfor (i = 0; consts[i].name; i++)\n", "\t\tinstall(consts[i].name, VAR, consts[i].cval);\n", "\tfor (i = 0; builtins[i].name; i++) {\n", "\t\ts = install(builtins[i].name, BLTIN, 0.0);\n", "\t\ts->u.ptr = builtins[i].func;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "double integer(double x)\n", "\n", "{\n", "  if ((x < -2147483648.00000000) || (2147483647.00000000 < x)) {\n", "    execerror(\"argument out of domain\",(char *)0x0);\n", "  }\n", "  return (double)(long)x;\n", "}\n", "\n"], "c": ["double\n", "integer(double x)\n", "{\n", "\tif(x<-2147483648.0 || x>2147483647.0)\n", "\t\texecerror(\"argument out of domain\", 0);\n", "\treturn (double)(long)x;\n", "}"]}, {"ghidra": ["\n", "void __fmtunlock(void)\n", "\n", "{\n", "  unlock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtunlock(void)\n", "{\n", "\tunlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "char * strecpy(char *to,char *e,char *from)\n", "\n", "{\n", "  void *pvVar1;\n", "  char *pcVar2;\n", "  \n", "  if (e <= to) {\n", "    return to;\n", "  }\n", "  pvVar1 = memccpy(to,from,0,(size_t)(e + -(long)to));\n", "  pcVar2 = (char *)((long)pvVar1 + -1);\n", "  if (pvVar1 == (void *)0x0) {\n", "    e[-1] = '\\0';\n", "    pcVar2 = e + -1;\n", "  }\n", "  return pcVar2;\n", "}\n", "\n"], "c": ["char*\n", "strecpy(char *to, char *e, char *from)\n", "{\n", "\tif(to >= e)\n", "\t\treturn to;\n", "\tto = memccpy(to, from, '\\0', e - to);\n", "\tif(to == nil){\n", "\t\tto = e - 1;\n", "\t\t*to = '\\0';\n", "\t}else{\n", "\t\tto--;\n", "\t}\n", "\treturn to;\n", "}"]}, {"ghidra": ["\n", "int errstr(char *err,uint n)\n", "\n", "{\n", "  char *to;\n", "  int *piVar1;\n", "  long in_FS_OFFSET;\n", "  char tmp [128];\n", "  char local_28 [8];\n", "  long local_20;\n", "  \n", "  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n", "  strecpy(tmp,local_28,err);\n", "  rerrstr(err,n);\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    to = (*_syserrstr)();\n", "    if (to != (char *)0x0) goto LAB_00404bf4;\n", "  }\n", "  to = xsyserr;\n", "LAB_00404bf4:\n", "  strecpy(to,to + 0x80,tmp);\n", "  piVar1 = __errno_location();\n", "  *piVar1 = 0x19283745;\n", "  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return 0;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "errstr(char *err, uint n)\n", "{\n", "\tchar tmp[ERRMAX];\n", "\tchar *syserr;\n", "\n", "\tstrecpy(tmp, tmp+ERRMAX, err);\n", "\trerrstr(err, n);\n", "\tsyserr = getsyserr();\n", "\tstrecpy(syserr, syserr+ERRMAX, tmp);\n", "\terrno = EPLAN9;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "Symbol * install(char *s,int t,double d)\n", "\n", "{\n", "  Symbol *pSVar1;\n", "  Symbol *pSVar2;\n", "  size_t sVar3;\n", "  char *__dest;\n", "  \n", "  pSVar2 = (Symbol *)p9malloc(0x20);\n", "  if (pSVar2 == (Symbol *)0x0) {\n", "    emalloc();\n", "  }\n", "  sVar3 = strlen(s);\n", "  __dest = (char *)p9malloc((ulong)((int)sVar3 + 1));\n", "  if (__dest == (char *)0x0) {\n", "    emalloc();\n", "  }\n", "  pSVar2->name = __dest;\n", "  strcpy(__dest,s);\n", "  pSVar1 = symlist;\n", "  pSVar2->type = (long)t;\n", "  symlist = pSVar2;\n", "  *(double *)&pSVar2->u = d;\n", "  pSVar2->next = pSVar1;\n", "  return pSVar2;\n", "}\n", "\n"], "c": ["Symbol*\n", "install(char* s, int t, double d)  /* install s in symbol table */\n", "{\n", "\tSymbol *sp;\n", "\n", "\tsp = emalloc(sizeof(Symbol));\n", "\tsp->name = emalloc(strlen(s)+1); /* +1 for '\\0' */\n", "\tstrcpy(sp->name, s);\n", "\tsp->type = t;\n", "\tsp->u.val = d;\n", "\tsp->next = symlist; /* put at front of list */\n", "\tsymlist = sp;\n", "\treturn sp;\n", "}"]}, {"ghidra": ["\n", "void qlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock != (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\t(*_qlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 1;\n", "}"]}, {"ghidra": ["\n", "void lock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock != (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "lock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\t(*_lock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 1;\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  p9main(argc,argv);\n", "  exits(\"main\");\n", "  return 99;\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tp9main(argc, argv);\n", "\texits(\"main\");\n", "\treturn 99;\n", "}"]}, {"ghidra": ["\n", "Symbol * lookup(char *s)\n", "\n", "{\n", "  int iVar1;\n", "  Symbol *pSVar2;\n", "  \n", "  pSVar2 = symlist;\n", "  if (symlist != (Symbol *)0x0) {\n", "    do {\n", "      iVar1 = strcmp(pSVar2->name,s);\n", "      if (iVar1 == 0) {\n", "        return pSVar2;\n", "      }\n", "      pSVar2 = pSVar2->next;\n", "    } while (pSVar2 != (Symbol *)0x0);\n", "  }\n", "  return (Symbol *)0x0;\n", "}\n", "\n"], "c": ["Symbol*\n", "lookup(char* s)\t/* find s in symbol table */\n", "{\n", "\tSymbol *sp;\n", "\n", "\tfor (sp = symlist; sp != (Symbol *) 0; sp = sp->next)\n", "\t\tif (strcmp(sp->name, s) == 0)\n", "\t\t\treturn sp;\n", "\treturn 0;\t/* 0 ==> not found */\t\n", "}"]}, {"ghidra": ["\n", "ulong getcallerpc(void *x)\n", "\n", "{\n", "  return *(ulong *)((long)x + -8);\n", "}\n", "\n"], "c": ["ulong\n", "getcallerpc(void *x)\n", "{\n", "\treturn (((ulong*)(x))[-1]);\n", "}"]}, {"ghidra": ["\n", "double NaN(void)\n", "\n", "{\n", "  return NAN;\n", "}\n", "\n"], "c": ["double\n", "NaN(void)\n", "{\n", "\treturn __NaN();\n", "}"]}, {"ghidra": ["\n", "void unlock(Lock *l)\n", "\n", "{\n", "  anon_subr_void_Lock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _unlock;\n", "  if (_unlock != (anon_subr_void_Lock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "unlock(Lock *l)\n", "{\n", "\tif(_unlock)\n", "\t\t(*_unlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 0;\n", "}"]}, {"ghidra": ["\n", "int isInf(double d,int sign)\n", "\n", "{\n", "  if (sign == 0) {\n", "    return (int)(uint)(((ulong)d & 0x7fffffffffffffff) == 0x7ff0000000000000);\n", "  }\n", "  if (0 < sign) {\n", "    return (int)(uint)(d == INFINITY);\n", "  }\n", "  return (int)(uint)(d == -INFINITY);\n", "}\n", "\n"], "c": ["int\n", "isInf(double x, int sign)\n", "{\n", "\treturn __isInf(x, sign);\n", "}"]}, {"ghidra": ["\n", "void * p9malloc(ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  if (n == 0) {\n", "    n = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = malloc(n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9malloc(ulong n)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(n == 0)\n", "\t\tn++;\n", "\tlock(&malloclock);\n", "\tv = malloc(n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void __fmtlock(void)\n", "\n", "{\n", "  lock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtlock(void)\n", "{\n", "\tlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "int __errfmt(Fmt *f)\n", "\n", "{\n", "  int iVar1;\n", "  int *piVar2;\n", "  char *s;\n", "  \n", "  piVar2 = __errno_location();\n", "  if (*piVar2 != 0x19283745) {\n", "    s = strerror(*piVar2);\n", "LAB_00404c5b:\n", "    iVar1 = fmtstrcpy(f,s);\n", "    return iVar1;\n", "  }\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    s = (*_syserrstr)();\n", "    if (s != (char *)0x0) goto LAB_00404c5b;\n", "  }\n", "  iVar1 = fmtstrcpy(f,xsyserr);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "__errfmt(Fmt *f)\n", "{\n", "\tif(errno == EPLAN9)\n", "\t\treturn fmtstrcpy(f, getsyserr());\n", "\treturn fmtstrcpy(f, strerror(errno));\n", "}"]}, {"ghidra": ["\n", "void qunlock(QLock *l)\n", "\n", "{\n", "  anon_subr_void_QLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qunlock;\n", "  if (_qunlock != (anon_subr_void_QLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qunlock(QLock *l)\n", "{\n", "\tif(_qunlock)\n", "\t\t(*_qunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 0;\n", "}"]}, {"ghidra": ["\n", "void * p9realloc(void *v,ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  lock(&malloclock);\n", "  pvVar1 = realloc(v,n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9realloc(void *v, ulong n)\n", "{\n", "\tlock(&malloclock);\n", "\tv = realloc(v, n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "double errcheck(double d,char *s)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = isNaN(d);\n", "  if (iVar1 != 0) {\n", "    execerror(s,\"argument out of domain\");\n", "  }\n", "  iVar1 = isInf(d,0);\n", "  if (iVar1 != 0) {\n", "    execerror(s,\"result out of range\");\n", "  }\n", "  return d;\n", "}\n", "\n"], "c": ["double\n", "errcheck(double d, char* s)\t/* check result of library call */\n", "{\n", "\tif(isNaN(d))\n", "\t\texecerror(s, \"argument out of domain\");\n", "\tif(isInf(d, 0))\n", "\t\texecerror(s, \"result out of range\");\n", "\treturn d;\n", "}"]}, {"ghidra": ["\n", "void * emalloc(uint n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  pvVar1 = p9malloc((ulong)n);\n", "  if (pvVar1 != (void *)0x0) {\n", "    return pvVar1;\n", "  }\n", "  emalloc();\n", "  return (void *)0x0;\n", "}\n", "\n"], "c": ["void*\n", "emalloc(unsigned n)\t/* check return from malloc */\n", "{\n", "\tchar *p;\n", "\n", "\tp = malloc(n);\n", "\tif (p == 0)\n", "\t\texecerror(\"out of memory\", (char *) 0);\n", "\treturn p;\n", "}"]}, {"ghidra": ["\n", "int canrlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->writer == (_Thread *)0x0) {\n", "      l->readers = l->readers + 1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canrlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\treturn (*_rlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer)\n", "\t\t\treturn 0;\n", "\t\tl->readers++;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void wunlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wunlock;\n", "  if (_wunlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wunlock(RWLock *l)\n", "{\n", "\tif(_wunlock)\n", "\t\t(*_wunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = nil;\n", "}"]}, {"ghidra": ["\n", "void rerrstr(char *err,uint n)\n", "\n", "{\n", "  int __errnum;\n", "  char *__dest;\n", "  int *piVar1;\n", "  char *__src;\n", "  \n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    __dest = (*_syserrstr)();\n", "    if ((undefined8 *)__dest != (undefined8 *)0x0) goto LAB_00404b2f;\n", "  }\n", "  __dest = xsyserr;\n", "LAB_00404b2f:\n", "  piVar1 = __errno_location();\n", "  __errnum = *piVar1;\n", "  if (__errnum == 4) {\n", "    *(undefined4 *)((undefined8 *)__dest + 1) = 0x646574;\n", "    *(undefined8 *)__dest = 0x7075727265746e69;\n", "  }\n", "  else {\n", "    if (__errnum != 0x19283745) {\n", "      __src = strerror(__errnum);\n", "      strcpy(__dest,__src);\n", "    }\n", "  }\n", "  strecpy(err,err + n,__dest);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rerrstr(char *err, uint n)\n", "{\n", "\tchar *syserr;\n", "\n", "\tsyserr = getsyserr();\n", "\tif(errno == EINTR)\n", "\t\tstrcpy(syserr, \"interrupted\");\n", "\telse if(errno != EPLAN9)\n", "\t\tstrcpy(syserr, strerror(errno));\n", "\tstrecpy(err, err+n, syserr);\n", "}"]}, {"ghidra": ["\n", "void rsleep(Rendez *r)\n", "\n", "{\n", "  anon_subr_void_Rendez_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rsleep;\n", "  if (_rsleep != (anon_subr_void_Rendez_ptr_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rsleep(Rendez *r)\n", "{\n", "\tif(_rsleep)\n", "\t\t(*_rsleep)(r, getcallerpc(&r));\n", "}"]}, {"ghidra": ["\n", "int rwakeupall(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,1,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeupall(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 1, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void wlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\t(*_wlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = (void*)1;\n", "}"]}, {"ghidra": ["\n", "int exitcode(char *s)\n", "\n", "{\n", "  return 1;\n", "}\n", "\n"], "c": ["int\n", "exitcode(char *s)\n", "{\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "int isNaN(double d)\n", "\n", "{\n", "  if (((ulong)d & 0x7ff0000000000000) != 0x7ff0000000000000) {\n", "    return 0;\n", "  }\n", "  return (int)(uint)(((ulong)d & 0xfffffffffffff) != 0);\n", "}\n", "\n"], "c": ["int\n", "isNaN(double x)\n", "{\n", "\treturn __isNaN(x);\n", "}"]}, {"ghidra": ["\n", "int canlock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock == (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->held == 0) {\n", "      l->held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canlock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\treturn (*_lock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->held)\n", "\t\t\treturn 0;\n", "\t\tl->held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "double Inf(int sign)\n", "\n", "{\n", "  if (-1 < sign) {\n", "    return INFINITY;\n", "  }\n", "  return -INFINITY;\n", "}\n", "\n"], "c": ["double\n", "Inf(int sign)\n", "{\n", "\treturn __Inf(sign);\n", "}"]}, {"ghidra": ["\n", "int canqlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock == (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->l).held == 0) {\n", "      (l->l).held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canqlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\treturn (*_qlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->l.held)\n", "\t\t\treturn 0;\n", "\t\tl->l.held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  byte bVar1;\n", "  long lVar2;\n", "  int iVar3;\n", "  undefined8 uVar4;\n", "  long lVar5;\n", "  char *pcVar6;\n", "  char *pcVar7;\n", "  int iVar8;\n", "  char **ppcVar9;\n", "  char *displayName;\n", "  long in_FS_OFFSET;\n", "  bool bVar10;\n", "  byte bVar11;\n", "  Move *automove;\n", "  XEvent event;\n", "  \n", "  bVar11 = 0;\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  __printf_chk(1,\"3Dc version %s, Copyright (C) 1995,1996 Paul Hicks\\n\",\"0.8.1\");\n", "  puts(\"3Dc comes with ABSOLUTELY NO WARRANTY: see the GPL file for details\");\n", "  puts(\"This is free software: you are welcome to redistribute it\");\n", "  puts(\"    under certain conditions (see the GPL file).\");\n", "  Init3Dc();\n", "  iVar3 = Init3DcGFX(argc,argv);\n", "  iVar8 = 1;\n", "  if (iVar3 != 0) {\n", "    if (1 < argc) {\n", "      iVar8 = 2;\n", "      ppcVar9 = argv + 2;\n", "      bVar10 = argc - 2U >> 1 == 0;\n", "      iVar3 = (argc - 2U & 0xfffffffe) + 4;\n", "LAB_00104db1:\n", "      do {\n", "        displayName = ppcVar9[-1];\n", "        lVar5 = 6;\n", "        pcVar6 = displayName;\n", "        pcVar7 = \"-play\";\n", "        do {\n", "          if (lVar5 == 0) break;\n", "          lVar5 = lVar5 + -1;\n", "          bVar10 = *pcVar6 == *pcVar7;\n", "          pcVar6 = pcVar6 + (ulong)bVar11 * -2 + 1;\n", "          pcVar7 = pcVar7 + (ulong)bVar11 * -2 + 1;\n", "        } while (bVar10);\n", "        if (bVar10) {\n", "          bVar10 = argc == iVar8;\n", "          if (argc <= iVar8) {\n", "            __fprintf_chk(stderr,1,\"%s: -play requires a colour (black or white)\\n\",*argv);\n", "            iVar8 = 1;\n", "            goto LAB_00104e30;\n", "          }\n", "          displayName = *ppcVar9;\n", "          lVar5 = 6;\n", "          pcVar6 = displayName;\n", "          pcVar7 = \"black\";\n", "          do {\n", "            if (lVar5 == 0) break;\n", "            lVar5 = lVar5 + -1;\n", "            bVar10 = *pcVar6 == *pcVar7;\n", "            pcVar6 = pcVar6 + (ulong)bVar11 * -2 + 1;\n", "            pcVar7 = pcVar7 + (ulong)bVar11 * -2 + 1;\n", "          } while (bVar10);\n", "          if (bVar10) {\n", "            computer = BLACK;\n", "          }\n", "          else {\n", "            lVar5 = 6;\n", "            pcVar6 = displayName;\n", "            pcVar7 = \"white\";\n", "            do {\n", "              if (lVar5 == 0) break;\n", "              lVar5 = lVar5 + -1;\n", "              bVar10 = *pcVar6 == *pcVar7;\n", "              pcVar6 = pcVar6 + (ulong)bVar11 * -2 + 1;\n", "              pcVar7 = pcVar7 + (ulong)bVar11 * -2 + 1;\n", "            } while (bVar10);\n", "            if (!bVar10) {\n", "              pcVar7 = \"%s: %s is not a colour (must be black or white)\\n\";\n", "              pcVar6 = *argv;\n", "              goto LAB_0010501f;\n", "            }\n", "            computer = WHITE;\n", "          }\n", "          iVar8 = iVar8 + 2;\n", "          ppcVar9 = ppcVar9 + 2;\n", "          bVar10 = iVar8 == iVar3;\n", "          if (bVar10) break;\n", "          goto LAB_00104db1;\n", "        }\n", "        lVar5 = 0xc;\n", "        pcVar6 = displayName;\n", "        pcVar7 = \"-altdisplay\";\n", "        do {\n", "          if (lVar5 == 0) break;\n", "          lVar5 = lVar5 + -1;\n", "          bVar10 = *pcVar6 == *pcVar7;\n", "          pcVar6 = pcVar6 + (ulong)bVar11 * -2 + 1;\n", "          pcVar7 = pcVar7 + (ulong)bVar11 * -2 + 1;\n", "        } while (bVar10);\n", "        if ((!bVar10) &&\n", "           ((((*displayName != '-' || (displayName[1] != 'a')) || (displayName[2] != 'd')) ||\n", "            (displayName[3] != '\\0')))) {\n", "          fwrite(\"Usage:\\n\",1,7,stderr);\n", "          displayName = *argv;\n", "          __fprintf_chk(stderr,1,\n", "                        \"%s ; play 3Dc, two humans on one display\\n%s -ad|-altdisplay [display] ; black plays on display `display\\'\\n%s -play colour ; play against the computer, which plays colour\\n\"\n", "                        ,displayName,displayName,displayName);\n", "          iVar8 = 1;\n", "          goto LAB_00104e30;\n", "        }\n", "        if ((argc == iVar8) || (displayName = *ppcVar9, *displayName == '-')) {\n", "          pcVar7 = \"%s: option %s requires a display name parameter\\n\";\n", "          displayName = argv[(long)iVar8 + -1];\n", "          pcVar6 = *argv;\n", "LAB_0010501f:\n", "          __fprintf_chk(stderr,1,pcVar7,pcVar6,displayName);\n", "          iVar8 = 1;\n", "          goto LAB_00104e30;\n", "        }\n", "        iVar8 = iVar8 + 2;\n", "        ppcVar9 = ppcVar9 + 2;\n", "        Open2ndDisplay(displayName);\n", "        bVar10 = iVar8 == iVar3;\n", "      } while (!bVar10);\n", "    }\n", "    if (firstGFX->mainWindow != (Widget)0x0) {\n", "      do {\n", "        iVar3 = IsGameFinished();\n", "        if (iVar3 == 0) {\n", "LAB_00104f47:\n", "          if (((bwToMove == computer) && (gamePaused == 0)) &&\n", "             (((retry == 0 && (iVar3 = GenMove(bwToMove,&automove), iVar3 == 1)) ||\n", "              ((retry == 1 && (iVar3 = GenAltMove(computer,&automove), iVar3 == 1)))))) {\n", "            if (automove == (Move *)0x0) {\n", "              gamePaused = 1;\n", "              Err3Dc(firstGFX,\"Gaah!  I give up.\",1);\n", "              XtDisplay(firstGFX->mainWindow);\n", "              XFlush();\n", "              FinishGame((uint)(computer != BLACK));\n", "            }\n", "            else {\n", "              bVar11 = *(byte *)&automove->xyzBefore;\n", "              if (Board[(ulong)((uint)bVar11 & 7) +\n", "                        ((ulong)((uint)(bVar11 >> 3) & 7) + (ulong)(bVar11 >> 6) * 8) * 8] !=\n", "                  (Piece *)0x0) {\n", "                bVar1 = *(byte *)&automove->xyzAfter;\n", "                iVar3 = PieceMove(Board[(ulong)((uint)bVar11 & 7) +\n", "                                        ((ulong)((uint)(bVar11 >> 3) & 7) + (ulong)(bVar11 >> 6) * 8\n", "                                        ) * 8],(uint)bVar1 & 7,(uint)(bVar1 >> 3) & 7,\n", "                                  (uint)(bVar1 >> 6));\n", "                if (iVar3 != 0) {\n", "                  retry = 0;\n", "                  PrintMove(automove);\n", "                  bwToMove = ZEXT14(computer == WHITE);\n", "                  goto LAB_00104ee6;\n", "                }\n", "              }\n", "              retry = 1;\n", "            }\n", "          }\n", "        }\n", "        else {\n", "          if (gamePaused == 0) {\n", "            FinishGame((uint)(bwToMove != BLACK));\n", "            goto LAB_00104f47;\n", "          }\n", "        }\n", "LAB_00104ee6:\n", "        uVar4 = XtWidgetToApplicationContext(firstGFX->mainWindow);\n", "        lVar5 = XtAppPending(uVar4);\n", "        if (lVar5 != 0) {\n", "          uVar4 = XtWidgetToApplicationContext(firstGFX->mainWindow);\n", "          XtAppNextEvent(uVar4,event);\n", "          XtDispatchEvent(event);\n", "        }\n", "        if (secondGFX != (GfxInfo *)0x0) {\n", "          uVar4 = XtWidgetToApplicationContext(secondGFX->mainWindow);\n", "          lVar5 = XtAppPending(uVar4);\n", "          if (lVar5 != 0) {\n", "            uVar4 = XtWidgetToApplicationContext(secondGFX->mainWindow);\n", "            XtAppNextEvent(uVar4,event);\n", "            XtDispatchEvent(event);\n", "          }\n", "        }\n", "        usleep(10);\n", "      } while (firstGFX->mainWindow != (Widget)0x0);\n", "    }\n", "    iVar8 = 0;\n", "  }\n", "LAB_00104e30:\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return iVar8;\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "  int argNum;\n", "\n", "  printf(\"3Dc version %s, Copyright (C) 1995,1996 Paul Hicks\\n\", VERSION);\n", "  printf(\"3Dc comes with ABSOLUTELY NO WARRANTY: see the GPL file for details\\n\");\n", "  printf(\"This is free software: you are welcome to redistribute it\\n\");\n", "  printf(\"    under certain conditions (see the GPL file).\\n\");\n", "\n", "  Init3Dc();\n", "  if (Init3DcGFX(argc, argv) == FALSE)\n", "    return 1;\n", "\n", "  for (argNum = 1; argNum < argc; ++argNum)\n", "    {\n", "      if (!strcmp(argv[argNum], \"-play\"))\n", "        {\n", "          if (++argNum >= argc)\n", "            {\n", "              fprintf(stderr,\n", "                      \"%s: -play requires a colour (black or white)\\n\",\n", "                      argv[0]);\n", "              return 1;\n", "            }\n", "\n", "          if (SetupAutoplay(argv[argNum]) == FALSE)\n", "            {\n", "              fprintf(stderr,\n", "                      \"%s: %s is not a colour (must be black or white)\\n\",\n", "                      argv[0], argv[argNum]);\n", "              return 1;\n", "            }\n", "        } /* End autoplay setup */\n", "      else if (!strcmp(argv[argNum], \"-altdisplay\") ||\n", "               !strcmp(argv[argNum], \"-ad\"))\n", "        {\n", "          /* If no more params   or next param is a new option */\n", "          if ((++argNum == argc) || argv[argNum][0] == '-')\n", "            {\n", "              fprintf(stderr,\n", "                      \"%s: option %s requires a display name parameter\\n\",\n", "                      argv[0], argv[argNum -1]);\n", "              return 1;\n", "            }\n", "          else\n", "            {\n", "              Open2ndDisplay(argv[argNum]);\n", "            }\n", "        } /* End net setup */\n", "      else /* The help option */\n", "        {\n", "          fprintf(stderr, \"Usage:\\n\");\n", "          fprintf(stderr, \"\\\n", "%s ; play 3Dc, two humans on one display\\n\\\n", "%s -ad|-altdisplay [display] ; black plays on display `display'\\n\\\n", "%s -play colour ; play against the computer, which plays colour\\n\",\n", "                 argv[0], argv[0], argv[0]);\n", "          return 1;\n", "        }\n", "    } /* Finish parameters */\n", "\n", "  DoMain3DcLoop();\n", "\n", "  return 0;\n", "}"]}, {"ghidra": ["\n", "int p9dup(int old,int new)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  if (new != -1) {\n", "    iVar1 = dup2(old,new);\n", "    return iVar1;\n", "  }\n", "  iVar1 = dup(old);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "p9dup(int old, int new)\n", "{\n", "\tif(new == -1)\n", "\t\treturn dup(old);\n", "\treturn dup2(old, new);\n", "}"]}, {"ghidra": ["\n", "void p9free(void *v)\n", "\n", "{\n", "  if (v != (void *)0x0) {\n", "    lock(&malloclock);\n", "    free(v);\n", "    unlock(&malloclock);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "p9free(void *v)\n", "{\n", "\tif(v == nil)\n", "\t\treturn;\n", "\tlock(&malloclock);\n", "\tfree(v);\n", "\tunlock(&malloclock);\n", "}"]}, {"ghidra": ["\n", "char * unsharp(char *old)\n", "\n", "{\n", "  char \"unsharp\" [8];\n", "  int iVar1;\n", "  size_t sVar2;\n", "  size_t sVar3;\n", "  int iVar4;\n", "  anon_struct_conflict *paVar5;\n", "  char *__s;\n", "  char *__s_00;\n", "  long lVar6;\n", "  \n", "  if (replace[0].new == (char *)0x0) {\n", "    replace[0].new = get9root();\n", "  }\n", "  lVar6 = 0;\n", "  paVar5 = replace;\n", "  __s = replace[0].new;\n", "  do {\n", "    if (__s != (char *)0x0) {\n", "      __s_00 = paVar5->old;\n", "      sVar2 = strlen(__s_00);\n", "      iVar4 = (int)sVar2;\n", "      iVar1 = strncmp(old,__s_00,(long)iVar4);\n", "      if (iVar1 == 0) {\n", "        __s_00 = old + (long)iVar4;\n", "        if ((*__s_00 == '/') || (*__s_00 == '\\0')) {\n", "          sVar2 = strlen(__s);\n", "          sVar3 = strlen(old);\n", "          iVar4 = ((int)sVar2 + (int)sVar3) - iVar4;\n", "          __s = (char *)p9malloc((long)(iVar4 + 1));\n", "          if (__s == (char *)0x0) {\n", "            sysfatal(\"out of memory translating %s to %s%s\",old,replace[lVar6].new,__s_00);\n", "          }\n", "          strcpy(__s,replace[lVar6].new);\n", "          strcpy(__s + (int)sVar2,__s_00);\n", "          sVar2 = strlen(__s);\n", "          if (sVar2 == (long)iVar4) {\n", "            return __s;\n", "          }\n", "                    /* WARNING: Subroutine does not return */\n", "          __assert_fail(\"strlen(new) == len\",\"unsharp.c\",0x28,\"unsharp\");\n", "        }\n", "      }\n", "    }\n", "    if ((int)lVar6 == 1) {\n", "      return old;\n", "    }\n", "    __s = paVar5[1].new;\n", "    lVar6 = 1;\n", "    paVar5 = paVar5 + 1;\n", "  } while( true );\n", "}\n", "\n"], "c": ["char*\n", "unsharp(char *old)\n", "{\n", "\tchar *new;\n", "\tint i, olen, nlen, len;\n", "\n", "\tif(replace[0].new == nil)\n", "\t\treplace[0].new = get9root();\n", "\n", "\tfor(i=0; i<nelem(replace); i++){\n", "\t\tif(!replace[i].new)\n", "\t\t\tcontinue;\n", "\t\tolen = strlen(replace[i].old);\n", "\t\tif(strncmp(old, replace[i].old, olen) != 0\n", "\t\t|| (old[olen] != '\\0' && old[olen] != '/'))\n", "\t\t\tcontinue;\n", "\t\tnlen = strlen(replace[i].new);\n", "\t\tlen = strlen(old)+nlen-olen;\n", "\t\tnew = malloc(len+1);\n", "\t\tif(new == nil)\n", "\t\t\t/* Most callers won't check the return value... */\n", "\t\t\tsysfatal(\"out of memory translating %s to %s%s\", old, replace[i].new, old+olen);\n", "\t\tstrcpy(new, replace[i].new);\n", "\t\tstrcpy(new+nlen, old+olen);\n", "\t\tassert(strlen(new) == len);\n", "\t\treturn new;\n", "\t}\n", "\treturn old;\n", "}"]}, {"ghidra": ["\n", "int p9open(char *name,int mode)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  uVar2 = mode & 0xffffdf9c;\n", "  if ((mode & 0x10U) != 0) {\n", "    uVar2 = uVar2 ^ 0x10;\n", "  }\n", "  if ((uVar2 & 0x80) != 0) {\n", "    uVar2 = uVar2 ^ 0x80;\n", "  }\n", "  if ((uVar2 & 0x100) != 0) {\n", "    uVar2 = uVar2 ^ 0x100;\n", "  }\n", "  if ((uVar2 & 0x4000) != 0) {\n", "    uVar2 = uVar2 ^ 0x4000;\n", "  }\n", "  if (uVar2 == 0) {\n", "    __fd = __open64_2();\n", "    iVar4 = __fd;\n", "    if (-1 < __fd) {\n", "      if ((mode & 0x2000U) != 0) {\n", "        fl.l_type = ZEXT12((mode & 3U) != 0);\n", "        fl.l_start = 0;\n", "        fl.l_whence = 0;\n", "        fl.l_len = 0;\n", "        iVar3 = fcntl(__fd,6,&fl);\n", "        if (iVar3 < 0) {\n", "          iVar4 = -1;\n", "          close(__fd);\n", "          werrstr(\"lock: %r\");\n", "          goto LAB_0040459d;\n", "        }\n", "      }\n", "      if ((mode & 0x20U) != 0) {\n", "        fcntl(__fd,2,1);\n", "      }\n", "      if ((mode & 0x40U) != 0) {\n", "        remove(name);\n", "      }\n", "    }\n", "  }\n", "  else {\n", "    werrstr(\"mode 0x%x not supported\",(ulong)uVar2);\n", "    iVar4 = -1;\n", "  }\n", "LAB_0040459d:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9open(char *name, int mode)\n", "{\n", "\tint cexec, rclose;\n", "\tint fd, umode, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tumode = rdwr;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tlock = mode&OLOCK;\n", "\tmode &= ~(3|OCEXEC|ORCLOSE|OLOCK);\n", "\tif(mode&OTRUNC){\n", "\t\tumode |= O_TRUNC;\n", "\t\tmode ^= OTRUNC;\n", "\t}\n", "\tif(mode&ODIRECT){\n", "\t\tumode |= O_DIRECT;\n", "\t\tmode ^= ODIRECT;\n", "\t}\n", "\tif(mode&ONONBLOCK){\n", "\t\tumode |= O_NONBLOCK;\n", "\t\tmode ^= ONONBLOCK;\n", "\t}\n", "\tif(mode&OAPPEND){\n", "\t\tumode |= O_APPEND;\n", "\t\tmode ^= OAPPEND;\n", "\t}\n", "\tif(mode){\n", "\t\twerrstr(\"mode 0x%x not supported\", mode);\n", "\t\treturn -1;\n", "\t}\n", "\tfd = open(name, umode);\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(name);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "void rlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\t(*_rlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers++;\n", "}"]}, {"ghidra": ["\n", "int p9pipe(int *fd)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = socketpair(1,1,0,fd);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "p9pipe(int fd[2])\n", "{\n", "\treturn socketpair(AF_UNIX, SOCK_STREAM, 0, fd);\n", "}"]}, {"ghidra": ["\n", "long p9write(int f,void *av,long n)\n", "\n", "{\n", "  ssize_t sVar1;\n", "  long lVar2;\n", "  \n", "  if (n < 1) {\n", "    lVar2 = 0;\n", "  }\n", "  else {\n", "    lVar2 = 0;\n", "    do {\n", "      sVar1 = write(f,(void *)((long)av + lVar2),n - lVar2);\n", "      if (sVar1 < 1) {\n", "        if (lVar2 != 0) {\n", "          return lVar2;\n", "        }\n", "        return sVar1;\n", "      }\n", "      lVar2 = lVar2 + sVar1;\n", "    } while (lVar2 < n);\n", "  }\n", "  return lVar2;\n", "}\n", "\n"], "c": ["long\n", "p9write(int f, void *av, long n)\n", "{\n", "\tchar *a;\n", "\tlong m, t;\n", "\n", "\ta = av;\n", "\tt = 0;\n", "\twhile(t < n){\n", "\t\tm = write(f, a+t, n-t);\n", "\t\tif(m <= 0){\n", "\t\t\tif(t == 0)\n", "\t\t\t\treturn m;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tt += m;\n", "\t}\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "int rwakeup(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeup(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 0, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int canwlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->writer == (_Thread *)0x0) && (l->readers == 0)) {\n", "      l->writer = (_Thread *)0x1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canwlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\treturn (*_wlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer || l->readers)\n", "\t\t\treturn 0;\n", "\t\tl->writer = (void*)1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void * p9calloc(ulong a,ulong b)\n", "\n", "{\n", "  void *pvVar1;\n", "  size_t __nmemb;\n", "  \n", "  __nmemb = a * b;\n", "  if (__nmemb == 0) {\n", "    __nmemb = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = calloc(__nmemb,1);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9calloc(ulong a, ulong b)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(a*b == 0)\n", "\t\ta = b = 1;\n", "\n", "\tlock(&malloclock);\n", "\tv = calloc(a*b, 1);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void werrstr(char *fmt,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list arg;\n", "  char buf [128];\n", "  char local_c8 [8];\n", "  long local_c0;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n", "  arg[0].overflow_arg_area = &stack0x00000008;\n", "  arg[0].reg_save_area = local_b8;\n", "  arg[0].gp_offset = 8;\n", "  arg[0].fp_offset = 0x30;\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  vseprint(buf,local_c8,fmt,arg);\n", "  errstr(buf,0x80);\n", "  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "werrstr(char *fmt, ...)\n", "{\n", "\tva_list arg;\n", "\tchar buf[ERRMAX];\n", "\n", "\tva_start(arg, fmt);\n", "\tvseprint(buf, buf+ERRMAX, fmt, arg);\n", "\tva_end(arg);\n", "\terrstr(buf, ERRMAX);\n", "}"]}, {"ghidra": ["\n", "void exits(char *s)\n", "\n", "{\n", "  anon_subr_void_for_f *paVar1;\n", "  __pid_t _Var2;\n", "  int __status;\n", "  anon_struct *paVar3;\n", "  \n", "  paVar3 = onex + 0x20;\n", "  _Var2 = getpid();\n", "  do {\n", "    while ((paVar1 = paVar3->f, paVar1 != (anon_subr_void_for_f *)0x0 && (paVar3->pid == _Var2))) {\n", "      paVar3->f = (anon_subr_void_for_f *)0x0;\n", "      paVar3 = paVar3 + -1;\n", "      (*paVar1)();\n", "      if (paVar3 == (anon_struct *)&DAT_0060dab0) goto LAB_00403e40;\n", "    }\n", "    paVar3 = paVar3 + -1;\n", "  } while (paVar3 != (anon_struct *)&DAT_0060dab0);\n", "LAB_00403e40:\n", "  if ((s != (char *)0x0) && (*s != '\\0')) {\n", "    __status = exitcode(s);\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(__status);\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(0);\n", "}\n", "\n"], "c": ["void\n", "exits(char *s)\n", "{\n", "\tint i, pid;\n", "\tvoid (*f)(void);\n", "\n", "\tpid = getpid();\n", "\tfor(i = NEXIT-1; i >= 0; i--)\n", "\t\tif((f = onex[i].f) && pid == onex[i].pid) {\n", "\t\t\tonex[i].f = 0;\n", "\t\t\t(*f)();\n", "\t\t}\n", "\tif(s == 0 || *s == 0)\n", "\t\texit(0);\n", "\texit(exitcode(s));\n", "}"]}, {"ghidra": ["\n", "void runlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _runlock;\n", "  if (_runlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + -1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "runlock(RWLock *l)\n", "{\n", "\tif(_runlock)\n", "\t\t(*_runlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers--;\n", "}"]}, {"ghidra": ["\n", "int p9create(char *path,int mode,ulong perm)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  uint __oflag;\n", "  uint uVar5;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  uVar5 = mode & 3;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if ((perm & 0x80000000) == 0) {\n", "    if ((mode & 0x80U) == 0) {\n", "      __oflag = uVar5 | 0x240;\n", "      uVar2 = mode & 0xffffdf8c;\n", "    }\n", "    else {\n", "      __oflag = uVar5 | 0x4240;\n", "      uVar2 = mode & 0xffffdf0c;\n", "    }\n", "    if ((uVar2 & 0x1000) != 0) {\n", "      __oflag = __oflag | 0x80;\n", "      uVar2 = uVar2 & 0xffffefff;\n", "    }\n", "    if ((uVar2 & 0x4000) != 0) {\n", "      __oflag = __oflag | 0x400;\n", "      uVar2 = uVar2 & 0xffffbfff;\n", "    }\n", "    if (uVar2 == 0) {\n", "      __fd = open64(path,__oflag);\n", "out:\n", "      iVar4 = __fd;\n", "      if (-1 < __fd) {\n", "        if ((mode & 0x2000U) != 0) {\n", "          fl.l_type = ZEXT12(uVar5 != 0);\n", "          fl.l_start = 0;\n", "          fl.l_whence = 0;\n", "          fl.l_len = 0;\n", "          iVar3 = fcntl(__fd,6,&fl);\n", "          if (iVar3 < 0) {\n", "            iVar4 = -1;\n", "            close(__fd);\n", "            werrstr(\"lock: %r\");\n", "            goto LAB_00403eb9;\n", "          }\n", "        }\n", "        if ((mode & 0x20U) != 0) {\n", "          fcntl(__fd,2,1);\n", "        }\n", "        if ((mode & 0x40U) != 0) {\n", "          remove(path);\n", "        }\n", "      }\n", "      goto LAB_00403eb9;\n", "    }\n", "    werrstr(\"unsupported mode in create\");\n", "  }\n", "  else {\n", "    if ((mode & 0xffffdf9fU) == 0) {\n", "      __fd = mkdir(path,(uint)perm & 0x1ff);\n", "      if (-1 < __fd) {\n", "        __fd = open64(path,0);\n", "        goto out;\n", "      }\n", "    }\n", "    else {\n", "      werrstr(\"bad mode in directory create\");\n", "    }\n", "  }\n", "  iVar4 = -1;\n", "LAB_00403eb9:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9create(char *path, int mode, ulong perm)\n", "{\n", "\tint fd, cexec, umode, rclose, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tlock = mode&OLOCK;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tmode &= ~(ORCLOSE|OCEXEC|OLOCK);\n", "\n", "\t/* XXX should get mode mask right? */\n", "\tfd = -1;\n", "\tif(perm&DMDIR){\n", "\t\tif(mode != OREAD){\n", "\t\t\twerrstr(\"bad mode in directory create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tif(mkdir(path, perm&0777) < 0)\n", "\t\t\tgoto out;\n", "\t\tfd = open(path, O_RDONLY);\n", "\t}else{\n", "\t\tumode = (mode&3)|O_CREAT|O_TRUNC;\n", "\t\tmode &= ~(3|OTRUNC);\n", "\t\tif(mode&ODIRECT){\n", "\t\t\tumode |= O_DIRECT;\n", "\t\t\tmode &= ~ODIRECT;\n", "\t\t}\n", "\t\tif(mode&OEXCL){\n", "\t\t\tumode |= O_EXCL;\n", "\t\t\tmode &= ~OEXCL;\n", "\t\t}\n", "\t\tif(mode&OAPPEND){\n", "\t\t\tumode |= O_APPEND;\n", "\t\t\tmode &= ~OAPPEND;\n", "\t\t}\n", "\t\tif(mode){\n", "\t\t\twerrstr(\"unsupported mode in create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tfd = open(path, umode, perm);\n", "\t}\n", "out:\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(path);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "void __fmtunlock(void)\n", "\n", "{\n", "  unlock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtunlock(void)\n", "{\n", "\tunlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "char * strecpy(char *to,char *e,char *from)\n", "\n", "{\n", "  void *pvVar1;\n", "  char *pcVar2;\n", "  \n", "  if (e <= to) {\n", "    return to;\n", "  }\n", "  pvVar1 = memccpy(to,from,0,(size_t)(e + -(long)to));\n", "  pcVar2 = (char *)((long)pvVar1 + -1);\n", "  if (pvVar1 == (void *)0x0) {\n", "    e[-1] = '\\0';\n", "    pcVar2 = e + -1;\n", "  }\n", "  return pcVar2;\n", "}\n", "\n"], "c": ["char*\n", "strecpy(char *to, char *e, char *from)\n", "{\n", "\tif(to >= e)\n", "\t\treturn to;\n", "\tto = memccpy(to, from, '\\0', e - to);\n", "\tif(to == nil){\n", "\t\tto = e - 1;\n", "\t\t*to = '\\0';\n", "\t}else{\n", "\t\tto--;\n", "\t}\n", "\treturn to;\n", "}"]}, {"ghidra": ["\n", "int errstr(char *err,uint n)\n", "\n", "{\n", "  char *to;\n", "  int *piVar1;\n", "  long in_FS_OFFSET;\n", "  char tmp [128];\n", "  char local_28 [8];\n", "  long local_20;\n", "  \n", "  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n", "  strecpy(tmp,local_28,err);\n", "  rerrstr(err,n);\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    to = (*_syserrstr)();\n", "    if (to != (char *)0x0) goto LAB_00404124;\n", "  }\n", "  to = xsyserr;\n", "LAB_00404124:\n", "  strecpy(to,to + 0x80,tmp);\n", "  piVar1 = __errno_location();\n", "  *piVar1 = 0x19283745;\n", "  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return 0;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "errstr(char *err, uint n)\n", "{\n", "\tchar tmp[ERRMAX];\n", "\tchar *syserr;\n", "\n", "\tstrecpy(tmp, tmp+ERRMAX, err);\n", "\trerrstr(err, n);\n", "\tsyserr = getsyserr();\n", "\tstrecpy(syserr, syserr+ERRMAX, tmp);\n", "\terrno = EPLAN9;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void qlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock != (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\t(*_qlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 1;\n", "}"]}, {"ghidra": ["\n", "void lock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock != (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "lock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\t(*_lock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 1;\n", "}"]}, {"ghidra": ["\n", "char * get9root(void)\n", "\n", "{\n", "  char *s;\n", "  char *pcVar1;\n", "  \n", "  if (s == (char *)0x0) {\n", "    pcVar1 = p9getenv(\"PLAN9\");\n", "    if (pcVar1 == (char *)0x0) {\n", "      pcVar1 = \"/usr/lib/plan9\";\n", "    }\n", "    return pcVar1;\n", "  }\n", "  return s;\n", "}\n", "\n"], "c": ["char*\n", "get9root(void)\n", "{\n", "\tstatic char *s;\n", "\n", "\tif(s)\n", "\t\treturn s;\n", "\n", "\tif((s = getenv(\"PLAN9\")) != 0)\n", "\t\treturn s;\n", "\t/* could do better - search $PATH */\n", "\ts = PREFIX;\n", "\treturn s;\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  p9main(argc,argv);\n", "  exits(\"main\");\n", "  return 99;\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tp9main(argc, argv);\n", "\texits(\"main\");\n", "\treturn 99;\n", "}"]}, {"ghidra": ["\n", "void sysfatal(char *fmt,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  char *pcVar1;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list arg;\n", "  char buf [256];\n", "  char local_d8 [8];\n", "  long local_d0;\n", "  undefined local_c8 [8];\n", "  undefined8 local_c0;\n", "  undefined8 local_b8;\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined4 local_98;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_98 = in_XMM0_Da;\n", "    local_88 = in_XMM1_Da;\n", "    local_78 = in_XMM2_Da;\n", "    local_68 = in_XMM3_Da;\n", "    local_58 = in_XMM4_Da;\n", "    local_48 = in_XMM5_Da;\n", "    local_38 = in_XMM6_Da;\n", "    local_28 = in_XMM7_Da;\n", "  }\n", "  local_d0 = *(long *)(in_FS_OFFSET + 0x28);\n", "  arg[0].overflow_arg_area = &stack0x00000008;\n", "  arg[0].reg_save_area = local_c8;\n", "  arg[0].gp_offset = 8;\n", "  arg[0].fp_offset = 0x30;\n", "  local_c0 = in_RSI;\n", "  local_b8 = in_RDX;\n", "  local_b0 = in_RCX;\n", "  local_a8 = in_R8;\n", "  local_a0 = in_R9;\n", "  if (_sysfatal != (anon_subr_void_char_ptr *)0x0) {\n", "    (*_sysfatal)(fmt,arg);\n", "  }\n", "  vseprint(buf,local_d8,fmt,arg);\n", "  __fixargv0();\n", "  pcVar1 = argv0;\n", "  if (argv0 == (char *)0x0) {\n", "    pcVar1 = \"<prog>\";\n", "  }\n", "  fprint(2,\"%s: %s\\n\",pcVar1,buf);\n", "  exits(\"fatal\");\n", "  if (local_d0 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "sysfatal(char *fmt, ...)\n", "{\n", "\tchar buf[256];\n", "\tva_list arg;\n", "\n", "\tva_start(arg, fmt);\n", "\tif(_sysfatal)\n", "\t\t(*_sysfatal)(fmt, arg);\n", "\tvseprint(buf, buf+sizeof buf, fmt, arg);\n", "\tva_end(arg);\n", "\n", "\t__fixargv0();\n", "\tfprint(2, \"%s: %s\\n\", argv0 ? argv0 : \"<prog>\", buf);\n", "\texits(\"fatal\");\n", "}"]}, {"ghidra": ["\n", "ulong getcallerpc(void *x)\n", "\n", "{\n", "  return *(ulong *)((long)x + -8);\n", "}\n", "\n"], "c": ["ulong\n", "getcallerpc(void *x)\n", "{\n", "\treturn (((ulong*)(x))[-1]);\n", "}"]}, {"ghidra": ["\n", "void unlock(Lock *l)\n", "\n", "{\n", "  anon_subr_void_Lock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _unlock;\n", "  if (_unlock != (anon_subr_void_Lock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "unlock(Lock *l)\n", "{\n", "\tif(_unlock)\n", "\t\t(*_unlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 0;\n", "}"]}, {"ghidra": ["\n", "void * p9malloc(ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  if (n == 0) {\n", "    n = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = malloc(n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9malloc(ulong n)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(n == 0)\n", "\t\tn++;\n", "\tlock(&malloclock);\n", "\tv = malloc(n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void __fmtlock(void)\n", "\n", "{\n", "  lock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtlock(void)\n", "{\n", "\tlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "int p9putenv(char *s,char *v)\n", "\n", "{\n", "  int iVar1;\n", "  char *__string;\n", "  \n", "  __string = smprint(\"%s=%s\",s,v);\n", "  if (__string == (char *)0x0) {\n", "    iVar1 = -1;\n", "  }\n", "  else {\n", "    putenv(__string);\n", "    iVar1 = 0;\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "p9putenv(char *s, char *v)\n", "{\n", "\tchar *t;\n", "\n", "\tt = smprint(\"%s=%s\", s, v);\n", "\tif(t == nil)\n", "\t\treturn -1;\n", "\tputenv(t);\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int __errfmt(Fmt *f)\n", "\n", "{\n", "  int iVar1;\n", "  int *piVar2;\n", "  char *s;\n", "  \n", "  piVar2 = __errno_location();\n", "  if (*piVar2 != 0x19283745) {\n", "    s = strerror(*piVar2);\n", "LAB_0040418b:\n", "    iVar1 = fmtstrcpy(f,s);\n", "    return iVar1;\n", "  }\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    s = (*_syserrstr)();\n", "    if (s != (char *)0x0) goto LAB_0040418b;\n", "  }\n", "  iVar1 = fmtstrcpy(f,xsyserr);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "__errfmt(Fmt *f)\n", "{\n", "\tif(errno == EPLAN9)\n", "\t\treturn fmtstrcpy(f, getsyserr());\n", "\treturn fmtstrcpy(f, strerror(errno));\n", "}"]}, {"ghidra": ["\n", "void qunlock(QLock *l)\n", "\n", "{\n", "  anon_subr_void_QLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qunlock;\n", "  if (_qunlock != (anon_subr_void_QLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qunlock(QLock *l)\n", "{\n", "\tif(_qunlock)\n", "\t\t(*_qunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 0;\n", "}"]}, {"ghidra": ["\n", "void * p9realloc(void *v,ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  lock(&malloclock);\n", "  pvVar1 = realloc(v,n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9realloc(void *v, ulong n)\n", "{\n", "\tlock(&malloclock);\n", "\tv = realloc(v, n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "int canrlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->writer == (_Thread *)0x0) {\n", "      l->readers = l->readers + 1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canrlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\treturn (*_rlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer)\n", "\t\t\treturn 0;\n", "\t\tl->readers++;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void wunlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wunlock;\n", "  if (_wunlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wunlock(RWLock *l)\n", "{\n", "\tif(_wunlock)\n", "\t\t(*_wunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = nil;\n", "}"]}, {"ghidra": ["\n", "void rerrstr(char *err,uint n)\n", "\n", "{\n", "  int __errnum;\n", "  char *__dest;\n", "  int *piVar1;\n", "  char *__src;\n", "  \n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    __dest = (*_syserrstr)();\n", "    if ((undefined8 *)__dest != (undefined8 *)0x0) goto LAB_0040405f;\n", "  }\n", "  __dest = xsyserr;\n", "LAB_0040405f:\n", "  piVar1 = __errno_location();\n", "  __errnum = *piVar1;\n", "  if (__errnum == 4) {\n", "    *(undefined4 *)((undefined8 *)__dest + 1) = 0x646574;\n", "    *(undefined8 *)__dest = 0x7075727265746e69;\n", "  }\n", "  else {\n", "    if (__errnum != 0x19283745) {\n", "      __src = strerror(__errnum);\n", "      strcpy(__dest,__src);\n", "    }\n", "  }\n", "  strecpy(err,err + n,__dest);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rerrstr(char *err, uint n)\n", "{\n", "\tchar *syserr;\n", "\n", "\tsyserr = getsyserr();\n", "\tif(errno == EINTR)\n", "\t\tstrcpy(syserr, \"interrupted\");\n", "\telse if(errno != EPLAN9)\n", "\t\tstrcpy(syserr, strerror(errno));\n", "\tstrecpy(err, err+n, syserr);\n", "}"]}, {"ghidra": ["\n", "void rsleep(Rendez *r)\n", "\n", "{\n", "  anon_subr_void_Rendez_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rsleep;\n", "  if (_rsleep != (anon_subr_void_Rendez_ptr_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rsleep(Rendez *r)\n", "{\n", "\tif(_rsleep)\n", "\t\t(*_rsleep)(r, getcallerpc(&r));\n", "}"]}, {"ghidra": ["\n", "int rwakeupall(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,1,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeupall(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 1, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void wlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\t(*_wlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = (void*)1;\n", "}"]}, {"ghidra": ["\n", "int exitcode(char *s)\n", "\n", "{\n", "  return 1;\n", "}\n", "\n"], "c": ["int\n", "exitcode(char *s)\n", "{\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "int canlock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock == (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->held == 0) {\n", "      l->held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canlock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\treturn (*_lock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->held)\n", "\t\t\treturn 0;\n", "\t\tl->held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "char * p9getenv(char *s)\n", "\n", "{\n", "  char *pcVar1;\n", "  \n", "  pcVar1 = getenv(s);\n", "  if (pcVar1 != (char *)0x0) {\n", "    pcVar1 = (char *)__strdup(pcVar1);\n", "    return pcVar1;\n", "  }\n", "  return (char *)0x0;\n", "}\n", "\n"], "c": ["char*\n", "p9getenv(char *s)\n", "{\n", "\tchar *t;\n", "\n", "\tt = getenv(s);\n", "\tif(t == 0)\n", "\t\treturn 0;\n", "\treturn strdup(t);\n", "}"]}, {"ghidra": ["\n", "int canqlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock == (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->l).held == 0) {\n", "      (l->l).held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canqlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\treturn (*_qlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->l.held)\n", "\t\t\treturn 0;\n", "\t\tl->l.held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  long lVar1;\n", "  bool bVar2;\n", "  char cVar3;\n", "  int iVar4;\n", "  QString *pQVar5;\n", "  QVariant *value;\n", "  long in_FS_OFFSET;\n", "  int local_24c;\n", "  QString local_248 [2];\n", "  QString local_238 [2];\n", "  QString local_228 [2];\n", "  QString locale;\n", "  QString local_208 [2];\n", "  QVariant local_1f8;\n", "  QString local_1e8 [2];\n", "  undefined local_1d8 [16];\n", "  QString local_1c8 [2];\n", "  QString local_1b8 [2];\n", "  QString local_1a8 [2];\n", "  QString local_198 [2];\n", "  QString local_188 [2];\n", "  QString local_178 [2];\n", "  QDebug local_168 [2];\n", "  QString local_158 [2];\n", "  QDebug local_148 [2];\n", "  QString local_138 [2];\n", "  QString local_128 [2];\n", "  QString local_118 [2];\n", "  QString local_108 [2];\n", "  undefined local_f8 [16];\n", "  QApplication app;\n", "  undefined8 local_d8;\n", "  undefined4 local_d0;\n", "  undefined local_c8 [16];\n", "  undefined local_b8 [16];\n", "  QTranslator translator;\n", "  MyClass myClass;\n", "  Settings settings;\n", "  QQmlApplicationEngine engine;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  local_24c = argc;\n", "  QApplication(&app,&local_24c,argv,0x50302);\n", "                    /* try { // try from 00402049 to 0040204d has its CatchHandler @ 004027ea */\n", "  QString(local_238,\"2048-Qt\");\n", "                    /* try { // try from 0040205d to 00402061 has its CatchHandler @ 004027e5 */\n", "  QString(local_248,\"xiaoyong\");\n", "                    /* try { // try from 00402075 to 00402079 has its CatchHandler @ 004027d8 */\n", "  Settings(&settings,(QObject *)0x0,local_248,local_238);\n", "                    /* try { // try from 0040207d to 00402081 has its CatchHandler @ 004027ba */\n", "  _QString(local_248);\n", "                    /* try { // try from 00402085 to 00402089 has its CatchHandler @ 004027aa */\n", "  _QString(local_238);\n", "                    /* try { // try from 00402099 to 0040209d has its CatchHandler @ 004027a2 */\n", "  QString(local_228,\"0.1.5\");\n", "                    /* try { // try from 004020a4 to 004020a8 has its CatchHandler @ 0040278f */\n", "  setVersion(&settings,local_228);\n", "                    /* try { // try from 004020ac to 004020b0 has its CatchHandler @ 004027a2 */\n", "  _QString(local_228);\n", "  locale = (Data *)&shared_null;\n", "                    /* try { // try from 004020d1 to 004020d5 has its CatchHandler @ 00402787 */\n", "  QString(local_208,\"language\");\n", "                    /* try { // try from 004020dc to 004020e0 has its CatchHandler @ 0040276f */\n", "  bVar2 = contains(&settings,local_208);\n", "                    /* try { // try from 004020ec to 004020f0 has its CatchHandler @ 00402787 */\n", "  _QString(local_208);\n", "  if (bVar2 == false) {\n", "                    /* try { // try from 0040236a to 0040236e has its CatchHandler @ 00402787 */\n", "    system();\n", "                    /* try { // try from 00402382 to 00402386 has its CatchHandler @ 004026cc */\n", "    name();\n", "                    /* try { // try from 00402392 to 00402396 has its CatchHandler @ 004026ae */\n", "    operator_(&locale,local_1c8);\n", "                    /* try { // try from 0040239a to 0040239e has its CatchHandler @ 004026cc */\n", "    _QString(local_1c8);\n", "                    /* try { // try from 004023a2 to 004023b9 has its CatchHandler @ 00402787 */\n", "    _QLocale(local_1d8);\n", "    value = (QVariant *)(local_c8 + 0x10);\n", "    QVariant(value,&locale);\n", "                    /* try { // try from 004023cc to 004023d0 has its CatchHandler @ 0040269f */\n", "    QString(local_1b8,\"language\");\n", "                    /* try { // try from 004023da to 004023de has its CatchHandler @ 00402684 */\n", "    setValue(&settings,local_1b8,value);\n", "                    /* try { // try from 004023e2 to 004023e6 has its CatchHandler @ 0040269f */\n", "    _QString(local_1b8);\n", "  }\n", "  else {\n", "    local_d8 = 0;\n", "    local_d0 = 0x80000000;\n", "                    /* try { // try from 00402142 to 00402146 has its CatchHandler @ 0040276a */\n", "    QString((QString *)&local_1f8,\"language\");\n", "    value = (QVariant *)&local_d8;\n", "                    /* try { // try from 00402168 to 0040216c has its CatchHandler @ 00402765 */\n", "    value((Settings *)local_c8,(QString *)&settings,&local_1f8);\n", "                    /* try { // try from 00402180 to 00402184 has its CatchHandler @ 00402760 */\n", "    toString();\n", "                    /* try { // try from 00402190 to 00402194 has its CatchHandler @ 0040272a */\n", "    operator_(&locale);\n", "                    /* try { // try from 00402198 to 0040219c has its CatchHandler @ 00402760 */\n", "    _QString(local_1e8);\n", "                    /* try { // try from 004021a0 to 004021a4 has its CatchHandler @ 00402765 */\n", "    _QVariant((Settings *)local_c8);\n", "                    /* try { // try from 004021a8 to 004021ac has its CatchHandler @ 0040276a */\n", "    _QString((QString *)&local_1f8);\n", "  }\n", "                    /* try { // try from 004021b0 to 004021ca has its CatchHandler @ 00402787 */\n", "  _QVariant(value);\n", "  QTranslator(&translator,(QObject *)0x0);\n", "                    /* try { // try from 004021dd to 004021e1 has its CatchHandler @ 00402722 */\n", "  QString(local_1a8,\"en\");\n", "                    /* try { // try from 004021ed to 004021f1 has its CatchHandler @ 0040270f */\n", "  cVar3 = startsWith((QString *)&locale,(CaseSensitivity)local_1a8);\n", "                    /* try { // try from 004021f8 to 00402217 has its CatchHandler @ 00402722 */\n", "  _QString(local_1a8);\n", "  if (cVar3 == '\\0') {\n", "                    /* try { // try from 00402401 to 00402405 has its CatchHandler @ 00402722 */\n", "    operator_((char *)&myClass,(QString *)\"2048-qt_\");\n", "    local_178[0] = (Data *)&shared_null;\n", "    local_188[0] = (Data *)&shared_null;\n", "                    /* try { // try from 0040243f to 00402443 has its CatchHandler @ 0040267f */\n", "    QString(local_198,\":/ts\");\n", "                    /* try { // try from 00402464 to 00402468 has its CatchHandler @ 0040264a */\n", "    cVar3 = load((QString *)&translator,(QString *)&myClass,(QString *)local_198,\n", "                 (QString *)local_188);\n", "                    /* try { // try from 00402470 to 00402474 has its CatchHandler @ 0040267f */\n", "    _QString(local_198);\n", "                    /* try { // try from 00402478 to 0040247c has its CatchHandler @ 004026a9 */\n", "    _QString(local_188);\n", "                    /* try { // try from 00402480 to 004024a9 has its CatchHandler @ 004026a4 */\n", "    _QString(local_178);\n", "    if (cVar3 == '\\0') {\n", "      operator_((char *)local_138,(QString *)\"Failed to load \");\n", "      _engine = 1;\n", "                    /* try { // try from 004025a4 to 004025a8 has its CatchHandler @ 004027f2 */\n", "      debug();\n", "                    /* try { // try from 004025af to 004025b3 has its CatchHandler @ 00402802 */\n", "      operator__(local_148,local_138);\n", "                    /* try { // try from 004025b7 to 004025bb has its CatchHandler @ 004027f2 */\n", "      _QDebug(local_148);\n", "                    /* try { // try from 004025bf to 004025c3 has its CatchHandler @ 004026a4 */\n", "      _QString(local_138);\n", "    }\n", "    else {\n", "      operator_((char *)local_158,(QString *)\"Successfully loaded \");\n", "      _engine = 1;\n", "                    /* try { // try from 00402503 to 00402507 has its CatchHandler @ 0040280f */\n", "      debug();\n", "                    /* try { // try from 0040250e to 00402512 has its CatchHandler @ 0040281f */\n", "      operator__(local_168,local_158);\n", "                    /* try { // try from 00402516 to 0040251a has its CatchHandler @ 0040280f */\n", "      _QDebug(local_168);\n", "                    /* try { // try from 0040251e to 0040254a has its CatchHandler @ 004026a4 */\n", "      _QString(local_158);\n", "      installTranslator(&translator);\n", "    }\n", "                    /* try { // try from 004025c7 to 004025cb has its CatchHandler @ 00402722 */\n", "    _QString((QString *)&myClass);\n", "  }\n", "  QQmlApplicationEngine(&engine,(QObject *)0x0);\n", "                    /* try { // try from 00402225 to 00402229 has its CatchHandler @ 00402707 */\n", "  MyClass(&myClass,(QObject *)0x0);\n", "                    /* try { // try from 0040223c to 00402240 has its CatchHandler @ 004026ff */\n", "  QString(local_128,\"myClass\");\n", "                    /* try { // try from 00402244 to 00402256 has its CatchHandler @ 004026ec */\n", "  pQVar5 = (QString *)rootContext();\n", "  setContextProperty(pQVar5,(QObject *)local_128);\n", "                    /* try { // try from 0040225a to 00402275 has its CatchHandler @ 004026ff */\n", "  _QString(local_128);\n", "  QString(local_118,\"settings\");\n", "                    /* try { // try from 00402279 to 0040228b has its CatchHandler @ 004026d9 */\n", "  pQVar5 = (QString *)rootContext();\n", "  setContextProperty(pQVar5,(QObject *)local_118);\n", "                    /* try { // try from 0040228f to 004022af has its CatchHandler @ 004026ff */\n", "  _QString(local_118);\n", "  fromUtf8_helper((char *)local_108,0x40333c);\n", "                    /* try { // try from 004022c0 to 004022c4 has its CatchHandler @ 004026d1 */\n", "  QUrl(local_f8,local_108,0);\n", "                    /* try { // try from 004022cb to 004022cf has its CatchHandler @ 004025d6 */\n", "  load((QUrl *)&engine);\n", "                    /* try { // try from 004022d3 to 004022d7 has its CatchHandler @ 004026d1 */\n", "  _QUrl(local_f8);\n", "                    /* try { // try from 004022db to 004022e4 has its CatchHandler @ 004026ff */\n", "  _QString(local_108);\n", "  iVar4 = exec();\n", "  myClass._0_8_ = &PTR_metaObject_009b0bd0;\n", "                    /* try { // try from 004022fe to 00402302 has its CatchHandler @ 00402707 */\n", "  _QObject((QObject *)&myClass);\n", "                    /* try { // try from 00402306 to 0040230a has its CatchHandler @ 00402722 */\n", "  _QQmlApplicationEngine(&engine);\n", "                    /* try { // try from 0040230f to 00402313 has its CatchHandler @ 00402787 */\n", "  _QTranslator(&translator);\n", "                    /* try { // try from 00402317 to 0040231b has its CatchHandler @ 004027a2 */\n", "  _QString(&locale);\n", "                    /* try { // try from 0040231f to 00402323 has its CatchHandler @ 004027ea */\n", "  _Settings(&settings);\n", "  _QApplication(&app);\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return iVar4;\n", "}\n", "\n"], "c": ["int main(int argc, char *argv[])\n", "{\n", "    QApplication app(argc, argv);\n", "    Settings settings(0, \"xiaoyong\", \"2048-Qt\");\n", "    settings.setVersion(QString(APP_VERSION));\n", "\n", "    // Localization\n", "    QString locale;\n", "    if (settings.contains(\"language\")) {\n", "        locale = settings.value(\"language\").toString();\n", "    } else {\n", "        locale = QLocale::system().name();\n", "        settings.setValue(\"language\", locale);\n", "    }\n", "\n", "    QTranslator translator;\n", "    if (! locale.startsWith(\"en\")) {\n", "        QString tsFile = \"2048-qt_\" + locale;\n", "\n", "        if (translator.load(tsFile, \":/ts\")) {\n", "            qDebug() << \"Successfully loaded \" + tsFile;\n", "            app.installTranslator(&translator);\n", "        } else {\n", "            qDebug() << \"Failed to load \" + tsFile;\n", "        }\n", "    }\n", "\n", "    QQmlApplicationEngine engine;\n", "\n", "    // Access C++ object \"myClass\" from QML as \"myClass\"\n", "    MyClass myClass;\n", "    engine.rootContext()->setContextProperty(\"myClass\", &myClass);\n", "\n", "    // Access C++ object \"settings\" from QML as \"settings\"\n", "    engine.rootContext()->setContextProperty(\"settings\", &settings);\n", "\n", "    engine.load(QUrl(QStringLiteral(\"qrc:///qml/main.qml\")));\n", "\n", "    return app.exec();\n", "}"]}, {"ghidra": ["\n", "void freeelem(Cell *ap,char *s)\n", "\n", "{\n", "  char cVar1;\n", "  int *piVar2;\n", "  long lVar3;\n", "  void *pvVar4;\n", "  int iVar5;\n", "  uint uVar6;\n", "  void *__ptr;\n", "  char *pcVar7;\n", "  void *pvVar8;\n", "  long lVar9;\n", "  \n", "  cVar1 = *s;\n", "  piVar2 = (int *)ap->sval;\n", "  if (cVar1 == '\\0') {\n", "    lVar9 = 0;\n", "  }\n", "  else {\n", "    uVar6 = 0;\n", "    pcVar7 = s;\n", "    do {\n", "      pcVar7 = pcVar7 + 1;\n", "      uVar6 = uVar6 * 0x1f + (int)cVar1;\n", "      cVar1 = *pcVar7;\n", "    } while (cVar1 != '\\0');\n", "    lVar9 = (long)(int)(uVar6 % piVar2[1]) * 8;\n", "  }\n", "  lVar3 = *(long *)(piVar2 + 2);\n", "  pvVar4 = *(void **)(lVar9 + lVar3);\n", "  if (pvVar4 != (void *)0x0) {\n", "    pvVar8 = (void *)0x0;\n", "    do {\n", "      __ptr = pvVar4;\n", "      iVar5 = strcmp(s,*(char **)((long)__ptr + 8));\n", "      pvVar4 = *(void **)((long)__ptr + 0x28);\n", "      if (iVar5 == 0) {\n", "        if (pvVar8 == (void *)0x0) {\n", "          *(void **)(lVar9 + lVar3) = pvVar4;\n", "        }\n", "        else {\n", "          *(void **)((long)pvVar8 + 0x28) = pvVar4;\n", "        }\n", "        if (((*(uint *)((long)__ptr + 0x20) & 6) == 2) &&\n", "           (*(void **)((long)__ptr + 0x10) != (void *)0x0)) {\n", "          free(*(void **)((long)__ptr + 0x10));\n", "          *(undefined8 *)((long)__ptr + 0x10) = 0;\n", "        }\n", "        free(*(void **)((long)__ptr + 8));\n", "        free(__ptr);\n", "        *piVar2 = *piVar2 + -1;\n", "        return;\n", "      }\n", "      pvVar8 = __ptr;\n", "    } while (pvVar4 != (void *)0x0);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void freeelem(Cell *ap, char *s)\t/* free elem s from ap (i.e., ap[\"s\"] */\n", "{\n", "\tArray *tp;\n", "\tCell *p, *prev = NULL;\n", "\tint h;\n", "\t\n", "\ttp = (Array *) ap->sval;\n", "\th = hash(s, tp->size);\n", "\tfor (p = tp->tab[h]; p != NULL; prev = p, p = p->cnext)\n", "\t\tif (strcmp(s, p->nval) == 0) {\n", "\t\t\tif (prev == NULL)\t/* 1st one */\n", "\t\t\t\ttp->tab[h] = p->cnext;\n", "\t\t\telse\t\t\t/* middle somewhere */\n", "\t\t\t\tprev->cnext = p->cnext;\n", "\t\t\tif (freeable(p))\n", "\t\t\t\txfree(p->sval);\n", "\t\t\tfree(p->nval);\n", "\t\t\tfree(p);\n", "\t\t\ttp->nelem--;\n", "\t\t\treturn;\n", "\t\t}\n", "}"]}, {"ghidra": ["\n", "int isclvar(char *s)\n", "\n", "{\n", "  char cVar1;\n", "  ushort uVar2;\n", "  ushort **ppuVar3;\n", "  char *pcVar4;\n", "  \n", "  ppuVar3 = __ctype_b_loc();\n", "  cVar1 = *s;\n", "  uVar2 = (*ppuVar3)[cVar1];\n", "  if (((uVar2 & 0x400) == 0) && (cVar1 != '_')) {\n", "    return 0;\n", "  }\n", "  if ((cVar1 != '\\0') && ((pcVar4 = s, (uVar2 & 8) != 0 || (cVar1 == '_')))) {\n", "    do {\n", "      pcVar4 = pcVar4;\n", "      pcVar4 = pcVar4 + 1;\n", "      cVar1 = *pcVar4;\n", "      if (cVar1 == '\\0') {\n", "        return 0;\n", "      }\n", "    } while (((*(byte *)(*ppuVar3 + cVar1) & 8) != 0) || (cVar1 == '_'));\n", "    if ((cVar1 == '=') && (s < pcVar4)) {\n", "      return (int)(uint)(pcVar4[2] != '=');\n", "    }\n", "  }\n", "  return 0;\n", "}\n", "\n"], "c": ["int isclvar(char *s)\t/* is s of form var=something ? */\n", "{\n", "\tchar *os = s;\n", "\n", "\tif (!isalpha(*s) && *s != '_')\n", "\t\treturn 0;\n", "\tfor ( ; *s; s++)\n", "\t\tif (!(isalnum(*s) || *s == '_'))\n", "\t\t\tbreak;\n", "\treturn *s == '=' && s > os && *(s+1) != '=';\n", "}"]}, {"ghidra": ["\n", "int getrec(char **pbuf,int *pbufsize,int isrecord)\n", "\n", "{\n", "  long lVar1;\n", "  int firsttime;\n", "  int iVar2;\n", "  char *s;\n", "  Cell *pCVar3;\n", "  Cell **ppCVar4;\n", "  long in_FS_OFFSET;\n", "  double dVar5;\n", "  int bufsize;\n", "  char *buf;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  buf = *pbuf;\n", "  bufsize = *pbufsize;\n", "  if (firsttime != 0) {\n", "    firsttime = 0;\n", "    initgetrec();\n", "  }\n", "  if (dbg != 0) {\n", "    __printf_chk(*ARGC,1,\"RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\\n\",*RS,*FS,*FILENAME);\n", "  }\n", "  if (isrecord != 0) {\n", "    donefld = 0;\n", "    donerec = 1;\n", "  }\n", "  *buf = '\\0';\n", "LAB_00407294:\n", "  do {\n", "    dVar5 = (double)argno;\n", "    if (((double)*ARGC <= dVar5) && (infile != stdin)) {\n", "      *pbuf = buf;\n", "      *pbufsize = bufsize;\n", "      iVar2 = 0;\n", "      goto LAB_00407410;\n", "    }\n", "    if (dbg == 0) {\n", "      if (infile == (FILE *)0x0) goto LAB_004072f7;\n", "LAB_00407240:\n", "      iVar2 = readrec(&buf,&bufsize,infile);\n", "      if ((iVar2 != 0) || (*buf != '\\0')) {\n", "        if (isrecord != 0) {\n", "          pCVar3 = *fldtab;\n", "          ppCVar4 = fldtab;\n", "          if (((pCVar3->tval & 6U) == 2) && (pCVar3->sval != (char *)0x0)) {\n", "            free(pCVar3->sval);\n", "            ppCVar4 = fldtab;\n", "            (*fldtab)->sval = (char *)0x0;\n", "            pCVar3 = *ppCVar4;\n", "          }\n", "          pCVar3->sval = buf;\n", "          pCVar3 = *ppCVar4;\n", "          pCVar3->tval = 0x86;\n", "          iVar2 = is_number(pCVar3->sval);\n", "          if (iVar2 != 0) {\n", "            pCVar3 = *fldtab;\n", "            dVar5 = strtod(pCVar3->sval,(char **)0x0);\n", "            ppCVar4 = fldtab;\n", "            *(double *)&pCVar3->fval = dVar5;\n", "            (*ppCVar4)->tval = (*ppCVar4)->tval | 1;\n", "          }\n", "        }\n", "        setfval(nrloc,(Awkfloat)((double)nrloc->fval + 1.00000000));\n", "        dVar5 = (double)setfval(fnrloc,(Awkfloat)((double)fnrloc->fval + 1.00000000));\n", "        *pbuf = buf;\n", "        *pbufsize = bufsize;\n", "        iVar2 = 1;\n", "LAB_00407410:\n", "        if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "          __stack_chk_fail(dVar5);\n", "        }\n", "        return iVar2;\n", "      }\n", "      if (infile != stdin) {\n", "        fclose((FILE *)infile);\n", "      }\n", "      infile = (FILE *)0x0;\n", "    }\n", "    else {\n", "      __printf_chk(dVar5,1,\"argno=%d, file=|%s|\\n\");\n", "      if (infile != (FILE *)0x0) goto LAB_00407240;\n", "LAB_004072f7:\n", "      s = getargv(argno);\n", "      file = s;\n", "      if (*s != '\\0') {\n", "        iVar2 = isclvar(s);\n", "        if (iVar2 == 0) {\n", "          *FILENAME = s;\n", "          if (dbg == 0) {\n", "            if (*file != '-') goto LAB_0040734d;\n", "LAB_00407430:\n", "            if (file[1] != '\\0') goto LAB_0040734d;\n", "            infile = stdin;\n", "          }\n", "          else {\n", "            __printf_chk(1,\"opening file %s\\n\",file);\n", "            if (*file == '-') goto LAB_00407430;\n", "LAB_0040734d:\n", "            infile = (FILE *)fopen(file,\"r\");\n", "            if (infile == (FILE *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "              FATAL(\"can\\'t open file %s\",file);\n", "            }\n", "          }\n", "          setfval(fnrloc,0.00000000);\n", "          goto LAB_00407240;\n", "        }\n", "        setclvar(s);\n", "        argno = argno + 1;\n", "        goto LAB_00407294;\n", "      }\n", "    }\n", "    argno = argno + 1;\n", "  } while( true );\n", "}\n", "\n"], "c": ["int getrec(char **pbuf, int *pbufsize, int isrecord)\t/* get next input record */\n", "{\t\t\t/* note: cares whether buf == record */\n", "\tint c;\n", "\tstatic int firsttime = 1;\n", "\tchar *buf = *pbuf;\n", "\tint bufsize = *pbufsize;\n", "\n", "\tif (firsttime) {\n", "\t\tfirsttime = 0;\n", "\t\tinitgetrec();\n", "\t}\n", "\t   dprintf( (\"RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\\n\",\n", "\t\t*RS, *FS, *ARGC, *FILENAME) );\n", "\tif (isrecord) {\n", "\t\tdonefld = 0;\n", "\t\tdonerec = 1;\n", "\t}\n", "\tbuf[0] = 0;\n", "\twhile (argno < *ARGC || infile == stdin) {\n", "\t\t   dprintf( (\"argno=%d, file=|%s|\\n\", argno, file) );\n", "\t\tif (infile == NULL) {\t/* have to open a new file */\n", "\t\t\tfile = getargv(argno);\n", "\t\t\tif (*file == '\\0') {\t/* it's been zapped */\n", "\t\t\t\targno++;\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t\tif (isclvar(file)) {\t/* a var=value arg */\n", "\t\t\t\tsetclvar(file);\n", "\t\t\t\targno++;\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t\t*FILENAME = file;\n", "\t\t\t   dprintf( (\"opening file %s\\n\", file) );\n", "\t\t\tif (*file == '-' && *(file+1) == '\\0')\n", "\t\t\t\tinfile = stdin;\n", "\t\t\telse if ((infile = fopen(file, \"r\")) == NULL)\n", "\t\t\t\tFATAL(\"can't open file %s\", file);\n", "\t\t\tsetfval(fnrloc, 0.0);\n", "\t\t}\n", "\t\tc = readrec(&buf, &bufsize, infile);\n", "\t\tif (c != 0 || buf[0] != '\\0') {\t/* normal record */\n", "\t\t\tif (isrecord) {\n", "\t\t\t\tif (freeable(fldtab[0]))\n", "\t\t\t\t\txfree(fldtab[0]->sval);\n", "\t\t\t\tfldtab[0]->sval = buf;\t/* buf == record */\n", "\t\t\t\tfldtab[0]->tval = REC | STR | DONTFREE;\n", "\t\t\t\tif (is_number(fldtab[0]->sval)) {\n", "\t\t\t\t\tfldtab[0]->fval = atof(fldtab[0]->sval);\n", "\t\t\t\t\tfldtab[0]->tval |= NUM;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tsetfval(nrloc, nrloc->fval+1);\n", "\t\t\tsetfval(fnrloc, fnrloc->fval+1);\n", "\t\t\t*pbuf = buf;\n", "\t\t\t*pbufsize = bufsize;\n", "\t\t\treturn 1;\n", "\t\t}\n", "\t\t/* EOF arrived on this file; set up next */\n", "\t\tif (infile != stdin)\n", "\t\t\tfclose(infile);\n", "\t\tinfile = NULL;\n", "\t\targno++;\n", "\t}\n", "\t*pbuf = buf;\n", "\t*pbufsize = bufsize;\n", "\treturn 0;\t/* true end of file */\n", "}"]}, {"ghidra": ["\n", "void p9free(void *v)\n", "\n", "{\n", "  if (v != (void *)0x0) {\n", "    lock(&malloclock);\n", "    free(v);\n", "    unlock(&malloclock);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "p9free(void *v)\n", "{\n", "\tif(v == nil)\n", "\t\treturn;\n", "\tlock(&malloclock);\n", "\tfree(v);\n", "\tunlock(&malloclock);\n", "}"]}, {"ghidra": ["\n", "void p9longjmp(long *buf,int val)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  __longjmp_chk();\n", "}\n", "\n"], "c": ["void\n", "p9longjmp(p9jmp_buf buf, int val)\n", "{\n", "\tsiglongjmp((void*)buf, val);\n", "}"]}, {"ghidra": ["\n", "void p9notejmp(void *x,long *buf,int val)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  __longjmp_chk(buf,(ulong)(uint)val);\n", "}\n", "\n"], "c": ["void\n", "p9notejmp(void *x, p9jmp_buf buf, int val)\n", "{\n", "\tUSED(x);\n", "\tsiglongjmp((void*)buf, val);\n", "}"]}, {"ghidra": ["\n", "int adjbuf(char **pbuf,int *psiz,int minlen,int quantum,char **pbptr,char *whatrtn)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  char *__ptr;\n", "  \n", "  if (*psiz < minlen) {\n", "    if (quantum == 0) {\n", "      iVar1 = 0;\n", "      if (pbptr != (char **)0x0) {\n", "LAB_00407b4f:\n", "        __ptr = *pbuf;\n", "        iVar2 = *(int *)pbptr - (int)__ptr;\n", "        goto LAB_00407b58;\n", "      }\n", "      __ptr = (char *)realloc(*pbuf,(long)minlen);\n", "      if (__ptr != (char *)0x0) {\n", "        *pbuf = __ptr;\n", "        *psiz = minlen;\n", "        goto LAB_00407b83;\n", "      }\n", "    }\n", "    else {\n", "      iVar1 = minlen % quantum;\n", "      if (pbptr != (char **)0x0) goto LAB_00407b4f;\n", "      __ptr = *pbuf;\n", "      iVar2 = 0;\n", "LAB_00407b58:\n", "      if (iVar1 != 0) {\n", "        minlen = minlen + (quantum - iVar1);\n", "      }\n", "      __ptr = (char *)realloc(__ptr,(long)minlen);\n", "      if (__ptr != (char *)0x0) {\n", "        *pbuf = __ptr;\n", "        *psiz = minlen;\n", "        if (pbptr != (char **)0x0) {\n", "          *pbptr = __ptr + iVar2;\n", "        }\n", "        goto LAB_00407b83;\n", "      }\n", "    }\n", "    iVar1 = 0;\n", "    if (whatrtn != (char *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "      FATAL(\"out of memory in %s\",whatrtn);\n", "    }\n", "  }\n", "  else {\n", "LAB_00407b83:\n", "    iVar1 = 1;\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int adjbuf(char **pbuf, int *psiz, int minlen, int quantum, char **pbptr,\n", "\tchar *whatrtn)\n", "/* pbuf:    address of pointer to buffer being managed\n", " * psiz:    address of buffer size variable\n", " * minlen:  minimum length of buffer needed\n", " * quantum: buffer size quantum\n", " * pbptr:   address of movable pointer into buffer, or 0 if none\n", " * whatrtn: name of the calling routine if failure should cause fatal error\n", " *\n", " * return   0 for realloc failure, !=0 for success\n", " */\n", "{\n", "\tif (minlen > *psiz) {\n", "\t\tchar *tbuf;\n", "\t\tint rminlen = quantum ? minlen % quantum : 0;\n", "\t\tint boff = pbptr ? *pbptr - *pbuf : 0;\n", "\t\t/* round up to next multiple of quantum */\n", "\t\tif (rminlen)\n", "\t\t\tminlen += quantum - rminlen;\n", "\t\ttbuf = (char *) realloc(*pbuf, minlen);\n", "\t\tif (tbuf == NULL) {\n", "\t\t\tif (whatrtn)\n", "\t\t\t\tFATAL(\"out of memory in %s\", whatrtn);\n", "\t\t\treturn 0;\n", "\t\t}\n", "\t\t*pbuf = tbuf;\n", "\t\t*psiz = minlen;\n", "\t\tif (pbptr)\n", "\t\t\t*pbptr = tbuf + boff;\n", "\t}\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "int ptoi(void *p)\n", "\n", "{\n", "  return (int)p;\n", "}\n", "\n"], "c": ["int ptoi(void *p)\t/* convert pointer to integer */\n", "{\n", "\treturn (int) (long) p;\t/* swearing that p fits, of course */\n", "}"]}, {"ghidra": ["\n", "void syminit(void)\n", "\n", "{\n", "  Cell *pCVar1;\n", "  \n", "  literal0 = setsymtab(\"0\",\"0\",0.00000000,0xf,symtab);\n", "  nullloc = setsymtab(\"$zero&null\",\"\",0.00000000,0xf,symtab);\n", "  nullnode = celltonode(nullloc,5);\n", "  pCVar1 = setsymtab(\"FS\",\" \",0.00000000,6,symtab);\n", "  FS = &pCVar1->sval;\n", "  pCVar1 = setsymtab(\"RS\",\"\\n\",0.00000000,6,symtab);\n", "  RS = &pCVar1->sval;\n", "  pCVar1 = setsymtab(\"OFS\",\" \",0.00000000,6,symtab);\n", "  OFS = &pCVar1->sval;\n", "  pCVar1 = setsymtab(\"ORS\",\"\\n\",0.00000000,6,symtab);\n", "  ORS = &pCVar1->sval;\n", "  pCVar1 = setsymtab(\"OFMT\",\"%.6g\",0.00000000,6,symtab);\n", "  OFMT = &pCVar1->sval;\n", "  pCVar1 = setsymtab(\"CONVFMT\",\"%.6g\",0.00000000,6,symtab);\n", "  CONVFMT = &pCVar1->sval;\n", "  pCVar1 = setsymtab(\"FILENAME\",\"\",0.00000000,6,symtab);\n", "  FILENAME = &pCVar1->sval;\n", "  nfloc = setsymtab(\"NF\",\"\",0.00000000,1,symtab);\n", "  NF = &nfloc->fval;\n", "  nrloc = setsymtab(\"NR\",\"\",0.00000000,1,symtab);\n", "  NR = &nrloc->fval;\n", "  fnrloc = setsymtab(\"FNR\",\"\",0.00000000,1,symtab);\n", "  FNR = &fnrloc->fval;\n", "  pCVar1 = setsymtab(\"SUBSEP\",\"\\x1c\",0.00000000,6,symtab);\n", "  SUBSEP = &pCVar1->sval;\n", "  rstartloc = setsymtab(\"RSTART\",\"\",0.00000000,1,symtab);\n", "  RSTART = &rstartloc->fval;\n", "  rlengthloc = setsymtab(\"RLENGTH\",\"\",0.00000000,1,symtab);\n", "  RLENGTH = &rlengthloc->fval;\n", "  symtabloc = setsymtab(\"SYMTAB\",\"\",0.00000000,0x10,symtab);\n", "  *(Array **)&symtabloc->sval = symtab;\n", "  return;\n", "}\n", "\n"], "c": ["void syminit(void)\t/* initialize symbol table with builtin vars */\n", "{\n", "\tliteral0 = setsymtab(\"0\", \"0\", 0.0, NUM|STR|CON|DONTFREE, symtab);\n", "\t/* this is used for if(x)... tests: */\n", "\tnullloc = setsymtab(\"$zero&null\", \"\", 0.0, NUM|STR|CON|DONTFREE, symtab);\n", "\tnullnode = celltonode(nullloc, CCON);\n", "\n", "\tFS = &setsymtab(\"FS\", \" \", 0.0, STR|DONTFREE, symtab)->sval;\n", "\tRS = &setsymtab(\"RS\", \"\\n\", 0.0, STR|DONTFREE, symtab)->sval;\n", "\tOFS = &setsymtab(\"OFS\", \" \", 0.0, STR|DONTFREE, symtab)->sval;\n", "\tORS = &setsymtab(\"ORS\", \"\\n\", 0.0, STR|DONTFREE, symtab)->sval;\n", "\tOFMT = &setsymtab(\"OFMT\", \"%.6g\", 0.0, STR|DONTFREE, symtab)->sval;\n", "\tCONVFMT = &setsymtab(\"CONVFMT\", \"%.6g\", 0.0, STR|DONTFREE, symtab)->sval;\n", "\tFILENAME = &setsymtab(\"FILENAME\", \"\", 0.0, STR|DONTFREE, symtab)->sval;\n", "\tnfloc = setsymtab(\"NF\", \"\", 0.0, NUM, symtab);\n", "\tNF = &nfloc->fval;\n", "\tnrloc = setsymtab(\"NR\", \"\", 0.0, NUM, symtab);\n", "\tNR = &nrloc->fval;\n", "\tfnrloc = setsymtab(\"FNR\", \"\", 0.0, NUM, symtab);\n", "\tFNR = &fnrloc->fval;\n", "\tSUBSEP = &setsymtab(\"SUBSEP\", \"\\034\", 0.0, STR|DONTFREE, symtab)->sval;\n", "\trstartloc = setsymtab(\"RSTART\", \"\", 0.0, NUM, symtab);\n", "\tRSTART = &rstartloc->fval;\n", "\trlengthloc = setsymtab(\"RLENGTH\", \"\", 0.0, NUM, symtab);\n", "\tRLENGTH = &rlengthloc->fval;\n", "\tsymtabloc = setsymtab(\"SYMTAB\", \"\", 0.0, ARR, symtab);\n", "\tsymtabloc->sval = (char *) symtab;\n", "}"]}, {"ghidra": ["\n", "int hexstr(char **pp)\n", "\n", "{\n", "  char cVar1;\n", "  char *pcVar2;\n", "  int iVar3;\n", "  ushort **ppuVar4;\n", "  long lVar5;\n", "  int iVar6;\n", "  long lVar7;\n", "  \n", "  pcVar2 = *pp;\n", "  ppuVar4 = __ctype_b_loc();\n", "  cVar1 = *pcVar2;\n", "  lVar5 = 0;\n", "  iVar3 = 0;\n", "  do {\n", "    iVar6 = (int)cVar1;\n", "    lVar7 = (long)(int)lVar5;\n", "    if (((*ppuVar4)[cVar1] & 0x1000) == 0) goto LAB_00401e1b;\n", "    if (((*ppuVar4)[cVar1] & 0x800) == 0) {\n", "      if ((byte)(cVar1 + 0x9fU) < 6) {\n", "        iVar3 = iVar3 * 0x10 + -0x57 + iVar6;\n", "      }\n", "      else {\n", "        if ((byte)(cVar1 + 0xbfU) < 6) {\n", "          iVar3 = iVar3 * 0x10 + -0x37 + iVar6;\n", "        }\n", "      }\n", "    }\n", "    else {\n", "      iVar3 = iVar3 * 0x10 + -0x30 + iVar6;\n", "    }\n", "    cVar1 = pcVar2[lVar5 + 1];\n", "    lVar5 = lVar5 + 1;\n", "  } while (lVar5 != 4);\n", "  lVar7 = 4;\n", "LAB_00401e1b:\n", "  *pp = pcVar2 + lVar7;\n", "  return iVar3;\n", "}\n", "\n"], "c": ["int\n", "hexstr(char **pp)\t/* find and eval hex string at pp, return new p */\n", "{\n", "\tchar c;\n", "\tint n = 0;\n", "\tint i;\n", "\n", "\tfor (i = 0, c = (*pp)[i]; i < 4 && isxdigit(c); i++, c = (*pp)[i]) {\n", "\t\tif (isdigit(c))\n", "\t\t\tn = 16 * n + c - '0';\n", "\t\telse if ('a' <= c && c <= 'f')\n", "\t\t\tn = 16 * n + c - 'a' + 10;\n", "\t\telse if ('A' <= c && c <= 'F')\n", "\t\t\tn = 16 * n + c - 'A' + 10;\n", "\t}\n", "\t*pp += i;\n", "\treturn n;\n", "}"]}, {"ghidra": ["\n", "void newfld(int n)\n", "\n", "{\n", "  if (nfields < n) {\n", "    growfldtab(n);\n", "  }\n", "  cleanfld(lastfld + 1,n);\n", "  lastfld = n;\n", "  setfval(nfloc,(Awkfloat)(double)n);\n", "  return;\n", "}\n", "\n"], "c": ["void newfld(int n)\t/* add field n after end of existing lastfld */\n", "{\n", "\tif (n > nfields)\n", "\t\tgrowfldtab(n);\n", "\tcleanfld(lastfld+1, n);\n", "\tlastfld = n;\n", "\tsetfval(nfloc, (Awkfloat) n);\n", "}"]}, {"ghidra": ["\n", "int nextc(Rune *rp)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = chartorune(rp,exprp);\n", "  exprp = exprp + iVar1;\n", "  if (*rp != 0x5c) {\n", "    if (*rp == 0) {\n", "      lexdone = 1;\n", "    }\n", "    return 0;\n", "  }\n", "  iVar1 = chartorune(rp,exprp);\n", "  exprp = exprp + iVar1;\n", "  return 1;\n", "}\n", "\n"], "c": ["int\n", "nextc(void)\n", "{\n", "\tif(future==EOF)\n", "\t\tfuture = getnext();\n", "\treturn future;\n", "}"]}, {"ghidra": ["\n", "void arginit(int ac,char **av)\n", "\n", "{\n", "  long lVar1;\n", "  Array *tp;\n", "  int iVar2;\n", "  Cell *pCVar3;\n", "  uint uVar4;\n", "  long in_FS_OFFSET;\n", "  double f;\n", "  char temp [50];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  pCVar3 = setsymtab(\"ARGC\",\"\",(Awkfloat)(double)ac,1,symtab);\n", "  ARGC = &pCVar3->fval;\n", "  pCVar3 = setsymtab(\"ARGV\",\"\",0.00000000,0x10,symtab);\n", "  ARGVtab = makesymtab(0x32);\n", "  *(Array **)&pCVar3->sval = ARGVtab;\n", "  uVar4 = 0;\n", "  if (0 < ac) {\n", "    do {\n", "      while( true ) {\n", "        __sprintf_chk(temp,1,0x32,0x41202c,(ulong)uVar4);\n", "        iVar2 = is_number(*av);\n", "        tp = ARGVtab;\n", "        if (iVar2 != 0) break;\n", "        uVar4 = uVar4 + 1;\n", "        setsymtab(temp,*av,0.00000000,2,ARGVtab);\n", "        av = av + 1;\n", "        if (uVar4 == ac) goto LAB_004051e8;\n", "      }\n", "      uVar4 = uVar4 + 1;\n", "      f = strtod(*av,(char **)0x0);\n", "      setsymtab(temp,*av,(Awkfloat)f,3,tp);\n", "      av = av + 1;\n", "    } while (uVar4 != ac);\n", "  }\n", "LAB_004051e8:\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void arginit(int ac, char **av)\t/* set up ARGV and ARGC */\n", "{\n", "\tCell *cp;\n", "\tint i;\n", "\tchar temp[50];\n", "\n", "\tARGC = &setsymtab(\"ARGC\", \"\", (Awkfloat) ac, NUM, symtab)->fval;\n", "\tcp = setsymtab(\"ARGV\", \"\", 0.0, ARR, symtab);\n", "\tARGVtab = makesymtab(NSYMTAB);\t/* could be (int) ARGC as well */\n", "\tcp->sval = (char *) ARGVtab;\n", "\tfor (i = 0; i < ac; i++) {\n", "\t\tsprintf(temp, \"%d\", i);\n", "\t\tif (is_number(*av))\n", "\t\t\tsetsymtab(temp, *av, atof(*av), STR|NUM, ARGVtab);\n", "\t\telse\n", "\t\t\tsetsymtab(temp, *av, 0.0, STR, ARGVtab);\n", "\t\tav++;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void freesymtab(Cell *ap)\n", "\n", "{\n", "  int iVar1;\n", "  char *__ptr;\n", "  void *pvVar2;\n", "  void **ppvVar3;\n", "  void *__ptr_00;\n", "  long lVar4;\n", "  int iVar5;\n", "  \n", "  if (((*(byte *)&ap->tval & 0x10) != 0) && (__ptr = ap->sval, __ptr != (char *)0x0)) {\n", "    lVar4 = 0;\n", "    iVar5 = 0;\n", "    if (0 < *(int *)(__ptr + 4)) {\n", "      do {\n", "        ppvVar3 = (void **)(lVar4 + *(long *)(__ptr + 8));\n", "        __ptr_00 = *ppvVar3;\n", "        if (*ppvVar3 != (void *)0x0) {\n", "          do {\n", "            if (*(void **)((long)__ptr_00 + 8) != (void *)0x0) {\n", "              free(*(void **)((long)__ptr_00 + 8));\n", "              *(undefined8 *)((long)__ptr_00 + 8) = 0;\n", "            }\n", "            if (((*(uint *)((long)__ptr_00 + 0x20) & 6) == 2) &&\n", "               (*(void **)((long)__ptr_00 + 0x10) != (void *)0x0)) {\n", "              free(*(void **)((long)__ptr_00 + 0x10));\n", "            }\n", "            pvVar2 = *(void **)((long)__ptr_00 + 0x28);\n", "            free(__ptr_00);\n", "            __ptr_00 = pvVar2;\n", "          } while (pvVar2 != (void *)0x0);\n", "          ppvVar3 = (void **)(lVar4 + *(long *)(__ptr + 8));\n", "        }\n", "        iVar5 = iVar5 + 1;\n", "        lVar4 = lVar4 + 8;\n", "        iVar1 = *(int *)(__ptr + 4);\n", "        iVar1 = *(int *)(__ptr + 4);\n", "        *ppvVar3 = (void *)0x0;\n", "      } while (iVar1 != iVar5 && iVar5 <= iVar1);\n", "    }\n", "    free(*(void **)(__ptr + 8));\n", "    free(__ptr);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void freesymtab(Cell *ap)\t/* free a symbol table */\n", "{\n", "\tCell *cp, *temp;\n", "\tArray *tp;\n", "\tint i;\n", "\n", "\tif (!isarr(ap))\n", "\t\treturn;\n", "\ttp = (Array *) ap->sval;\n", "\tif (tp == NULL)\n", "\t\treturn;\n", "\tfor (i = 0; i < tp->size; i++) {\n", "\t\tfor (cp = tp->tab[i]; cp != NULL; cp = temp) {\n", "\t\t\txfree(cp->nval);\n", "\t\t\tif (freeable(cp))\n", "\t\t\t\txfree(cp->sval);\n", "\t\t\ttemp = cp->cnext;\t/* avoids freeing then using */\n", "\t\t\tfree(cp); \n", "\t\t}\n", "\t\ttp->tab[i] = 0;\n", "\t}\n", "\tfree(tp->tab);\n", "\tfree(tp);\n", "}"]}, {"ghidra": ["\n", "void rlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\t(*_rlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers++;\n", "}"]}, {"ghidra": ["\n", "void WARNING(char *fmt,...)\n", "\n", "{\n", "  long lVar1;\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list varg;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  fflush(stdout);\n", "  __fprintf_chk(stderr,1,&DAT_00411f36,cmdname);\n", "  varg[0].overflow_arg_area = &stack0x00000008;\n", "  varg[0].gp_offset = 8;\n", "  varg[0].reg_save_area = local_b8;\n", "  varg[0].fp_offset = 0x30;\n", "  __vfprintf_chk(stderr,1,fmt,varg);\n", "  error();\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void WARNING(char *fmt, ...)\n", "{\n", "\textern char *cmdname;\n", "\tva_list varg;\n", "\n", "\tfflush(stdout);\n", "\tfprintf(stderr, \"%s: \", cmdname);\n", "\tva_start(varg, fmt);\n", "\tvfprintf(stderr, fmt, varg);\n", "\tva_end(varg);\n", "\terror();\n", "}"]}, {"ghidra": ["\n", "int hash(char *s,int n)\n", "\n", "{\n", "  char cVar1;\n", "  uint uVar2;\n", "  \n", "  cVar1 = *s;\n", "  uVar2 = 0;\n", "  if (cVar1 != '\\0') {\n", "    do {\n", "      s = s + 1;\n", "      uVar2 = uVar2 * 0x1f + (int)cVar1;\n", "      cVar1 = *s;\n", "    } while (cVar1 != '\\0');\n", "    uVar2 = uVar2 % n;\n", "  }\n", "  return (int)uVar2;\n", "}\n", "\n"], "c": ["int hash(char *s, int n)\t/* form hash value for string s */\n", "{\n", "\tunsigned hashval;\n", "\n", "\tfor (hashval = 0; *s != '\\0'; s++)\n", "\t\thashval = (*s + 31 * hashval);\n", "\treturn hashval % n;\n", "}"]}, {"ghidra": ["\n", "int refldbld(char *rec,char *fs)\n", "\n", "{\n", "  int iVar1;\n", "  size_t sVar2;\n", "  void *p;\n", "  Cell *pCVar3;\n", "  long lVar4;\n", "  char *__dest;\n", "  uint n;\n", "  Cell **ppCVar5;\n", "  \n", "  sVar2 = strlen(rec);\n", "  iVar1 = fieldssize;\n", "  if (fieldssize < (int)sVar2) {\n", "    if (fields != (char *)0x0) {\n", "      free(fields);\n", "    }\n", "    iVar1 = (int)(sVar2 & 0xffffffff);\n", "    fields = (char *)malloc((long)(iVar1 + 1));\n", "    if (fields == (char *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "      FATAL(\"out of space for fields in refldbld %d\",sVar2 & 0xffffffff);\n", "    }\n", "  }\n", "  fieldssize = iVar1;\n", "  __dest = fields;\n", "  *fields = '\\0';\n", "  n = 0;\n", "  if (*rec != '\\0') {\n", "    p = compre(fs);\n", "    if (dbg != 0) {\n", "      __printf_chk(1,\"into refldbld, rec = <%s>, pat = <%s>\\n\",rec);\n", "    }\n", "    lVar4 = 0;\n", "    while( true ) {\n", "      n = (int)lVar4 + 1;\n", "      if (nfields < (int)n) {\n", "        growfldtab(n);\n", "      }\n", "      lVar4 = lVar4 + 1;\n", "      pCVar3 = fldtab[lVar4];\n", "      if (((pCVar3->tval & 6U) == 2) && (pCVar3->sval != (char *)0x0)) {\n", "        free(pCVar3->sval);\n", "        ppCVar5 = fldtab + lVar4;\n", "        (*ppCVar5)->sval = (char *)0x0;\n", "        pCVar3 = *ppCVar5;\n", "      }\n", "      iVar1 = dbg;\n", "      pCVar3->tval = 0x46;\n", "      pCVar3->sval = __dest;\n", "      if (iVar1 != 0) {\n", "        __printf_chk(1,\"refldbld: i=%d\\n\",(ulong)n);\n", "      }\n", "      iVar1 = nematch(p,rec,rec);\n", "      if (iVar1 == 0) break;\n", "      if (dbg != 0) {\n", "        __printf_chk(1,\"match %s (%d chars)\\n\",patbeg);\n", "      }\n", "      strncpy(__dest,rec,(size_t)(patbeg + -(long)rec));\n", "      __dest = __dest + 1 + (long)(patbeg + -(long)rec);\n", "      __dest[-1] = '\\0';\n", "      rec = patbeg + patlen;\n", "    }\n", "    if (dbg != 0) {\n", "      __printf_chk(1,\"no match %s\\n\",rec);\n", "    }\n", "    strcpy(__dest,rec);\n", "  }\n", "  return (int)n;\n", "}\n", "\n"], "c": ["int refldbld(char *rec, char *fs)\t/* build fields from reg expr in FS */\n", "{\n", "\t/* this relies on having fields[] the same length as $0 */\n", "\t/* the fields are all stored in this one array with \\0's */\n", "\tchar *fr;\n", "\tvoid *p;\n", "\tint i, n;\n", "\n", "\tn = strlen(rec);\n", "\tif (n > fieldssize) {\n", "\t\txfree(fields);\n", "\t\tif ((fields = (char *) malloc(n+1)) == NULL)\n", "\t\t\tFATAL(\"out of space for fields in refldbld %d\", n);\n", "\t\tfieldssize = n;\n", "\t}\n", "\tfr = fields;\n", "\t*fr = '\\0';\n", "\tif (*rec == '\\0')\n", "\t\treturn 0;\n", "\tp = compre(fs);\n", "\t   dprintf( (\"into refldbld, rec = <%s>, pat = <%s>\\n\", rec, fs) );\n", "\tfor (i = 1; ; i++) {\n", "\t\tif (i > nfields)\n", "\t\t\tgrowfldtab(i);\n", "\t\tif (freeable(fldtab[i]))\n", "\t\t\txfree(fldtab[i]->sval);\n", "\t\tfldtab[i]->tval = FLD | STR | DONTFREE;\n", "\t\tfldtab[i]->sval = fr;\n", "\t\t   dprintf( (\"refldbld: i=%d\\n\", i) );\n", "\t\tif (nematch(p, rec, rec)) {\n", "\t\t\t   dprintf( (\"match %s (%d chars)\\n\", patbeg, patlen) );\n", "\t\t\tstrncpy(fr, rec, patbeg-rec);\n", "\t\t\tfr += patbeg - rec + 1;\n", "\t\t\t*(fr-1) = '\\0';\n", "\t\t\trec = patbeg + patlen;\n", "\t\t} else {\n", "\t\t\t   dprintf( (\"no match %s\\n\", rec) );\n", "\t\t\tstrcpy(fr, rec);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\treturn i;\t\t\n", "}"]}, {"ghidra": ["\n", "void SYNTAX(char *fmt,...)\n", "\n", "{\n", "  int iVar1;\n", "  long lVar2;\n", "  bool bVar3;\n", "  int been_here;\n", "  char in_AL;\n", "  char *pcVar4;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list varg;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar1 = been_here + 1;\n", "  bVar3 = 2 < been_here;\n", "  been_here = iVar1;\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  if (bVar3) goto LAB_00405e43;\n", "  __fprintf_chk(stderr,1,&DAT_00411f36,cmdname);\n", "  varg[0].overflow_arg_area = &stack0x00000008;\n", "  varg[0].gp_offset = 8;\n", "  varg[0].reg_save_area = local_b8;\n", "  varg[0].fp_offset = 0x30;\n", "  __vfprintf_chk(stderr,1,fmt,varg);\n", "  if (compile_time == 1) {\n", "    pcVar4 = cursource();\n", "    iVar1 = lineno;\n", "    if (pcVar4 == (char *)0x0) goto LAB_00405ec5;\n", "    pcVar4 = cursource();\n", "    __fprintf_chk(stderr,1,\" at %s:%d\",pcVar4,(ulong)(uint)iVar1);\n", "  }\n", "  else {\n", "LAB_00405ec5:\n", "    __fprintf_chk(stderr,1,\" at line %d\",(ulong)(uint)lineno);\n", "  }\n", "  if (curfname != (char *)0x0) {\n", "    __fprintf_chk(stderr,1,\" in function %s\");\n", "  }\n", "  fputc(10,stderr);\n", "  errorflag = 2;\n", "  eprint();\n", "LAB_00405e43:\n", "  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void SYNTAX(char *fmt, ...)\n", "{\n", "\textern char *cmdname, *curfname;\n", "\tstatic int been_here = 0;\n", "\tva_list varg;\n", "\n", "\tif (been_here++ > 2)\n", "\t\treturn;\n", "\tfprintf(stderr, \"%s: \", cmdname);\n", "\tva_start(varg, fmt);\n", "\tvfprintf(stderr, fmt, varg);\n", "\tva_end(varg);\n", "\tif(compile_time == 1 && cursource() != NULL)\n", "\t\tfprintf(stderr, \" at %s:%d\", cursource(), lineno);\n", "\telse\n", "\t\tfprintf(stderr, \" at line %d\", lineno);\n", "\tif (curfname != NULL)\n", "\t\tfprintf(stderr, \" in function %s\", curfname);\n", "\tfprintf(stderr, \"\\n\");\n", "\terrorflag = 2;\n", "\teprint();\n", "}"]}, {"ghidra": ["\n", "int rwakeup(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeup(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 0, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int is_number(char *s)\n", "\n", "{\n", "  long lVar1;\n", "  char *pcVar2;\n", "  uint uVar3;\n", "  int *piVar4;\n", "  char cVar5;\n", "  long in_FS_OFFSET;\n", "  double dVar6;\n", "  char *ep;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  switch(*s) {\n", "  case '\\t':\n", "  case '\\n':\n", "  case '\\v':\n", "  case '\\f':\n", "  case '\\r':\n", "  case ' ':\n", "  case '+':\n", "  case '-':\n", "  case '.':\n", "  case '0':\n", "  case '1':\n", "  case '2':\n", "  case '3':\n", "  case '4':\n", "  case '5':\n", "  case '6':\n", "  case '7':\n", "  case '8':\n", "  case '9':\n", "  case 'I':\n", "  case 'N':\n", "  case 'i':\n", "  case 'n':\n", "    piVar4 = __errno_location();\n", "    *piVar4 = 0;\n", "    dVar6 = strtod(s,&ep);\n", "    uVar3 = 0;\n", "    if (((s != ep) &&\n", "        (dVar6 <= \n", "         179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000\n", "        )) && (*piVar4 != 0x22)) {\n", "      cVar5 = *ep;\n", "      if (((byte)(cVar5 - 9U) < 2) || (cVar5 == ' ')) {\n", "        pcVar2 = ep + 1;\n", "        do {\n", "          do {\n", "            ep = pcVar2;\n", "            cVar5 = *ep;\n", "            pcVar2 = ep + 1;\n", "          } while ((byte)(cVar5 - 9U) < 2);\n", "        } while (cVar5 == ' ');\n", "      }\n", "      uVar3 = (uint)(cVar5 == '\\0');\n", "    }\n", "    break;\n", "  default:\n", "    uVar3 = 0;\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return (int)uVar3;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int is_number(char *s)\n", "{\n", "\tdouble r;\n", "\tchar *ep;\n", "\n", "\t/*\n", "\t * fast could-it-be-a-number check before calling strtod,\n", "\t * which takes a surprisingly long time to reject non-numbers.\n", "\t */\n", "\tswitch (*s) {\n", "\tcase '0': case '1': case '2': case '3': case '4':\n", "\tcase '5': case '6': case '7': case '8': case '9':\n", "\tcase '\\t':\n", "\tcase '\\n':\n", "\tcase '\\v':\n", "\tcase '\\f':\n", "\tcase '\\r':\n", "\tcase ' ':\n", "\tcase '-':\n", "\tcase '+':\n", "\tcase '.':\n", "\tcase 'n':\t\t/* nans */\n", "\tcase 'N':\n", "\tcase 'i':\t\t/* infs */\n", "\tcase 'I':\n", "\t\tbreak;\n", "\tdefault:\n", "\t\treturn 0;\t/* can't be a number */\n", "\t}\n", "\n", "\terrno = 0;\n", "\tr = strtod(s, &ep);\n", "\tif (ep == s || r == HUGE_VAL || errno == ERANGE)\n", "\t\treturn 0;\n", "\twhile (*ep == ' ' || *ep == '\\t' || *ep == '\\n')\n", "\t\tep++;\n", "\tif (*ep == '\\0')\n", "\t\treturn 1;\n", "\telse\n", "\t\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int canwlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->writer == (_Thread *)0x0) && (l->readers == 0)) {\n", "      l->writer = (_Thread *)0x1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canwlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\treturn (*_wlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer || l->readers)\n", "\t\t\treturn 0;\n", "\t\tl->writer = (void*)1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void tfree(Cell *a)\n", "\n", "{\n", "  Cell *pCVar1;\n", "  \n", "  pCVar1 = tmps;\n", "  if ((a->tval & 6U) == 2) {\n", "    if (dbg != 0) {\n", "      __printf_chk(1,\"freeing %s %s %o\\n\",a->nval,a->sval);\n", "    }\n", "    pCVar1 = tmps;\n", "    if (a->sval != (char *)0x0) {\n", "      free(a->sval);\n", "      pCVar1 = tmps;\n", "      a->sval = (char *)0x0;\n", "    }\n", "  }\n", "  if (a == pCVar1) {\n", "                    /* WARNING: Subroutine does not return */\n", "    FATAL(\"tempcell list is curdled\");\n", "  }\n", "  a->cnext = pCVar1;\n", "  tmps = a;\n", "  return;\n", "}\n", "\n"], "c": ["void tfree(Cell *a)\t/* free a tempcell */\n", "{\n", "\tif (freeable(a)) {\n", "\t\t   dprintf( (\"freeing %s %s %o\\n\", a->nval, a->sval, a->tval) );\n", "\t\txfree(a->sval);\n", "\t}\n", "\tif (a == tmps)\n", "\t\tFATAL(\"tempcell list is curdled\");\n", "\ta->cnext = tmps;\n", "\ttmps = a;\n", "}"]}, {"ghidra": ["\n", "void * p9calloc(ulong a,ulong b)\n", "\n", "{\n", "  void *pvVar1;\n", "  size_t __nmemb;\n", "  \n", "  __nmemb = a * b;\n", "  if (__nmemb == 0) {\n", "    __nmemb = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = calloc(__nmemb,1);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9calloc(ulong a, ulong b)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(a*b == 0)\n", "\t\ta = b = 1;\n", "\n", "\tlock(&malloclock);\n", "\tv = calloc(a*b, 1);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void closeall(void)\n", "\n", "{\n", "  char **ppcVar1;\n", "  int iVar2;\n", "  files *pfVar3;\n", "  FILE *__stream;\n", "  \n", "  pfVar3 = files;\n", "LAB_0040c249:\n", "  do {\n", "    if (pfVar3->fp != (FILE *)0x0) {\n", "      iVar2 = ferror((FILE *)pfVar3->fp);\n", "      if (iVar2 == 0) {\n", "        iVar2 = pfVar3->mode;\n", "        __stream = pfVar3->fp;\n", "        if (iVar2 != 0xe01d) goto LAB_0040c22d;\n", "LAB_0040c280:\n", "        iVar2 = pclose((FILE *)__stream);\n", "      }\n", "      else {\n", "        WARNING(\"i/o error occurred on %s\",pfVar3->fname);\n", "        iVar2 = pfVar3->mode;\n", "        __stream = pfVar3->fp;\n", "        if (iVar2 == 0xe01d) goto LAB_0040c280;\n", "LAB_0040c22d:\n", "        if (iVar2 == 0x7c) goto LAB_0040c280;\n", "        iVar2 = fclose((FILE *)__stream);\n", "      }\n", "      if (iVar2 == -1) {\n", "        ppcVar1 = &pfVar3->fname;\n", "        pfVar3 = pfVar3 + 1;\n", "        WARNING(\"i/o error occurred while closing %s\",*ppcVar1);\n", "        if (pfVar3 == (files *)&jret) {\n", "          return;\n", "        }\n", "        goto LAB_0040c249;\n", "      }\n", "    }\n", "    pfVar3 = pfVar3 + 1;\n", "    if (pfVar3 == (files *)&jret) {\n", "      return;\n", "    }\n", "  } while( true );\n", "}\n", "\n"], "c": ["void closeall(void)\n", "{\n", "\tint i, stat;\n", "\n", "\tfor (i = 0; i < FOPEN_MAX; i++)\n", "\t\tif (files[i].fp) {\n", "\t\t\tif (ferror(files[i].fp))\n", "\t\t\t\tWARNING( \"i/o error occurred on %s\", files[i].fname );\n", "\t\t\tif (files[i].mode == '|' || files[i].mode == LE)\n", "\t\t\t\tstat = pclose(files[i].fp);\n", "\t\t\telse\n", "\t\t\t\tstat = fclose(files[i].fp);\n", "\t\t\tif (stat == EOF)\n", "\t\t\t\tWARNING( \"i/o error occurred while closing %s\", files[i].fname );\n", "\t\t}\n", "}"]}, {"ghidra": ["\n", "void runlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _runlock;\n", "  if (_runlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + -1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "runlock(RWLock *l)\n", "{\n", "\tif(_runlock)\n", "\t\t(*_runlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers--;\n", "}"]}, {"ghidra": ["\n", "void overflow(void)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  FATAL(\"%s\",\"regular expression too big\");\n", "}\n", "\n"], "c": ["void\n", "overflow(void)\n", "{\n", "\tFATAL(\"%s\", \"regular expression too big\");\n", "}"]}, {"ghidra": ["\n", "void defn(Cell *v,Node *vl,Node *st)\n", "\n", "{\n", "  int iVar1;\n", "  uint uVar2;\n", "  ulong uVar3;\n", "  Awkfloat AVar4;\n", "  \n", "  if ((*(byte *)&v->tval & 0x10) != 0) {\n", "    SYNTAX(\"`%s\\' is an array name and a function name\",v->nval);\n", "    return;\n", "  }\n", "  v->tval = 0x20;\n", "  *(Node **)&v->sval = st;\n", "  iVar1 = dbg;\n", "  if (vl == (Node *)0x0) {\n", "    AVar4 = 0.00000000;\n", "    uVar3 = 0;\n", "  }\n", "  else {\n", "    uVar3 = 0;\n", "    do {\n", "      vl = vl->nnext;\n", "      uVar2 = (int)uVar3 + 1;\n", "      uVar3 = (ulong)uVar2;\n", "    } while (vl != (Node *)0x0);\n", "    AVar4 = (Awkfloat)(double)uVar2;\n", "  }\n", "  v->fval = AVar4;\n", "  if (iVar1 == 0) {\n", "    return;\n", "  }\n", "  __printf_chk(AVar4,1,\"defining func %s (%d args)\\n\",v->nval,uVar3);\n", "  return;\n", "}\n", "\n"], "c": ["void defn(Cell *v, Node *vl, Node *st)\t/* turn on FCN bit in definition, */\n", "{\t\t\t\t\t/*   body of function, arglist */\n", "\tNode *p;\n", "\tint n;\n", "\n", "\tif (isarr(v)) {\n", "\t\tSYNTAX( \"`%s' is an array name and a function name\", v->nval );\n", "\t\treturn;\n", "\t}\n", "\tv->tval = FCN;\n", "\tv->sval = (char *) st;\n", "\tn = 0;\t/* count arguments */\n", "\tfor (p = vl; p; p = p->nnext)\n", "\t\tn++;\n", "\tv->fval = n;\n", "\tdprintf( (\"defining func %s (%d args)\\n\", v->nval, n) );\n", "}"]}, {"ghidra": ["\n", "void nextfile(void)\n", "\n", "{\n", "  if (infile != stdin) {\n", "    fclose((FILE *)infile);\n", "  }\n", "  argno = argno + 1;\n", "  infile = (FILE *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void nextfile(void)\n", "{\n", "\tif (infile != stdin)\n", "\t\tfclose(infile);\n", "\tinfile = NULL;\n", "\targno++;\n", "}"]}, {"ghidra": ["\n", "void recinit(uint n)\n", "\n", "{\n", "  char *pcVar1;\n", "  Cell **ppCVar2;\n", "  Cell *pCVar3;\n", "  char *pcVar4;\n", "  \n", "  pcVar4 = (char *)malloc((ulong)n);\n", "  record = pcVar4;\n", "  pcVar1 = (char *)malloc((ulong)n);\n", "  fields = pcVar1;\n", "  ppCVar2 = (Cell **)malloc((long)(nfields + 1) << 3);\n", "  fldtab = ppCVar2;\n", "  if ((pcVar4 != (char *)0x0 && pcVar1 != (char *)0x0) && (ppCVar2 != (Cell **)0x0)) {\n", "    pCVar3 = (Cell *)malloc(0x30);\n", "    *ppCVar2 = pCVar3;\n", "    pCVar3->sval = pcVar4;\n", "    *(undefined8 *)pCVar3 = 0x101;\n", "    pCVar3->nval = (char *)0x0;\n", "    pCVar3->fval = 0.00000000;\n", "    *(undefined8 *)&pCVar3->tval = 0x86;\n", "    pCVar3->cnext = (Cell *)0x0;\n", "    pcVar4 = tostring(\"0\");\n", "    pCVar3->nval = pcVar4;\n", "    makefields(1,nfields);\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  FATAL(\"out of space for $0 and fields\");\n", "}\n", "\n"], "c": ["void recinit(unsigned int n)\n", "{\n", "\trecord = (char *) malloc(n);\n", "\tfields = (char *) malloc(n);\n", "\tfldtab = (Cell **) malloc((nfields+1) * sizeof(Cell *));\n", "\tif (record == NULL || fields == NULL || fldtab == NULL)\n", "\t\tFATAL(\"out of space for $0 and fields\");\n", "\tfldtab[0] = (Cell *) malloc(sizeof (Cell));\n", "\t*fldtab[0] = dollar0;\n", "\tfldtab[0]->sval = record;\n", "\tfldtab[0]->nval = tostring(\"0\");\n", "\tmakefields(1, nfields);\n", "}"]}, {"ghidra": ["\n", "void bracecheck(void)\n", "\n", "{\n", "  int beenhere;\n", "  int c;\n", "  bool bVar1;\n", "  \n", "  bVar1 = beenhere != 0;\n", "  beenhere = beenhere + 1;\n", "  if (bVar1) {\n", "    return;\n", "  }\n", "  while (c = input(), 1 < c + 1U) {\n", "    bclass(c);\n", "  }\n", "  bcheck2(bracecnt,0x7b,0x7d);\n", "  bcheck2(brackcnt,0x5b,0x5d);\n", "  bcheck2(parencnt,0x28,0x29);\n", "  return;\n", "}\n", "\n"], "c": ["void bracecheck(void)\n", "{\n", "\tint c;\n", "\tstatic int beenhere = 0;\n", "\n", "\tif (beenhere++)\n", "\t\treturn;\n", "\twhile ((c = input()) != EOF && c != '\\0')\n", "\t\tbclass(c);\n", "\tbcheck2(bracecnt, '{', '}');\n", "\tbcheck2(brackcnt, '[', ']');\n", "\tbcheck2(parencnt, '(', ')');\n", "}"]}, {"ghidra": ["\n", "void bclass(int c)\n", "\n", "{\n", "  if (c == 0x5b) {\n", "    brackcnt = brackcnt + 1;\n", "    return;\n", "  }\n", "  if (c < 0x5c) {\n", "    if (c == 0x28) {\n", "      parencnt = parencnt + 1;\n", "      return;\n", "    }\n", "    if (c == 0x29) {\n", "      parencnt = parencnt + -1;\n", "      return;\n", "    }\n", "    return;\n", "  }\n", "  if (c == 0x7b) {\n", "    bracecnt = bracecnt + 1;\n", "    return;\n", "  }\n", "  if (c != 0x7d) {\n", "    if (c != 0x5d) {\n", "      return;\n", "    }\n", "    brackcnt = brackcnt + -1;\n", "    return;\n", "  }\n", "  bracecnt = bracecnt + -1;\n", "  return;\n", "}\n", "\n"], "c": ["void bclass(int c)\n", "{\n", "\tswitch (c) {\n", "\tcase '{': bracecnt++; break;\n", "\tcase '}': bracecnt--; break;\n", "\tcase '[': brackcnt++; break;\n", "\tcase ']': brackcnt--; break;\n", "\tcase '(': parencnt++; break;\n", "\tcase ')': parencnt--; break;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void fpecatch(int n)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  FATAL(\"floating point exception %d\",(ulong)(uint)n);\n", "}\n", "\n"], "c": ["void fpecatch(int n)\n", "{\n", "\tFATAL(\"floating point exception %d\", n);\n", "}"]}, {"ghidra": ["\n", "void fldbld(void)\n", "\n", "{\n", "  long lVar1;\n", "  char cVar2;\n", "  byte bVar3;\n", "  uint uVar4;\n", "  int n;\n", "  size_t sVar5;\n", "  char *pcVar6;\n", "  long *plVar7;\n", "  byte *pbVar8;\n", "  Cell *vp;\n", "  uint *puVar9;\n", "  uint *puVar10;\n", "  Cell **ppCVar11;\n", "  ulong uVar12;\n", "  int n_00;\n", "  byte *pbVar13;\n", "  byte *__s;\n", "  long lVar14;\n", "  long lVar15;\n", "  long in_FS_OFFSET;\n", "  bool bVar16;\n", "  double dVar17;\n", "  char buf [2];\n", "  \n", "  n = donefld;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (donefld != 0) goto LAB_004077a5;\n", "  vp = *fldtab;\n", "  if ((*(byte *)&vp->tval & 2) == 0) {\n", "    getsval(vp);\n", "    vp = *fldtab;\n", "  }\n", "  __s = (byte *)vp->sval;\n", "  sVar5 = strlen((char *)__s);\n", "  n_00 = fieldssize;\n", "  if (fieldssize < (int)sVar5) {\n", "    if (fields != (char *)0x0) {\n", "      free(fields);\n", "    }\n", "    n_00 = (int)(sVar5 & 0xffffffff);\n", "    fields = (char *)malloc((long)(n_00 + 1));\n", "    if (fields == (char *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "      FATAL(\"out of space for fields in fldbld %d\",sVar5 & 0xffffffff);\n", "    }\n", "  }\n", "  fieldssize = n_00;\n", "  pbVar13 = (byte *)fields;\n", "  cVar2 = inputFS[0];\n", "  puVar10 = (uint *)inputFS;\n", "  do {\n", "    puVar9 = puVar10;\n", "    uVar4 = *puVar9 + 0xfefefeff & ~*puVar9;\n", "    _bVar3 = uVar4 & 0x80808080;\n", "    bVar3 = (byte)_bVar3;\n", "    puVar10 = puVar9 + 1;\n", "  } while (_bVar3 == 0);\n", "  bVar16 = (uVar4 & 0x8080) == 0;\n", "  if (bVar16) {\n", "    bVar3 = (byte)(_bVar3 >> 0x10);\n", "  }\n", "  if (bVar16) {\n", "    puVar10 = (uint *)((long)puVar9 + 6);\n", "  }\n", "  if ((long)puVar10 + (-0x61a8c3 - (ulong)CARRY1(bVar3,bVar3)) < 2) {\n", "    if (inputFS[0] == ' ') {\n", "      n = 0;\n", "      do {\n", "        bVar3 = *__s;\n", "        while ((1 < (byte)(bVar3 - 9) && (bVar3 != 0x20))) {\n", "          if (bVar3 == 0) goto LAB_004079a8;\n", "          n = n + 1;\n", "          if (nfields < n) {\n", "            growfldtab(n);\n", "          }\n", "          ppCVar11 = fldtab + n;\n", "          vp = *ppCVar11;\n", "          if (((vp->tval & 6U) == 2) && (vp->sval != (char *)0x0)) {\n", "            free(vp->sval);\n", "            ppCVar11 = fldtab + n;\n", "            (*ppCVar11)->sval = (char *)0x0;\n", "            vp = *ppCVar11;\n", "          }\n", "          *(byte **)&vp->sval = pbVar13;\n", "          (*ppCVar11)->tval = 0x46;\n", "          bVar3 = *__s;\n", "          do {\n", "            pbVar8 = pbVar13;\n", "            __s = __s + 1;\n", "            *pbVar8 = bVar3;\n", "            bVar3 = *__s;\n", "            if ((byte)(bVar3 - 9) < 2) break;\n", "            pbVar13 = pbVar8 + 1;\n", "          } while ((bVar3 & 0xdf) != 0);\n", "          pbVar8[1] = 0;\n", "          bVar3 = *__s;\n", "          pbVar13 = pbVar8 + 2;\n", "        }\n", "        __s = __s + 1;\n", "      } while( true );\n", "    }\n", "    if (inputFS[0] == '\\0') {\n", "      if (*__s == 0) {\n", "        n = 0;\n", "      }\n", "      else {\n", "        lVar14 = 8;\n", "        n = 0;\n", "        do {\n", "          n = n + 1;\n", "          if (nfields < n) {\n", "            growfldtab(n);\n", "          }\n", "          lVar15 = *(long *)((long)fldtab + lVar14);\n", "          if (((*(uint *)(lVar15 + 0x20) & 6) == 2) && (*(void **)(lVar15 + 0x10) != (void *)0x0)) {\n", "            free(*(void **)(lVar15 + 0x10));\n", "            plVar7 = (long *)(lVar14 + (long)fldtab);\n", "            *(undefined8 *)(*plVar7 + 0x10) = 0;\n", "            lVar15 = *plVar7;\n", "          }\n", "          buf[0] = *__s;\n", "          buf[1] = '\\0';\n", "          __s = __s + 1;\n", "          pcVar6 = tostring(buf);\n", "          *(char **)(lVar15 + 0x10) = pcVar6;\n", "          plVar7 = (long *)((long)fldtab + lVar14);\n", "          lVar14 = lVar14 + 8;\n", "          *(undefined4 *)(*plVar7 + 0x20) = 0x42;\n", "        } while (*__s != 0);\n", "      }\n", "LAB_004079a8:\n", "      *pbVar13 = 0;\n", "      goto LAB_00407680;\n", "    }\n", "    if (*__s != 0) {\n", "      lVar14 = 0;\n", "      do {\n", "        pbVar8 = pbVar13;\n", "        n = (int)lVar14;\n", "        n_00 = n + 1;\n", "        if (nfields < n_00) {\n", "          growfldtab(n_00);\n", "        }\n", "        lVar14 = lVar14 + 1;\n", "        ppCVar11 = fldtab + lVar14;\n", "        vp = *ppCVar11;\n", "        if (((vp->tval & 6U) == 2) && (vp->sval != (char *)0x0)) {\n", "          free(vp->sval);\n", "          ppCVar11 = fldtab + lVar14;\n", "          (*ppCVar11)->sval = (char *)0x0;\n", "          vp = *ppCVar11;\n", "        }\n", "        *(byte **)&vp->sval = pbVar8;\n", "        (*ppCVar11)->tval = 0x46;\n", "        bVar3 = *__s;\n", "        pbVar13 = pbVar8;\n", "        if (cVar2 != bVar3 && bVar3 != 10) {\n", "          do {\n", "            pbVar8 = pbVar13;\n", "            if (bVar3 == 0) break;\n", "            pbVar8 = pbVar13 + 1;\n", "            __s = __s + 1;\n", "            *pbVar13 = bVar3;\n", "            bVar3 = *__s;\n", "            pbVar13 = pbVar8;\n", "          } while (cVar2 != bVar3 && bVar3 != 10);\n", "        }\n", "        *pbVar8 = 0;\n", "        bVar3 = *__s;\n", "        __s = __s + 1;\n", "        pbVar13 = pbVar8 + 1;\n", "      } while (bVar3 != 0);\n", "      pbVar8[1] = 0;\n", "      if (nfields < n_00) goto LAB_00407b01;\n", "      cleanfld(n + 2,lastfld);\n", "      lastfld = n_00;\n", "      goto LAB_004076b6;\n", "    }\n", "    if (nfields < 0) goto LAB_00407b01;\n", "    cleanfld(1,lastfld);\n", "    lastfld = 0;\n", "    donefld = 1;\n", "  }\n", "  else {\n", "    n = refldbld((char *)__s,inputFS);\n", "LAB_00407680:\n", "    if (nfields < n) {\n", "LAB_00407b01:\n", "                    /* WARNING: Subroutine does not return */\n", "      FATAL(\"record `%.30s...\\' has too many fields; can\\'t happen\",__s);\n", "    }\n", "    cleanfld(n + 1,lastfld);\n", "    donefld = 1;\n", "    lastfld = n;\n", "    if (0 < n) {\n", "LAB_004076b6:\n", "      donefld = 1;\n", "      lVar14 = 8;\n", "      n_00 = 1;\n", "      do {\n", "        lVar15 = *(long *)((long)fldtab + lVar14);\n", "        n = is_number(*(char **)(lVar15 + 0x10));\n", "        if (n != 0) {\n", "          dVar17 = strtod(*(char **)(lVar15 + 0x10),(char **)0x0);\n", "          *(uint *)(lVar15 + 0x20) = *(uint *)(lVar15 + 0x20) | 1;\n", "          *(double *)(lVar15 + 0x18) = dVar17;\n", "        }\n", "        n_00 = n_00 + 1;\n", "        lVar14 = lVar14 + 8;\n", "        n = lastfld;\n", "      } while (n_00 <= lastfld);\n", "    }\n", "  }\n", "  setfval(nfloc,(Awkfloat)(double)n);\n", "  if ((dbg != 0) && (-1 < lastfld)) {\n", "    lVar14 = 0;\n", "    uVar12 = 0;\n", "    do {\n", "      uVar4 = (int)uVar12 + 1;\n", "      plVar7 = (long *)((long)fldtab + lVar14);\n", "      lVar14 = lVar14 + 8;\n", "      __printf_chk(1,\"field %d (%s): |%s|\\n\",uVar12,*(undefined8 *)(*plVar7 + 8),\n", "                   *(undefined8 *)(*plVar7 + 0x10));\n", "      uVar12 = (ulong)uVar4;\n", "    } while ((int)uVar4 <= lastfld);\n", "  }\n", "LAB_004077a5:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void fldbld(void)\t/* create fields from current record */\n", "{\n", "\t/* this relies on having fields[] the same length as $0 */\n", "\t/* the fields are all stored in this one array with \\0's */\n", "\tchar *r, *fr, sep;\n", "\tCell *p;\n", "\tint i, j, n;\n", "\n", "\tif (donefld)\n", "\t\treturn;\n", "\tif (!isstr(fldtab[0]))\n", "\t\tgetsval(fldtab[0]);\n", "\tr = fldtab[0]->sval;\n", "\tn = strlen(r);\n", "\tif (n > fieldssize) {\n", "\t\txfree(fields);\n", "\t\tif ((fields = (char *) malloc(n+1)) == NULL)\n", "\t\t\tFATAL(\"out of space for fields in fldbld %d\", n);\n", "\t\tfieldssize = n;\n", "\t}\n", "\tfr = fields;\n", "\ti = 0;\t/* number of fields accumulated here */\n", "\tif (strlen(inputFS) > 1) {\t/* it's a regular expression */\n", "\t\ti = refldbld(r, inputFS);\n", "\t} else if ((sep = *inputFS) == ' ') {\t/* default whitespace */\n", "\t\tfor (i = 0; ; ) {\n", "\t\t\twhile (*r == ' ' || *r == '\\t' || *r == '\\n')\n", "\t\t\t\tr++;\n", "\t\t\tif (*r == 0)\n", "\t\t\t\tbreak;\n", "\t\t\ti++;\n", "\t\t\tif (i > nfields)\n", "\t\t\t\tgrowfldtab(i);\n", "\t\t\tif (freeable(fldtab[i]))\n", "\t\t\t\txfree(fldtab[i]->sval);\n", "\t\t\tfldtab[i]->sval = fr;\n", "\t\t\tfldtab[i]->tval = FLD | STR | DONTFREE;\n", "\t\t\tdo\n", "\t\t\t\t*fr++ = *r++;\n", "\t\t\twhile (*r != ' ' && *r != '\\t' && *r != '\\n' && *r != '\\0');\n", "\t\t\t*fr++ = 0;\n", "\t\t}\n", "\t\t*fr = 0;\n", "\t} else if ((sep = *inputFS) == 0) {\t\t/* new: FS=\"\" => 1 char/field */\n", "\t\tfor (i = 0; *r != 0; r++) {\n", "\t\t\tchar buf[2];\n", "\t\t\ti++;\n", "\t\t\tif (i > nfields)\n", "\t\t\t\tgrowfldtab(i);\n", "\t\t\tif (freeable(fldtab[i]))\n", "\t\t\t\txfree(fldtab[i]->sval);\n", "\t\t\tbuf[0] = *r;\n", "\t\t\tbuf[1] = 0;\n", "\t\t\tfldtab[i]->sval = tostring(buf);\n", "\t\t\tfldtab[i]->tval = FLD | STR;\n", "\t\t}\n", "\t\t*fr = 0;\n", "\t} else if (*r != 0) {\t/* if 0, it's a null field */\n", "\t\tfor (;;) {\n", "\t\t\ti++;\n", "\t\t\tif (i > nfields)\n", "\t\t\t\tgrowfldtab(i);\n", "\t\t\tif (freeable(fldtab[i]))\n", "\t\t\t\txfree(fldtab[i]->sval);\n", "\t\t\tfldtab[i]->sval = fr;\n", "\t\t\tfldtab[i]->tval = FLD | STR | DONTFREE;\n", "\t\t\twhile (*r != sep && *r != '\\n' && *r != '\\0')\t/* \\n is always a separator */\n", "\t\t\t\t*fr++ = *r++;\n", "\t\t\t*fr++ = 0;\n", "\t\t\tif (*r++ == 0)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t\t*fr = 0;\n", "\t}\n", "\tif (i > nfields)\n", "\t\tFATAL(\"record `%.30s...' has too many fields; can't happen\", r);\n", "\tcleanfld(i+1, lastfld);\t/* clean out junk from previous record */\n", "\tlastfld = i;\n", "\tdonefld = 1;\n", "\tfor (j = 1; j <= lastfld; j++) {\n", "\t\tp = fldtab[j];\n", "\t\tif(is_number(p->sval)) {\n", "\t\t\tp->fval = atof(p->sval);\n", "\t\t\tp->tval |= NUM;\n", "\t\t}\n", "\t}\n", "\tsetfval(nfloc, (Awkfloat) lastfld);\n", "\tif (dbg) {\n", "\t\tfor (j = 0; j <= lastfld; j++) {\n", "\t\t\tp = fldtab[j];\n", "\t\t\tprintf(\"field %d (%s): |%s|\\n\", j, p->nval, p->sval);\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void funnyvar(Cell *vp,char *rw)\n", "\n", "{\n", "  if ((vp->tval & 0x10U) != 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "    FATAL(\"can\\'t %s %s; it\\'s an array name.\",rw,vp->nval);\n", "  }\n", "  if ((vp->tval & 0x20U) != 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "    FATAL(\"can\\'t %s %s; it\\'s a function.\",rw,vp->nval);\n", "  }\n", "  WARNING((char *)vp->fval,\"funny variable %p: n=%s s=\\\"%s\\\" f=%g t=%o\",vp,vp->nval,vp->sval);\n", "  return;\n", "}\n", "\n"], "c": ["void funnyvar(Cell *vp, char *rw)\n", "{\n", "\tif (isarr(vp))\n", "\t\tFATAL(\"can't %s %s; it's an array name.\", rw, vp->nval);\n", "\tif (vp->tval & FCN)\n", "\t\tFATAL(\"can't %s %s; it's a function.\", rw, vp->nval);\n", "\tWARNING(\"funny variable %p: n=%s s=\\\"%s\\\" f=%g t=%o\",\n", "\t\tvp, vp->nval, vp->sval, vp->fval, vp->tval);\n", "}"]}, {"ghidra": ["\n", "void qlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock != (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\t(*_qlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 1;\n", "}"]}, {"ghidra": ["\n", "void FATAL(char *fmt,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list varg;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  fflush(stdout);\n", "  __fprintf_chk(stderr,1,&DAT_00411f36,cmdname);\n", "  varg[0].overflow_arg_area = &stack0x00000008;\n", "  varg[0].gp_offset = 8;\n", "  varg[0].reg_save_area = local_b8;\n", "  varg[0].fp_offset = 0x30;\n", "  __vfprintf_chk(stderr,1,fmt,varg);\n", "  error();\n", "  if (1 < dbg) {\n", "                    /* WARNING: Subroutine does not return */\n", "    abort();\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(2);\n", "}\n", "\n"], "c": ["void FATAL(char *fmt, ...)\n", "{\n", "\textern char *cmdname;\n", "\tva_list varg;\n", "\n", "\tfflush(stdout);\n", "\tfprintf(stderr, \"%s: \", cmdname);\n", "\tva_start(varg, fmt);\n", "\tvfprintf(stderr, fmt, varg);\n", "\tva_end(varg);\n", "\terror();\n", "\tif (dbg > 1)\t\t/* core dump if serious debugging on */\n", "\t\tabort();\n", "\texit(2);\n", "}"]}, {"ghidra": ["\n", "void lock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock != (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "lock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\t(*_lock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 1;\n", "}"]}, {"ghidra": ["\n", "double ipow(double x,int n)\n", "\n", "{\n", "  double dVar1;\n", "  \n", "  dVar1 = ipow(x,n / 2);\n", "  if ((n & 1U) != 0) {\n", "    return x * dVar1 * dVar1;\n", "  }\n", "  return dVar1 * dVar1;\n", "}\n", "\n"], "c": ["double ipow(double x, int n)\t/* x**n.  ought to be done by pow, but isn't always */\n", "{\n", "\tdouble v;\n", "\n", "\tif (n <= 0)\n", "\t\treturn 1;\n", "\tv = ipow(x, n/2);\n", "\tif (n % 2 == 0)\n", "\t\treturn v * v;\n", "\telse\n", "\t\treturn x * v * v;\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  char cVar1;\n", "  int iVar2;\n", "  int iVar3;\n", "  int iVar4;\n", "  long lVar5;\n", "  char *s;\n", "  char *__s1;\n", "  char **ppcVar6;\n", "  bool bVar7;\n", "  \n", "  cmdname = *argv;\n", "  if (argc == 1) {\n", "    __fprintf_chk(stderr,1,\n", "                  \"Usage: %s [-F fieldsep] [-mf n] [-mr n] [-v var=value] [-f programfile | \\'program\\'] [file ...]\\n\"\n", "                 );\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(1);\n", "  }\n", "  signal(8,fpecatch);\n", "  yyin = (FILE *)0x0;\n", "  symtab = makesymtab(0x32);\n", "  if (argc < 2) {\n", "    s = (char *)0x0;\n", "LAB_00401aa7:\n", "    if (npfile == 0) {\n", "LAB_00401ab4:\n", "      if (dbg == 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "        FATAL(\"no program given\");\n", "      }\n", "                    /* WARNING: Subroutine does not return */\n", "      exit(0);\n", "    }\n", "  }\n", "  else {\n", "    __s1 = argv[1];\n", "    if (*__s1 == '-') {\n", "      cVar1 = __s1[1];\n", "      s = (char *)0x0;\n", "      while (cVar1 != '\\0') {\n", "        if (((*__s1 == '-') && (__s1[1] == '-')) && (__s1[2] == '\\0')) {\n", "          argc = argc - 1;\n", "          argv = argv + 1;\n", "          if (npfile != 0) goto LAB_00401908;\n", "          if (argc != 1) goto LAB_004018e8;\n", "          goto LAB_00401ab4;\n", "        }\n", "        ppcVar6 = argv;\n", "        iVar2 = nfields;\n", "        iVar3 = recsize;\n", "        switch(cVar1) {\n", "        case 'F':\n", "          if (__s1[2] == '\\0') {\n", "            argc = argc - 1;\n", "            ppcVar6 = argv + 1;\n", "            if (argc == 1) goto LAB_00401a12;\n", "            __s1 = argv[2];\n", "            if (*__s1 == 't') {\n", "              if (__s1[1] == '\\0') {\n", "                __s1 = \"\\t\";\n", "              }\n", "            }\n", "            else {\n", "              if (*__s1 == '\\0') goto LAB_00401a12;\n", "            }\n", "LAB_00401a17:\n", "            s = __s1;\n", "            if (*__s1 != '\\0') break;\n", "          }\n", "          else {\n", "            if ((__s1[2] == 't') && (__s1[3] == '\\0')) {\n", "              __s1 = \"\\t\";\n", "              goto LAB_00401a17;\n", "            }\n", "            s = __s1 + 2;\n", "LAB_00401a12:\n", "            __s1 = s;\n", "            if (s != (char *)0x0) goto LAB_00401a17;\n", "          }\n", "          WARNING(\"field separator FS is empty\");\n", "          s = __s1;\n", "          iVar2 = nfields;\n", "          iVar3 = recsize;\n", "          break;\n", "        default:\n", "          WARNING(\"unknown option %s ignored\");\n", "          iVar2 = nfields;\n", "          iVar3 = recsize;\n", "          break;\n", "        case 'V':\n", "          __printf_chk(1,\"awk %s\\n\",version);\n", "                    /* WARNING: Subroutine does not return */\n", "          exit(0);\n", "        case 'd':\n", "          lVar5 = strtol(__s1 + 2,(char **)0x0,10);\n", "          dbg = (int)lVar5;\n", "          if (dbg == 0) {\n", "            dbg = 1;\n", "          }\n", "          __printf_chk(1,\"awk %s\\n\",version);\n", "          iVar2 = nfields;\n", "          iVar3 = recsize;\n", "          break;\n", "        case 'f':\n", "          argc = argc - 1;\n", "          if (argc == 1) {\n", "                    /* WARNING: Subroutine does not return */\n", "            FATAL(\"no program filename\");\n", "          }\n", "          lVar5 = (long)npfile;\n", "          npfile = npfile + 1;\n", "          pfile[lVar5] = argv[2];\n", "          ppcVar6 = argv + 1;\n", "          iVar2 = nfields;\n", "          iVar3 = recsize;\n", "          break;\n", "        case 'm':\n", "          if (__s1[3] == '\\0') {\n", "            argc = argc - 1;\n", "            lVar5 = strtol(argv[2],(char **)0x0,10);\n", "            iVar4 = (int)lVar5;\n", "            ppcVar6 = argv + 1;\n", "          }\n", "          else {\n", "            lVar5 = strtol(__s1 + 3,(char **)0x0,10);\n", "            iVar4 = (int)lVar5;\n", "          }\n", "          iVar2 = iVar4;\n", "          iVar3 = recsize;\n", "          if ((__s1[2] != 'f') && (iVar2 = nfields, iVar3 = iVar4, __s1[2] != 'r')) {\n", "                    /* WARNING: Subroutine does not return */\n", "            FATAL(\"unknown option %s\\n\",__s1);\n", "          }\n", "          break;\n", "        case 's':\n", "          iVar4 = strcmp(__s1,\"-safe\");\n", "          iVar2 = nfields;\n", "          iVar3 = recsize;\n", "          if (iVar4 == 0) {\n", "            safe = 1;\n", "          }\n", "          break;\n", "        case 'v':\n", "          if (__s1[2] == '\\0') {\n", "            argc = argc - 1;\n", "            if (argc == 1) {\n", "              argv = argv + 1;\n", "              argc = 0;\n", "              goto LAB_00401aa7;\n", "            }\n", "            iVar4 = isclvar(argv[2]);\n", "            ppcVar6 = argv + 1;\n", "            iVar2 = nfields;\n", "            iVar3 = recsize;\n", "            if (iVar4 != 0) {\n", "              setclvar(argv[2]);\n", "              iVar2 = nfields;\n", "              iVar3 = recsize;\n", "            }\n", "          }\n", "        }\n", "        recsize = iVar3;\n", "        nfields = iVar2;\n", "        argc = argc - 1;\n", "        argv = ppcVar6 + 1;\n", "        if (argc < 2) goto LAB_00401aa7;\n", "        __s1 = ppcVar6[2];\n", "        if (*__s1 != '-') break;\n", "        cVar1 = __s1[1];\n", "      }\n", "    }\n", "    else {\n", "      s = (char *)0x0;\n", "    }\n", "    if (npfile == 0) {\n", "LAB_004018e8:\n", "      if (dbg != 0) {\n", "        __printf_chk(1,\"program = |%s|\\n\",argv[1]);\n", "      }\n", "      lexprog = argv[1];\n", "      argc = argc - 1;\n", "      argv = argv + 1;\n", "    }\n", "  }\n", "LAB_00401908:\n", "  recinit(recsize);\n", "  syminit();\n", "  bVar7 = dbg != 0;\n", "  compile_time = 1;\n", "  *argv = cmdname;\n", "  if (bVar7) {\n", "    __printf_chk(1,\"argc=%d, argv[0]=%s\\n\",(ulong)(uint)argc);\n", "  }\n", "  arginit(argc,argv);\n", "  if (safe == 0) {\n", "    envinit(environ);\n", "  }\n", "  yyparse();\n", "  ppcVar6 = FS;\n", "  if (s != (char *)0x0) {\n", "    s = qstring(s,0);\n", "    *ppcVar6 = s;\n", "  }\n", "  if (dbg != 0) {\n", "    __printf_chk(1,\"errorflag=%d\\n\",(ulong)(uint)errorflag);\n", "  }\n", "  if (errorflag == 0) {\n", "    compile_time = 0;\n", "    run(winner);\n", "  }\n", "  else {\n", "    bracecheck();\n", "  }\n", "  return errorflag;\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tp9main(argc, argv);\n", "\texits(\"main\");\n", "\treturn 99;\n", "}"]}, {"ghidra": ["\n", "void stdinit(void)\n", "\n", "{\n", "  files[0].fp = stdin;\n", "  files[1].fp = stdout;\n", "  files[2].fp = stderr;\n", "  return;\n", "}\n", "\n"], "c": ["void stdinit(void)\t/* in case stdin, etc., are not constants */\n", "{\n", "\tfiles[0].fp = stdin;\n", "\tfiles[1].fp = stdout;\n", "\tfiles[2].fp = stderr;\n", "}"]}, {"ghidra": ["\n", "int countposn(char *s,int n)\n", "\n", "{\n", "  char *pcVar1;\n", "  int iVar2;\n", "  long lVar3;\n", "  int iVar4;\n", "  \n", "  pcVar1 = s + (long)n;\n", "  iVar4 = 0;\n", "  iVar2 = iVar4;\n", "  if ((s < pcVar1) && (iVar2 = 0, *s != '\\0')) {\n", "    do {\n", "      iVar2 = mblen(s,(long)n);\n", "      lVar3 = (long)iVar2;\n", "      if (iVar2 < 1) {\n", "        lVar3 = 1;\n", "      }\n", "      iVar4 = iVar4 + 1;\n", "      s = s + lVar3;\n", "      iVar2 = iVar4;\n", "    } while ((*s != '\\0') && (s < pcVar1));\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "countposn(char *s, int n)\n", "{\n", "\tint i, j;\n", "\tchar *end;\n", "\n", "\tfor (i = 0, end = s+n; *s && s < end; i++){\n", "\t\tj = mblen(s, n);\n", "\t\tif(j <= 0)\n", "\t\t\tj = 1;\n", "\t\ts += j;\n", "\t}\n", "\treturn(i);\n", "}"]}, {"ghidra": ["\n", "int pmatch(void *p,char *s,char *start)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  long in_FS_OFFSET;\n", "  Resub m;\n", "  \n", "  m.e = 0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  m.s = start;\n", "  iVar2 = regexec9((Reprog *)p,s,&m,1);\n", "  if (iVar2 == 0) {\n", "    patlen = -1;\n", "    patbeg = start;\n", "  }\n", "  else {\n", "    patlen = (int)m.e - (int)m.s;\n", "    patbeg = m.s;\n", "    iVar2 = 1;\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar2;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "pmatch(void *p, char *s, char *start)\n", "{\n", "\tResub m;\n", "\n", "\tm.s.sp = start;\n", "\tm.e.ep = 0;\n", "\tif (regexec((Reprog *) p, (char *) s, &m, 1)) {\n", "\t\tpatbeg = m.s.sp;\n", "\t\tpatlen = m.e.ep-m.s.sp;\n", "\t\treturn 1;\n", "\t}\n", "\tpatlen = -1;\n", "\tpatbeg = start;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "ulong getcallerpc(void *x)\n", "\n", "{\n", "  return *(ulong *)((long)x + -8);\n", "}\n", "\n"], "c": ["ulong\n", "getcallerpc(void *x)\n", "{\n", "\treturn (((ulong*)(x))[-1]);\n", "}"]}, {"ghidra": ["\n", "void unlock(Lock *l)\n", "\n", "{\n", "  anon_subr_void_Lock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _unlock;\n", "  if (_unlock != (anon_subr_void_Lock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "unlock(Lock *l)\n", "{\n", "\tif(_unlock)\n", "\t\t(*_unlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 0;\n", "}"]}, {"ghidra": ["\n", "void * p9malloc(ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  if (n == 0) {\n", "    n = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = malloc(n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9malloc(ulong n)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(n == 0)\n", "\t\tn++;\n", "\tlock(&malloclock);\n", "\tv = malloc(n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void eprint(void)\n", "\n", "{\n", "  char cVar1;\n", "  int been_here;\n", "  int __c;\n", "  char *pcVar2;\n", "  char *pcVar3;\n", "  char *pcVar4;\n", "  \n", "  if (((compile_time & 0xfffffffdU) == 0) || (0 < been_here)) {\n", "    return;\n", "  }\n", "  pcVar3 = ep + -1;\n", "  if (pcVar3 < ebuf + 1) {\n", "    cVar1 = ep[-1];\n", "  }\n", "  else {\n", "    if (ep[-1] == '\\n') {\n", "      pcVar2 = ep + -2;\n", "      cVar1 = ep[-2];\n", "      pcVar3 = pcVar2;\n", "      if (((pcVar2 < ebuf + 1) || (cVar1 == '\\n')) || (cVar1 == '\\0')) goto joined_r0x00405bea;\n", "    }\n", "    else {\n", "      pcVar2 = pcVar3;\n", "      if (ep[-1] == '\\0') goto LAB_00405bf9;\n", "    }\n", "    do {\n", "      pcVar3 = pcVar2 + -1;\n", "      cVar1 = pcVar2[-1];\n", "      if ((pcVar3 < ebuf + 1) || (cVar1 == '\\n')) break;\n", "      pcVar2 = pcVar3;\n", "    } while (cVar1 != '\\0');\n", "  }\n", "joined_r0x00405bea:\n", "  while (cVar1 == '\\n') {\n", "    cVar1 = pcVar3[1];\n", "    pcVar3 = pcVar3 + 1;\n", "  }\n", "LAB_00405bf9:\n", "  been_here = been_here + 1;\n", "  fwrite(\" context is\\n\\t\",1,0xd,stderr);\n", "  pcVar2 = ep + -1;\n", "  pcVar4 = pcVar2;\n", "  if (((pcVar3 <= pcVar2) && (1 < (byte)(ep[-1] - 9U))) && (ep[-1] != ' ')) {\n", "    do {\n", "      pcVar2 = pcVar2 + -1;\n", "      pcVar4 = pcVar3 + -1;\n", "      if ((pcVar2 == pcVar3 + -1) || (pcVar4 = pcVar2, (byte)(*pcVar2 - 9U) < 2)) break;\n", "    } while (*pcVar2 != ' ');\n", "  }\n", "  if (pcVar3 < pcVar4) {\n", "    do {\n", "      while (cVar1 = *pcVar3, cVar1 != '\\0') {\n", "        pcVar3 = pcVar3 + 1;\n", "        _IO_putc((int)cVar1,(_IO_FILE *)stderr);\n", "        if (pcVar3 == pcVar4) goto LAB_00405ca6;\n", "      }\n", "      pcVar3 = pcVar3 + 1;\n", "    } while (pcVar3 != pcVar4);\n", "  }\n", "LAB_00405ca6:\n", "  fwrite(\" >>> \",1,5,stderr);\n", "  if (pcVar3 < ep) {\n", "    do {\n", "      while (cVar1 = *pcVar3, cVar1 != '\\0') {\n", "        pcVar3 = pcVar3 + 1;\n", "        _IO_putc((int)cVar1,(_IO_FILE *)stderr);\n", "        if (ep <= pcVar3) goto LAB_00405cfe;\n", "      }\n", "      pcVar3 = pcVar3 + 1;\n", "    } while (pcVar3 < ep);\n", "  }\n", "LAB_00405cfe:\n", "  fwrite(\" <<< \",1,5,stderr);\n", "  if (*ep != '\\0') {\n", "    while ((__c = input(), __c != 10 && (1 < __c + 1U))) {\n", "      _IO_putc(__c,(_IO_FILE *)stderr);\n", "      bclass(__c);\n", "    }\n", "  }\n", "  _IO_putc(10,(_IO_FILE *)stderr);\n", "  ep = ebuf;\n", "  return;\n", "}\n", "\n"], "c": ["void eprint(void)\t/* try to print context around error */\n", "{\n", "\tchar *p, *q;\n", "\tint c;\n", "\tstatic int been_here = 0;\n", "\textern char ebuf[], *ep;\n", "\n", "\tif (compile_time == 2 || compile_time == 0 || been_here++ > 0)\n", "\t\treturn;\n", "\tp = ep - 1;\n", "\tif (p > ebuf && *p == '\\n')\n", "\t\tp--;\n", "\tfor ( ; p > ebuf && *p != '\\n' && *p != '\\0'; p--)\n", "\t\t;\n", "\twhile (*p == '\\n')\n", "\t\tp++;\n", "\tfprintf(stderr, \" context is\\n\\t\");\n", "\tfor (q=ep-1; q>=p && *q!=' ' && *q!='\\t' && *q!='\\n'; q--)\n", "\t\t;\n", "\tfor ( ; p < q; p++)\n", "\t\tif (*p)\n", "\t\t\tputc(*p, stderr);\n", "\tfprintf(stderr, \" >>> \");\n", "\tfor ( ; p < ep; p++)\n", "\t\tif (*p)\n", "\t\t\tputc(*p, stderr);\n", "\tfprintf(stderr, \" <<< \");\n", "\tif (*ep)\n", "\t\twhile ((c = input()) != '\\n' && c != '\\0' && c != EOF) {\n", "\t\t\tputc(c, stderr);\n", "\t\t\tbclass(c);\n", "\t\t}\n", "\tputc('\\n', stderr);\n", "\tep = ebuf;\n", "}"]}, {"ghidra": ["\n", "void qunlock(QLock *l)\n", "\n", "{\n", "  anon_subr_void_QLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qunlock;\n", "  if (_qunlock != (anon_subr_void_QLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qunlock(QLock *l)\n", "{\n", "\tif(_qunlock)\n", "\t\t(*_qunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 0;\n", "}"]}, {"ghidra": ["\n", "void * p9realloc(void *v,ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  lock(&malloclock);\n", "  pvVar1 = realloc(v,n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9realloc(void *v, ulong n)\n", "{\n", "\tlock(&malloclock);\n", "\tv = realloc(v, n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void recbld(void)\n", "\n", "{\n", "  char cVar1;\n", "  long lVar2;\n", "  int iVar3;\n", "  char *__s;\n", "  size_t sVar4;\n", "  Cell *pCVar5;\n", "  Cell **ppCVar6;\n", "  int iVar7;\n", "  long lVar8;\n", "  long in_FS_OFFSET;\n", "  double dVar9;\n", "  double dVar10;\n", "  char *r;\n", "  \n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (donerec != 1) {\n", "    dVar10 = 1.00000000;\n", "    iVar3 = (int)record;\n", "    r = record;\n", "    iVar7 = iVar3;\n", "    if (1.00000000 <= (double)*NF) {\n", "      lVar8 = 8;\n", "      iVar7 = 1;\n", "      do {\n", "        __s = getsval(*(Cell **)((long)fldtab + lVar8));\n", "        sVar4 = strlen(__s);\n", "        iVar3 = adjbuf(&record,&recsize,((int)r + 1 + (int)sVar4) - (int)record,recsize,&r,\n", "                       \"recbld 1\");\n", "        if (iVar3 == 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "          FATAL(\"created $0 `%.30s...\\' too long\",record);\n", "        }\n", "        cVar1 = *__s;\n", "        *r = cVar1;\n", "        while (cVar1 != '\\0') {\n", "          __s = __s + 1;\n", "          cVar1 = *__s;\n", "          r[1] = cVar1;\n", "          r = r + 1;\n", "        }\n", "        dVar9 = (double)*NF;\n", "        if (dVar10 < dVar9) {\n", "          sVar4 = strlen(*OFS);\n", "          iVar3 = adjbuf(&record,&recsize,((int)r + 2 + (int)sVar4) - (int)record,recsize,&r,\n", "                         \"recbld 2\");\n", "          if (iVar3 == 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "            FATAL(\"created $0 `%.30s...\\' too long\",record);\n", "          }\n", "          __s = *OFS;\n", "          cVar1 = *__s;\n", "          *r = cVar1;\n", "          while (cVar1 != '\\0') {\n", "            __s = __s + 1;\n", "            cVar1 = *__s;\n", "            r[1] = cVar1;\n", "            r = r + 1;\n", "          }\n", "          dVar9 = (double)*NF;\n", "        }\n", "        iVar7 = iVar7 + 1;\n", "        lVar8 = lVar8 + 8;\n", "        dVar10 = (double)iVar7;\n", "      } while (dVar10 <= dVar9);\n", "      iVar3 = (int)record;\n", "      iVar7 = (int)r;\n", "    }\n", "    iVar7 = adjbuf(&record,&recsize,(iVar7 + 2) - iVar3,recsize,&r,\"recbld 3\");\n", "    if (iVar7 == 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "      FATAL(\"built giant record `%.30s...\\'\",record);\n", "    }\n", "    *r = '\\0';\n", "    if (dbg != 0) {\n", "      __printf_chk(1,\"in recbld inputFS=%s, fldtab[0]=%p\\n\",inputFS);\n", "    }\n", "    pCVar5 = *fldtab;\n", "    ppCVar6 = fldtab;\n", "    if (((pCVar5->tval & 6U) == 2) && (pCVar5->sval != (char *)0x0)) {\n", "      free(pCVar5->sval);\n", "      ppCVar6 = fldtab;\n", "      (*fldtab)->sval = (char *)0x0;\n", "      pCVar5 = *ppCVar6;\n", "    }\n", "    __s = record;\n", "    pCVar5->tval = 0x86;\n", "    pCVar5->sval = __s;\n", "    if ((dbg != 0) &&\n", "       (__printf_chk(1,\"in recbld inputFS=%s, fldtab[0]=%p\\n\",inputFS,*ppCVar6), dbg != 0)) {\n", "      __printf_chk(1,\"recbld = |%s|\\n\",record);\n", "    }\n", "    donerec = 1;\n", "  }\n", "  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void recbld(void)\t/* create $0 from $1..$NF if necessary */\n", "{\n", "\tint i;\n", "\tchar *r, *p;\n", "\n", "\tif (donerec == 1)\n", "\t\treturn;\n", "\tr = record;\n", "\tfor (i = 1; i <= *NF; i++) {\n", "\t\tp = getsval(fldtab[i]);\n", "\t\tif (!adjbuf(&record, &recsize, 1+strlen(p)+r-record, recsize, &r, \"recbld 1\"))\n", "\t\t\tFATAL(\"created $0 `%.30s...' too long\", record);\n", "\t\twhile ((*r = *p++) != 0)\n", "\t\t\tr++;\n", "\t\tif (i < *NF) {\n", "\t\t\tif (!adjbuf(&record, &recsize, 2+strlen(*OFS)+r-record, recsize, &r, \"recbld 2\"))\n", "\t\t\t\tFATAL(\"created $0 `%.30s...' too long\", record);\n", "\t\t\tfor (p = *OFS; (*r = *p++) != 0; )\n", "\t\t\t\tr++;\n", "\t\t}\n", "\t}\n", "\tif (!adjbuf(&record, &recsize, 2+r-record, recsize, &r, \"recbld 3\"))\n", "\t\tFATAL(\"built giant record `%.30s...'\", record);\n", "\t*r = '\\0';\n", "\t   dprintf( (\"in recbld inputFS=%s, fldtab[0]=%p\\n\", inputFS, fldtab[0]) );\n", "\n", "\tif (freeable(fldtab[0]))\n", "\t\txfree(fldtab[0]->sval);\n", "\tfldtab[0]->tval = REC | STR | DONTFREE;\n", "\tfldtab[0]->sval = record;\n", "\n", "\t   dprintf( (\"in recbld inputFS=%s, fldtab[0]=%p\\n\", inputFS, fldtab[0]) );\n", "\t   dprintf( (\"recbld = |%s|\\n\", record) );\n", "\tdonerec = 1;\n", "}"]}, {"ghidra": ["\n", "double errcheck(double x,char *s)\n", "\n", "{\n", "  int *piVar1;\n", "  \n", "  piVar1 = __errno_location();\n", "  if (*piVar1 == 0x21) {\n", "    *piVar1 = 0;\n", "    WARNING(\"%s argument out of domain\",s);\n", "    x = 1.00000000;\n", "  }\n", "  else {\n", "    if (*piVar1 == 0x22) {\n", "      *piVar1 = 0;\n", "      WARNING(\"%s result out of range\",s);\n", "      return 1.00000000;\n", "    }\n", "  }\n", "  return x;\n", "}\n", "\n"], "c": ["double errcheck(double x, char *s)\n", "{\n", "\n", "\tif (errno == EDOM) {\n", "\t\terrno = 0;\n", "\t\tWARNING(\"%s argument out of domain\", s);\n", "\t\tx = 1;\n", "\t} else if (errno == ERANGE) {\n", "\t\terrno = 0;\n", "\t\tWARNING(\"%s result out of range\", s);\n", "\t\tx = 1;\n", "\t}\n", "\treturn x;\n", "}"]}, {"ghidra": ["\n", "void cleanfld(int n1,int n2)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  ulong uVar3;\n", "  long lVar4;\n", "  \n", "  uVar3 = SEXT48(n1);\n", "  lVar4 = uVar3 << 3;\n", "  if (n1 <= n2) {\n", "    do {\n", "      lVar1 = *(long *)((long)fldtab + lVar4);\n", "      if (((*(uint *)(lVar1 + 0x20) & 6) == 2) && (*(void **)(lVar1 + 0x10) != (void *)0x0)) {\n", "        free(*(void **)(lVar1 + 0x10));\n", "      }\n", "      uVar2 = (int)uVar3 + 1;\n", "      uVar3 = (ulong)uVar2;\n", "      lVar4 = lVar4 + 8;\n", "      *(undefined8 *)(lVar1 + 0x10) = 0x411f29;\n", "      *(undefined4 *)(lVar1 + 0x20) = 0x46;\n", "    } while ((int)uVar2 <= n2);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void cleanfld(int n1, int n2)\t/* clean out fields n1 .. n2 inclusive */\n", "{\t\t\t\t/* nvals remain intact */\n", "\tCell *p;\n", "\tint i;\n", "\n", "\tfor (i = n1; i <= n2; i++) {\n", "\t\tp = fldtab[i];\n", "\t\tif (freeable(p))\n", "\t\t\txfree(p->sval);\n", "\t\tp->sval = \"\";\n", "\t\tp->tval = FLD | STR | DONTFREE;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int canrlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->writer == (_Thread *)0x0) {\n", "      l->readers = l->readers + 1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canrlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\treturn (*_rlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer)\n", "\t\t\treturn 0;\n", "\t\tl->readers++;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void rehash(Array *tp)\n", "\n", "{\n", "  uint uVar1;\n", "  char cVar2;\n", "  int iVar3;\n", "  Cell **__ptr;\n", "  Cell *pCVar4;\n", "  Cell *pCVar5;\n", "  Cell **ppCVar6;\n", "  long lVar7;\n", "  uint uVar8;\n", "  Cell **ppCVar9;\n", "  char *pcVar10;\n", "  \n", "  iVar3 = tp->size;\n", "  uVar1 = iVar3 * 4;\n", "  ppCVar6 = (Cell **)calloc((long)(int)uVar1,8);\n", "  if (ppCVar6 != (Cell **)0x0) {\n", "    __ptr = tp->tab;\n", "    if (0 < iVar3) {\n", "      ppCVar9 = __ptr;\n", "      do {\n", "        pCVar5 = *ppCVar9;\n", "        while (pCVar5 != (Cell *)0x0) {\n", "          pcVar10 = pCVar5->nval;\n", "          pCVar4 = pCVar5->cnext;\n", "          cVar2 = *pcVar10;\n", "          if (cVar2 == '\\0') {\n", "            lVar7 = 0;\n", "          }\n", "          else {\n", "            uVar8 = 0;\n", "            do {\n", "              pcVar10 = pcVar10 + 1;\n", "              uVar8 = uVar8 * 0x1f + (int)cVar2;\n", "              cVar2 = *pcVar10;\n", "            } while (cVar2 != '\\0');\n", "            lVar7 = (long)(int)(uVar8 % uVar1) << 3;\n", "          }\n", "          pCVar5->cnext = *(Cell **)(lVar7 + (long)ppCVar6);\n", "          *(Cell **)(lVar7 + (long)ppCVar6) = pCVar5;\n", "          pCVar5 = pCVar4;\n", "        }\n", "        ppCVar9 = ppCVar9 + 1;\n", "      } while (ppCVar9 != __ptr + (ulong)(iVar3 - 1) + 1);\n", "    }\n", "    free(__ptr);\n", "    tp->tab = ppCVar6;\n", "    tp->size = uVar1;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void rehash(Array *tp)\t/* rehash items in small table into big one */\n", "{\n", "\tint i, nh, nsz;\n", "\tCell *cp, *op, **np;\n", "\n", "\tnsz = GROWTAB * tp->size;\n", "\tnp = (Cell **) calloc(nsz, sizeof(Cell *));\n", "\tif (np == NULL)\t\t/* can't do it, but can keep running. */\n", "\t\treturn;\t\t/* someone else will run out later. */\n", "\tfor (i = 0; i < tp->size; i++) {\n", "\t\tfor (cp = tp->tab[i]; cp; cp = op) {\n", "\t\t\top = cp->cnext;\n", "\t\t\tnh = hash(cp->nval, nsz);\n", "\t\t\tcp->cnext = np[nh];\n", "\t\t\tnp[nh] = cp;\n", "\t\t}\n", "\t}\n", "\tfree(tp->tab);\n", "\ttp->tab = np;\n", "\ttp->size = nsz;\n", "}"]}, {"ghidra": ["\n", "void wunlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wunlock;\n", "  if (_wunlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wunlock(RWLock *l)\n", "{\n", "\tif(_wunlock)\n", "\t\t(*_wunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = nil;\n", "}"]}, {"ghidra": ["\n", "void rsleep(Rendez *r)\n", "\n", "{\n", "  anon_subr_void_Rendez_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rsleep;\n", "  if (_rsleep != (anon_subr_void_Rendez_ptr_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rsleep(Rendez *r)\n", "{\n", "\tif(_rsleep)\n", "\t\t(*_rsleep)(r, getcallerpc(&r));\n", "}"]}, {"ghidra": ["\n", "int rwakeupall(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,1,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeupall(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 1, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int format(char **pbuf,int *pbufsize,char *s,Node *a)\n", "\n", "{\n", "  char cVar1;\n", "  long lVar2;\n", "  int iVar3;\n", "  long lVar4;\n", "  ushort **ppuVar5;\n", "  Cell *vp;\n", "  size_t sVar6;\n", "  size_t sVar7;\n", "  uint uVar8;\n", "  uint uVar9;\n", "  char *pcVar10;\n", "  char *__nptr;\n", "  undefined4 uVar11;\n", "  char *pcVar12;\n", "  ulong uVar13;\n", "  long in_FS_OFFSET;\n", "  Awkfloat AVar14;\n", "  int fmtsz;\n", "  int bufsize;\n", "  char *fmt;\n", "  char *p;\n", "  char *t;\n", "  char *buf;\n", "  \n", "  pcVar12 = *pbuf;\n", "  bufsize = *pbufsize;\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  fmtsz = recsize;\n", "  p = pcVar12;\n", "  buf = pcVar12;\n", "  fmt = (char *)malloc((long)recsize);\n", "  pcVar10 = s;\n", "  if (fmt == (char *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "    FATAL(\"out of memory in format()\");\n", "  }\n", "LAB_00409807:\n", "  while( true ) {\n", "    cVar1 = *pcVar10;\n", "    while( true ) {\n", "      if (cVar1 == '\\0') {\n", "        *pcVar12 = '\\0';\n", "        free(fmt);\n", "        while (a != (Node *)0x0) {\n", "          execute(a);\n", "          a = a->nnext;\n", "        }\n", "        *pbuf = buf;\n", "        *pbufsize = bufsize;\n", "        if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "          return (int)p - (int)buf;\n", "        }\n", "                    /* WARNING: Subroutine does not return */\n", "        __stack_chk_fail();\n", "      }\n", "      adjbuf(&buf,&bufsize,((int)pcVar12 + 0x33) - (int)buf,recsize,&p,\"format\");\n", "      cVar1 = *pcVar10;\n", "      if (cVar1 == '%') break;\n", "      pcVar10 = pcVar10 + 1;\n", "      pcVar12 = p + 1;\n", "      *p = cVar1;\n", "      cVar1 = *pcVar10;\n", "      p = pcVar12;\n", "    }\n", "    if (pcVar10[1] != '%') break;\n", "    pcVar12 = p + 1;\n", "    *p = '%';\n", "    pcVar10 = pcVar10 + 2;\n", "    p = pcVar12;\n", "  }\n", "  __nptr = pcVar10 + 1;\n", "  lVar4 = strtol(__nptr,(char **)0x0,10);\n", "  uVar8 = (int)(uint)lVar4 >> 0x1f;\n", "  uVar8 = ((uint)lVar4 ^ uVar8) - uVar8;\n", "  iVar3 = uVar8 + 1;\n", "  adjbuf(&buf,&bufsize,(iVar3 + (int)p) - (int)buf,recsize,&p,\"format\");\n", "  t = fmt + 1;\n", "  cVar1 = *pcVar10;\n", "  *fmt = cVar1;\n", "  if (cVar1 != '\\0') {\n", "    ppuVar5 = __ctype_b_loc();\n", "    uVar9 = uVar8;\n", "    do {\n", "      iVar3 = adjbuf(&fmt,&fmtsz,((int)t + 0x33) - (int)fmt,recsize,&t,(char *)0x0);\n", "      if (iVar3 == 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "        FATAL(\"format item %.30s... ran format() out of memory\",s);\n", "      }\n", "      cVar1 = *pcVar10;\n", "      if ((*(byte *)((long)*ppuVar5 + (long)cVar1 * 2 + 1) & 4) == 0) {\n", "LAB_00409998:\n", "        if (cVar1 == '*') {\n", "          vp = execute(a);\n", "          a = a->nnext;\n", "          AVar14 = getfval(vp);\n", "          uVar8 = (uint)(double)AVar14;\n", "          __sprintf_chk(t + -1,1,0xffffffffffffffff,0x41202c,(ulong)uVar8);\n", "          uVar8 = (uVar8 ^ (int)uVar8 >> 0x1f) - ((int)uVar8 >> 0x1f);\n", "          adjbuf(&buf,&bufsize,((int)p + 1 + uVar8) - (int)buf,recsize,&p,\"format\");\n", "          pcVar12 = fmt;\n", "          sVar6 = strlen(fmt);\n", "          t = pcVar12 + sVar6;\n", "          uVar9 = uVar8;\n", "          if (vp->csub == '\\x04') {\n", "            tfree(vp);\n", "          }\n", "        }\n", "      }\n", "      else {\n", "        if (cVar1 != 'l') {\n", "          if ((cVar1 == 'h') || (cVar1 == 'L')) goto LAB_00409998;\n", "          iVar3 = uVar9 + 1;\n", "          break;\n", "        }\n", "      }\n", "      cVar1 = *__nptr;\n", "      *t = cVar1;\n", "      pcVar10 = __nptr;\n", "      if (cVar1 == '\\0') goto LAB_00409ac0;\n", "      __nptr = __nptr + 1;\n", "      t = t + 1;\n", "    } while( true );\n", "  }\n", "  goto LAB_00409acb;\n", "LAB_00409ac0:\n", "  iVar3 = uVar9 + 1;\n", "  __nptr = __nptr + 1;\n", "  t = t + 1;\n", "LAB_00409acb:\n", "  *t = '\\0';\n", "  adjbuf(&buf,&bufsize,(iVar3 + (int)p) - (int)buf,recsize,&p,\"format\");\n", "  switch(*pcVar10) {\n", "  case 'E':\n", "  case 'G':\n", "  case 'e':\n", "  case 'f':\n", "  case 'g':\n", "    uVar13 = 1;\n", "    break;\n", "  default:\n", "    uVar13 = 0;\n", "    WARNING(\"weird printf conversion %s\",fmt);\n", "    break;\n", "  case 'X':\n", "  case 'o':\n", "  case 'u':\n", "  case 'x':\n", "    uVar13 = (ulong)((uint)(pcVar10[-1] != 'l') + 2);\n", "    break;\n", "  case 'c':\n", "    uVar13 = 5;\n", "    break;\n", "  case 'd':\n", "  case 'i':\n", "    uVar13 = 2;\n", "    if (pcVar10[-1] != 'l') {\n", "      t[-1] = 'l';\n", "      *t = 'd';\n", "      t[1] = '\\0';\n", "      t = t + 1;\n", "    }\n", "    break;\n", "  case 's':\n", "    uVar13 = 4;\n", "  }\n", "  if (a == (Node *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "    FATAL(\"not enough args in printf(%s)\",s);\n", "  }\n", "  vp = execute(a);\n", "  uVar9 = 0x32;\n", "  if (0x31 < (int)uVar8) {\n", "    uVar9 = uVar8;\n", "  }\n", "  uVar11 = (undefined4)((ulong)&p >> 0x20);\n", "  a = a->nnext;\n", "  adjbuf(&buf,&bufsize,(uVar9 + 1 + (int)p) - (int)buf,recsize,&p,\"format\");\n", "  switch(uVar13) {\n", "  default:\n", "    strcpy(p,fmt);\n", "    t = getsval(vp);\n", "    sVar6 = strlen(t);\n", "    pcVar12 = p;\n", "    sVar7 = strlen(p);\n", "    if ((int)uVar8 <= (int)(uint)sVar6) {\n", "      uVar8 = (uint)sVar6;\n", "    }\n", "    adjbuf(&buf,&bufsize,((int)pcVar12 + (int)sVar7 + 1 + uVar8) - (int)buf,recsize,&p,\"format\");\n", "    pcVar12 = p;\n", "    sVar6 = strlen(p);\n", "    p = pcVar12 + sVar6;\n", "    strcpy(p,t);\n", "    break;\n", "  case 1:\n", "    getfval(vp);\n", "    __sprintf_chk(p,1,0xffffffffffffffff);\n", "    break;\n", "  case 2:\n", "    AVar14 = getfval(vp);\n", "    pcVar12 = (char *)(long)(double)AVar14;\n", "    goto LAB_00409be8;\n", "  case 3:\n", "switchD_00409b88_caseD_3:\n", "    AVar14 = getfval(vp);\n", "    uVar13 = CONCAT44(uVar11,(int)(double)AVar14);\n", "LAB_00409b9d:\n", "    __sprintf_chk(p,1,0xffffffffffffffff,fmt,uVar13);\n", "    break;\n", "  case 4:\n", "    t = getsval(vp);\n", "    sVar6 = strlen(t);\n", "    if ((int)uVar8 <= (int)(uint)sVar6) {\n", "      uVar8 = (uint)sVar6;\n", "    }\n", "    iVar3 = adjbuf(&buf,&bufsize,(uVar8 + 1 + (int)p) - (int)buf,recsize,&p,(char *)0x0);\n", "    pcVar12 = t;\n", "    if (iVar3 == 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "      FATAL(\"huge string/format (%d chars) in printf %.30s... ran format() out of memory\",\n", "            (ulong)uVar8,t);\n", "    }\n", "LAB_00409be8:\n", "    __sprintf_chk(p,1,0xffffffffffffffff,fmt,pcVar12);\n", "    if (vp->csub != '\\x04') goto LAB_00409bc1;\n", "    goto LAB_00409c0c;\n", "  case 5:\n", "    if ((*(byte *)&vp->tval & 1) == 0) {\n", "      pcVar12 = getsval(vp);\n", "      uVar13 = (ulong)(uint)(int)*pcVar12;\n", "      goto LAB_00409b9d;\n", "    }\n", "    AVar14 = getfval(vp);\n", "    if ((double)AVar14 != 0.00000000) goto switchD_00409b88_caseD_3;\n", "    *p = '\\0';\n", "    p[1] = '\\0';\n", "    p = p + 1;\n", "  }\n", "  if (vp->csub == '\\x04') {\n", "LAB_00409c0c:\n", "    tfree(vp);\n", "  }\n", "LAB_00409bc1:\n", "  pcVar12 = p;\n", "  sVar6 = strlen(p);\n", "  pcVar12 = pcVar12 + sVar6;\n", "  pcVar10 = __nptr;\n", "  p = pcVar12;\n", "  goto LAB_00409807;\n", "}\n", "\n"], "c": ["int format(char **pbuf, int *pbufsize, char *s, Node *a)\t/* printf-like conversions */\n", "{\n", "\tchar *fmt;\n", "\tchar *p, *t, *os;\n", "\tCell *x;\n", "\tint flag = 0, n;\n", "\tint fmtwd; /* format width */\n", "\tint fmtsz = recsize;\n", "\tchar *buf = *pbuf;\n", "\tint bufsize = *pbufsize;\n", "\n", "\tos = s;\n", "\tp = buf;\n", "\tif ((fmt = (char *) malloc(fmtsz)) == NULL)\n", "\t\tFATAL(\"out of memory in format()\");\n", "\twhile (*s) {\n", "\t\tadjbuf(&buf, &bufsize, MAXNUMSIZE+1+p-buf, recsize, &p, \"format\");\n", "\t\tif (*s != '%') {\n", "\t\t\t*p++ = *s++;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\tif (*(s+1) == '%') {\n", "\t\t\t*p++ = '%';\n", "\t\t\ts += 2;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\t/* have to be real careful in case this is a huge number, eg, %100000d */\n", "\t\tfmtwd = atoi(s+1);\n", "\t\tif (fmtwd < 0)\n", "\t\t\tfmtwd = -fmtwd;\n", "\t\tadjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, \"format\");\n", "\t\tfor (t = fmt; (*t++ = *s) != '\\0'; s++) {\n", "\t\t\tif (!adjbuf(&fmt, &fmtsz, MAXNUMSIZE+1+t-fmt, recsize, &t, 0))\n", "\t\t\t\tFATAL(\"format item %.30s... ran format() out of memory\", os);\n", "\t\t\tif (isalpha(*s) && *s != 'l' && *s != 'h' && *s != 'L')\n", "\t\t\t\tbreak;\t/* the ansi panoply */\n", "\t\t\tif (*s == '*') {\n", "\t\t\t\tx = execute(a);\n", "\t\t\t\ta = a->nnext;\n", "\t\t\t\tsprintf(t-1, \"%d\", fmtwd=(int) getfval(x));\n", "\t\t\t\tif (fmtwd < 0)\n", "\t\t\t\t\tfmtwd = -fmtwd;\n", "\t\t\t\tadjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, \"format\");\n", "\t\t\t\tt = fmt + strlen(fmt);\n", "\t\t\t\ttempfree(x);\n", "\t\t\t}\n", "\t\t}\n", "\t\t*t = '\\0';\n", "\t\tif (fmtwd < 0)\n", "\t\t\tfmtwd = -fmtwd;\n", "\t\tadjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, \"format\");\n", "\n", "\t\tswitch (*s) {\n", "\t\tcase 'f': case 'e': case 'g': case 'E': case 'G':\n", "\t\t\tflag = 1;\n", "\t\t\tbreak;\n", "\t\tcase 'd': case 'i':\n", "\t\t\tflag = 2;\n", "\t\t\tif(*(s-1) == 'l') break;\n", "\t\t\t*(t-1) = 'l';\n", "\t\t\t*t = 'd';\n", "\t\t\t*++t = '\\0';\n", "\t\t\tbreak;\n", "\t\tcase 'o': case 'x': case 'X': case 'u':\n", "\t\t\tflag = *(s-1) == 'l' ? 2 : 3;\n", "\t\t\tbreak;\n", "\t\tcase 's':\n", "\t\t\tflag = 4;\n", "\t\t\tbreak;\n", "\t\tcase 'c':\n", "\t\t\tflag = 5;\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tWARNING(\"weird printf conversion %s\", fmt);\n", "\t\t\tflag = 0;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tif (a == NULL)\n", "\t\t\tFATAL(\"not enough args in printf(%s)\", os);\n", "\t\tx = execute(a);\n", "\t\ta = a->nnext;\n", "\t\tn = MAXNUMSIZE;\n", "\t\tif (fmtwd > n)\n", "\t\t\tn = fmtwd;\n", "\t\tadjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, \"format\");\n", "\t\tswitch (flag) {\n", "\t\tcase 0:\tsprintf(p, \"%s\", fmt);\t/* unknown, so dump it too */\n", "\t\t\tt = getsval(x);\n", "\t\t\tn = strlen(t);\n", "\t\t\tif (fmtwd > n)\n", "\t\t\t\tn = fmtwd;\n", "\t\t\tadjbuf(&buf, &bufsize, 1+strlen(p)+n+p-buf, recsize, &p, \"format\");\n", "\t\t\tp += strlen(p);\n", "\t\t\tsprintf(p, \"%s\", t);\n", "\t\t\tbreak;\n", "\t\tcase 1:\tsprintf(p, fmt, getfval(x)); break;\n", "\t\tcase 2:\tsprintf(p, fmt, (long) getfval(x)); break;\n", "\t\tcase 3:\tsprintf(p, fmt, (int) getfval(x)); break;\n", "\t\tcase 4:\n", "\t\t\tt = getsval(x);\n", "\t\t\tn = strlen(t);\n", "\t\t\tif (fmtwd > n)\n", "\t\t\t\tn = fmtwd;\n", "\t\t\tif (!adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, 0))\n", "\t\t\t\tFATAL(\"huge string/format (%d chars) in printf %.30s... ran format() out of memory\", n, t);\n", "\t\t\tsprintf(p, fmt, t);\n", "\t\t\tbreak;\n", "\t\tcase 5:\n", "\t\t\tif (isnum(x)) {\n", "\t\t\t\tif (getfval(x))\n", "\t\t\t\t\tsprintf(p, fmt, (int) getfval(x));\n", "\t\t\t\telse{\n", "\t\t\t\t\t*p++ = '\\0';\n", "\t\t\t\t\t*p = '\\0';\n", "\t\t\t\t}\n", "\t\t\t} else\n", "\t\t\t\tsprintf(p, fmt, getsval(x)[0]);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\ttempfree(x);\n", "\t\tp += strlen(p);\n", "\t\ts++;\n", "\t}\n", "\t*p = '\\0';\n", "\tfree(fmt);\n", "\tfor ( ; a; a = a->nnext)\t\t/* evaluate any remaining args */\n", "\t\texecute(a);\n", "\t*pbuf = buf;\n", "\t*pbufsize = bufsize;\n", "\treturn p - buf;\n", "}"]}, {"ghidra": ["\n", "Awkfloat getfval(Cell *vp)\n", "\n", "{\n", "  uint uVar1;\n", "  int iVar2;\n", "  double dVar3;\n", "  \n", "  uVar1 = vp->tval;\n", "  if ((uVar1 & 3) == 0) {\n", "    funnyvar(vp,\"read value of\");\n", "    uVar1 = vp->tval;\n", "  }\n", "  if (((uVar1 & 0x40) == 0) || (donefld != 0)) {\n", "    if (((uVar1 & 0x80) != 0) && (donerec == 0)) {\n", "      recbld();\n", "      uVar1 = vp->tval;\n", "    }\n", "  }\n", "  else {\n", "    fldbld();\n", "    uVar1 = vp->tval;\n", "  }\n", "  if ((uVar1 & 1) == 0) {\n", "    dVar3 = strtod(vp->sval,(char **)0x0);\n", "    *(double *)&vp->fval = dVar3;\n", "    iVar2 = is_number(vp->sval);\n", "    if ((iVar2 != 0) && ((vp->tval & 8U) == 0)) {\n", "      vp->tval = vp->tval | 1;\n", "    }\n", "  }\n", "  if (dbg != 0) {\n", "    __printf_chk(vp->fval,1,\"getfval %p: %s = %g, t=%o\\n\",vp,vp->nval,(ulong)(uint)vp->tval);\n", "  }\n", "  return vp->fval;\n", "}\n", "\n"], "c": ["Awkfloat getfval(Cell *vp)\t/* get float val of a Cell */\n", "{\n", "\tif ((vp->tval & (NUM | STR)) == 0)\n", "\t\tfunnyvar(vp, \"read value of\");\n", "\tif (isfld(vp) && donefld == 0)\n", "\t\tfldbld();\n", "\telse if (isrec(vp) && donerec == 0)\n", "\t\trecbld();\n", "\tif (!isnum(vp)) {\t/* not a number */\n", "\t\tvp->fval = atof(vp->sval);\t/* best guess */\n", "\t\tif (is_number(vp->sval) && !(vp->tval&CON))\n", "\t\t\tvp->tval |= NUM;\t/* make NUM only sparingly */\n", "\t}\n", "\t   dprintf( (\"getfval %p: %s = %g, t=%o\\n\", vp, vp->nval, vp->fval, vp->tval) );\n", "\treturn(vp->fval);\n", "}"]}, {"ghidra": ["\n", "int readrec(char **pbuf,int *pbufsize,FILE *inf)\n", "\n", "{\n", "  long lVar1;\n", "  char *__s;\n", "  int iVar2;\n", "  int iVar3;\n", "  uint uVar4;\n", "  size_t sVar5;\n", "  ulong uVar6;\n", "  int __c;\n", "  long in_FS_OFFSET;\n", "  int bufsize;\n", "  char *rr;\n", "  char *buf;\n", "  \n", "  rr = *pbuf;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  bufsize = *pbufsize;\n", "  __s = *FS;\n", "  buf = rr;\n", "  sVar5 = strlen(__s);\n", "  if (99 < sVar5) {\n", "                    /* WARNING: Subroutine does not return */\n", "    FATAL(\"field separator %.10s... is too long\",__s);\n", "  }\n", "  __memcpy_chk(inputFS,__s,sVar5 + 1);\n", "  __c = (int)**RS;\n", "  if (**RS == '\\0') {\n", "    do {\n", "      __c = _IO_getc((_IO_FILE *)inf);\n", "    } while (__c == 10);\n", "    if (__c != -1) {\n", "      ungetc(__c,(FILE *)inf);\n", "    }\n", "    __c = 10;\n", "    rr = buf;\n", "  }\n", "  while( true ) {\n", "    iVar2 = _IO_getc((_IO_FILE *)inf);\n", "    while ((__c != iVar2 && (iVar2 != -1))) {\n", "      if (((long)bufsize <= (long)(rr + -(long)buf)) &&\n", "         (iVar3 = adjbuf(&buf,&bufsize,((int)rr + 1) - (int)buf,recsize,&rr,\"readrec 1\"), iVar3 == 0\n", "         )) {\n", "                    /* WARNING: Subroutine does not return */\n", "        FATAL(\"input record `%.30s...\\' too long\",buf);\n", "      }\n", "      *rr = (char)iVar2;\n", "      rr = rr + 1;\n", "      iVar2 = _IO_getc((_IO_FILE *)inf);\n", "    }\n", "    if ((int)**RS == __c) break;\n", "    if (iVar2 == -1) {\n", "LAB_00406600:\n", "      iVar2 = -1;\n", "      break;\n", "    }\n", "    iVar2 = _IO_getc((_IO_FILE *)inf);\n", "    if (iVar2 == 10) break;\n", "    if (iVar2 == -1) goto LAB_00406600;\n", "    iVar3 = adjbuf(&buf,&bufsize,((int)rr + 2) - (int)buf,recsize,&rr,\"readrec 2\");\n", "    if (iVar3 == 0) goto LAB_004066b6;\n", "    __s = rr + 1;\n", "    *rr = '\\n';\n", "    rr = rr + 2;\n", "    *__s = (char)iVar2;\n", "  }\n", "  __c = adjbuf(&buf,&bufsize,((int)rr + 1) - (int)buf,recsize,&rr,\"readrec 3\");\n", "  if (__c != 0) {\n", "    *rr = '\\0';\n", "    if (dbg != 0) {\n", "      uVar6 = 1;\n", "      if (iVar2 == -1) {\n", "        uVar6 = (ulong)(rr != buf);\n", "      }\n", "      __printf_chk(1,\"readrec saw <%s>, returns %d\\n\",buf,uVar6);\n", "    }\n", "    *pbuf = buf;\n", "    *pbufsize = bufsize;\n", "    uVar4 = 1;\n", "    if (iVar2 == -1) {\n", "      uVar4 = (uint)(buf != rr);\n", "    }\n", "    if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "      return (int)uVar4;\n", "    }\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "LAB_004066b6:\n", "                    /* WARNING: Subroutine does not return */\n", "  FATAL(\"input record `%.30s...\\' too long\",buf);\n", "}\n", "\n"], "c": ["int readrec(char **pbuf, int *pbufsize, FILE *inf)\t/* read one record into buf */\n", "{\n", "\tint sep, c;\n", "\tchar *rr, *buf = *pbuf;\n", "\tint bufsize = *pbufsize;\n", "\n", "\tif (strlen(*FS) >= sizeof(inputFS))\n", "\t\tFATAL(\"field separator %.10s... is too long\", *FS);\n", "\tstrcpy(inputFS, *FS);\t/* for subsequent field splitting */\n", "\tif ((sep = **RS) == 0) {\n", "\t\tsep = '\\n';\n", "\t\twhile ((c=getc(inf)) == '\\n' && c != EOF)\t/* skip leading \\n's */\n", "\t\t\t;\n", "\t\tif (c != EOF)\n", "\t\t\tungetc(c, inf);\n", "\t}\n", "\tfor (rr = buf; ; ) {\n", "\t\tfor (; (c=getc(inf)) != sep && c != EOF; ) {\n", "\t\t\tif (rr-buf+1 > bufsize)\n", "\t\t\t\tif (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, \"readrec 1\"))\n", "\t\t\t\t\tFATAL(\"input record `%.30s...' too long\", buf);\n", "\t\t\t*rr++ = c;\n", "\t\t}\n", "\t\tif (**RS == sep || c == EOF)\n", "\t\t\tbreak;\n", "\t\tif ((c = getc(inf)) == '\\n' || c == EOF) /* 2 in a row */\n", "\t\t\tbreak;\n", "\t\tif (!adjbuf(&buf, &bufsize, 2+rr-buf, recsize, &rr, \"readrec 2\"))\n", "\t\t\tFATAL(\"input record `%.30s...' too long\", buf);\n", "\t\t*rr++ = '\\n';\n", "\t\t*rr++ = c;\n", "\t}\n", "\tif (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, \"readrec 3\"))\n", "\t\tFATAL(\"input record `%.30s...' too long\", buf);\n", "\t*rr = 0;\n", "\t   dprintf( (\"readrec saw <%s>, returns %d\\n\", buf, c == EOF && rr == buf ? 0 : 1) );\n", "\t*pbuf = buf;\n", "\t*pbufsize = bufsize;\n", "\treturn c == EOF && rr == buf ? 0 : 1;\n", "}"]}, {"ghidra": ["\n", "void wlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\t(*_wlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = (void*)1;\n", "}"]}, {"ghidra": ["\n", "void initgetrec(void)\n", "\n", "{\n", "  int iVar1;\n", "  char *s;\n", "  Cell *vp;\n", "  int n;\n", "  \n", "  n = 1;\n", "  if (1.00000000 < (double)*ARGC) {\n", "    do {\n", "      s = getargv(n);\n", "      iVar1 = isclvar(s);\n", "      if (iVar1 == 0) {\n", "        s = getargv(n);\n", "        vp = lookup(\"FILENAME\",symtab);\n", "        setsval(vp,s);\n", "        return;\n", "      }\n", "      n = n + 1;\n", "      setclvar(s);\n", "      argno = argno + 1;\n", "    } while ((double)n < (double)*ARGC);\n", "  }\n", "  infile = stdin;\n", "  return;\n", "}\n", "\n"], "c": ["void initgetrec(void)\n", "{\n", "\tint i;\n", "\tchar *p;\n", "\n", "\tfor (i = 1; i < *ARGC; i++) {\n", "\t\tif (!isclvar(p = getargv(i))) {\t/* find 1st real filename */\n", "\t\t\tsetsval(lookup(\"FILENAME\", symtab), getargv(i));\n", "\t\t\treturn;\n", "\t\t}\n", "\t\tsetclvar(p);\t/* a commandline assignment before filename */\n", "\t\targno++;\n", "\t}\n", "\tinfile = stdin;\t\t/* no filenames, so use stdin */\n", "}"]}, {"ghidra": ["\n", "void backsub(char **pb_ptr,char **sptr_ptr)\n", "\n", "{\n", "  char *pcVar1;\n", "  char *pcVar2;\n", "  char *pcVar3;\n", "  char *pcVar4;\n", "  \n", "  pcVar1 = *sptr_ptr;\n", "  pcVar2 = *pb_ptr;\n", "  if (pcVar1[1] == '\\\\') {\n", "    if (pcVar1[2] == '\\\\') {\n", "      if (pcVar1[3] != '&') goto LAB_0040c33e;\n", "      *pcVar2 = '\\\\';\n", "      pcVar4 = pcVar2 + 2;\n", "      pcVar2[1] = '&';\n", "      pcVar3 = pcVar1 + 4;\n", "    }\n", "    else {\n", "      if (pcVar1[2] != '&') {\n", "LAB_0040c33e:\n", "        *pcVar2 = *pcVar1;\n", "        pcVar2[1] = pcVar1[1];\n", "        *pb_ptr = pcVar2 + 2;\n", "        *sptr_ptr = pcVar1 + 2;\n", "        return;\n", "      }\n", "      pcVar4 = pcVar2 + 1;\n", "      *pcVar2 = '\\\\';\n", "      pcVar3 = pcVar1 + 2;\n", "    }\n", "  }\n", "  else {\n", "    pcVar4 = pcVar2 + 1;\n", "    if (pcVar1[1] == '&') {\n", "      *pcVar2 = '&';\n", "      *pb_ptr = pcVar4;\n", "      *sptr_ptr = pcVar1 + 2;\n", "      return;\n", "    }\n", "    pcVar3 = pcVar1 + 1;\n", "    *pcVar2 = *pcVar1;\n", "  }\n", "  *pb_ptr = pcVar4;\n", "  *sptr_ptr = pcVar3;\n", "  return;\n", "}\n", "\n"], "c": ["void backsub(char **pb_ptr, char **sptr_ptr)\t/* handle \\\\& variations */\n", "{\t\t\t\t\t\t/* sptr[0] == '\\\\' */\n", "\tchar *pb = *pb_ptr, *sptr = *sptr_ptr;\n", "\n", "\tif (sptr[1] == '\\\\') {\n", "\t\tif (sptr[2] == '\\\\' && sptr[3] == '&') { /* \\\\\\& -> \\& */\n", "\t\t\t*pb++ = '\\\\';\n", "\t\t\t*pb++ = '&';\n", "\t\t\tsptr += 4;\n", "\t\t} else if (sptr[2] == '&') {\t/* \\\\& -> \\ + matched */\n", "\t\t\t*pb++ = '\\\\';\n", "\t\t\tsptr += 2;\n", "\t\t} else {\t\t\t/* \\\\x -> \\\\x */\n", "\t\t\t*pb++ = *sptr++;\n", "\t\t\t*pb++ = *sptr++;\n", "\t\t}\n", "\t} else if (sptr[1] == '&') {\t/* literal & */\n", "\t\tsptr++;\n", "\t\t*pb++ = *sptr++;\n", "\t} else\t\t\t\t/* literal \\ */\n", "\t\t*pb++ = *sptr++;\n", "\n", "\t*pb_ptr = pb;\n", "\t*sptr_ptr = sptr;\n", "}"]}, {"ghidra": ["\n", "int nematch(void *p,char *s,char *start)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = pmatch(p,s,start);\n", "  if ((iVar1 == 1) && (0 < patlen)) {\n", "    return 1;\n", "  }\n", "  patbeg = start;\n", "  patlen = -1;\n", "  return 0;\n", "}\n", "\n"], "c": ["int\n", "nematch(void *p, char *s, char *start)\n", "{\n", "\tif (pmatch(p, s, start) == 1 && patlen > 0)\n", "\t\treturn 1;\n", "\tpatlen = -1;\n", "\tpatbeg = start; \n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void envinit(char **envp)\n", "\n", "{\n", "  char *s;\n", "  Array *tp;\n", "  int iVar1;\n", "  Cell *pCVar2;\n", "  char *__s;\n", "  double f;\n", "  \n", "  pCVar2 = setsymtab(\"ENVIRON\",\"\",0.00000000,0x10,symtab);\n", "  ENVtab = makesymtab(0x32);\n", "  *(Array **)&pCVar2->sval = ENVtab;\n", "  __s = *envp;\n", "  while (__s != (char *)0x0) {\n", "    __s = strchr(__s,0x3d);\n", "    if (__s != (char *)0x0) {\n", "      s = __s + 1;\n", "      *__s = '\\0';\n", "      iVar1 = is_number(s);\n", "      tp = ENVtab;\n", "      if (iVar1 == 0) {\n", "        setsymtab(*envp,s,0.00000000,2,ENVtab);\n", "      }\n", "      else {\n", "        f = strtod(s,(char **)0x0);\n", "        setsymtab(*envp,s,(Awkfloat)f,3,tp);\n", "      }\n", "      *__s = '=';\n", "    }\n", "    envp = envp + 1;\n", "    __s = *envp;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void envinit(char **envp)\t/* set up ENVIRON variable */\n", "{\n", "\tCell *cp;\n", "\tchar *p;\n", "\n", "\tcp = setsymtab(\"ENVIRON\", \"\", 0.0, ARR, symtab);\n", "\tENVtab = makesymtab(NSYMTAB);\n", "\tcp->sval = (char *) ENVtab;\n", "\tfor ( ; *envp; envp++) {\n", "\t\tif ((p = strchr(*envp, '=')) == NULL)\n", "\t\t\tcontinue;\n", "\t\t*p++ = 0;\t/* split into two strings at = */\n", "\t\tif (is_number(p))\n", "\t\t\tsetsymtab(*envp, p, atof(p), STR|NUM, ENVtab);\n", "\t\telse\n", "\t\t\tsetsymtab(*envp, p, 0.0, STR, ENVtab);\n", "\t\tp[-1] = '=';\t/* restore in case env is passed down to a shell */\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void run(Node *a)\n", "\n", "{\n", "  files[0].fp = stdin;\n", "  files[1].fp = stdout;\n", "  files[2].fp = stderr;\n", "  execute(a);\n", "  closeall();\n", "  return;\n", "}\n", "\n"], "c": ["void run(Node *a)\t/* execution of parse tree starts here */\n", "{\n", "\textern void stdinit(void);\n", "\n", "\tstdinit();\n", "\texecute(a);\n", "\tcloseall();\n", "}"]}, {"ghidra": ["\n", "void quoted(char **s,char **to,char *end)\n", "\n", "{\n", "  long lVar1;\n", "  char *pcVar2;\n", "  wchar_t __wchar;\n", "  int iVar3;\n", "  size_t sVar4;\n", "  char cVar5;\n", "  uint uVar6;\n", "  char *__s;\n", "  long in_FS_OFFSET;\n", "  char *p;\n", "  \n", "  __s = *to;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  pcVar2 = *s;\n", "  p = pcVar2 + 1;\n", "  cVar5 = *pcVar2;\n", "  switch(cVar5) {\n", "  case 'b':\n", "    cVar5 = '\\b';\n", "    break;\n", "  default:\n", "    if (__s < end + -1) {\n", "      *__s = '\\\\';\n", "      __s = __s + 1;\n", "    }\n", "    if ((int)cVar5 == 0x78) {\n", "      __wchar = hexstr(&p);\n", "      sVar4 = __ctype_get_mb_cur_max();\n", "      if (end + -sVar4 <= __s) {\n", "                    /* WARNING: Subroutine does not return */\n", "        FATAL(\"%s\",\"regular expression too big\");\n", "      }\n", "      iVar3 = wctomb(__s,__wchar);\n", "      *to = __s + iVar3;\n", "      *s = p;\n", "      goto LAB_00401ed8;\n", "    }\n", "    uVar6 = (int)cVar5 - 0x30;\n", "    if ((uVar6 < 8) && (cVar5 = (char)uVar6, (byte)(*p - 0x30U) < 8)) {\n", "      cVar5 = *p + -0x30 + cVar5 * '\\b';\n", "      p = pcVar2 + 2;\n", "      if ((byte)(pcVar2[2] - 0x30U) < 8) {\n", "        p = pcVar2 + 3;\n", "        cVar5 = pcVar2[2] + -0x30 + cVar5 * '\\b';\n", "      }\n", "    }\n", "    break;\n", "  case 'f':\n", "    cVar5 = '\\f';\n", "    break;\n", "  case 'n':\n", "    cVar5 = '\\n';\n", "    break;\n", "  case 'r':\n", "    cVar5 = '\\r';\n", "    break;\n", "  case 't':\n", "    cVar5 = '\\t';\n", "  }\n", "  if (__s < end + -1) {\n", "    *__s = cVar5;\n", "    __s = __s + 1;\n", "  }\n", "  *s = p;\n", "  *to = __s;\n", "LAB_00401ed8:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "quoted(char **s, char **to, char *end)\t/* handle escaped sequence */\n", "{\n", "\tchar *p = *s;\n", "\tchar *t = *to;\n", "\twchar_t c;\n", "\n", "\tswitch(c = *p++) {\n", "\tcase 't':\n", "\t\tc = '\\t';\n", "\t\tbreak;\n", "\tcase 'n':\n", "\t\tc = '\\n';\n", "\t\tbreak;\n", "\tcase 'f':\n", "\t\tc = '\\f';\n", "\t\tbreak;\n", "\tcase 'r':\n", "\t\tc = '\\r';\n", "\t\tbreak;\n", "\tcase 'b':\n", "\t\tc = '\\b';\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tif (t < end-1)\t\t/* all else must be escaped */\n", "\t\t\t*t++ = '\\\\';\n", "\t\tif (c == 'x') {\t\t/* hexadecimal goo follows */\n", "\t\t\tc = hexstr(&p);\n", "\t\t\tif (t < end-MB_CUR_MAX)\n", "\t\t\t\tt += wctomb(t, c);\n", "\t\t\telse overflow();\n", "\t\t\t*to = t;\n", "\t\t\t*s = p;\n", "\t\t\treturn;\n", "\t\t} else if (isoctdigit(c)) {\t/* \\d \\dd \\ddd */\n", "\t\t\tc -= '0';\n", "\t\t\tif (isoctdigit(*p)) {\n", "\t\t\t\tc = 8 * c + *p++ - '0';\n", "\t\t\t\tif (isoctdigit(*p))\n", "\t\t\t\t\tc = 8 * c + *p++ - '0';\n", "\t\t\t}\n", "\t\t}\n", "\t\tbreak;\n", "\t}\n", "\tif (t < end-1)\n", "\t\t*t++ = c;\n", "\t*s = p;\n", "\t*to = t;\n", "}"]}, {"ghidra": ["\n", "void growfldtab(int n)\n", "\n", "{\n", "  uint n2;\n", "  \n", "  n2 = nfields * 2;\n", "  if (SBORROW4(n,nfields * 2) == n + nfields * -2 < 0) {\n", "    n2 = n;\n", "  }\n", "  fldtab = (Cell **)realloc(fldtab,(long)(int)(n2 + 1) << 3);\n", "  if (fldtab != (Cell **)0x0) {\n", "    makefields(nfields + 1,n2);\n", "    nfields = n2;\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  FATAL(\"out of space creating %d fields\",(ulong)n2);\n", "}\n", "\n"], "c": ["void growfldtab(int n)\t/* make new fields up to at least $n */\n", "{\n", "\tint nf = 2 * nfields;\n", "\n", "\tif (n > nf)\n", "\t\tnf = n;\n", "\tfldtab = (Cell **) realloc(fldtab, (nf+1) * (sizeof (struct Cell *)));\n", "\tif (fldtab == NULL)\n", "\t\tFATAL(\"out of space creating %d fields\", nf);\n", "\tmakefields(nfields+1, nf);\n", "\tnfields = nf;\n", "}"]}, {"ghidra": ["\n", "int canlock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock == (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->held == 0) {\n", "      l->held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canlock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\treturn (*_lock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->held)\n", "\t\t\treturn 0;\n", "\t\tl->held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void error(void)\n", "\n", "{\n", "  char *pcVar1;\n", "  uint uVar2;\n", "  undefined8 in_R8;\n", "  undefined4 uVar3;\n", "  \n", "  uVar3 = (undefined4)((ulong)in_R8 >> 0x20);\n", "  fputc(10,stderr);\n", "  if (compile_time == 2) goto LAB_0040604d;\n", "  if ((NR != (Awkfloat *)0x0) && (0.00000000 < (double)*NR)) {\n", "    pcVar1 = *FILENAME;\n", "    if ((*pcVar1 == '-') && (pcVar1[1] == '\\0')) {\n", "      __fprintf_chk(stderr,1,\" input record number %d\",\n", "                    (ulong)pcVar1 & 0xffffffff00000000 | (ulong)(uint)(int)(double)*FNR);\n", "    }\n", "    else {\n", "      __fprintf_chk(stderr,1,\" input record %s:%d\",pcVar1,CONCAT44(uVar3,(int)(double)*FNR));\n", "    }\n", "    fputc(10,stderr);\n", "    if (compile_time == 2) goto LAB_0040604d;\n", "  }\n", "  if (curnode == (Node *)0x0) {\n", "    uVar2 = lineno;\n", "    if (lineno != 0) goto LAB_00406026;\n", "    if (compile_time != 1) goto LAB_0040604d;\n", "    pcVar1 = cursource();\n", "    if (pcVar1 == (char *)0x0) goto LAB_0040604d;\n", "LAB_00406081:\n", "    pcVar1 = cursource();\n", "    __fprintf_chk(stderr,1,\" source file %s\",pcVar1);\n", "  }\n", "  else {\n", "    uVar2 = curnode->lineno;\n", "LAB_00406026:\n", "    if (compile_time == 1) {\n", "      pcVar1 = cursource();\n", "      if (pcVar1 != (char *)0x0) {\n", "        if (-1 < (int)uVar2) {\n", "          pcVar1 = cursource();\n", "          __fprintf_chk(stderr,1,\" source %s:%d\",pcVar1,(ulong)uVar2);\n", "          goto LAB_0040604d;\n", "        }\n", "        goto LAB_00406081;\n", "      }\n", "    }\n", "    if (-1 < (int)uVar2) {\n", "      __fprintf_chk(stderr,1,\" source line %d\",(ulong)uVar2);\n", "    }\n", "  }\n", "LAB_0040604d:\n", "  fputc(10,stderr);\n", "  eprint();\n", "  return;\n", "}\n", "\n"], "c": ["void error()\n", "{\n", "\textern Node *curnode;\n", "\tint line;\n", "\n", "\tfprintf(stderr, \"\\n\");\n", "\tif (compile_time != 2 && NR && *NR > 0) {\n", "\t\tif (strcmp(*FILENAME, \"-\") != 0)\n", "\t\t\tfprintf(stderr, \" input record %s:%d\", *FILENAME, (int) (*FNR));\n", "\t\telse\n", "\t\t\tfprintf(stderr, \" input record number %d\", (int) (*FNR));\n", "\t\tfprintf(stderr, \"\\n\");\n", "\t}\n", "\tif (compile_time != 2 && curnode)\n", "\t\tline = curnode->lineno;\n", "\telse if (compile_time != 2 && lineno)\n", "\t\tline = lineno;\n", "\telse\n", "\t\tline = -1;\n", "\tif (compile_time == 1 && cursource() != NULL){\n", "\t\tif(line >= 0)\n", "\t\t\tfprintf(stderr, \" source %s:%d\", cursource(), line);\n", "\t\telse\n", "\t\t\tfprintf(stderr, \" source file %s\", cursource());\n", "\t}else if(line >= 0)\n", "\t\tfprintf(stderr, \" source line %d\", line);\n", "\tfprintf(stderr, \"\\n\");\n", "\teprint();\n", "}"]}, {"ghidra": ["\n", "void makefields(int n1,int n2)\n", "\n", "{\n", "  long lVar1;\n", "  undefined8 *puVar2;\n", "  long lVar3;\n", "  void *pvVar4;\n", "  char *pcVar5;\n", "  ulong uVar6;\n", "  long lVar7;\n", "  uint uVar8;\n", "  ulong uVar9;\n", "  void **ppvVar10;\n", "  long in_FS_OFFSET;\n", "  char temp [50];\n", "  \n", "  uVar6 = SEXT48(n1);\n", "  lVar7 = uVar6 << 3;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (n1 <= n2) {\n", "    do {\n", "      ppvVar10 = (void **)(lVar7 + (long)fldtab);\n", "      pvVar4 = malloc(0x30);\n", "      *ppvVar10 = pvVar4;\n", "      puVar2 = *(undefined8 **)((long)fldtab + lVar7);\n", "      if (puVar2 == (undefined8 *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "        FATAL(\"out of space in makefields %d\",uVar6 & 0xffffffff);\n", "      }\n", "      uVar9 = uVar6 & 0xffffffff;\n", "      *puVar2 = 0x101;\n", "      *(char **)(puVar2 + 1) = (char *)0x0;\n", "      *(char **)(puVar2 + 2) = \"\";\n", "      uVar8 = (int)uVar6 + 1;\n", "      uVar6 = (ulong)uVar8;\n", "      *(Awkfloat *)(puVar2 + 3) = 0.00000000;\n", "      puVar2[4] = 0x46;\n", "      *(Cell **)(puVar2 + 5) = (Cell *)0x0;\n", "      __sprintf_chk(temp,1,0x32,0x41202c,uVar9);\n", "      lVar3 = *(long *)((long)fldtab + lVar7);\n", "      lVar7 = lVar7 + 8;\n", "      pcVar5 = tostring(temp);\n", "      *(char **)(lVar3 + 8) = pcVar5;\n", "    } while ((int)uVar8 <= n2);\n", "  }\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void makefields(int n1, int n2)\t\t/* create $n1..$n2 inclusive */\n", "{\n", "\tchar temp[50];\n", "\tint i;\n", "\n", "\tfor (i = n1; i <= n2; i++) {\n", "\t\tfldtab[i] = (Cell *) malloc(sizeof (struct Cell));\n", "\t\tif (fldtab[i] == NULL)\n", "\t\t\tFATAL(\"out of space in makefields %d\", i);\n", "\t\t*fldtab[i] = dollar1;\n", "\t\tsprintf(temp, \"%d\", i);\n", "\t\tfldtab[i]->nval = tostring(temp);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void yyerror(char *s)\n", "\n", "{\n", "  SYNTAX(s);\n", "  return;\n", "}\n", "\n"], "c": ["void yyerror(char *s)\n", "{\n", "\tSYNTAX(s);\n", "}"]}, {"ghidra": ["\n", "void setclvar(char *s)\n", "\n", "{\n", "  char cVar1;\n", "  int iVar2;\n", "  char *s_00;\n", "  Cell *vp;\n", "  double dVar3;\n", "  \n", "  cVar1 = *s;\n", "  s_00 = s;\n", "  while (cVar1 != '=') {\n", "    s_00 = s_00 + 1;\n", "    cVar1 = *s_00;\n", "  }\n", "  *s_00 = '\\0';\n", "  s_00 = qstring(s_00 + 1,0);\n", "  vp = setsymtab(s,s_00,0.00000000,2,symtab);\n", "  setsval(vp,s_00);\n", "  iVar2 = is_number(vp->sval);\n", "  if (iVar2 != 0) {\n", "    dVar3 = strtod(vp->sval,(char **)0x0);\n", "    vp->tval = vp->tval | 1;\n", "    *(double *)&vp->fval = dVar3;\n", "  }\n", "  if (dbg != 0) {\n", "    __printf_chk(1,\"command line set %s to |%s|\\n\",s,s_00);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void setclvar(char *s)\t/* set var=value from s */\n", "{\n", "\tchar *p;\n", "\tCell *q;\n", "\n", "\tfor (p=s; *p != '='; p++)\n", "\t\t;\n", "\t*p++ = 0;\n", "\tp = qstring(p, '\\0');\n", "\tq = setsymtab(s, p, 0.0, STR, symtab);\n", "\tsetsval(q, p);\n", "\tif (is_number(q->sval)) {\n", "\t\tq->fval = atof(q->sval);\n", "\t\tq->tval |= NUM;\n", "\t}\n", "\t   dprintf( (\"command line set %s to |%s|\\n\", s, p) );\n", "}"]}, {"ghidra": ["\n", "void bcheck2(int n,int c1,int c2)\n", "\n", "{\n", "  if (n == 1) {\n", "    __fprintf_chk(stderr,1,\"\\tmissing %c\\n\",(ulong)(uint)c2);\n", "    return;\n", "  }\n", "  if (1 < n) {\n", "    __fprintf_chk(stderr,1,\"\\t%d missing %c\\'s\\n\",(ulong)(uint)n,(ulong)(uint)c2);\n", "    return;\n", "  }\n", "  if (n == -1) {\n", "    __fprintf_chk(stderr,1,\"\\textra %c\\n\",(ulong)(uint)c2);\n", "    return;\n", "  }\n", "  if (-2 < n) {\n", "    return;\n", "  }\n", "  __fprintf_chk(stderr,1,\"\\t%d extra %c\\'s\\n\",(ulong)(uint)-n,(ulong)(uint)c2);\n", "  return;\n", "}\n", "\n"], "c": ["void bcheck2(int n, int c1, int c2)\n", "{\n", "\tif (n == 1)\n", "\t\tfprintf(stderr, \"\\tmissing %c\\n\", c2);\n", "\telse if (n > 1)\n", "\t\tfprintf(stderr, \"\\t%d missing %c's\\n\", n, c2);\n", "\telse if (n == -1)\n", "\t\tfprintf(stderr, \"\\textra %c\\n\", c2);\n", "\telse if (n < -1)\n", "\t\tfprintf(stderr, \"\\t%d extra %c's\\n\", -n, c2);\n", "}"]}, {"ghidra": ["\n", "int match(void *p,char *s,char *start)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = regexec9((Reprog *)p,s,(Resub *)0x0,0);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "match(void *p, char *s, char *start)\n", "{\n", "\treturn regexec((Reprog *) p, (char *) s, 0, 0);\n", "}"]}, {"ghidra": ["\n", "Awkfloat setfval(Cell *vp,Awkfloat f)\n", "\n", "{\n", "  int iVar1;\n", "  ulong uVar2;\n", "  uint uVar3;\n", "  double dVar4;\n", "  \n", "  uVar3 = vp->tval;\n", "  if ((uVar3 & 3) == 0) {\n", "    funnyvar(vp,\"assign to\");\n", "    uVar3 = vp->tval;\n", "  }\n", "  if ((uVar3 & 0x40) == 0) {\n", "    if ((uVar3 & 0x80) != 0) {\n", "      donefld = 0;\n", "      donerec = 1;\n", "    }\n", "  }\n", "  else {\n", "    donerec = 0;\n", "    uVar2 = strtol(vp->nval,(char **)0x0,10);\n", "    dVar4 = (double)(int)uVar2;\n", "    if ((double)*NF <= dVar4 && dVar4 != (double)*NF) {\n", "      newfld((int)uVar2);\n", "    }\n", "    if (dbg == 0) {\n", "      uVar3 = vp->tval;\n", "    }\n", "    else {\n", "      __printf_chk(f,1,\"setting field %d to %g\\n\",uVar2 & 0xffffffff);\n", "      uVar3 = vp->tval;\n", "    }\n", "  }\n", "  if (((uVar3 & 6) == 2) && (vp->sval != (char *)0x0)) {\n", "    free(vp->sval);\n", "    vp->sval = (char *)0x0;\n", "    uVar3 = vp->tval;\n", "  }\n", "  iVar1 = dbg;\n", "  vp->tval = uVar3 & 0xfffffffd | 1;\n", "  if (iVar1 != 0) {\n", "    __printf_chk(f,1,\"setfval %p: %s = %g, t=%o\\n\",vp,vp->nval);\n", "  }\n", "  vp->fval = f;\n", "  return f;\n", "}\n", "\n"], "c": ["Awkfloat setfval(Cell *vp, Awkfloat f)\t/* set float val of a Cell */\n", "{\n", "\tint fldno;\n", "\n", "\tif ((vp->tval & (NUM | STR)) == 0) \n", "\t\tfunnyvar(vp, \"assign to\");\n", "\tif (isfld(vp)) {\n", "\t\tdonerec = 0;\t/* mark $0 invalid */\n", "\t\tfldno = atoi(vp->nval);\n", "\t\tif (fldno > *NF)\n", "\t\t\tnewfld(fldno);\n", "\t\t   dprintf( (\"setting field %d to %g\\n\", fldno, f) );\n", "\t} else if (isrec(vp)) {\n", "\t\tdonefld = 0;\t/* mark $1... invalid */\n", "\t\tdonerec = 1;\n", "\t}\n", "\tif (freeable(vp))\n", "\t\txfree(vp->sval); /* free any previous string */\n", "\tvp->tval &= ~STR;\t/* mark string invalid */\n", "\tvp->tval |= NUM;\t/* mark number ok */\n", "\t   dprintf( (\"setfval %p: %s = %g, t=%o\\n\", vp, vp->nval, f, vp->tval) );\n", "\treturn vp->fval = f;\n", "}"]}, {"ghidra": ["\n", "int isarg(char *s)\n", "\n", "{\n", "  int iVar1;\n", "  Node *pNVar2;\n", "  int iVar3;\n", "  \n", "  iVar3 = -1;\n", "  if (arglist != (Node *)0x0) {\n", "    iVar3 = 0;\n", "    pNVar2 = arglist;\n", "    while (iVar1 = strcmp((char *)pNVar2->narg[0]->nnext,s), iVar1 != 0) {\n", "      pNVar2 = pNVar2->nnext;\n", "      iVar3 = iVar3 + 1;\n", "      if (pNVar2 == (Node *)0x0) {\n", "        return -1;\n", "      }\n", "    }\n", "  }\n", "  return iVar3;\n", "}\n", "\n"], "c": ["int isarg(char *s)\t\t/* is s in argument list for current function? */\n", "{\t\t\t/* return -1 if not, otherwise arg # */\n", "\textern Node *arglist;\n", "\tNode *p = arglist;\n", "\tint n;\n", "\n", "\tfor (n = 0; p != 0; p = p->nnext, n++)\n", "\t\tif (strcmp(((Cell *)(p->narg[0]))->nval, s) == 0)\n", "\t\t\treturn n;\n", "\treturn -1;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Type propagation algorithm not settling */\n", "\n", "int yylex(void)\n", "\n", "{\n", "  ulong uVar1;\n", "  Array *tp;\n", "  int bufsize;\n", "  char *buf;\n", "  uint n;\n", "  int c;\n", "  int iVar2;\n", "  ushort **ppuVar3;\n", "  char *s;\n", "  double f;\n", "  \n", "  if ((buf == (char *)0x0) && (buf = (char *)malloc((long)bufsize), buf == (char *)0x0)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    FATAL(\"out of space in yylex\");\n", "  }\n", "  if (sc == 0) {\n", "    if (reg != 0) {\n", "      reg = 0;\n", "      c = regexpr();\n", "      return c;\n", "    }\n", "switchD_0040333b_caseD_9:\n", "    n = gettok((char **)0x61b1b0,(int *)0x61a248);\n", "    if (n == 0) {\n", "      return 0;\n", "    }\n", "    ppuVar3 = __ctype_b_loc();\n", "    tp = symtab;\n", "    if ((((*ppuVar3)[(int)n] & 0x400) != 0) || (n == 0x5f)) {\n", "      c = word(buf);\n", "      return c;\n", "    }\n", "    if ((((*ppuVar3)[(int)n] & 0x800) != 0) || (n == 0x2e)) {\n", "      n = 0xe04e;\n", "      f = strtod(buf,(char **)0x0);\n", "      s = tostring(buf);\n", "      yylval = setsymtab(buf,s,(Awkfloat)f,9,tp);\n", "      if (dbg == 0) {\n", "        return 0xe04e;\n", "      }\n", "      c = 0xe04e;\n", "      goto LAB_00403370;\n", "    }\n", "    uVar1 = (ulong)yylval & 0xffffffff00000000;\n", "    yylval = (Cell *)(uVar1 | n);\n", "    switch(n) {\n", "    case 9:\n", "    case 0xd:\n", "    case 0x20:\n", "      goto switchD_0040333b_caseD_9;\n", "    case 10:\n", "      goto switchD_0040333b_caseD_a;\n", "    default:\n", "      if (dbg == 0) {\n", "        return n;\n", "      }\n", "      s = tokname(n);\n", "      __printf_chk(1,\"lex %s\\n\",s);\n", "      return n;\n", "    case 0x21:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x3d) {\n", "        input();\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe01f);\n", "        n = 0xe01f;\n", "        c = 0xe01f;\n", "      }\n", "      else {\n", "        c = input();\n", "        unput(c);\n", "        if (c == 0x7e) {\n", "          input();\n", "          yylval = (Cell *)CONCAT44(yylval._4_4_,0xe00b);\n", "          goto joined_r0x00403922;\n", "        }\n", "        n = 0xe057;\n", "        c = 0xe057;\n", "      }\n", "      goto joined_r0x00403bf4;\n", "    case 0x22:\n", "      c = string();\n", "      return c;\n", "    case 0x23:\n", "      do {\n", "        c = input();\n", "        if (c == 10) break;\n", "      } while (c != 0);\n", "      unput(c);\n", "      goto switchD_0040333b_caseD_9;\n", "    case 0x24:\n", "      c = gettok((char **)0x61b1b0,(int *)0x61a248);\n", "      if (((c == 0x5b) || (c == 0x28)) || ((infunc != 0 && (iVar2 = isarg(buf), -1 < iVar2)))) {\n", "        unputstr(buf);\n", "      }\n", "      else {\n", "        if ((*(byte *)((long)*ppuVar3 + (long)c * 2 + 1) & 4) == 0) {\n", "          unputstr(buf);\n", "        }\n", "        else {\n", "          if (((*buf != 'N') || (buf[1] != 'F')) || (buf[2] != '\\0')) {\n", "            n = 0xe04b;\n", "            yylval = setsymtab(buf,\"\",0.00000000,3,symtab);\n", "            c = 0xe04b;\n", "            goto joined_r0x00403bf4;\n", "          }\n", "          unputstr(\"(NF)\");\n", "        }\n", "      }\n", "      if (dbg != 0) {\n", "        s = tokname(0xe05c);\n", "        __printf_chk(1,\"lex %s\\n\",s);\n", "      }\n", "      return 0xe05c;\n", "    case 0x25:\n", "      c = input();\n", "      unput(c);\n", "      if (c != 0x3d) {\n", "        n = 0x25;\n", "        c = 0x25;\n", "        goto joined_r0x00403bf4;\n", "      }\n", "      input();\n", "      yylval = (Cell *)CONCAT44(yylval._4_4_,0xe03e);\n", "      break;\n", "    case 0x26:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x26) {\n", "        input();\n", "        n = 0xe017;\n", "        c = 0xe017;\n", "      }\n", "      else {\n", "        n = 0x26;\n", "        c = 0x26;\n", "      }\n", "      goto joined_r0x00403bf4;\n", "    case 0x28:\n", "      parencnt = parencnt + 1;\n", "      n = 0x28;\n", "      c = 0x28;\n", "      goto joined_r0x00403bf4;\n", "    case 0x29:\n", "      parencnt = parencnt + -1;\n", "      if (parencnt < 0) {\n", "        SYNTAX(\"extra )\");\n", "      }\n", "      n = 0x29;\n", "      if (dbg == 0) {\n", "        return 0x29;\n", "      }\n", "      c = 0x29;\n", "      goto LAB_00403370;\n", "    case 0x2a:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x3d) {\n", "        input();\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe03c);\n", "        break;\n", "      }\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x2a) {\n", "        input();\n", "        goto switchD_0040333b_caseD_5e;\n", "      }\n", "      n = 0x2a;\n", "      c = 0x2a;\n", "      goto joined_r0x00403bf4;\n", "    case 0x2b:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x2b) {\n", "        input();\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe05b);\n", "        n = 0xe05b;\n", "        c = 0xe05b;\n", "        goto joined_r0x00403bf4;\n", "      }\n", "      c = input();\n", "      unput(c);\n", "      if (c != 0x3d) {\n", "        n = 0x2b;\n", "        c = 0x2b;\n", "        goto joined_r0x00403bf4;\n", "      }\n", "      input();\n", "      yylval = (Cell *)CONCAT44(yylval._4_4_,0xe03a);\n", "      break;\n", "    case 0x2d:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x2d) {\n", "        input();\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe05a);\n", "        n = 0xe05a;\n", "        if (dbg == 0) {\n", "          return 0xe05a;\n", "        }\n", "        c = 0xe05a;\n", "        goto LAB_00403370;\n", "      }\n", "      c = input();\n", "      unput(c);\n", "      if (c != 0x3d) {\n", "        n = 0x2d;\n", "        c = 0x2d;\n", "        goto joined_r0x00403bf4;\n", "      }\n", "      input();\n", "      yylval = (Cell *)CONCAT44(yylval._4_4_,0xe03b);\n", "      break;\n", "    case 0x2f:\n", "      n = 0x2f;\n", "      c = 0x2f;\n", "      goto joined_r0x00403bf4;\n", "    case 0x3b:\n", "      goto switchD_0040333b_caseD_3b;\n", "    case 0x3c:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x3d) {\n", "        input();\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe01d);\n", "        n = 0xe01d;\n", "        c = 0xe01d;\n", "      }\n", "      else {\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe01e);\n", "        n = 0xe01e;\n", "        c = 0xe01e;\n", "      }\n", "      goto joined_r0x00403bf4;\n", "    case 0x3d:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x3d) {\n", "        input();\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe01a);\n", "        n = 0xe01a;\n", "        c = 0xe01a;\n", "        goto joined_r0x00403bf4;\n", "      }\n", "      yylval = (Cell *)CONCAT44(yylval._4_4_,0xe038);\n", "      break;\n", "    case 0x3e:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 0x3d) {\n", "        input();\n", "        yylval = (Cell *)CONCAT44(yylval._4_4_,0xe01b);\n", "        n = 0xe01b;\n", "        c = 0xe01b;\n", "      }\n", "      else {\n", "        c = input();\n", "        unput(c);\n", "        if (c == 0x3e) {\n", "          input();\n", "          yylval = (Cell *)CONCAT44(yylval._4_4_,0xe019);\n", "          n = 0xe019;\n", "          c = 0xe019;\n", "        }\n", "        else {\n", "          yylval = (Cell *)CONCAT44(yylval._4_4_,0xe01c);\n", "          n = 0xe01c;\n", "          c = 0xe01c;\n", "        }\n", "      }\n", "      goto joined_r0x00403bf4;\n", "    case 0x5b:\n", "      brackcnt = brackcnt + 1;\n", "      n = 0x5b;\n", "      c = 0x5b;\n", "      goto joined_r0x00403bf4;\n", "    case 0x5c:\n", "      c = input();\n", "      unput(c);\n", "      if (c == 10) {\n", "        input();\n", "      }\n", "      else {\n", "        c = input();\n", "        unput(c);\n", "        if (c != 0xd) {\n", "          if (dbg != 0) {\n", "            s = tokname(0x5c);\n", "            __printf_chk(1,\"lex %s\\n\",s);\n", "          }\n", "          return 0x5c;\n", "        }\n", "        input();\n", "        input();\n", "        lineno = lineno + 1;\n", "      }\n", "      goto switchD_0040333b_caseD_9;\n", "    case 0x5d:\n", "      brackcnt = brackcnt + -1;\n", "      if (brackcnt < 0) {\n", "        SYNTAX(\"extra ]\");\n", "      }\n", "      n = 0x5d;\n", "      c = 0x5d;\n", "      goto joined_r0x00403bf4;\n", "    case 0x5e:\n", "switchD_0040333b_caseD_5e:\n", "      c = input();\n", "      unput(c);\n", "      if (c != 0x3d) {\n", "        if (dbg != 0) {\n", "          s = tokname(0xe059);\n", "          __printf_chk(1,\"lex %s\\n\",s);\n", "        }\n", "        return 0xe059;\n", "      }\n", "      input();\n", "      yylval = (Cell *)CONCAT44(yylval._4_4_,0xe03f);\n", "      break;\n", "    case 0x7b:\n", "      bracecnt = bracecnt + 1;\n", "      n = 0x7b;\n", "      c = 0x7b;\n", "      goto joined_r0x00403bf4;\n", "    case 0x7c:\n", "      c = input();\n", "      unput(c);\n", "      if (c != 0x7c) {\n", "        n = 0x7c;\n", "        c = 0x7c;\n", "        goto joined_r0x00403bf4;\n", "      }\n", "      input();\n", "      n = 0xe018;\n", "      if (dbg == 0) {\n", "        return 0xe018;\n", "      }\n", "      c = 0xe018;\n", "      goto LAB_00403370;\n", "    case 0x7d:\n", "      bracecnt = bracecnt + -1;\n", "      if (bracecnt < 0) {\n", "        SYNTAX(\"extra }\");\n", "      }\n", "      sc = 1;\n", "switchD_0040333b_caseD_3b:\n", "      n = 0x3b;\n", "      c = 0x3b;\n", "      goto joined_r0x00403bf4;\n", "    case 0x7e:\n", "      yylval._4_4_ = (undefined4)(uVar1 >> 0x20);\n", "      yylval = (Cell *)CONCAT44(yylval._4_4_,0xe00a);\n", "joined_r0x00403922:\n", "      if (dbg != 0) {\n", "        s = tokname(0xe00c);\n", "        __printf_chk(1,\"lex %s\\n\",s);\n", "      }\n", "      return 0xe00c;\n", "    }\n", "    if (dbg != 0) {\n", "      s = tokname(0xe039);\n", "      __printf_chk(1,\"lex %s\\n\",s);\n", "    }\n", "    return 0xe039;\n", "  }\n", "  sc = 0;\n", "  n = 0x7d;\n", "  c = 0x7d;\n", "joined_r0x00403bf4:\n", "  if (dbg == 0) {\n", "    return (int)n;\n", "  }\n", "LAB_00403370:\n", "  s = tokname(c);\n", "  __printf_chk(1,\"lex %s\\n\",s);\n", "  return (int)n;\n", "switchD_0040333b_caseD_a:\n", "  n = 0xe008;\n", "  c = 0xe008;\n", "  goto joined_r0x00403bf4;\n", "}\n", "\n"], "c": ["int\n", "yylex(void)\n", "{\n", "\tint c, d = nextc();\n", "\tchar *w = tok;\n", "\tstruct tree *t;\n", "\tyylval.tree = 0;\n", "\t/*\n", "\t * Embarassing sneakiness:  if the last token read was a quoted or unquoted\n", "\t * WORD then we alter the meaning of what follows.  If the next character\n", "\t * is `(', we return SUB (a subscript paren) and consume the `('.  Otherwise,\n", "\t * if the next character is the first character of a simple or compound word,\n", "\t * we insert a `^' before it.\n", "\t */\n", "\tif(lastword){\n", "\t\tlastword = 0;\n", "\t\tif(d=='('){\n", "\t\t\tadvance();\n", "\t\t\tstrcpy(tok, \"( [SUB]\");\n", "\t\t\treturn SUB;\n", "\t\t}\n", "\t\tif(wordchr(d) || d=='\\'' || d=='`' || d=='$' || d=='\"'){\n", "\t\t\tstrcpy(tok, \"^\");\n", "\t\t\treturn '^';\n", "\t\t}\n", "\t}\n", "\tinquote = 0;\n", "\tskipwhite();\n", "\tswitch(c = advance()){\n", "\tcase EOF:\n", "\t\tlastdol = 0;\n", "\t\tstrcpy(tok, \"EOF\");\n", "\t\treturn EOF;\n", "\tcase '$':\n", "\t\tlastdol = 1;\n", "\t\tif(nextis('#')){\n", "\t\t\tstrcpy(tok, \"$#\");\n", "\t\t\treturn COUNT;\n", "\t\t}\n", "\t\tif(nextis('\"')){\n", "\t\t\tstrcpy(tok, \"$\\\"\");\n", "\t\t\treturn '\"';\n", "\t\t}\n", "\t\tstrcpy(tok, \"$\");\n", "\t\treturn '$';\n", "\tcase '&':\n", "\t\tlastdol = 0;\n", "\t\tif(nextis('&')){\n", "\t\t\tskipnl();\n", "\t\t\tstrcpy(tok, \"&&\");\n", "\t\t\treturn ANDAND;\n", "\t\t}\n", "\t\tstrcpy(tok, \"&\");\n", "\t\treturn '&';\n", "\tcase '|':\n", "\t\tlastdol = 0;\n", "\t\tif(nextis(c)){\n", "\t\t\tskipnl();\n", "\t\t\tstrcpy(tok, \"||\");\n", "\t\t\treturn OROR;\n", "\t\t}\n", "\tcase '<':\n", "\tcase '>':\n", "\t\tlastdol = 0;\n", "\t\t/*\n", "\t\t * funny redirection tokens:\n", "\t\t *\tredir:\tarrow | arrow '[' fd ']'\n", "\t\t *\tarrow:\t'<' | '<<' | '>' | '>>' | '|'\n", "\t\t *\tfd:\tdigit | digit '=' | digit '=' digit\n", "\t\t *\tdigit:\t'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'\n", "\t\t * some possibilities are nonsensical and get a message.\n", "\t\t */\n", "\t\t*w++=c;\n", "\t\tt = newtree();\n", "\t\tswitch(c){\n", "\t\tcase '|':\n", "\t\t\tt->type = PIPE;\n", "\t\t\tt->fd0 = 1;\n", "\t\t\tt->fd1 = 0;\n", "\t\t\tbreak;\n", "\t\tcase '>':\n", "\t\t\tt->type = REDIR;\n", "\t\t\tif(nextis(c)){\n", "\t\t\t\tt->rtype = APPEND;\n", "\t\t\t\t*w++=c;\n", "\t\t\t}\n", "\t\t\telse t->rtype = WRITE;\n", "\t\t\tt->fd0 = 1;\n", "\t\t\tbreak;\n", "\t\tcase '<':\n", "\t\t\tt->type = REDIR;\n", "\t\t\tif(nextis(c)){\n", "\t\t\t\tt->rtype = HERE;\n", "\t\t\t\t*w++=c;\n", "\t\t\t} else if (nextis('>')){\n", "\t\t\t\tt->rtype = RDWR;\n", "\t\t\t\t*w++=c;\n", "\t\t\t} else t->rtype = READ;\n", "\t\t\tt->fd0 = 0;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tif(nextis('[')){\n", "\t\t\t*w++='[';\n", "\t\t\tc = advance();\n", "\t\t\t*w++=c;\n", "\t\t\tif(c<'0' || '9'<c){\n", "\t\t\tRedirErr:\n", "\t\t\t\t*w = 0;\n", "\t\t\t\tyyerror(t->type==PIPE?\"pipe syntax\"\n", "\t\t\t\t\t\t:\"redirection syntax\");\n", "\t\t\t\treturn EOF;\n", "\t\t\t}\n", "\t\t\tt->fd0 = 0;\n", "\t\t\tdo{\n", "\t\t\t\tt->fd0 = t->fd0*10+c-'0';\n", "\t\t\t\t*w++=c;\n", "\t\t\t\tc = advance();\n", "\t\t\t}while('0'<=c && c<='9');\n", "\t\t\tif(c=='='){\n", "\t\t\t\t*w++='=';\n", "\t\t\t\tif(t->type==REDIR)\n", "\t\t\t\t\tt->type = DUP;\n", "\t\t\t\tc = advance();\n", "\t\t\t\tif('0'<=c && c<='9'){\n", "\t\t\t\t\tt->rtype = DUPFD;\n", "\t\t\t\t\tt->fd1 = t->fd0;\n", "\t\t\t\t\tt->fd0 = 0;\n", "\t\t\t\t\tdo{\n", "\t\t\t\t\t\tt->fd0 = t->fd0*10+c-'0';\n", "\t\t\t\t\t\t*w++=c;\n", "\t\t\t\t\t\tc = advance();\n", "\t\t\t\t\t}while('0'<=c && c<='9');\n", "\t\t\t\t}\n", "\t\t\t\telse{\n", "\t\t\t\t\tif(t->type==PIPE)\n", "\t\t\t\t\t\tgoto RedirErr;\n", "\t\t\t\t\tt->rtype = CLOSE;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif(c!=']'\n", "\t\t\t|| t->type==DUP && (t->rtype==HERE || t->rtype==APPEND))\n", "\t\t\t\tgoto RedirErr;\n", "\t\t\t*w++=']';\n", "\t\t}\n", "\t\t*w='\\0';\n", "\t\tyylval.tree = t;\n", "\t\tif(t->type==PIPE)\n", "\t\t\tskipnl();\n", "\t\treturn t->type;\n", "\tcase '\\'':\n", "\t\tlastdol = 0;\n", "\t\tlastword = 1;\n", "\t\tinquote = 1;\n", "\t\tfor(;;){\n", "\t\t\tc = advance();\n", "\t\t\tif(c==EOF)\n", "\t\t\t\tbreak;\n", "\t\t\tif(c=='\\''){\n", "\t\t\t\tif(nextc()!='\\'')\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tadvance();\n", "\t\t\t}\n", "\t\t\tw = addutf(w, c);\n", "\t\t}\n", "\t\tif(w!=0)\n", "\t\t\t*w='\\0';\n", "\t\tt = token(tok, WORD);\n", "\t\tt->quoted = 1;\n", "\t\tyylval.tree = t;\n", "\t\treturn t->type;\n", "\t}\n", "\tif(!wordchr(c)){\n", "\t\tlastdol = 0;\n", "\t\ttok[0] = c;\n", "\t\ttok[1]='\\0';\n", "\t\treturn c;\n", "\t}\n", "\tfor(;;){\n", "\t\t/* next line should have (char)c==GLOB, but ken's compiler is broken */\n", "\t\tif(c=='*' || c=='[' || c=='?' || c==(unsigned char)GLOB)\n", "\t\t\tw = addtok(w, GLOB);\n", "\t\tw = addutf(w, c);\n", "\t\tc = nextc();\n", "\t\tif(lastdol?!idchr(c):!wordchr(c)) break;\n", "\t\tadvance();\n", "\t}\n", "\n", "\tlastword = 1;\n", "\tlastdol = 0;\n", "\tif(w!=0)\n", "\t\t*w='\\0';\n", "\tt = klook(tok);\n", "\tif(t->type!=WORD)\n", "\t\tlastword = 0;\n", "\tt->quoted = 0;\n", "\tyylval.tree = t;\n", "\treturn t->type;\n", "}"]}, {"ghidra": ["\n", "int canqlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock == (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->l).held == 0) {\n", "      (l->l).held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canqlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\treturn (*_qlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->l.held)\n", "\t\t\treturn 0;\n", "\t\tl->l.held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int getrec(void)\n", "\n", "{\n", "  uint uVar1;\n", "  \n", "  if (flags[102] == '\\0') {\n", "    uVar1 = (uint)(byte)*input;\n", "    input = input + 1;\n", "  }\n", "  else {\n", "    uVar1 = Bgetc(rein);\n", "    if ((int)uVar1 < 1) {\n", "      return 0;\n", "    }\n", "  }\n", "  if ((flags[105] == '\\0') || (0x19 < uVar1 - 0x41)) {\n", "    if (uVar1 == 10) {\n", "      lineno = lineno + 1;\n", "      return 10;\n", "    }\n", "  }\n", "  else {\n", "    uVar1 = uVar1 + 0x20;\n", "  }\n", "  return (int)uVar1;\n", "}\n", "\n"], "c": ["int\n", "getrec(void)\n", "{\n", "\tint c;\n", "\n", "\tif(flags['f']) {\n", "\t\tc = Bgetc(rein);\n", "\t\tif(c <= 0)\n", "\t\t\treturn 0;\n", "\t} else\n", "\t\tc = *input++ & 0xff;\n", "\tif(flags['i'] && c >= 'A' && c <= 'Z')\n", "\t\tc += 'a'-'A';\n", "\tif(c == '\\n')\n", "\t\tlineno++;\n", "\treturn c;\n", "}"]}, {"ghidra": ["\n", "void p9free(void *v)\n", "\n", "{\n", "  if (v != (void *)0x0) {\n", "    lock(&malloclock);\n", "    free(v);\n", "    unlock(&malloclock);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "p9free(void *v)\n", "{\n", "\tif(v == nil)\n", "\t\treturn;\n", "\tlock(&malloclock);\n", "\tfree(v);\n", "\tunlock(&malloclock);\n", "}"]}, {"ghidra": ["\n", "Re2 re2or(void)\n", "\n", "{\n", "  long lVar1;\n", "  undefined *puVar2;\n", "  long in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_RDI;\n", "  long lVar3;\n", "  \n", "  puVar2 = (undefined *)mal(0x18);\n", "  *puVar2 = 6;\n", "  *(undefined8 *)(puVar2 + 8) = in_RDX;\n", "  maxfollow = maxfollow + 1;\n", "  *(undefined8 *)(puVar2 + 0x10) = in_RDI;\n", "  lVar1 = in_RCX;\n", "  do {\n", "    lVar3 = lVar1;\n", "    lVar1 = *(long *)(lVar3 + 0x10);\n", "  } while (lVar1 != 0);\n", "  *(undefined8 *)(lVar3 + 0x10) = in_RSI;\n", "  return (Re2)CONCAT88(in_RCX,puVar2);\n", "}\n", "\n"], "c": ["Re2\n", "re2or(Re2 a, Re2 b)\n", "{\n", "\tRe2 c;\n", "\n", "\tc.beg = ral(Tor);\n", "\tc.beg->u.alt = b.beg;\n", "\tc.beg->next = a.beg;\n", "\tc.end = b.end;\n", "\tappendnext(c.end,  a.end);\n", "\treturn c;\n", "}"]}, {"ghidra": ["\n", "int p9open(char *name,int mode)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  uVar2 = mode & 0xffffdf9c;\n", "  if ((mode & 0x10U) != 0) {\n", "    uVar2 = uVar2 ^ 0x10;\n", "  }\n", "  if ((uVar2 & 0x80) != 0) {\n", "    uVar2 = uVar2 ^ 0x80;\n", "  }\n", "  if ((uVar2 & 0x100) != 0) {\n", "    uVar2 = uVar2 ^ 0x100;\n", "  }\n", "  if ((uVar2 & 0x4000) != 0) {\n", "    uVar2 = uVar2 ^ 0x4000;\n", "  }\n", "  if (uVar2 == 0) {\n", "    __fd = __open64_2();\n", "    iVar4 = __fd;\n", "    if (-1 < __fd) {\n", "      if ((mode & 0x2000U) != 0) {\n", "        fl.l_type = ZEXT12((mode & 3U) != 0);\n", "        fl.l_start = 0;\n", "        fl.l_whence = 0;\n", "        fl.l_len = 0;\n", "        iVar3 = fcntl(__fd,6,&fl);\n", "        if (iVar3 < 0) {\n", "          iVar4 = -1;\n", "          close(__fd);\n", "          werrstr(\"lock: %r\");\n", "          goto LAB_004046fd;\n", "        }\n", "      }\n", "      if ((mode & 0x20U) != 0) {\n", "        fcntl(__fd,2,1);\n", "      }\n", "      if ((mode & 0x40U) != 0) {\n", "        remove(name);\n", "      }\n", "    }\n", "  }\n", "  else {\n", "    werrstr(\"mode 0x%x not supported\",(ulong)uVar2);\n", "    iVar4 = -1;\n", "  }\n", "LAB_004046fd:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9open(char *name, int mode)\n", "{\n", "\tint cexec, rclose;\n", "\tint fd, umode, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tumode = rdwr;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tlock = mode&OLOCK;\n", "\tmode &= ~(3|OCEXEC|ORCLOSE|OLOCK);\n", "\tif(mode&OTRUNC){\n", "\t\tumode |= O_TRUNC;\n", "\t\tmode ^= OTRUNC;\n", "\t}\n", "\tif(mode&ODIRECT){\n", "\t\tumode |= O_DIRECT;\n", "\t\tmode ^= ODIRECT;\n", "\t}\n", "\tif(mode&ONONBLOCK){\n", "\t\tumode |= O_NONBLOCK;\n", "\t\tmode ^= ONONBLOCK;\n", "\t}\n", "\tif(mode&OAPPEND){\n", "\t\tumode |= O_APPEND;\n", "\t\tmode ^= OAPPEND;\n", "\t}\n", "\tif(mode){\n", "\t\twerrstr(\"mode 0x%x not supported\", mode);\n", "\t\treturn -1;\n", "\t}\n", "\tfd = open(name, umode);\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(name);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "void rlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\t(*_rlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers++;\n", "}"]}, {"ghidra": ["\n", "long p9write(int f,void *av,long n)\n", "\n", "{\n", "  ssize_t sVar1;\n", "  long lVar2;\n", "  \n", "  if (n < 1) {\n", "    lVar2 = 0;\n", "  }\n", "  else {\n", "    lVar2 = 0;\n", "    do {\n", "      sVar1 = write(f,(void *)((long)av + lVar2),n - lVar2);\n", "      if (sVar1 < 1) {\n", "        if (lVar2 != 0) {\n", "          return lVar2;\n", "        }\n", "        return sVar1;\n", "      }\n", "      lVar2 = lVar2 + sVar1;\n", "    } while (lVar2 < n);\n", "  }\n", "  return lVar2;\n", "}\n", "\n"], "c": ["long\n", "p9write(int f, void *av, long n)\n", "{\n", "\tchar *a;\n", "\tlong m, t;\n", "\n", "\ta = av;\n", "\tt = 0;\n", "\twhile(t < n){\n", "\t\tm = write(f, a+t, n-t);\n", "\t\tif(m <= 0){\n", "\t\t\tif(t == 0)\n", "\t\t\t\treturn m;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tt += m;\n", "\t}\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "void fol1(Re *r,int c)\n", "\n", "{\n", "  Re **ppRVar1;\n", "  Re *pRVar2;\n", "  \n", "LAB_004023f5:\n", "  if (r->gen == gen) {\n", "    return;\n", "  }\n", "  if (maxfollow <= nfollow) {\n", "    error(\"nfollow\");\n", "  }\n", "  r->gen = gen;\n", "  switch(r->type) {\n", "  default:\n", "    error(\"fol1\");\n", "    goto switchD_0040241e_caseD_3;\n", "  case '\\x01':\n", "  case '\\x06':\n", "    fol1((Re *)r->u,c);\n", "    r = r->next;\n", "    goto LAB_004023f5;\n", "  case '\\x02':\n", "    if ((c != 0x10000) && (c != 10)) {\n", "      return;\n", "    }\n", "    break;\n", "  case '\\x03':\n", "    goto switchD_0040241e_caseD_3;\n", "  case '\\x04':\n", "    if (c < (int)(uint)*(ushort *)&r->u) {\n", "      return;\n", "    }\n", "    if ((int)(uint)*(ushort *)((long)&r->u + 2) < c) {\n", "      return;\n", "    }\n", "    break;\n", "  case '\\x05':\n", "    if (c != 10) {\n", "      return;\n", "    }\n", "    matched = 1;\n", "    return;\n", "  }\n", "  ppRVar1 = follow + nfollow;\n", "  nfollow = nfollow + 1;\n", "  *ppRVar1 = r->next;\n", "  return;\n", "switchD_0040241e_caseD_3:\n", "  if (((uint)c < 0x100) && (pRVar2 = *(Re **)(r->u + (long)c * 8), pRVar2 != (Re *)0x0)) {\n", "    ppRVar1 = follow + nfollow;\n", "    nfollow = nfollow + 1;\n", "    *ppRVar1 = pRVar2;\n", "  }\n", "  r = r->next;\n", "  if (r == (Re *)0x0) {\n", "    return;\n", "  }\n", "  goto LAB_004023f5;\n", "}\n", "\n"], "c": ["void\n", "fol1(Re *r, int c)\n", "{\n", "\tRe *r1;\n", "\n", "loop:\n", "\tif(r->gen == gen)\n", "\t\treturn;\n", "\tif(nfollow >= maxfollow)\n", "\t\terror(\"nfollow\");\n", "\tr->gen = gen;\n", "\tswitch(r->type) {\n", "\tdefault:\n", "\t\terror(\"fol1\");\n", "\n", "\tcase Tcase:\n", "\t\tif(c >= 0 && c < 256)\n", "\t\tif(r1 = r->u.cases[c])\n", "\t\t\tfollow[nfollow++] = r1;\n", "\t\tif(r = r->next)\n", "\t\t\tgoto loop;\n", "\t\tbreak;\n", "\n", "\tcase Talt:\n", "\tcase Tor:\n", "\t\tfol1(r->u.alt, c);\n", "\t\tr = r->next;\n", "\t\tgoto loop;\n", "\n", "\tcase Tbegin:\n", "\t\tif(c == '\\n' || c == Cbegin)\n", "\t\t\tfollow[nfollow++] = r->next;\n", "\t\tbreak;\n", "\n", "\tcase Tend:\n", "\t\tif(c == '\\n')\n", "\t\t\tmatched = 1;\n", "\t\tbreak;\n", "\n", "\tcase Tclass:\n", "\t\tif(c >= r->u.x.lo && c <= r->u.x.hi)\n", "\t\t\tfollow[nfollow++] = r->next;\n", "\t\tbreak;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int rwakeup(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeup(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 0, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void reprint(char *s,Re *r)\n", "\n", "{\n", "  print(\"%s:\\n\",s);\n", "  gen = gen + 1;\n", "  reprint1(r);\n", "  print(\"\\n\\n\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "reprint(char *s, Re *r)\n", "{\n", "\tprint(\"%s:\\n\", s);\n", "\tgen++;\n", "\treprint1(r);\n", "\tprint(\"\\n\\n\");\n", "}"]}, {"ghidra": ["\n", "int canwlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->writer == (_Thread *)0x0) && (l->readers == 0)) {\n", "      l->writer = (_Thread *)0x1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canwlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\treturn (*_wlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer || l->readers)\n", "\t\t\treturn 0;\n", "\t\tl->writer = (void*)1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int countor(Re *r)\n", "\n", "{\n", "  uchar uVar1;\n", "  int iVar2;\n", "  int iVar3;\n", "  \n", "  iVar3 = 0;\n", "  uVar1 = r->type;\n", "  while( true ) {\n", "    if (uVar1 == '\\x04') {\n", "      return (int)(((iVar3 + (uint)*(ushort *)((long)&r->u + 2)) - (uint)*(ushort *)&r->u) + 1);\n", "    }\n", "    if (uVar1 != '\\x06') break;\n", "    iVar2 = countor((Re *)r->u);\n", "    r = r->next;\n", "    iVar3 = iVar3 + iVar2;\n", "    uVar1 = r->type;\n", "  }\n", "  return iVar3;\n", "}\n", "\n"], "c": ["int\n", "countor(Re *r)\n", "{\n", "\tint n;\n", "\n", "\tn = 0;\n", "loop:\n", "\tswitch(r->type) {\n", "\tcase Tor:\n", "\t\tn += countor(r->u.alt);\n", "\t\tr = r->next;\n", "\t\tgoto loop;\n", "\tcase Tclass:\n", "\t\treturn n + r->u.x.hi - r->u.x.lo + 1;\n", "\t}\n", "\treturn n;\n", "}"]}, {"ghidra": ["\n", "void * p9calloc(ulong a,ulong b)\n", "\n", "{\n", "  void *pvVar1;\n", "  size_t __nmemb;\n", "  \n", "  __nmemb = a * b;\n", "  if (__nmemb == 0) {\n", "    __nmemb = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = calloc(__nmemb,1);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9calloc(ulong a, ulong b)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(a*b == 0)\n", "\t\ta = b = 1;\n", "\n", "\tlock(&malloclock);\n", "\tv = calloc(a*b, 1);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void werrstr(char *fmt,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list arg;\n", "  char buf [128];\n", "  char local_c8 [8];\n", "  long local_c0;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n", "  arg[0].overflow_arg_area = &stack0x00000008;\n", "  arg[0].reg_save_area = local_b8;\n", "  arg[0].gp_offset = 8;\n", "  arg[0].fp_offset = 0x30;\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  vseprint(buf,local_c8,fmt,arg);\n", "  errstr(buf,0x80);\n", "  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "werrstr(char *fmt, ...)\n", "{\n", "\tva_list arg;\n", "\tchar buf[ERRMAX];\n", "\n", "\tva_start(arg, fmt);\n", "\tvseprint(buf, buf+ERRMAX, fmt, arg);\n", "\tva_end(arg);\n", "\terrstr(buf, ERRMAX);\n", "}"]}, {"ghidra": ["\n", "void exits(char *s)\n", "\n", "{\n", "  anon_subr_void_for_f *paVar1;\n", "  __pid_t _Var2;\n", "  int __status;\n", "  anon_struct_conflict1 *paVar3;\n", "  \n", "  paVar3 = onex + 0x20;\n", "  _Var2 = getpid();\n", "  do {\n", "    while ((paVar1 = paVar3->f, paVar1 != (anon_subr_void_for_f *)0x0 && (paVar3->pid == _Var2))) {\n", "      paVar3->f = (anon_subr_void_for_f *)0x0;\n", "      paVar3 = paVar3 + -1;\n", "      (*paVar1)();\n", "      if (paVar3 == (anon_struct_conflict1 *)&DAT_0060c630) goto LAB_00404100;\n", "    }\n", "    paVar3 = paVar3 + -1;\n", "  } while (paVar3 != (anon_struct_conflict1 *)&DAT_0060c630);\n", "LAB_00404100:\n", "  if ((s != (char *)0x0) && (*s != '\\0')) {\n", "    __status = exitcode(s);\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(__status);\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(0);\n", "}\n", "\n"], "c": ["void\n", "exits(char *s)\n", "{\n", "\tint i, pid;\n", "\tvoid (*f)(void);\n", "\n", "\tpid = getpid();\n", "\tfor(i = NEXIT-1; i >= 0; i--)\n", "\t\tif((f = onex[i].f) && pid == onex[i].pid) {\n", "\t\t\tonex[i].f = 0;\n", "\t\t\t(*f)();\n", "\t\t}\n", "\tif(s == 0 || *s == 0)\n", "\t\texit(0);\n", "\texit(exitcode(s));\n", "}"]}, {"ghidra": ["\n", "void runlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _runlock;\n", "  if (_runlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + -1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "runlock(RWLock *l)\n", "{\n", "\tif(_runlock)\n", "\t\t(*_runlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers--;\n", "}"]}, {"ghidra": ["\n", "int p9create(char *path,int mode,ulong perm)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  uint __oflag;\n", "  uint uVar5;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  uVar5 = mode & 3;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if ((perm & 0x80000000) == 0) {\n", "    if ((mode & 0x80U) == 0) {\n", "      __oflag = uVar5 | 0x240;\n", "      uVar2 = mode & 0xffffdf8c;\n", "    }\n", "    else {\n", "      __oflag = uVar5 | 0x4240;\n", "      uVar2 = mode & 0xffffdf0c;\n", "    }\n", "    if ((uVar2 & 0x1000) != 0) {\n", "      __oflag = __oflag | 0x80;\n", "      uVar2 = uVar2 & 0xffffefff;\n", "    }\n", "    if ((uVar2 & 0x4000) != 0) {\n", "      __oflag = __oflag | 0x400;\n", "      uVar2 = uVar2 & 0xffffbfff;\n", "    }\n", "    if (uVar2 == 0) {\n", "      __fd = open64(path,__oflag);\n", "out:\n", "      iVar4 = __fd;\n", "      if (-1 < __fd) {\n", "        if ((mode & 0x2000U) != 0) {\n", "          fl.l_type = ZEXT12(uVar5 != 0);\n", "          fl.l_start = 0;\n", "          fl.l_whence = 0;\n", "          fl.l_len = 0;\n", "          iVar3 = fcntl(__fd,6,&fl);\n", "          if (iVar3 < 0) {\n", "            iVar4 = -1;\n", "            close(__fd);\n", "            werrstr(\"lock: %r\");\n", "            goto LAB_00404179;\n", "          }\n", "        }\n", "        if ((mode & 0x20U) != 0) {\n", "          fcntl(__fd,2,1);\n", "        }\n", "        if ((mode & 0x40U) != 0) {\n", "          remove(path);\n", "        }\n", "      }\n", "      goto LAB_00404179;\n", "    }\n", "    werrstr(\"unsupported mode in create\");\n", "  }\n", "  else {\n", "    if ((mode & 0xffffdf9fU) == 0) {\n", "      __fd = mkdir(path,(uint)perm & 0x1ff);\n", "      if (-1 < __fd) {\n", "        __fd = open64(path,0);\n", "        goto out;\n", "      }\n", "    }\n", "    else {\n", "      werrstr(\"bad mode in directory create\");\n", "    }\n", "  }\n", "  iVar4 = -1;\n", "LAB_00404179:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9create(char *path, int mode, ulong perm)\n", "{\n", "\tint fd, cexec, umode, rclose, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tlock = mode&OLOCK;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tmode &= ~(ORCLOSE|OCEXEC|OLOCK);\n", "\n", "\t/* XXX should get mode mask right? */\n", "\tfd = -1;\n", "\tif(perm&DMDIR){\n", "\t\tif(mode != OREAD){\n", "\t\t\twerrstr(\"bad mode in directory create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tif(mkdir(path, perm&0777) < 0)\n", "\t\t\tgoto out;\n", "\t\tfd = open(path, O_RDONLY);\n", "\t}else{\n", "\t\tumode = (mode&3)|O_CREAT|O_TRUNC;\n", "\t\tmode &= ~(3|OTRUNC);\n", "\t\tif(mode&ODIRECT){\n", "\t\t\tumode |= O_DIRECT;\n", "\t\t\tmode &= ~ODIRECT;\n", "\t\t}\n", "\t\tif(mode&OEXCL){\n", "\t\t\tumode |= O_EXCL;\n", "\t\t\tmode &= ~OEXCL;\n", "\t\t}\n", "\t\tif(mode&OAPPEND){\n", "\t\t\tumode |= O_APPEND;\n", "\t\t\tmode &= ~OAPPEND;\n", "\t\t}\n", "\t\tif(mode){\n", "\t\t\twerrstr(\"unsupported mode in create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tfd = open(path, umode, perm);\n", "\t}\n", "out:\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(path);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "void __fmtunlock(void)\n", "\n", "{\n", "  unlock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtunlock(void)\n", "{\n", "\tunlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "char * strecpy(char *to,char *e,char *from)\n", "\n", "{\n", "  void *pvVar1;\n", "  char *pcVar2;\n", "  \n", "  if (e <= to) {\n", "    return to;\n", "  }\n", "  pvVar1 = memccpy(to,from,0,(size_t)(e + -(long)to));\n", "  pcVar2 = (char *)((long)pvVar1 + -1);\n", "  if (pvVar1 == (void *)0x0) {\n", "    e[-1] = '\\0';\n", "    pcVar2 = e + -1;\n", "  }\n", "  return pcVar2;\n", "}\n", "\n"], "c": ["char*\n", "strecpy(char *to, char *e, char *from)\n", "{\n", "\tif(to >= e)\n", "\t\treturn to;\n", "\tto = memccpy(to, from, '\\0', e - to);\n", "\tif(to == nil){\n", "\t\tto = e - 1;\n", "\t\t*to = '\\0';\n", "\t}else{\n", "\t\tto--;\n", "\t}\n", "\treturn to;\n", "}"]}, {"ghidra": ["\n", "int errstr(char *err,uint n)\n", "\n", "{\n", "  char *to;\n", "  int *piVar1;\n", "  long in_FS_OFFSET;\n", "  char tmp [128];\n", "  char local_28 [8];\n", "  long local_20;\n", "  \n", "  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n", "  strecpy(tmp,local_28,err);\n", "  rerrstr(err,n);\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    to = (*_syserrstr)();\n", "    if (to != (char *)0x0) goto LAB_004043c4;\n", "  }\n", "  to = xsyserr;\n", "LAB_004043c4:\n", "  strecpy(to,to + 0x80,tmp);\n", "  piVar1 = __errno_location();\n", "  *piVar1 = 0x19283745;\n", "  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return 0;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "errstr(char *err, uint n)\n", "{\n", "\tchar tmp[ERRMAX];\n", "\tchar *syserr;\n", "\n", "\tstrecpy(tmp, tmp+ERRMAX, err);\n", "\trerrstr(err, n);\n", "\tsyserr = getsyserr();\n", "\tstrecpy(syserr, syserr+ERRMAX, tmp);\n", "\terrno = EPLAN9;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void qlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock != (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\t(*_qlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 1;\n", "}"]}, {"ghidra": ["\n", "void lock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock != (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "lock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\t(*_lock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 1;\n", "}"]}, {"ghidra": ["\n", "void patchnext(long param_1,undefined8 param_2)\n", "\n", "{\n", "  long lVar1;\n", "  \n", "  while (param_1 != 0) {\n", "    lVar1 = *(long *)(param_1 + 0x10);\n", "    *(undefined8 *)(param_1 + 0x10) = param_2;\n", "    param_1 = lVar1;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "patchnext(Re *a, Re *b)\n", "{\n", "\tRe *n;\n", "\n", "\twhile(a) {\n", "\t\tn = a->next;\n", "\t\ta->next = b;\n", "\t\ta = n;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  p9main(argc,argv);\n", "  exits(\"main\");\n", "  return 99;\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tp9main(argc, argv);\n", "\texits(\"main\");\n", "\treturn 99;\n", "}"]}, {"ghidra": ["\n", "Re2 re2cat(void)\n", "\n", "{\n", "  long lVar1;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  long in_RSI;\n", "  undefined8 in_RDI;\n", "  \n", "  if (in_RSI != 0) {\n", "    do {\n", "      lVar1 = *(long *)(in_RSI + 0x10);\n", "      *(undefined8 *)(in_RSI + 0x10) = in_RDX;\n", "      in_RSI = lVar1;\n", "    } while (lVar1 != 0);\n", "  }\n", "  return (Re2)CONCAT88(in_RCX,in_RDI);\n", "}\n", "\n"], "c": ["Re2\n", "re2cat(Re2 a, Re2 b)\n", "{\n", "\tRe2 c;\n", "\n", "\tc.beg = a.beg;\n", "\tc.end = b.end;\n", "\tpatchnext(a.end, b.beg);\n", "\treturn c;\n", "}"]}, {"ghidra": ["\n", "ulong getcallerpc(void *x)\n", "\n", "{\n", "  return *(ulong *)((long)x + -8);\n", "}\n", "\n"], "c": ["ulong\n", "getcallerpc(void *x)\n", "{\n", "\treturn (((ulong*)(x))[-1]);\n", "}"]}, {"ghidra": ["\n", "void unlock(Lock *l)\n", "\n", "{\n", "  anon_subr_void_Lock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _unlock;\n", "  if (_unlock != (anon_subr_void_Lock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "unlock(Lock *l)\n", "{\n", "\tif(_unlock)\n", "\t\t(*_unlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 0;\n", "}"]}, {"ghidra": ["\n", "void * p9malloc(ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  if (n == 0) {\n", "    n = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = malloc(n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9malloc(ulong n)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(n == 0)\n", "\t\tn++;\n", "\tlock(&malloclock);\n", "\tv = malloc(n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void __fmtlock(void)\n", "\n", "{\n", "  lock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtlock(void)\n", "{\n", "\tlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "Re2 re2class(char *s)\n", "\n", "{\n", "  ushort *puVar1;\n", "  char cVar2;\n", "  Rune RVar3;\n", "  int iVar4;\n", "  ushort *puVar5;\n", "  ushort *puVar6;\n", "  ushort *puVar7;\n", "  ushort uVar8;\n", "  Rune *rune;\n", "  Rune *rune_00;\n", "  ushort uVar9;\n", "  long in_FS_OFFSET;\n", "  Re2 RVar10;\n", "  Rune pairs [200];\n", "  long local_30;\n", "  \n", "  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n", "  cVar2 = *s;\n", "  if (cVar2 == '^') {\n", "    s = s + 1;\n", "  }\n", "  iVar4 = chartorune(pairs,s);\n", "  s = s + iVar4;\n", "  rune_00 = pairs;\n", "  while( true ) {\n", "    do {\n", "      rune = rune_00;\n", "      RVar3 = *rune;\n", "      if (RVar3 == 0x5c) {\n", "        iVar4 = chartorune(rune,s);\n", "        s = s + iVar4;\n", "        RVar3 = *rune;\n", "      }\n", "      rune_00 = rune;\n", "      if (RVar3 == 0) goto LAB_00402940;\n", "      rune[1] = RVar3;\n", "      rune_00 = rune + 2;\n", "      iVar4 = chartorune(rune_00,s);\n", "      s = s + iVar4;\n", "    } while (*rune_00 != 0x2d);\n", "    iVar4 = chartorune(rune_00,s);\n", "    s = s + iVar4;\n", "    if (*rune_00 == 0x5c) {\n", "      iVar4 = chartorune(rune_00,s);\n", "      s = s + iVar4;\n", "    }\n", "    if (*rune_00 == 0) break;\n", "    rune[1] = *rune_00;\n", "    iVar4 = chartorune(rune_00,s);\n", "    s = s + iVar4;\n", "  }\n", "LAB_00402940:\n", "  *rune_00 = 0;\n", "  qsort(pairs,((long)(Rune *)((long)rune_00 - (long)pairs) >> 1) -\n", "              ((long)(Rune *)((long)rune_00 - (long)pairs) >> 0x3f) >> 1,4,pcmp);\n", "  puVar7 = pairs;\n", "  if (pairs[2] != 0) {\n", "    puVar5 = pairs + 2;\n", "    puVar7 = pairs;\n", "    uVar8 = pairs[2];\n", "    do {\n", "      while (uVar9 = puVar5[1], uVar9 < uVar8) {\n", "LAB_004029a0:\n", "        puVar5 = puVar5 + 2;\n", "        uVar8 = *puVar5;\n", "        if (uVar8 == 0) goto LAB_004029da;\n", "      }\n", "      if ((uVar8 <= puVar7[1]) && (*puVar7 <= uVar9)) {\n", "        if (uVar8 < *puVar7) {\n", "          *puVar7 = uVar8;\n", "          uVar9 = puVar5[1];\n", "        }\n", "        if (puVar7[1] < uVar9) {\n", "          puVar7[1] = uVar9;\n", "        }\n", "        goto LAB_004029a0;\n", "      }\n", "      puVar7[2] = uVar8;\n", "      puVar1 = puVar5 + 1;\n", "      puVar5 = puVar5 + 2;\n", "      puVar6 = puVar7 + 2;\n", "      puVar7[3] = *puVar1;\n", "      uVar8 = *puVar5;\n", "      puVar7 = puVar6;\n", "    } while (uVar8 != 0);\n", "  }\n", "LAB_004029da:\n", "  puVar7[2] = 0;\n", "  if (cVar2 == '^') {\n", "    rclass(0,pairs[0] - 1);\n", "    pairs[1] = pairs[1] + 1;\n", "    if (pairs[2] != 0) {\n", "      rune_00 = pairs + 2;\n", "      do {\n", "        rclass(pairs[1],pairs[2] - 1);\n", "        re2or();\n", "        pairs[2] = rune_00[2];\n", "        pairs[1] = rune_00[1] + 1;\n", "        rune_00 = rune_00 + 2;\n", "      } while (pairs[2] != 0);\n", "    }\n", "    rclass(pairs[1],0xffff);\n", "    RVar10 = re2or();\n", "  }\n", "  else {\n", "    rune_00 = pairs + 2;\n", "    RVar10 = rclass(pairs[0],pairs[1]);\n", "    while (pairs[2] != 0) {\n", "      rune = rune_00 + 1;\n", "      rune_00 = rune_00 + 2;\n", "      rclass(pairs[2],*rune);\n", "      RVar10 = re2or();\n", "      pairs[2] = *rune_00;\n", "    }\n", "  }\n", "  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return RVar10;\n", "}\n", "\n"], "c": ["Re2\n", "re2class(char *s)\n", "{\n", "\tRune pairs[200], *p, *q, ov;\n", "\tint nc;\n", "\tRe2 x;\n", "\n", "\tnc = 0;\n", "\tif(*s == '^') {\n", "\t\tnc = 1;\n", "\t\ts++;\n", "\t}\n", "\n", "\tp = pairs;\n", "\ts += chartorune(p, s);\n", "\tfor(;;) {\n", "\t\tif(*p == '\\\\')\n", "\t\t\ts += chartorune(p, s);\n", "\t\tif(*p == 0)\n", "\t\t\tbreak;\n", "\t\tp[1] = *p;\n", "\t\tp += 2;\n", "\t\ts += chartorune(p, s);\n", "\t\tif(*p != '-')\n", "\t\t\tcontinue;\n", "\t\ts += chartorune(p, s);\n", "\t\tif(*p == '\\\\')\n", "\t\t\ts += chartorune(p, s);\n", "\t\tif(*p == 0)\n", "\t\t\tbreak;\n", "\t\tp[-1] = *p;\n", "\t\ts += chartorune(p, s);\n", "\t}\n", "\t*p = 0;\n", "\tqsort(pairs, (p-pairs)/2, 2*sizeof(*pairs), pcmp);\n", "\n", "\tq = pairs;\n", "\tfor(p=pairs+2; *p; p+=2) {\n", "\t\tif(p[0] > p[1])\n", "\t\t\tcontinue;\n", "\t\tif(p[0] > q[1] || p[1] < q[0]) {\n", "\t\t\tq[2] = p[0];\n", "\t\t\tq[3] = p[1];\n", "\t\t\tq += 2;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\tif(p[0] < q[0])\n", "\t\t\tq[0] = p[0];\n", "\t\tif(p[1] > q[1])\n", "\t\t\tq[1] = p[1];\n", "\t}\n", "\tq[2] = 0;\n", "\n", "\tp = pairs;\n", "\tif(nc) {\n", "\t\tx = rclass(0, p[0]-1);\n", "\t\tov = p[1]+1;\n", "\t\tfor(p+=2; *p; p+=2) {\n", "\t\t\tx = re2or(x, rclass(ov, p[0]-1));\n", "\t\t\tov = p[1]+1;\n", "\t\t}\n", "\t\tx = re2or(x, rclass(ov, 0xffff));\n", "\t} else {\n", "\t\tx = rclass(p[0], p[1]);\n", "\t\tfor(p+=2; *p; p+=2)\n", "\t\t\tx = re2or(x, rclass(p[0], p[1]));\n", "\t}\n", "\treturn x;\n", "}"]}, {"ghidra": ["\n", "void increment(State *s,int c)\n", "\n", "{\n", "  Re **ppRVar1;\n", "  Re *pRVar2;\n", "  Re *pRVar3;\n", "  int iVar4;\n", "  State *pSVar5;\n", "  long lVar6;\n", "  long lVar7;\n", "  State **ppSVar8;\n", "  \n", "  gen = gen + 1;\n", "  nfollow = 0;\n", "  matched = 0;\n", "  if (0 < s->count) {\n", "    lVar7 = 0;\n", "    do {\n", "      fol1(s->re[lVar7],c);\n", "      iVar4 = (int)lVar7 + 1;\n", "      lVar7 = lVar7 + 1;\n", "    } while (s->count != iVar4 && iVar4 <= s->count);\n", "  }\n", "  ppSVar8 = &state0;\n", "  qsort(follow,nfollow,8,fcmp);\n", "LAB_004025a0:\n", "  pSVar5 = *ppSVar8;\n", "  do {\n", "    if (pSVar5 == (State *)0x0) {\n", "      pSVar5 = sal((int)nfollow);\n", "      lVar7 = nfollow;\n", "      lVar6 = 0;\n", "      *ppSVar8 = pSVar5;\n", "      if (0 < lVar7) {\n", "        do {\n", "          *(undefined8 *)((long)pSVar5->re + lVar6) = *(undefined8 *)((long)follow + lVar6);\n", "          lVar6 = lVar6 + 8;\n", "        } while (lVar6 != lVar7 * 8);\n", "      }\n", "      iVar4 = matched;\n", "      s->next[c] = pSVar5;\n", "      pSVar5->match = iVar4;\n", "      return;\n", "    }\n", "    if (pSVar5->count <= nfollow) {\n", "      if (pSVar5->count < nfollow) goto LAB_00402680;\n", "      if (0 < nfollow) {\n", "        pRVar2 = (Re *)pSVar5->re;\n", "        pRVar3 = *follow;\n", "        if (*(Re **)pRVar2 >= pRVar3 && *(Re **)pRVar2 != pRVar3) goto LAB_00402610;\n", "        if (*(Re **)pRVar2 < pRVar3) goto LAB_00402680;\n", "        lVar7 = 1;\n", "        while (lVar7 != nfollow) {\n", "          pRVar3 = *(Re **)((long)&pRVar2->type + lVar7 * 8);\n", "          ppRVar1 = follow + lVar7;\n", "          if (*ppRVar1 < pRVar3) goto LAB_00402610;\n", "          lVar7 = lVar7 + 1;\n", "          if (pRVar3 < *ppRVar1) goto LAB_00402680;\n", "        }\n", "      }\n", "      if (matched == 0) break;\n", "      if (pSVar5->match != 0) goto LAB_00402603;\n", "    }\n", "LAB_00402610:\n", "    ppSVar8 = &pSVar5->linkleft;\n", "    pSVar5 = *ppSVar8;\n", "  } while( true );\n", "  if (pSVar5->match == 0) {\n", "LAB_00402603:\n", "    s->next[c] = pSVar5;\n", "    return;\n", "  }\n", "LAB_00402680:\n", "  ppSVar8 = &pSVar5->linkright;\n", "  goto LAB_004025a0;\n", "}\n", "\n"], "c": ["void\n", "increment(State *s, int c)\n", "{\n", "\tint i;\n", "\tState *t, **tt;\n", "\tRe *re1, *re2;\n", "\n", "\tnfollow = 0;\n", "\tgen++;\n", "\tmatched = 0;\n", "\tfor(i=0; i<s->count; i++)\n", "\t\tfol1(s->re[i], c);\n", "\tqsort(follow, nfollow, sizeof(*follow), fcmp);\n", "\tfor(tt=&state0; t = *tt;) {\n", "\t\tif(t->count > nfollow) {\n", "\t\t\ttt = &t->linkleft;\n", "\t\t\tgoto cont;\n", "\t\t}\n", "\t\tif(t->count < nfollow) {\n", "\t\t\ttt = &t->linkright;\n", "\t\t\tgoto cont;\n", "\t\t}\n", "\t\tfor(i=0; i<nfollow; i++) {\n", "\t\t\tre1 = t->re[i];\n", "\t\t\tre2 = follow[i];\n", "\t\t\tif(re1 > re2) {\n", "\t\t\t\ttt = &t->linkleft;\n", "\t\t\t\tgoto cont;\n", "\t\t\t}\n", "\t\t\tif(re1 < re2) {\n", "\t\t\t\ttt = &t->linkright;\n", "\t\t\t\tgoto cont;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(!!matched && !t->match) {\n", "\t\t\ttt = &t->linkleft;\n", "\t\t\tgoto cont;\n", "\t\t}\n", "\t\tif(!matched && !!t->match) {\n", "\t\t\ttt = &t->linkright;\n", "\t\t\tgoto cont;\n", "\t\t}\n", "\t\ts->next[c] = t;\n", "\t\treturn;\n", "\tcont:;\n", "\t}\n", "\n", "\tt = sal(nfollow);\n", "\t*tt = t;\n", "\tfor(i=0; i<nfollow; i++) {\n", "\t\tre1 = follow[i];\n", "\t\tt->re[i] = re1;\n", "\t}\n", "\ts->next[c] = t;\n", "\tt->match = matched;\n", "}"]}, {"ghidra": ["\n", "int __errfmt(Fmt *f)\n", "\n", "{\n", "  int iVar1;\n", "  int *piVar2;\n", "  char *s;\n", "  \n", "  piVar2 = __errno_location();\n", "  if (*piVar2 != 0x19283745) {\n", "    s = strerror(*piVar2);\n", "LAB_0040442b:\n", "    iVar1 = fmtstrcpy(f,s);\n", "    return iVar1;\n", "  }\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    s = (*_syserrstr)();\n", "    if (s != (char *)0x0) goto LAB_0040442b;\n", "  }\n", "  iVar1 = fmtstrcpy(f,xsyserr);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "__errfmt(Fmt *f)\n", "{\n", "\tif(errno == EPLAN9)\n", "\t\treturn fmtstrcpy(f, getsyserr());\n", "\treturn fmtstrcpy(f, strerror(errno));\n", "}"]}, {"ghidra": ["\n", "void qunlock(QLock *l)\n", "\n", "{\n", "  anon_subr_void_QLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qunlock;\n", "  if (_qunlock != (anon_subr_void_QLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qunlock(QLock *l)\n", "{\n", "\tif(_qunlock)\n", "\t\t(*_qunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 0;\n", "}"]}, {"ghidra": ["\n", "Re2 rclass(Rune p0,Rune p1)\n", "\n", "{\n", "  ushort uVar1;\n", "  long lVar2;\n", "  long lVar3;\n", "  long lVar4;\n", "  int iVar5;\n", "  int iVar6;\n", "  Rune *pRVar7;\n", "  long lVar8;\n", "  Rune p1_00;\n", "  long in_FS_OFFSET;\n", "  Re2 RVar9;\n", "  Rune local_60 [2];\n", "  Rune local_5c [2];\n", "  char xc0 [6];\n", "  char xc1 [6];\n", "  \n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  local_60[0] = p1;\n", "  local_5c[0] = p0;\n", "  if (p1 < p0) {\n", "    RVar9 = re2char(0xff,0xff);\n", "  }\n", "  else {\n", "    if (((tab1[0] < p0) || (p1_00 = tab1[0], p1 <= tab1[0])) &&\n", "       ((tab1[1] < p0 || (p1_00 = tab1[1], p1 <= tab1[1])))) {\n", "      pRVar7 = tab2;\n", "      do {\n", "        uVar1 = *pRVar7;\n", "        if ((ushort)(~uVar1 & (p1 ^ p0)) != 0) {\n", "          if ((uVar1 & p0) != 0) {\n", "            rclass((p0 | uVar1) + 1,p1);\n", "            p1_00 = uVar1 | local_5c[0];\n", "            goto LAB_0040281d;\n", "          }\n", "          if ((uVar1 & p1) != uVar1) {\n", "            rclass(p1 & ~uVar1,p1);\n", "            p1_00 = (~uVar1 & local_60[0]) - 1;\n", "            goto LAB_0040281d;\n", "          }\n", "        }\n", "        pRVar7 = pRVar7 + 1;\n", "      } while (pRVar7 != tab1);\n", "      iVar5 = runetochar(xc0,local_5c);\n", "      iVar6 = runetochar(xc1,local_60);\n", "      if (iVar6 != iVar5) {\n", "        error(\"length\");\n", "      }\n", "      RVar9 = re2char((int)xc0[0],(int)xc1[0]);\n", "      if (1 < iVar5) {\n", "        lVar8 = 0;\n", "        do {\n", "          lVar3 = lVar8 + 1;\n", "          lVar4 = lVar8 + 1;\n", "          lVar8 = lVar8 + 1;\n", "          re2char((int)xc0[lVar4],(int)xc1[lVar3]);\n", "          RVar9 = re2cat();\n", "        } while (lVar8 != (ulong)(iVar5 - 2) + 1);\n", "      }\n", "    }\n", "    else {\n", "      rclass(p1_00 + 1,p1);\n", "LAB_0040281d:\n", "      rclass(local_5c[0],p1_00);\n", "      RVar9 = re2or();\n", "    }\n", "  }\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return RVar9;\n", "}\n", "\n"], "c": ["Re2\n", "rclass(Rune p0, Rune p1)\n", "{\n", "\tchar xc0[6], xc1[6];\n", "\tint i, n, m;\n", "\tRe2 x;\n", "\n", "\tif(p0 > p1)\n", "\t\treturn re2char(0xff, 0xff);\t/* no match */\n", "\n", "\t/*\n", "\t * bust range into same length\n", "\t * character sequences\n", "\t */\n", "\tfor(i=0; i<nelem(tab1); i++) {\n", "\t\tm = tab1[i];\n", "\t\tif(p0 <= m && p1 > m)\n", "\t\t\treturn re2or(rclass(p0, m), rclass(m+1, p1));\n", "\t}\n", "\n", "\t/*\n", "\t * bust range into part of a single page\n", "\t * or into full pages\n", "\t */\n", "\tfor(i=0; i<nelem(tab2); i++) {\n", "\t\tm = tab2[i];\n", "\t\tif((p0 & ~m) != (p1 & ~m)) {\n", "\t\t\tif((p0 & m) != 0)\n", "\t\t\t\treturn re2or(rclass(p0, p0|m), rclass((p0|m)+1, p1));\n", "\t\t\tif((p1 & m) != m)\n", "\t\t\t\treturn re2or(rclass(p0, (p1&~m)-1), rclass(p1&~m, p1));\n", "\t\t}\n", "\t}\n", "\n", "\tn = runetochar(xc0, &p0);\n", "\ti = runetochar(xc1, &p1);\n", "\tif(i != n)\n", "\t\terror(\"length\");\n", "\n", "\tx = re2char(xc0[0], xc1[0]);\n", "\tfor(i=1; i<n; i++)\n", "\t\tx = re2cat(x, re2char(xc0[i], xc1[i]));\n", "\treturn x;\n", "}"]}, {"ghidra": ["\n", "void * p9realloc(void *v,ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  lock(&malloclock);\n", "  pvVar1 = realloc(v,n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9realloc(void *v, ulong n)\n", "{\n", "\tlock(&malloclock);\n", "\tv = realloc(v, n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "Re2 re2star(void)\n", "\n", "{\n", "  long lVar1;\n", "  undefined *puVar2;\n", "  long in_RSI;\n", "  undefined8 in_RDI;\n", "  \n", "  puVar2 = (undefined *)mal(0x18);\n", "  *puVar2 = 1;\n", "  maxfollow = maxfollow + 1;\n", "  *(undefined8 *)(puVar2 + 8) = in_RDI;\n", "  if (in_RSI != 0) {\n", "    do {\n", "      lVar1 = *(long *)(in_RSI + 0x10);\n", "      *(undefined **)(in_RSI + 0x10) = puVar2;\n", "      in_RSI = lVar1;\n", "    } while (lVar1 != 0);\n", "  }\n", "  return (Re2)CONCAT88(puVar2,puVar2);\n", "}\n", "\n"], "c": ["Re2\n", "re2star(Re2 a)\n", "{\n", "\tRe2 c;\n", "\n", "\tc.beg = ral(Talt);\n", "\tc.beg->u.alt = a.beg;\n", "\tpatchnext(a.end, c.beg);\n", "\tc.end = c.beg;\n", "\treturn c;\n", "}"]}, {"ghidra": ["\n", "int canrlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->writer == (_Thread *)0x0) {\n", "      l->readers = l->readers + 1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canrlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\treturn (*_rlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer)\n", "\t\t\treturn 0;\n", "\t\tl->readers++;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void wunlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wunlock;\n", "  if (_wunlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wunlock(RWLock *l)\n", "{\n", "\tif(_wunlock)\n", "\t\t(*_wunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = nil;\n", "}"]}, {"ghidra": ["\n", "Re2 re2char(int c0,int c1)\n", "\n", "{\n", "  undefined *puVar1;\n", "  \n", "  puVar1 = (undefined *)mal(0x18);\n", "  *puVar1 = 4;\n", "  *(ushort *)(puVar1 + 8) = (ushort)c0 & 0xff;\n", "  *(ushort *)(puVar1 + 10) = (ushort)c1 & 0xff;\n", "  maxfollow = maxfollow + 1;\n", "  return (Re2)CONCAT88(puVar1,puVar1);\n", "}\n", "\n"], "c": ["Re2\n", "re2char(int c0, int c1)\n", "{\n", "\tRe2 c;\n", "\n", "\tc.beg = ral(Tclass);\n", "\tc.beg->u.x.lo = c0 & 0xff;\n", "\tc.beg->u.x.hi = c1 & 0xff;\n", "\tc.end = c.beg;\n", "\treturn c;\n", "}"]}, {"ghidra": ["\n", "void rerrstr(char *err,uint n)\n", "\n", "{\n", "  int __errnum;\n", "  char *__dest;\n", "  int *piVar1;\n", "  char *__src;\n", "  \n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    __dest = (*_syserrstr)();\n", "    if ((undefined8 *)__dest != (undefined8 *)0x0) goto LAB_004042ff;\n", "  }\n", "  __dest = xsyserr;\n", "LAB_004042ff:\n", "  piVar1 = __errno_location();\n", "  __errnum = *piVar1;\n", "  if (__errnum == 4) {\n", "    *(undefined4 *)((undefined8 *)__dest + 1) = 0x646574;\n", "    *(undefined8 *)__dest = 0x7075727265746e69;\n", "  }\n", "  else {\n", "    if (__errnum != 0x19283745) {\n", "      __src = strerror(__errnum);\n", "      strcpy(__dest,__src);\n", "    }\n", "  }\n", "  strecpy(err,err + n,__dest);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rerrstr(char *err, uint n)\n", "{\n", "\tchar *syserr;\n", "\n", "\tsyserr = getsyserr();\n", "\tif(errno == EINTR)\n", "\t\tstrcpy(syserr, \"interrupted\");\n", "\telse if(errno != EPLAN9)\n", "\t\tstrcpy(syserr, strerror(errno));\n", "\tstrecpy(err, err+n, syserr);\n", "}"]}, {"ghidra": ["\n", "State * sal(int n)\n", "\n", "{\n", "  State *pSVar1;\n", "  Re **ppRVar2;\n", "  \n", "  pSVar1 = (State *)mal(0x820);\n", "  pSVar1->count = n;\n", "  ppRVar2 = (Re **)mal(n * 8);\n", "  pSVar1->re = ppRVar2;\n", "  return pSVar1;\n", "}\n", "\n"], "c": ["State*\n", "sal(int n)\n", "{\n", "\tState *s;\n", "\n", "\ts = mal(sizeof(*s));\n", "/*\ts->next = mal(256*sizeof(*s->next)); */\n", "\ts->count = n;\n", "\ts->re = mal(n*sizeof(*state0->re));\n", "\treturn s;\n", "}"]}, {"ghidra": ["\n", "void rsleep(Rendez *r)\n", "\n", "{\n", "  anon_subr_void_Rendez_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rsleep;\n", "  if (_rsleep != (anon_subr_void_Rendez_ptr_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rsleep(Rendez *r)\n", "{\n", "\tif(_rsleep)\n", "\t\t(*_rsleep)(r, getcallerpc(&r));\n", "}"]}, {"ghidra": ["\n", "void case1(Re *c,Re *r)\n", "\n", "{\n", "  uchar uVar1;\n", "  Re *pRVar2;\n", "  long lVar3;\n", "  uint uVar4;\n", "  ulong uVar5;\n", "  Re **ppRVar6;\n", "  \n", "  uVar1 = r->type;\n", "  while( true ) {\n", "    if (uVar1 == '\\x04') {\n", "      uVar5 = (ulong)*(ushort *)&r->u;\n", "      lVar3 = uVar5 << 3;\n", "      if (*(ushort *)&r->u <= *(ushort *)((long)&r->u + 2)) {\n", "        do {\n", "          ppRVar6 = (Re **)(lVar3 + c->u);\n", "          uVar4 = (int)uVar5 + 1;\n", "          uVar5 = (ulong)uVar4;\n", "          lVar3 = lVar3 + 8;\n", "          pRVar2 = oralloc(6,r->next,*ppRVar6);\n", "          *ppRVar6 = pRVar2;\n", "        } while ((int)uVar4 <= (int)(uint)*(ushort *)((long)&r->u + 2));\n", "      }\n", "      return;\n", "    }\n", "    if (uVar1 != '\\x06') break;\n", "    case1(c,(Re *)r->u);\n", "    r = r->next;\n", "    uVar1 = r->type;\n", "  }\n", "  pRVar2 = oralloc(1,r,c->next);\n", "  c->next = pRVar2;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "case1(Re *c, Re *r)\n", "{\n", "\tint n;\n", "\n", "loop:\n", "\tswitch(r->type) {\n", "\tcase Tor:\n", "\t\tcase1(c, r->u.alt);\n", "\t\tr = r->next;\n", "\t\tgoto loop;\n", "\n", "\tcase Tclass:\t/* add to character */\n", "\t\tfor(n=r->u.x.lo; n<=r->u.x.hi; n++)\n", "\t\t\tc->u.cases[n] = oralloc(Tor, r->next, c->u.cases[n]);\n", "\t\tbreak;\n", "\n", "\tdefault:\t/* add everything unknown to next */\n", "\t\tc->next = oralloc(Talt, r, c->next);\n", "\t\tbreak;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int rwakeupall(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,1,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeupall(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 1, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void wlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\t(*_wlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = (void*)1;\n", "}"]}, {"ghidra": ["\n", "Re * addcase(Re *r)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  Re *c;\n", "  void *pvVar3;\n", "  Re *r_00;\n", "  long lVar4;\n", "  Re **ppRVar5;\n", "  \n", "  if (r->gen != gen) {\n", "    r->gen = gen;\n", "    switch(r->type) {\n", "    default:\n", "      error(\"addcase\");\n", "    case '\\x06':\n", "      iVar1 = countor(r);\n", "      if (6 < iVar1) {\n", "        c = (Re *)mal(0x18);\n", "        c->type = '\\x03';\n", "        maxfollow = maxfollow + 1;\n", "        pvVar3 = mal(0x800);\n", "        *(void **)&c->u = pvVar3;\n", "        case1(c,r);\n", "        lVar4 = 0;\n", "        do {\n", "          ppRVar5 = (Re **)(lVar4 + c->u);\n", "          r_00 = *ppRVar5;\n", "          if ((r_00 != (Re *)0x0) && (iVar2 = countor(r_00), iVar2 < iVar1)) {\n", "            r_00 = addcase(r_00);\n", "            *ppRVar5 = r_00;\n", "          }\n", "          lVar4 = lVar4 + 8;\n", "        } while (lVar4 != 0x800);\n", "        return c;\n", "      }\n", "      break;\n", "    case '\\x01':\n", "      c = addcase(r->next);\n", "      r->next = c;\n", "      c = addcase((Re *)r->u);\n", "      *(Re **)&r->u = c;\n", "      return r;\n", "    case '\\x02':\n", "    case '\\x04':\n", "    case '\\x05':\n", "      break;\n", "    }\n", "  }\n", "  return r;\n", "}\n", "\n"], "c": ["Re*\n", "addcase(Re *r)\n", "{\n", "\tint i, n;\n", "\tRe *a;\n", "\n", "\tif(r->gen == gen)\n", "\t\treturn r;\n", "\tr->gen = gen;\n", "\tswitch(r->type) {\n", "\tdefault:\n", "\t\terror(\"addcase\");\n", "\n", "\tcase Tor:\n", "\t\tn = countor(r);\n", "\t\tif(n >= Caselim) {\n", "\t\t\ta = ral(Tcase);\n", "\t\t\ta->u.cases = mal(256*sizeof(*a->u.cases));\n", "\t\t\tcase1(a, r);\n", "\t\t\tfor(i=0; i<256; i++)\n", "\t\t\t\tif(a->u.cases[i]) {\n", "\t\t\t\t\tr = a->u.cases[i];\n", "\t\t\t\t\tif(countor(r) < n)\n", "\t\t\t\t\t\ta->u.cases[i] = addcase(r);\n", "\t\t\t\t}\n", "\t\t\treturn a;\n", "\t\t}\n", "\t\treturn r;\n", "\n", "\tcase Talt:\n", "\t\tr->next = addcase(r->next);\n", "\t\tr->u.alt = addcase(r->u.alt);\n", "\t\treturn r;\n", "\n", "\tcase Tbegin:\n", "\tcase Tend:\n", "\tcase Tclass:\n", "\t\treturn r;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int pcmp(void *va,void *vb)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = (uint)*(ushort *)va - (uint)*(ushort *)vb;\n", "  if (iVar1 == 0) {\n", "    iVar1 = (uint)*(ushort *)((long)va + 2) - (uint)*(ushort *)((long)vb + 2);\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "pcmp(const void *va, const void *vb)\n", "{\n", "\tint n;\n", "\tRune *a, *b;\n", "\n", "\ta = (Rune*)va;\n", "\tb = (Rune*)vb;\n", "\n", "\tn = a[0] - b[0];\n", "\tif(n)\n", "\t\treturn n;\n", "\treturn a[1] - b[1];\n", "}"]}, {"ghidra": ["\n", "int exitcode(char *s)\n", "\n", "{\n", "  return 1;\n", "}\n", "\n"], "c": ["int\n", "exitcode(char *s)\n", "{\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "int canlock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock == (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->held == 0) {\n", "      l->held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canlock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\treturn (*_lock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->held)\n", "\t\t\treturn 0;\n", "\t\tl->held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void error(char *s)\n", "\n", "{\n", "  fprint(2,\"grep: internal error: %s\\n\",s);\n", "  exits(s);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "error(char *s)\n", "{\n", "\tfprint(2, \"grep: internal error: %s\\n\", s);\n", "\texits(s);\n", "}"]}, {"ghidra": ["\n", "void * mal(int n)\n", "\n", "{\n", "  char *s;\n", "  int m;\n", "  void *__s;\n", "  uint uVar1;\n", "  char *__s_00;\n", "  \n", "  uVar1 = n + 3U & 0xfffffffc;\n", "  __s_00 = s;\n", "  if (m < (int)uVar1) {\n", "    if (0x10000 < (int)uVar1) {\n", "      __s = sbrk((long)(int)uVar1);\n", "      memset(__s,0,(long)(int)uVar1);\n", "      return __s;\n", "    }\n", "    __s_00 = (char *)sbrk(0x10000);\n", "    m = 0x10000;\n", "  }\n", "  m = m - uVar1;\n", "  s = __s_00 + (long)(int)uVar1;\n", "  memset(__s_00,0,(long)(int)uVar1);\n", "  return __s_00;\n", "}\n", "\n"], "c": ["void*\n", "mal(int n)\n", "{\n", "\tstatic char *s;\n", "\tstatic int m = 0;\n", "\tvoid *v;\n", "\n", "\tn = (n+3) & ~3;\n", "\tif(m < n) {\n", "\t\tif(n > Nhunk) {\n", "\t\t\tv = sbrk(n);\n", "\t\t\tmemset(v, 0, n);\n", "\t\t\treturn v;\n", "\t\t}\n", "\t\ts = sbrk(Nhunk);\n", "\t\tm = Nhunk;\n", "\t}\n", "\tv = s;\n", "\ts += n;\n", "\tm -= n;\n", "\tmemset(v, 0, n);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "Re * ral(int type)\n", "\n", "{\n", "  Re *pRVar1;\n", "  \n", "  pRVar1 = (Re *)mal(0x18);\n", "  pRVar1->type = (uchar)type;\n", "  maxfollow = maxfollow + 1;\n", "  return pRVar1;\n", "}\n", "\n"], "c": ["Re*\n", "ral(int type)\n", "{\n", "\tRe *r;\n", "\n", "\tr = mal(sizeof(*r));\n", "\tr->type = type;\n", "\tmaxfollow++;\n", "\treturn r;\n", "}"]}, {"ghidra": ["\n", "void appendnext(long param_1,undefined8 param_2)\n", "\n", "{\n", "  long lVar1;\n", "  \n", "  do {\n", "    lVar1 = param_1;\n", "    param_1 = *(long *)(lVar1 + 0x10);\n", "  } while (param_1 != 0);\n", "  *(undefined8 *)(lVar1 + 0x10) = param_2;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "appendnext(Re *a, Re *b)\n", "{\n", "\tRe *n;\n", "\n", "\twhile(n = a->next)\n", "\t\ta = n;\n", "\ta->next = b;\n", "}"]}, {"ghidra": ["\n", "Re * oralloc(int t,Re *r,Re *b)\n", "\n", "{\n", "  Re *pRVar1;\n", "  \n", "  pRVar1 = r;\n", "  if (b != (Re *)0x0) {\n", "    pRVar1 = (Re *)mal(0x18);\n", "    pRVar1->type = (uchar)t;\n", "    maxfollow = maxfollow + 1;\n", "    *(Re **)&pRVar1->u = r;\n", "    pRVar1->next = b;\n", "  }\n", "  return pRVar1;\n", "}\n", "\n"], "c": ["Re*\n", "oralloc(int t, Re *r, Re *b)\n", "{\n", "\tRe *a;\n", "\n", "\tif(b == 0)\n", "\t\treturn r;\n", "\ta = ral(t);\n", "\ta->u.alt = r;\n", "\ta->next = b;\n", "\treturn a;\n", "}"]}, {"ghidra": ["\n", "void reprint1(Re *a)\n", "\n", "{\n", "  Re **ppRVar1;\n", "  long lVar2;\n", "  uint uVar3;\n", "  uint uVar4;\n", "  long *plVar5;\n", "  ulong uVar6;\n", "  long lVar7;\n", "  ulong uVar8;\n", "  long lVar9;\n", "  int iVar10;\n", "  \n", "  if (a != (Re *)0x0) {\n", "    do {\n", "      if (a->gen == gen) {\n", "        return;\n", "      }\n", "      a->gen = gen;\n", "      print(\"%p: \",a);\n", "      switch(a->type) {\n", "      default:\n", "        print(\"type %d\\n\",(ulong)a->type);\n", "        error(\"print1 type\");\n", "      case '\\x03':\n", "        print(\"case ->%p\\n\");\n", "        lVar7 = a->u;\n", "        _iVar10 = 0;\n", "        do {\n", "          iVar10 = (int)_iVar10;\n", "          lVar2 = *(long *)(lVar7 + (long)iVar10 * 8);\n", "          lVar9 = (long)iVar10 * 8;\n", "          if (lVar2 == 0) {\n", "            uVar8 = (ulong)(iVar10 + 1);\n", "          }\n", "          else {\n", "            uVar3 = iVar10 + 1;\n", "            if (uVar3 == 0x100) {\n", "LAB_00403250:\n", "              uVar8 = 0x100;\n", "              uVar6 = 0xff;\n", "            }\n", "            else {\n", "              if (lVar2 == *(long *)(lVar7 + 8 + lVar9)) {\n", "                plVar5 = (long *)(lVar7 + 0x10 + lVar9);\n", "                do {\n", "                  uVar4 = uVar3;\n", "                  uVar3 = uVar4 + 1;\n", "                  if (uVar3 == 0x100) goto LAB_00403250;\n", "                  lVar7 = *plVar5;\n", "                  plVar5 = plVar5 + 1;\n", "                } while (lVar2 == lVar7);\n", "                uVar8 = (ulong)uVar3;\n", "                uVar6 = (ulong)uVar4;\n", "              }\n", "              else {\n", "                uVar8 = (ulong)uVar3;\n", "                uVar6 = _iVar10;\n", "              }\n", "            }\n", "            print(\"\\t[%.2x-%.2x] ->%p\\n\",_iVar10,uVar6);\n", "            lVar7 = a->u;\n", "          }\n", "          _iVar10 = uVar8;\n", "        } while ((int)uVar8 < 0x100);\n", "        lVar9 = 0;\n", "        while( true ) {\n", "          ppRVar1 = (Re **)(lVar7 + lVar9);\n", "          lVar9 = lVar9 + 8;\n", "          reprint1(*ppRVar1);\n", "          if (lVar9 == 0x800) break;\n", "          lVar7 = a->u;\n", "        }\n", "        a = a->next;\n", "        break;\n", "      case '\\x01':\n", "      case '\\x06':\n", "        print(\"| %p ->%p\\n\",a->u,a->next);\n", "        reprint1((Re *)a->u);\n", "        a = a->next;\n", "        break;\n", "      case '\\x02':\n", "        print(\"^ ->%p\\n\",a->next);\n", "        a = a->next;\n", "        break;\n", "      case '\\x04':\n", "        print(\"[%.2x-%.2x] ->%p\\n\",(ulong)*(ushort *)&a->u,(ulong)*(ushort *)((long)&a->u + 2),\n", "              a->next);\n", "        a = a->next;\n", "        break;\n", "      case '\\x05':\n", "        print(\"$ ->%p\\n\",a->next);\n", "        a = a->next;\n", "      }\n", "    } while (a != (Re *)0x0);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "reprint1(Re *a)\n", "{\n", "\tint i, j;\n", "\n", "loop:\n", "\tif(a == 0)\n", "\t\treturn;\n", "\tif(a->gen == gen)\n", "\t\treturn;\n", "\ta->gen = gen;\n", "\tprint(\"%p: \", a);\n", "\tswitch(a->type) {\n", "\tdefault:\n", "\t\tprint(\"type %d\\n\", a->type);\n", "\t\terror(\"print1 type\");\n", "\n", "\tcase Tcase:\n", "\t\tprint(\"case ->%p\\n\", a->next);\n", "\t\tfor(i=0; i<256; i++)\n", "\t\t\tif(a->u.cases[i]) {\n", "\t\t\t\tfor(j=i+1; j<256; j++)\n", "\t\t\t\t\tif(a->u.cases[i] != a->u.cases[j])\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\tprint(\"\t[%.2x-%.2x] ->%p\\n\", i, j-1, a->u.cases[i]);\n", "\t\t\t\ti = j-1;\n", "\t\t\t}\n", "\t\tfor(i=0; i<256; i++)\n", "\t\t\treprint1(a->u.cases[i]);\n", "\t\tbreak;\n", "\n", "\tcase Tbegin:\n", "\t\tprint(\"^ ->%p\\n\", a->next);\n", "\t\tbreak;\n", "\n", "\tcase Tend:\n", "\t\tprint(\"$ ->%p\\n\", a->next);\n", "\t\tbreak;\n", "\n", "\tcase Tclass:\n", "\t\tprint(\"[%.2x-%.2x] ->%p\\n\", a->u.x.lo, a->u.x.hi, a->next);\n", "\t\tbreak;\n", "\n", "\tcase Tor:\n", "\tcase Talt:\n", "\t\tprint(\"| %p ->%p\\n\", a->u.alt, a->next);\n", "\t\treprint1(a->u.alt);\n", "\t\tbreak;\n", "\t}\n", "\ta = a->next;\n", "\tgoto loop;\n", "}"]}, {"ghidra": ["\n", "int fcmp(void *va,void *vb)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = -(uint)(*(ulong *)va < *(ulong *)vb);\n", "  if (*(ulong *)vb <= *(ulong *)va && *(ulong *)va != *(ulong *)vb) {\n", "    iVar1 = 1;\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "fcmp(const void *va, const void *vb)\n", "{\n", "\tRe **aa, **bb;\n", "\tRe *a, *b;\n", "\n", "\taa = (Re**)va;\n", "\tbb = (Re**)vb;\n", "\ta = *aa;\n", "\tb = *bb;\n", "\tif(a > b)\n", "\t\treturn 1;\n", "\tif(a < b)\n", "\t\treturn -1;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void str2top(char *p)\n", "\n", "{\n", "  Re *pRVar1;\n", "  Re2 RVar2;\n", "  \n", "  pRVar1 = topre.beg;\n", "  topre.end = (Re *)0x0;\n", "  topre.beg = (Re *)0x0;\n", "  input = p;\n", "  yyparse();\n", "  gen = gen + 1;\n", "  if (topre.beg == (Re *)0x0) {\n", "    yyerror(\"syntax\");\n", "  }\n", "  RVar2 = (Re2)CONCAT88(topre.end,topre.beg);\n", "  if (pRVar1 != (Re *)0x0) {\n", "    RVar2 = re2or();\n", "  }\n", "  topre.end = SUB168((undefined  [16])RVar2 >> 0x40,0);\n", "  topre.beg = SUB168((undefined  [16])RVar2,0);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "str2top(char *p)\n", "{\n", "\tRe2 oldtop;\n", "\n", "\toldtop = topre;\n", "\tinput = p;\n", "\ttopre.beg = 0;\n", "\ttopre.end = 0;\n", "\tyyparse();\n", "\tgen++;\n", "\tif(topre.beg == 0)\n", "\t\tyyerror(\"syntax\");\n", "\tif(oldtop.beg)\n", "\t\ttopre = re2or(oldtop, topre);\n", "}"]}, {"ghidra": ["\n", "int canqlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock == (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->l).held == 0) {\n", "      (l->l).held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canqlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\treturn (*_qlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->l.held)\n", "\t\t\treturn 0;\n", "\t\tl->l.held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int sort_display_function(void *a,void *b)\n", "\n", "{\n", "  return (int)*(short *)((long)a + 4) - (int)*(short *)((long)b + 4);\n", "}\n", "\n"], "c": ["static int sort_display_function( const void *a, const void *b )\n", "{\n", "\treturn ((DisplaySort*)a)->object_y2 - ((DisplaySort*)b)->object_y2;\n", "}"]}, {"ghidra": ["\n", "int nation_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  long *plVar2;\n", "  int iVar3;\n", "  char *pcVar4;\n", "  long lVar5;\n", "  \n", "  lVar5 = 0;\n", "  if (((nation_array.player_recno != 0) && (iVar1 = (int)info.viewing_nation_recno, 0 < iVar1)) &&\n", "     (iVar1 <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    lVar5 = *(long *)(nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (iVar1 + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  if (nation_array.super_DynArrayB.super_DynArray.last_ele < 1) {\n", "    return 0;\n", "  }\n", "  pcVar4 = (char *)(lVar5 + 0x19a);\n", "  iVar1 = 0;\n", "  iVar3 = 1;\n", "  plVar2 = (long *)nation_array.super_DynArrayB.super_DynArray.body_buf;\n", "  do {\n", "    if (*plVar2 != 0) {\n", "      if (((iVar3 == (int)info.viewing_nation_recno) || (lVar5 == 0)) || (*pcVar4 != '\\0')) {\n", "        iVar1 = iVar1 + 1;\n", "      }\n", "      if ((iVar1 == recNo) && (recNo != 0)) {\n", "        return iVar3;\n", "      }\n", "    }\n", "    iVar3 = iVar3 + 1;\n", "    plVar2 = (long *)((long)plVar2 + (long)nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    pcVar4 = pcVar4 + 0x90;\n", "    if (nation_array.super_DynArrayB.super_DynArray.last_ele < iVar3) {\n", "      return iVar1;\n", "    }\n", "  } while( true );\n", "}\n", "\n"], "c": ["static int nation_filter(int recNo)\n", "{\n", "\tint    \ti, nationCount=0;\n", "\tNation*  viewingNation = NULL;\n", "\t\n", "\tif( nation_array.player_recno )\n", "\t\tviewingNation = nation_array[info.viewing_nation_recno];\n", "\n", "\tfor( i=1 ; i<=nation_array.size() ; i++ )\n", "\t{\n", "\t\tif( nation_array.is_deleted(i) )\n", "\t\t\tcontinue;\n", "\n", "\t\tif( i==info.viewing_nation_recno ||\n", "\t\t\t !viewingNation ||\n", "\t\t\t viewingNation->get_relation(i)->has_contact )\n", "\t\t{\n", "\t\t\tnationCount++;\n", "\t\t}\n", "\n", "\t\tif( recNo && nationCount==recNo )\n", "\t\t\treturn i;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn nationCount;\n", "}"]}, {"ghidra": ["\n", "int sort_region_function(void *a,void *b)\n", "\n", "{\n", "  return region_array.region_info_array[(ulong)*(byte *)b - 1].region_size -\n", "         region_array.region_info_array[(ulong)*(byte *)a - 1].region_size;\n", "}\n", "\n"], "c": ["static int sort_region_function( const void *a, const void *b )\n", "{\n", "\treturn region_array[*((BYTE*)b)]->region_size - region_array[*((BYTE*)a)]->region_size;\n", "}"]}, {"ghidra": ["\n", "void put_firm_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  short sVar1;\n", "  int firmId;\n", "  FirmInfo *pFVar2;\n", "  char *textPtr;\n", "  \n", "  y = y + 3;\n", "  firmId = firm_filter(recNo);\n", "  pFVar2 = operator__(&firm_res,firmId);\n", "  sVar1 = pFVar2->nation_firm_count_array[(int)info.viewing_nation_recno + -1];\n", "  put(&font_san,x + 3,y,pFVar2->name,'\\0',-1);\n", "  textPtr = format(&misc,(int)pFVar2->year_cost,2);\n", "  put(&font_san,x + 0x9e,y,textPtr,'\\0',-1);\n", "  textPtr = format(&misc,(int)sVar1,1);\n", "  put(&font_san,x + 0x10c,y,textPtr,'\\0',-1);\n", "  textPtr = format(&misc,(int)pFVar2->year_cost * (int)sVar1,2);\n", "  put(&font_san,x + 0x175,y,textPtr,'\\0',-1);\n", "  textPtr = format(&misc,firm_income_array[firmId + -1],2);\n", "  put(&font_san,x + 0x1d9,y,textPtr,'\\0',-1);\n", "  return;\n", "}\n", "\n"], "c": ["static void put_firm_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint   \t firmId = firm_filter(recNo);\n", "\tFirmInfo* firmInfo = firm_res[firmId];\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tint firmCount = firmInfo->nation_firm_count_array[info.viewing_nation_recno-1];\n", "\n", "\tfont_san.put( x    , y, firmInfo->name );\n", "\tfont_san.put( x+155, y, misc.format(firmInfo->year_cost,2) );\n", "\tfont_san.put( x+265, y, firmCount );\n", "\tfont_san.put( x+370, y, misc.format(firmInfo->year_cost*firmCount,2) );\n", "\tfont_san.put( x+470, y, misc.format(firm_income_array[firmId-1], 2) );\n", "}"]}, {"ghidra": ["\n", "void __thiscall detect_button(Unit *this)\n", "\n", "{\n", "  Unit *this_00;\n", "  short sVar1;\n", "  int recNo;\n", "  int iVar2;\n", "  int recNo_00;\n", "  short *psVar3;\n", "  undefined2 *puVar4;\n", "  char *buttonName;\n", "  Spy *this_01;\n", "  bool bVar5;\n", "  RelVolume in_stack_00000008;\n", "  undefined in_stack_ffffffffffffffb8 [14];\n", "  ushort local_3a;\n", "  \n", "  if (((nation_array.player_recno != 0) && (nation_array.player_recno == (short)this->nation_recno))\n", "     && (((nation_array.player_ptr)->super_NationBase).king_unit_recno == 0)) {\n", "    if (this->race_id == '\\0') {\n", "      return;\n", "    }\n", "    recNo = detect(&button_succeed_king,0,0,0,0);\n", "    if (recNo == 0) {\n", "      return;\n", "    }\n", "    recNo = is_enable(&remote);\n", "    if (recNo != 0) {\n", "      psVar3 = (short *)new_send_queue_msg(&remote,0x25f0,4);\n", "      *psVar3 = (this->super_Sprite).sprite_recno;\n", "      psVar3[1] = nation_array.player_recno;\n", "      return;\n", "    }\n", "    succeed_king((NationBase *)nation_array.player_ptr,(int)(this->super_Sprite).sprite_recno);\n", "LAB_004edf41:\n", "    disp(&info);\n", "    return;\n", "  }\n", "  if ((this->home_camp_firm_recno != 0) && (recNo = detect(&button_return_camp,0,0,0,0), recNo != 0)\n", "     ) {\n", "    far_sound(&se_res,(this->super_Sprite).next_x >> 5,(this->super_Sprite).next_y >> 5,1,'S',\n", "              (this->super_Sprite).sprite_id,\"ACK\",'\\0',0);\n", "    return_camp(&unit_array,0,(short *)0x0,0);\n", "    return;\n", "  }\n", "  recNo = detect(&button_aggressive_mode,0,0,0,0);\n", "  if (recNo != 0) {\n", "    recNo = (int)unit_array.super_SpriteArray._58_2_;\n", "    if ((recNo < 1) ||\n", "       (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    bVar5 = *(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf\n", "                               + (recNo + -1) *\n", "                                 unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                 ele_size) + 0xb6) == '\\0';\n", "    local_3a = (ushort)bVar5;\n", "    recNo = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "    recNo_00 = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "    while (0 < recNo_00) {\n", "      recNo_00 = recNo_00 + -1;\n", "      iVar2 = is_deleted(&unit_array,recNo);\n", "      if (iVar2 == 0) {\n", "        if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo)\n", "        goto code_r0x004ee133;\n", "        this_00 = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                            unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size *\n", "                            recNo_00);\n", "        if ((this_00->selected_flag != '\\0') && (iVar2 = is_own(this_00), iVar2 != 0)) {\n", "          iVar2 = is_enable(&remote);\n", "          if (iVar2 == 0) {\n", "            *(bool *)&this_00->aggressive_mode = bVar5;\n", "          }\n", "          else {\n", "            puVar4 = (undefined2 *)new_send_queue_msg(&remote,0x2600,4);\n", "            *puVar4 = (short)recNo;\n", "            puVar4[1] = local_3a;\n", "          }\n", "        }\n", "      }\n", "      recNo = recNo + -1;\n", "    }\n", "    if (bVar5) {\n", "      immediate_sound(&se_ctrl,\"TURN_ON\",(RelVolume)CONCAT214(local_3a,in_stack_ffffffffffffffb8));\n", "      buttonName = \"AGGRESS1\";\n", "    }\n", "    else {\n", "      immediate_sound(&se_ctrl,\"TURN_OFF\",(RelVolume)CONCAT214(local_3a,in_stack_ffffffffffffffb8));\n", "      buttonName = \"AGGRESS0\";\n", "    }\n", "    update_bitmap(&button_aggressive_mode,buttonName);\n", "  }\n", "  recNo = detect(&button_build,0,0,0,0);\n", "  if (recNo != 0) {\n", "    unit_menu_mode = 1;\n", "    disp(&info);\n", "  }\n", "  recNo = detect(&button_settle,0,0,0,0);\n", "  if (recNo != 0) {\n", "    issue_command(&power,4,(int)(this->super_Sprite).sprite_recno,0);\n", "    goto LAB_004edf41;\n", "  }\n", "  if (this->rank_id == '\\0') {\n", "    recNo = detect(&button_promote,0,0,0,0);\n", "    if (recNo != 0) {\n", "      recNo = is_enable(&remote);\n", "      if (recNo == 0) {\n", "        set_rank(this,1);\n", "      }\n", "      else {\n", "        psVar3 = (short *)new_send_queue_msg(&remote,0x25e9,4);\n", "        sVar1 = (this->super_Sprite).sprite_recno;\n", "        psVar3[1] = 1;\n", "        *psVar3 = sVar1;\n", "      }\n", "      immediate_sound(&se_ctrl,\"TURN_ON\",(RelVolume)CONCAT214(local_3a,in_stack_ffffffffffffffb8));\n", "    }\n", "  }\n", "  else {\n", "    if ((this->rank_id == '\\x01') && (recNo = detect(&button_demote,0,0,0,0), recNo != 0)) {\n", "      recNo = is_enable(&remote);\n", "      if (recNo == 0) {\n", "        set_rank(this,0);\n", "      }\n", "      else {\n", "        psVar3 = (short *)new_send_queue_msg(&remote,0x25e9,4);\n", "        *psVar3 = (this->super_Sprite).sprite_recno;\n", "        psVar3[1] = 0;\n", "      }\n", "      immediate_sound(&se_ctrl,\"TURN_OFF\",(RelVolume)CONCAT214(local_3a,in_stack_ffffffffffffffb8));\n", "    }\n", "  }\n", "  recNo = detect(&button_assign,0,0,0,0);\n", "  if (recNo != 0) {\n", "    issue_command(&power,2,(int)(this->super_Sprite).sprite_recno,0);\n", "  }\n", "  iVar2 = detect(&button_reward,0,0,0,0);\n", "  recNo = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "  recNo_00 = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "  if (iVar2 != 0) {\n", "    while (0 < recNo_00) {\n", "      iVar2 = is_deleted(&unit_array,recNo);\n", "      if (iVar2 == 0) {\n", "        if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo) {\n", "          do {\n", "            invalidInstructionException();\n", "          } while( true );\n", "        }\n", "        this_00 = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                            unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size *\n", "                            (recNo_00 + -1));\n", "        if ((this_00->selected_flag != '\\0') && (iVar2 = is_own(this_00), iVar2 != 0)) {\n", "          iVar2 = is_enable(&remote);\n", "          if (iVar2 == 0) {\n", "            reward(this_00,(int)nation_array.player_recno);\n", "          }\n", "          else {\n", "            puVar4 = (undefined2 *)new_send_queue_msg(&remote,0x25eb,4);\n", "            *puVar4 = (short)recNo;\n", "            puVar4[1] = nation_array.player_recno;\n", "          }\n", "        }\n", "      }\n", "      recNo = recNo + -1;\n", "      recNo_00 = recNo_00 + -1;\n", "    }\n", "    immediate_sound(&se_ctrl,\"TURN_ON\",(RelVolume)CONCAT214(local_3a,in_stack_ffffffffffffffb8));\n", "  }\n", "  if (this->spy_recno == 0) {\n", "    return;\n", "  }\n", "  recNo = detect(&button_spy_notify,0,0,0,0);\n", "  if (recNo != 0) {\n", "    recNo = (int)unit_array.super_SpriteArray._58_2_;\n", "    if ((recNo < 1) ||\n", "       (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    sVar1 = *(short *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                 body_buf +\n", "                                (recNo + -1) *\n", "                                unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size\n", "                                ) + 0x6f);\n", "    if ((sVar1 < 1) || (spy_array.super_DynArrayB.super_DynArray.last_ele < (int)sVar1)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    bVar5 = spy_array.super_DynArrayB.super_DynArray.body_buf\n", "            [(long)(((int)sVar1 + -1) * spy_array.super_DynArrayB.super_DynArray.ele_size) + 9] ==\n", "            '\\0';\n", "    recNo = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "    while (recNo_00 = recNo, 0 < recNo_00) {\n", "      recNo = recNo_00 + -1;\n", "      iVar2 = is_deleted(&unit_array,recNo_00);\n", "      if (iVar2 == 0) {\n", "        if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo_00)\n", "        goto code_r0x004ee133;\n", "        this_00 = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                            unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size *\n", "                            recNo);\n", "        if ((this_00->selected_flag != '\\0') && (recNo_00 = is_own_spy(this_00), recNo_00 != 0)) {\n", "          recNo_00 = is_enable(&remote);\n", "          if (recNo_00 == 0) {\n", "            sVar1 = this_00->spy_recno;\n", "            if ((sVar1 < 1) || (spy_array.super_DynArrayB.super_DynArray.last_ele < (int)sVar1)) {\n", "              do {\n", "                invalidInstructionException();\n", "              } while( true );\n", "            }\n", "            *(bool *)(spy_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (long)(((int)sVar1 + -1) * spy_array.super_DynArrayB.super_DynArray.ele_size) +\n", "                     9) = bVar5;\n", "          }\n", "          else {\n", "            psVar3 = (short *)new_send_queue_msg(&remote,0x2601,4);\n", "            sVar1 = this_00->spy_recno;\n", "            psVar3[1] = (ushort)bVar5;\n", "            *psVar3 = sVar1;\n", "          }\n", "        }\n", "      }\n", "    }\n", "    if (!bVar5) {\n", "      update_bitmap(&button_spy_notify,\"SPYNOTI0\");\n", "      immediate_sound(&se_ctrl,\"TURN_OFF\",(RelVolume)CONCAT214(local_3a,in_stack_ffffffffffffffb8));\n", "      sVar1 = this->spy_recno;\n", "      goto LAB_004ee2c1;\n", "    }\n", "    update_bitmap(&button_spy_notify,\"SPYNOTI1\");\n", "    immediate_sound(&se_ctrl,\"TURN_ON\",(RelVolume)CONCAT214(local_3a,in_stack_ffffffffffffffb8));\n", "  }\n", "  sVar1 = this->spy_recno;\n", "LAB_004ee2c1:\n", "  if ((sVar1 == 0) ||\n", "     (recNo_00 = detect(&button_spy_drop_identity,0,0,0,0),\n", "     recNo = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele, recNo_00 == 0)) {\n", "    return;\n", "  }\n", "  while( true ) {\n", "    do {\n", "      recNo_00 = recNo;\n", "      if (recNo_00 < 1) {\n", "        immediate_sound(&se_ctrl,\"TURN_OFF\",in_stack_00000008);\n", "        return;\n", "      }\n", "      recNo = recNo_00 + -1;\n", "      iVar2 = is_deleted(&unit_array,recNo_00);\n", "    } while (iVar2 != 0);\n", "    if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo_00) break;\n", "    this_00 = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                        unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size * recNo\n", "                        );\n", "    if ((this_00->selected_flag != '\\0') && (recNo_00 = is_own_spy(this_00), recNo_00 != 0)) {\n", "      recNo_00 = is_enable(&remote);\n", "      if (recNo_00 == 0) {\n", "        sVar1 = this_00->spy_recno;\n", "        this_01 = (Spy *)0x0;\n", "        if ((0 < sVar1) && ((int)sVar1 <= spy_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "          this_01 = (Spy *)(spy_array.super_DynArrayB.super_DynArray.body_buf +\n", "                           ((int)sVar1 + -1) * spy_array.super_DynArrayB.super_DynArray.ele_size);\n", "        }\n", "        drop_spy_identity(this_01);\n", "      }\n", "      else {\n", "        psVar3 = (short *)new_send_queue_msg(&remote,0x2632,2);\n", "        *psVar3 = this_00->spy_recno;\n", "      }\n", "    }\n", "  }\n", "code_r0x004ee133:\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static int detect_button()\n", "{\n", "\tint x=REPORT_BUTTON_X1;\n", "\n", "\tfor( int i=1 ; i<=MAX_NATION_REPORT_MODE ; i++ )\n", "\t{\n", "\t\tif( i==NATION_REPORT_DEBUG )\n", "\t\t{\n", "\t\t\tif( remote.is_enable() ||\n", "\t\t\t\t ( !sys.debug_session && !sys.testing_session ) )\n", "\t\t\t{\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t}\n", "\t\telse if( !sys.debug_session && i==NATION_REPORT_CHAT )\n", "\t\t{\n", "\t\t\tif( !remote.is_enable() )\n", "\t\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\t//-----------------------------------------//\n", "\n", "\t\tif( mouse.single_click( x, REPORT_BUTTON_Y1, x+REPORT_BUTTON_WIDTH-1, REPORT_BUTTON_Y2 ) )\n", "\t\t{\n", "\t\t\tinfo.nation_report_mode = i;\n", "\t\t\treturn 1;\n", "\t\t}\n", "\n", "\t\tx+=REPORT_BUTTON_WIDTH;\n", "\t}\n", "\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void set_source_volume(ALuint source,int volume_millibels)\n", "\n", "{\n", "  undefined4 in_register_0000003c;\n", "  double dVar1;\n", "  undefined8 extraout_XMM0_Qb;\n", "  \n", "  if (volume_millibels < -10000) {\n", "    volume_millibels = -10000;\n", "  }\n", "  if (0 < volume_millibels) {\n", "    volume_millibels = 0;\n", "  }\n", "  if (volume_millibels == -10000) {\n", "    alSourcef(0,CONCAT44(in_register_0000003c,source),0x100a);\n", "    return;\n", "  }\n", "  dVar1 = pow(10.00000000,(double)((float)volume_millibels / 2000.00000000));\n", "  alSourcef(SUB168(CONCAT124(SUB1612(CONCAT88(extraout_XMM0_Qb,dVar1) >> 0x20,0),(float)dVar1),0),\n", "            (ulong)source,0x100a);\n", "  return;\n", "}\n", "\n"], "c": ["static void set_source_volume(ALuint source, int volume_millibels)\n", "{\n", "   volume_millibels = MAX(volume_millibels, -10000);\n", "   volume_millibels = MIN(volume_millibels, 0);\n", "\n", "   MSG(\"set_source_volume(%x, %f)\\n\",\n", "       source, millibels_to_ratio(volume_millibels));\n", "\n", "   alSourcef(source, AL_GAIN, millibels_to_ratio(volume_millibels));\n", "}"]}, {"ghidra": ["\n", "void IMGbarRemap16x16(char *imageBuf,int pitch,int x,int y,char *table)\n", "\n", "{\n", "  byte *pbVar1;\n", "  byte *pbVar2;\n", "  byte *pbVar3;\n", "  int iVar4;\n", "  \n", "  pbVar3 = (byte *)(imageBuf + (y * pitch + x));\n", "  iVar4 = 0x10;\n", "  do {\n", "    pbVar1 = pbVar3;\n", "    do {\n", "      pbVar2 = pbVar1 + 1;\n", "      *pbVar1 = table[*pbVar1];\n", "      pbVar1 = pbVar2;\n", "    } while (pbVar3 + 0x10 != pbVar2);\n", "    pbVar3 = pbVar3 + pitch;\n", "    iVar4 = iVar4 + -1;\n", "  } while (iVar4 != 0);\n", "  return;\n", "}\n", "\n"], "c": ["void IMGbarRemap16x16(char* imageBuf, int pitch, int x, int y, char* table)\n", "{\n", "\tint dest = y*pitch + x;\n", "\tfor (int j=0; j<16; ++j, dest+=pitch)\n", "\t{\n", "\t\tfor (int i=0; i<16; ++i)\n", "\t\t{\n", "\t\t\timageBuf[dest+i] = table[ ((unsigned char*)imageBuf)[dest+i] ];\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void disp_nation_info(void)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  int y;\n", "  char *value;\n", "  Button *this;\n", "  char *s;\n", "  long lVar3;\n", "  int iVar4;\n", "  int y_00;\n", "  NationBase *this_00;\n", "  NationBase *this_01;\n", "  long in_FS_OFFSET;\n", "  float fVar5;\n", "  String str;\n", "  String str_1;\n", "  \n", "  this_01 = (NationBase *)0x0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  d3_panel_down(&vga_util,6,0x12a,0x239,0x251,0,0);\n", "  iVar2 = nation_filter((int)browse_nation.super_VBrowse.rec_no);\n", "  if ((0 < iVar2) && (iVar2 <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    this_01 = *(NationBase **)\n", "               (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "               (iVar2 + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  y = (int)info.viewing_nation_recno;\n", "  lVar3 = 0;\n", "  if ((0 < y) && (y <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    lVar3 = *(long *)(nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (y + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  String(&str);\n", "  if ((int)info.viewing_nation_recno == iVar2) {\n", "    y = 0x16a;\n", "    iVar4 = 0x150;\n", "    value = food_str(this_01);\n", "    put_field(&font_san,0xc,0x130,\"Your Food\",0x15a,value);\n", "    operator_(&str,\"$\");\n", "    value = cash_str(this_01);\n", "    operator__(&str,value);\n", "    put_field(&font_san,0xc,0x140,\"Your Treasure\",0x15a,(char *)&str);\n", "    value = peace_duration_str(this_01);\n", "    field(&font_san,0xc,0x150,\"Your Continuous Peace Time\",0x15a,value,0x22f,10,\"PEACE\");\n", "  }\n", "  else {\n", "    lVar3 = lVar3 + 400 + (long)iVar2 * 0x90;\n", "    value = process(&translate,\"Your Yearly Import from \");\n", "    operator_(&str,value);\n", "    value = nation_name(this_01);\n", "    operator__(&str,value);\n", "    field(&font_san,0xc,0x130,(char *)&str,0x15a,\n", "          (int)(((float)(0x16d - info.year_day) * *(float *)(lVar3 + -0x61)) / 365.00000000 +\n", "               *(float *)(lVar3 + -0x6d)),2,0x22f,10,\"IMPORT\");\n", "    value = process(&translate,\"Your Yearly Export to \");\n", "    operator_(&str,value);\n", "    value = nation_name(this_01);\n", "    operator__(&str,value);\n", "    y = 0x18a;\n", "    field(&font_san,0xc,0x140,(char *)&str,0x15a,\n", "          (int)(((float)(0x16d - info.year_day) *\n", "                (this_01->relation_array + info.viewing_nation_recno)[-1].last_year_import[2]) /\n", "                365.00000000 +\n", "               (this_01->relation_array + info.viewing_nation_recno)[-1].cur_year_import[2]),2,0x22f\n", "          ,10,\"EXPORT\");\n", "    value = process(&translate,\"Continuous Peace Time of \");\n", "    operator_(&str,value);\n", "    value = nation_name(this_01);\n", "    operator__(&str,value);\n", "    value = peace_duration_str(this_01);\n", "    field(&font_san,0xc,0x150,(char *)&str,0x15a,value,0x22f,10,\"PEACE\");\n", "    value = process(&translate,\"Duration of \");\n", "    operator_(&str,value);\n", "    value = process(&translate,relation_status_str_array[*(char *)(lVar3 + -0x83)]);\n", "    operator__(&str,value);\n", "    operator__(&str,\" Status\");\n", "    value = status_duration_str((NationRelation *)(lVar3 + -0x86));\n", "    field(&font_san,0xc,0x160,(char *)&str,0x15a,value,0x22f,10,\"STATTIME\");\n", "    operator_(&str,\"Allow Your Units to Attack \");\n", "    value = nation_name(this_01);\n", "    operator__(&str,value);\n", "    field(&font_san,0xc,0x170,(char *)&str,0x15a,\"\",0x22f,10,\"ALLOWATK\");\n", "    this = operator__(&button_allow_attack,1);\n", "    create(this,1,0x160,0x170,0x18c,0x17f,&DAT_00534394,'\\x01','\\0');\n", "    this = operator__(&button_allow_attack,0);\n", "    create(this,1,400,0x170,0x1be,0x17f,&DAT_00534391,'\\x01','\\0');\n", "    iVar4 = 0x170;\n", "    paint(&button_allow_attack,(int)*(char *)(lVar3 + -0x85));\n", "    if (*(char *)(lVar3 + -0x83) == '\\x04') {\n", "      y = 0x1aa;\n", "      iVar4 = 400;\n", "      value = nation_name(this_01);\n", "      operator_(&str,value);\n", "      operator__(&str,\" \\'s Treasure\");\n", "      field(&font_san,0xc,0x180,(char *)&str,0x15a,(double)this_01->cash,2,0x22f,10,(char *)0x0);\n", "      value = nation_name(this_01);\n", "      operator_(&str,value);\n", "      operator__(&str,\" \\'s Food\");\n", "      field(&font_san,0xc,400,(char *)&str,0x15a,(double)this_01->food,2,0x22f,10,(char *)0x0);\n", "    }\n", "  }\n", "  if ((int)info.viewing_nation_recno != iVar2) {\n", "    value = &this_01->relation_array[0].ai_relation_level;\n", "    String(&str_1);\n", "    s = nation_name(this_01);\n", "    operator_(&str_1,s);\n", "    operator__(&str_1,\"\\'s \");\n", "    s = process(&translate,\"Diplomatic Status with Other Kingdoms:\");\n", "    operator__(&str_1,s);\n", "    y_00 = iVar4 + 0x2e;\n", "    disp_nation_color(this_01,0xc,iVar4 + 0x1b);\n", "    put(&font_san,0x20,y,(char *)&str_1,'\\0',-1);\n", "    y = 1;\n", "    if (0 < nation_array.super_DynArrayB.super_DynArray.last_ele) {\n", "      do {\n", "        if (0 < y) {\n", "          if (((*(NationBase **)\n", "                 (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                 nation_array.super_DynArrayB.super_DynArray.ele_size * (y + -1)) !=\n", "                (NationBase *)0x0) && (y != iVar2)) && ((int)info.viewing_nation_recno != y)) {\n", "            disp_nation_color(*(NationBase **)\n", "                               (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                               nation_array.super_DynArrayB.super_DynArray.ele_size * (y + -1)),0xc,\n", "                              y_00 + 1);\n", "            this_00 = (NationBase *)0x0;\n", "            if (y <= nation_array.super_DynArrayB.super_DynArray.last_ele) {\n", "              this_00 = *(NationBase **)\n", "                         (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                         (y + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "            }\n", "            s = nation_name(this_00);\n", "            put(&font_san,0x20,y_00,s,'\\0',-1);\n", "            put(&font_san,0xfc,y_00,relation_status_str_array[value[-5]],'\\0',-1);\n", "            if (value[-6] != '\\0') {\n", "              put(&font_san,0x156,y_00,\"Trade Treaty\",'\\0',-1);\n", "              fVar5 = total_year_trade(this_01,y);\n", "              s = format(&misc,(int)fVar5,2);\n", "              put(&font_san,0x1ce,y_00,s,'\\0',-1);\n", "            }\n", "            if (config.show_ai_info != '\\0') {\n", "              s = format(&misc,(int)*value,1);\n", "              put(&font_san,0x200,y_00,s,'\\0',-1);\n", "              s = format(&misc,(int)*(float *)(value + 3),1);\n", "              put(&font_san,0x21e,y_00,s,'\\0',-1);\n", "            }\n", "            y_00 = y_00 + 0x10;\n", "          }\n", "        }\n", "        y = y + 1;\n", "        value = value + 0x90;\n", "      } while (y <= nation_array.super_DynArrayB.super_DynArray.last_ele);\n", "    }\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["static void disp_nation_info()\n", "{\n", "\tvga_util.d3_panel_down( REPORT_DET_X1, REPORT_DET_Y1, REPORT_DET_X2, REPORT_DET_Y2 );\n", "\n", "\t//----------- display info ------------//\n", "\n", "\tint\t  nationRecno  = nation_filter(browse_nation.recno());\n", "\tNation* nationPtr    = nation_array[nationRecno];\n", "\tNation* viewingNation = nation_array[info.viewing_nation_recno];\n", "\tNationRelation* nationRelation = viewingNation->get_relation(nationRecno);\n", "\n", "\tint x1=REPORT_DET_X1+6, x2=REPORT_DET_X1+340, x3=REPORT_DET_X2-10;\n", "\tint y=REPORT_DET_Y1+6;\n", "\n", "\t//-------- display economic data ----------//\n", "\n", "\tString str;\n", "\n", "\tif( nationRecno == info.viewing_nation_recno )\n", "\t{\n", "\t\tfont_san.put_field( x1, y, \"Your Food\", x2, nationPtr->food_str() );\n", "\n", "\t\tstr  = \"$\";\n", "\t\tstr += nationPtr->cash_str();\n", "\n", "\t\tfont_san.put_field( x1, y+=16, \"Your Treasure\", x2, str );\n", "\n", "\t\tfont_san.field( x1, y+=16, \"Your Continuous Peace Time\", x2, nationPtr->peace_duration_str(), x3, INFO_REPAINT, \"PEACE\" );\n", "\t}\n", "\telse\n", "\t{\n", "\t\tstr  = translate.process(\"Your Yearly Import from \");\n", "\t\tstr += nationPtr->nation_name();\n", "\n", "\t\tfont_san.field( x1, y    , str, x2, (int) viewingNation->get_relation(nationRecno)->import_365days(IMPORT_TOTAL), 2, x3, INFO_REPAINT, \"IMPORT\" );\n", "\n", "\t\tstr  = translate.process(\"Your Yearly Export to \");\n", "\t\tstr += nationPtr->nation_name();\n", "\n", "\t\tfont_san.field( x1, y+=16, str, x2, (int) nationPtr->get_relation(info.viewing_nation_recno)->import_365days(IMPORT_TOTAL), 2, x3, INFO_REPAINT, \"EXPORT\" );\n", "\n", "\t\tstr  = translate.process(\"Continuous Peace Time of \");\n", "\t\tstr += nationPtr->nation_name();\n", "\n", "\t\tfont_san.field( x1, y+=16, str, x2, nationPtr->peace_duration_str(), x3, INFO_REPAINT, \"PEACE\" );\n", "\n", "\t\t//--------- duration of current status ----------//\n", "\n", "#if(defined(SPANISH))\n", "\t\tstr  = \"Duraci\ufffdn del estado de \";\n", "\t\tstr += translate.process(nationRelation->status_str());\n", "#elif(defined(FRENCH))\n", "\t\tstr  = \"Duration of \";\n", "\t\tstr += nationRelation->status_str();\n", "\t\tstr += \" Status\";\n", "\t\tstr  = translate.process(str);\n", "#else\n", "\t\t// GERMAN and US\n", "\t\tstr  = translate.process(\"Duration of \");\n", "\t\tstr += translate.process(nationRelation->status_str());\n", "\t\tstr += \" Status\";\n", "#endif\n", "\n", "\t\tfont_san.field( x1, y+=16, str, x2, nationRelation->status_duration_str(), x3, INFO_REPAINT, \"STATTIME\" );\n", "\n", "\t\t//------- display the allow_attack field --------//\n", "\n", "\t\t#if(defined(SPANISH))\n", "\t\t\t// str  = \"Permitir que tus Unidades ataquen al \";\n", "\t\t\tstr  = \"Permitir atacar al \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "\t\t#elif(defined(FRENCH))\n", "\t\t\tstr  = \"Autoriser attaque contre le \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "\t\t#elif(defined(GERMAN))\n", "\t\t\tstr  = \"Angriffe auf \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "\t\t\tstr += \" erlauben\";\n", "\t\t#else\n", "\t\t\tstr  = \"Allow Your Units to Attack \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "\t\t#endif\n", "\n", "\t\tfont_san.field( x1, y+=16, str, x2, \"\", x3, INFO_REPAINT, \"ALLOWATK\" );\n", "\n", "\t\tbutton_allow_attack[1].create_text( x2+6 , y, x2+50 , y+15, \"Yes\" );\n", "\t\tbutton_allow_attack[0].create_text( x2+54, y, x2+100, y+15, \"No\"  );\n", "\n", "\t\tbutton_allow_attack.paint( viewingNation->get_relation(nationRecno)->should_attack );\n", "\n", "\t\t//---- if this nation is our ally, display its cash and food ----//\n", "\n", "\t\tif( viewingNation->get_relation(nationRecno)->status == NATION_ALLIANCE )\n", "\t\t{\n", "#if(defined(SPANISH))\n", "\t\t\tstr  = \"Tesoro del \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "#elif(defined(FRENCH))\n", "\t\t\tstr  = \"Tr\ufffdsor du \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "#else\n", "\t\t\t// GERMAN and US\n", "\t\t\tstr  = nationPtr->nation_name();\n", "\t\t\tstr += \" 's Treasure\";\n", "#endif\n", "\n", "\t\t\tfont_san.field( x1, y+=16, str, x2, nationPtr->cash, 2, x3, INFO_REPAINT );\n", "\n", "#if(defined(SPANISH))\n", "\t\t\tstr = \"Alimentos del \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "#elif(defined(FRENCH))\n", "\t\t\tstr = \"R\ufffdserves de nourriture du \";\n", "\t\t\tstr += nationPtr->nation_name();\n", "#else\n", "\t\t\t// GERMAN and US\n", "\t\t\tstr  = nationPtr->nation_name();\n", "\t\t\tstr += \" 's Food\";\n", "#endif\n", "\n", "\t\t\tfont_san.field( x1, y+=16, str, x2, nationPtr->food, 2, x3, INFO_REPAINT );\n", "\t\t}\n", "\t}\n", "\n", "\ty+=26;\n", "\n", "\t//----- display its relation status with other nations -----//\n", "\n", "\tif( info.viewing_nation_recno != nationRecno )\n", "\t{\n", "\t\tString str;\n", "\n", "#if(defined(SPANISH))\n", "\t\tstr  = \"Estado Diplom\ufffdtico del \";\n", "\t\tstr += nationPtr->nation_name();\n", "\t\tstr += \" con otros Reinos:\";\n", "#elif(defined(FRENCH))\n", "\t\tstr  = \"Relations diplomatiques de \";\n", "\t\tstr += nationPtr->nation_name();\n", "\t\tstr += \" avec les autres royaumes:\";\n", "#else\n", "\t\t// GERMAN and US\n", "\t\tstr  = nationPtr->nation_name();\n", "\t\tstr += \"'s \";\n", "\t\tstr += translate.process( \"Diplomatic Status with Other Kingdoms:\" );\n", "#endif\n", "\n", "\t\tnationPtr->disp_nation_color(x1, y+1);\n", "\t\tfont_san.put(x1+20, y, str);\n", "\t\ty+=20;\n", "\n", "\t\tfor( int i=1 ; i<=nation_array.size() ; i++ )\n", "\t\t{\n", "\t\t\tif( nation_array.is_deleted(i) ||\n", "\t\t\t\t i == nationRecno ||\n", "\t\t\t\t i == info.viewing_nation_recno )\n", "\t\t\t{\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\n", "\t\t\tnation_array[i]->disp_nation_color(x1, y+1);\n", "\n", "\t\t\tfont_san.put( x1+20, y, nation_array[i]->nation_name() );\n", "\t\t\tfont_san.put( x1+240, y, nationPtr->get_relation(i)->status_str() );\n", "\n", "\t\t\tif( nationPtr->get_relation(i)->trade_treaty )\n", "\t\t\t{\n", "\t\t\t\tfont_san.put( x1+330, y, \"Trade Treaty\" );\n", "#if(defined(FRENCH))\n", "\t\t\t\tfont_san.put( x1+460, y, misc.format((int)nationPtr->total_year_trade(i),2) );\n", "#else\n", "\t\t\t\t// German and US\n", "\t\t\t\tfont_san.put( x1+450, y, misc.format((int)nationPtr->total_year_trade(i),2) );\n", "#endif\n", "\t\t\t}\n", "\n", "\t\t\tif( config.show_ai_info )\n", "\t\t\t{\n", "\t\t\t\tfont_san.put( x1+500, y, nationPtr->get_relation(i)->ai_relation_level );\n", "\t\t\t\tfont_san.put( x1+530, y, (int) nationPtr->get_relation(i)->good_relation_duration_rating );\n", "\t\t\t}\n", "\n", "\t\t\ty+=16;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "ALenum openal_format(AudioStream *as)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = (*as->_vptr_AudioStream[6])();\n", "  if (iVar1 == 1) {\n", "    iVar1 = (*as->_vptr_AudioStream[5])(as);\n", "    if (iVar1 == 1) {\n", "      return 0x1100;\n", "    }\n", "    if (iVar1 == 2) {\n", "      return 0x1102;\n", "    }\n", "  }\n", "  else {\n", "    if (iVar1 == 2) {\n", "      iVar1 = (*as->_vptr_AudioStream[5])(as);\n", "      if (iVar1 == 1) {\n", "        return 0x1101;\n", "      }\n", "      if (iVar1 == 2) {\n", "        return 0x1103;\n", "      }\n", "    }\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  abort();\n", "}\n", "\n"], "c": ["ALenum openal_format(AudioStream *as)\n", "{\n", "   switch (as->sample_size())\n", "   {\n", "      case 1:\n", "\t switch (as->channels())\n", "\t {\n", "\t    case 1: return AL_FORMAT_MONO8;\n", "\t    case 2: return AL_FORMAT_STEREO8;\n", "\t }\n", "\t break;\n", "\n", "      case 2:\n", "\t switch (as->channels())\n", "\t {\n", "\t    case 1: return AL_FORMAT_MONO16;\n", "\t    case 2: return AL_FORMAT_STEREO16;\n", "\t }\n", "\t break;\n", "   }\n", "\n", "   abort();\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "void i_disp_skill_button(ButtonCustom *button,int repaintBody)\n", "\n", "{\n", "  long lVar1;\n", "  char *bitmapBuf;\n", "  long lVar2;\n", "  int x1;\n", "  int desX;\n", "  int y1;\n", "  int x2;\n", "  ButtonCustom *this;\n", "  short sVar3;\n", "  int y2;\n", "  long in_FS_OFFSET;\n", "  char str [9];\n", "  \n", "  x1 = (int)button->x1;\n", "  y1 = (int)button->y1;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  x2 = (int)button->x2;\n", "  y2 = (int)button->y2;\n", "  if (button->pushed_flag == '\\0') {\n", "    if (repaintBody != 0) {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      d3_panel2_up(&vga_util,x1,y1,x2,y2,1,0);\n", "      this = (ButtonCustom *)(button->custom_para).ptr;\n", "      desX = x1;\n", "LAB_004c861a:\n", "      str._0_8_ = 0x5f55;\n", "      str[8] = '\\0';\n", "      sVar3 = (short)(button->custom_para).value;\n", "      lVar2 = (long)((int)sVar3 + -1);\n", "      __strcpy_chk(str + 2,skill_code_array[lVar2],9);\n", "      bitmapBuf = read((ResourceIdx *)&image_button,str);\n", "      IMGbltTransDecompress\n", "                ((char *)(vga_front.surface)->surface->pixels,\n", "                 (uint)(vga_front.surface)->surface->pitch,desX,y1 + 4,bitmapBuf);\n", "      if (sVar3 == 4) {\n", "        put(&font_bible,desX + 0x32,y1 + 0xb,\"Manufacturing\",'\\0',-1);\n", "      }\n", "      else {\n", "        put(&font_bible,desX + 0x32,y1 + 0xb,skill_str_array[lVar2],'\\0',-1);\n", "      }\n", "      goto LAB_004c8599;\n", "    }\n", "  }\n", "  else {\n", "    if (repaintBody != 0) {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      desX = x1 + 1;\n", "      d3_panel2_down(&vga_util,x1,y1,x2,y2,1,0);\n", "      this = (ButtonCustom *)(button->custom_para).ptr;\n", "      y1 = y1 + 1;\n", "      goto LAB_004c861a;\n", "    }\n", "  }\n", "  this = (ButtonCustom *)(button->custom_para).ptr;\n", "LAB_004c8599:\n", "  paint(this,-1,repaintBody);\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["static void i_disp_skill_button(ButtonCustom *button, int repaintBody)\n", "{\n", "\tint x1 = button->x1;\n", "\tint y1 = button->y1;\n", "\tint x2 = button->x2;\n", "\tint y2 = button->y2;\n", "\tif( !button->pushed_flag )\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_up( x1, y1, x2, y2, 1 );\n", "\t\t}\n", "\t\tx2--;\n", "\t\ty2--;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_down( x1, y1, x2, y2, 1 );\n", "\t\t}\n", "\t\tx1++;\n", "\t\ty1++;\n", "\t}\n", "\n", "\tButtonCustom *queueButton = (ButtonCustom *)button->custom_para.ptr;\n", "\tif( repaintBody)\n", "\t{\n", "\t\t// display skill large icon\n", "\t\tshort skillId = button->custom_para.value;\n", "\t\tchar str[9] = \"U_\";\n", "\t\tstrcat( str, Skill::skill_code_array[skillId-1] );\n", "\t\tchar *bitmapPtr = image_button.get_ptr(str);\n", "\n", "\t\tvga_front.put_bitmap_trans_decompress(x1, y1+4, bitmapPtr);\n", "\n", "\t\t// put name\n", "\n", "\t\tif( skillId == SKILL_MFT )\n", "\t\t\tfont_bible.put(x1+50, y1+11, \"Manufacturing\" );\t\t// the string in skill_str_array[] is \"Manufacture\".\n", "\t\telse\n", "\t\t\tfont_bible.put(x1+50, y1+11, Skill::skill_str_array[skillId-1]);\n", "\t}\n", "\n", "\t// display small button\n", "\tqueueButton->paint(-1, repaintBody);\n", "}"]}, {"ghidra": ["\n", "void decideBarRemap(char *imageBuf,int pitch,int x,int y,char **colorTableArray,uchar cornera,\n", "                   uchar cornerb,uchar cornerc,uchar cornerd)\n", "\n", "{\n", "  char *pcVar1;\n", "  byte *pbVar2;\n", "  byte *pbVar3;\n", "  int iVar4;\n", "  byte *pbVar5;\n", "  byte bVar6;\n", "  \n", "  bVar6 = (byte)((int)(uint)cornera >> 3);\n", "  if ((bVar6 == (byte)((int)(uint)cornerb >> 3) && bVar6 == (byte)((int)(uint)cornerc >> 3)) &&\n", "     ((int)(uint)cornerc >> 3 == (int)(uint)cornerd >> 3)) {\n", "    if (bVar6 != 10) {\n", "      if (bVar6 == 0) {\n", "        IMGbar16x16(imageBuf,pitch,x,y,0);\n", "        return;\n", "      }\n", "      pcVar1 = colorTableArray[(ulong)bVar6 - 10];\n", "      iVar4 = 0x10;\n", "      pbVar5 = (byte *)(imageBuf + (x + y * pitch));\n", "      do {\n", "        pbVar2 = pbVar5;\n", "        do {\n", "          pbVar3 = pbVar2 + 1;\n", "          *pbVar2 = pcVar1[*pbVar2];\n", "          pbVar2 = pbVar3;\n", "        } while (pbVar5 + 0x10 != pbVar3);\n", "        pbVar5 = pbVar5 + pitch;\n", "        iVar4 = iVar4 + -1;\n", "      } while (iVar4 != 0);\n", "    }\n", "    return;\n", "  }\n", "  IMGfogRemap16x16(imageBuf,pitch,x,y,colorTableArray,cornera,cornerb,cornerc,cornerd);\n", "  return;\n", "}\n", "\n"], "c": ["void decideBarRemap(char*imageBuf, int pitch, int x, int y, char**colorTableArray, unsigned char cornera, unsigned char cornerb, unsigned char cornerc, unsigned char cornerd)\n", "{\n", "\tunsigned char cornera_lvl = cornera>>3;\n", "\tunsigned char cornerb_lvl = cornerb>>3;\n", "\tunsigned char cornerc_lvl = cornerc>>3;\n", "\tunsigned char cornerd_lvl = cornerd>>3;\n", "\tif ( (cornera_lvl==cornerb_lvl) && (cornerc_lvl==cornerd_lvl) && (cornera_lvl==cornerc_lvl) )\n", "\t{\n", "\t\t// no interpolation needed\n", "\t\tif (cornera_lvl == MAX_VISIBILITY)\t// MAX visibility\n", "\t\t{\n", "\t\t\t// (don't do anything)\n", "\t\t}\n", "\t\telse if (cornera_lvl == 0)\t\t// invisible, draw black\n", "\t\t{\n", "\t\t\tIMGbar16x16(imageBuf, pitch, x, y, 0);\t\t// black = 0\n", "\t\t}\n", "\t\telse\n", "\t\t{\n", "\t\t\t// visibility < 0 : darker, so subtract MAX_VISIBILITY\n", "\t\t\tIMGbarRemap16x16( imageBuf, pitch, x, y, colorTableArray[cornera_lvl-MAX_VISIBILITY] );\n", "\t\t}\n", "\t}\n", "\telse\n", "\t{\n", "\t\tIMGfogRemap16x16(imageBuf, pitch, x, y, colorTableArray, cornera, cornerb, cornerc, cornerd);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void set_source_panning(ALuint source,int panning)\n", "\n", "{\n", "  if (panning < -10000) {\n", "    panning = -10000;\n", "  }\n", "  if (10000 < panning) {\n", "    panning = 10000;\n", "  }\n", "  alSource3f(SUB168(CONCAT124(SUB1612((undefined  [16])0x0 >> 0x20,0),\n", "                              ((float)panning * 20.00000000) / 10000.00000000),0),0,0xbf800000,\n", "             source,0x1004);\n", "  return;\n", "}\n", "\n"], "c": ["static void set_source_panning(ALuint source, int panning)\n", "{\n", "   panning = MAX(panning, -10000);\n", "   panning = MIN(panning, 10000);\n", "\n", "   alSource3f(source, AL_POSITION,\n", "\t      PANNING_MAX_X * panning / 10000.f, 0, PANNING_Z);\n", "}"]}, {"ghidra": ["\n", "void update_ship_stop_and_goods_info_to_dummy(UnitMarine *shipPtr)\n", "\n", "{\n", "  int iVar1;\n", "  ShipStop *this;\n", "  char *enableFlag;\n", "  char *pcVar2;\n", "  \n", "  pcVar2 = dummyShipGoodsNum;\n", "  this = shipPtr->stop_array;\n", "  enableFlag = dummyShipEnableFlag;\n", "  do {\n", "    if ((this->super_TradeStop).firm_recno != 0) {\n", "      iVar1 = update_pick_up(this,enableFlag);\n", "      *pcVar2 = (char)iVar1;\n", "    }\n", "    enableFlag = enableFlag + 8;\n", "    this = this + 1;\n", "    pcVar2 = pcVar2 + 1;\n", "  } while (enableFlag != ship_goods_num);\n", "  return;\n", "}\n", "\n"], "c": ["static void update_ship_stop_and_goods_info_to_dummy(UnitMarine *shipPtr)\n", "{\n", "\tShipStop *stopPtr = shipPtr->stop_array;\n", "\tfor(int i=0; i<MAX_STOP_FOR_SHIP; i++, stopPtr++)\n", "\t{\n", "\t\tif(!stopPtr->firm_recno)\n", "\t\t\tcontinue;\n", "\n", "\t\terr_when(firm_array.is_deleted(stopPtr->firm_recno));\n", "\t\tdummyShipGoodsNum[i] = stopPtr->update_pick_up(dummyShipEnableFlag[i]);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void put_stop_info(int x,int y,TradeStop *tradeStop)\n", "\n", "{\n", "  short sVar1;\n", "  char *bitmapPtr;\n", "  NationBase *this;\n", "  int x_00;\n", "  int iVar2;\n", "  long lVar3;\n", "  \n", "  sVar1 = tradeStop->firm_recno;\n", "  if (((0 < sVar1) && ((int)sVar1 <= firm_array.super_DynArrayB.super_DynArray.last_ele)) &&\n", "     (*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "               ((int)sVar1 + -1) * firm_array.super_DynArrayB.super_DynArray.ele_size) != 0)) {\n", "    sVar1 = *(short *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                                ((int)sVar1 + -1) *\n", "                                firm_array.super_DynArrayB.super_DynArray.ele_size) + 0x13);\n", "    this = (NationBase *)0x0;\n", "    if ((0 < sVar1) && ((int)sVar1 <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "      this = *(NationBase **)\n", "              (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "              ((int)sVar1 + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    }\n", "    x_00 = x + 0xf;\n", "    disp_nation_color(this,x,y);\n", "    if (tradeStop->pick_up_type == '\\0') {\n", "      bitmapPtr = \"AUTOPICK\";\n", "    }\n", "    else {\n", "      if (tradeStop->pick_up_type != '\\a') {\n", "        lVar3 = 0;\n", "        do {\n", "          if (tradeStop->pick_up_array[lVar3] != '\\0') {\n", "            bitmapPtr = read(&raw_res.res_icon,(int)lVar3 + 10);\n", "            put_bitmap(&vga_back,x_00,y,bitmapPtr);\n", "            iVar2 = x_00 + 0x13;\n", "            x_00 = x_00 + 10;\n", "            if (x + 0x3a <= iVar2) {\n", "              return;\n", "            }\n", "          }\n", "          lVar3 = lVar3 + 1;\n", "        } while (lVar3 != 3);\n", "        lVar3 = 0;\n", "        do {\n", "          if (tradeStop->pick_up_array[lVar3 + 3] != '\\0') {\n", "            bitmapPtr = read(&raw_res.res_icon,(int)lVar3 + 4);\n", "            put_bitmap(&vga_back,x_00,y,bitmapPtr);\n", "            iVar2 = x_00 + 0x15;\n", "            x_00 = x_00 + 0xc;\n", "            if (x + 0x3a <= iVar2) {\n", "              return;\n", "            }\n", "          }\n", "          lVar3 = lVar3 + 1;\n", "        } while (lVar3 != 3);\n", "        return;\n", "      }\n", "      bitmapPtr = \"NOPICK\";\n", "    }\n", "    bitmapPtr = read((ResourceIdx *)&image_icon,bitmapPtr);\n", "    put_bitmap(&vga_back,x_00,y,bitmapPtr);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_stop_info(int x, int y, TradeStop* tradeStop)\n", "{\n", "\tint x2=x+58;\n", "\n", "\t//----- display the color of the stop ----//\n", "\n", "\tif( firm_array.is_deleted(tradeStop->firm_recno) )\n", "\t\treturn;\n", "\n", "\tFirm* firmPtr = firm_array[tradeStop->firm_recno];\n", "\n", "\tnation_array[firmPtr->nation_recno]->disp_nation_color( x, y );\n", "\n", "\tx+=15;\n", "\n", "\t//------ display pick up type icon ------//\n", "\n", "\tint i, pickUpType = tradeStop->pick_up_type;\n", "\n", "\tswitch( pickUpType )\n", "\t{\n", "\t\tcase AUTO_PICK_UP:\n", "\t\t\tvga_back.put_bitmap( x, y, image_icon.get_ptr(\"AUTOPICK\") );\n", "\t\t\tbreak;\n", "\n", "\t\tcase NO_PICK_UP:\n", "\t\t\tvga_back.put_bitmap( x, y, image_icon.get_ptr(\"NOPICK\") );\n", "\t\t\tbreak;\n", "\n", "\t\tdefault:\n", "\t\t\tfor( i=PICK_UP_RAW_FIRST ; i<=PICK_UP_RAW_LAST ; i++ )\n", "\t\t\t{\n", "\t\t\t\tif( tradeStop->pick_up_array[i-1] )\n", "\t\t\t\t{\n", "\t\t\t\t\tvga_back.put_bitmap( x, y, raw_res.small_raw_icon(i-PICK_UP_RAW_FIRST+1) );\n", "\t\t\t\t\tx+=10;\n", "\n", "\t\t\t\t\tif( x+10 > x2 )\n", "\t\t\t\t\t\treturn;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\n", "\t\t\tfor( i=PICK_UP_PRODUCT_FIRST ; i<=PICK_UP_PRODUCT_LAST ; i++ )\n", "\t\t\t{\n", "\t\t\t\tif( tradeStop->pick_up_array[i-1] )\n", "\t\t\t\t{\n", "\t\t\t\t\tvga_back.put_bitmap( x, y, raw_res.small_product_icon(i-PICK_UP_PRODUCT_FIRST+1) );\n", "\t\t\t\t\tx+=12;\n", "\n", "\t\t\t\t\tif( x+10 > x2 )\n", "\t\t\t\t\t\treturn;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void disp_firm_button(ButtonCustom *button,int param_2)\n", "\n", "{\n", "  uint uVar1;\n", "  long lVar2;\n", "  char *bitmapBuf;\n", "  uint uVar3;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  uVar1 = (button->custom_para).value;\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  uVar3 = uVar1 & 0xff;\n", "  String(&str);\n", "  operator__(&str,\"F-\");\n", "  operator__(&str,(long)(int)uVar3);\n", "  if (uVar3 == 1) {\n", "    operator__(&str,\"-\");\n", "    operator__(&str,(ulong)(uVar1 >> 8) & 0xff);\n", "  }\n", "  bitmapBuf = read((ResourceIdx *)&image_button,(char *)&str);\n", "  hide_area((MouseSDL *)&mouse,(int)button->x1,(int)button->y1,(int)button->x2,(int)button->y2);\n", "  IMGbltTransRemapDecompress\n", "            ((char *)(vga_front.surface)->surface->pixels,(uint)(vga_front.surface)->surface->pitch,\n", "             (int)button->x1,(int)button->y1,bitmapBuf,(char *)(button->custom_para).ptr);\n", "  if (button->pushed_flag != '\\0') {\n", "    put_front(&image_button,(int)button->x1,(int)button->y1,\"F-DOWN\",1);\n", "  }\n", "  show_area((MouseSDL *)&mouse);\n", "  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["static void disp_firm_button(ButtonCustom *button, int)\n", "{\n", "\t// button->custom_para.ptr is the color remap table\n", "\t// button->custom_para.value is (unit_id << 16) + (race_id << 8) + firm_id\n", "\tint firmId = button->custom_para.value & 0xff;\n", "\tint raceId = (button->custom_para.value >> 8) & 0xff;\n", "\n", "\t// format is \"F-d-n\", d is firmId, n is build code for FIRM_BASE\n", "\tString str;\n", "\tstr += \"F-\";\n", "\tstr += firmId;\n", "\tif( firmId == FIRM_BASE )\n", "\t{\n", "\t\tstr += \"-\";\n", "\t\tstr += raceId;\n", "\t}\n", "\n", "\tchar *bitmap = image_button.get_ptr(str);\n", "\n", "\tmouse.hide_area(button->x1, button->y1, button->x2, button->y2 );\n", "\n", "\tvga_front.put_bitmap_trans_remap_decompress(button->x1, button->y1,\tbitmap, (char*) button->custom_para.ptr);\n", "\n", "\tif( button->pushed_flag )\n", "\t{\n", "\t\timage_button.put_front(button->x1, button->y1, \"F-DOWN\", 1);\n", "\t}\n", "\n", "\tmouse.show_area();\n", "}"]}, {"ghidra": ["\n", "void put_town_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  short sVar1;\n", "  Town *this;\n", "  int inNum;\n", "  int y_00;\n", "  char *textPtr;\n", "  short *psVar2;\n", "  RaceInfo *pRVar3;\n", "  long lVar4;\n", "  \n", "  inNum = town_filter(recNo);\n", "  if ((0 < inNum) && (inNum <= town_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    y_00 = y + 3;\n", "    this = *(Town **)(town_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (inNum + -1) * town_array.super_DynArrayB.super_DynArray.ele_size);\n", "    textPtr = get_name(&town_res,(int)this->town_name_id);\n", "    put(&font_san,x + 3,y_00,textPtr,'\\0',-1);\n", "    textPtr = format(&misc,(int)this->population,1);\n", "    put(&font_san,x + 0xb2,y_00,textPtr,'\\0',-1);\n", "    textPtr = format(&misc,(int)this->jobless_population,1);\n", "    put(&font_san,x + 0xf4,y_00,textPtr,'\\0',-1);\n", "    inNum = average_loyalty(this);\n", "    textPtr = format(&misc,inNum,1);\n", "    put(&font_san,x + 0x138,y_00,textPtr,'\\0',-1);\n", "    psVar2 = this->race_pop_array;\n", "    x = x + 0x161;\n", "    inNum = 0;\n", "    do {\n", "      sVar1 = *psVar2;\n", "      psVar2 = psVar2 + 1;\n", "      inNum = inNum + (uint)(0 < sVar1);\n", "    } while (psVar2 != (short *)this->race_pop_growth_array);\n", "    y_00 = 0x1a;\n", "    if (7 < inNum) {\n", "      y_00 = 0xb6 / inNum;\n", "    }\n", "    lVar4 = 0;\n", "    do {\n", "      if (0 < this->race_pop_array[lVar4]) {\n", "        pRVar3 = operator__(&race_res,(int)lVar4 + 1);\n", "        put_bitmap(&vga_back,x,y + 1,pRVar3->icon_bitmap_ptr);\n", "        x = x + y_00;\n", "      }\n", "      lVar4 = lVar4 + 1;\n", "    } while (lVar4 != 10);\n", "    return;\n", "  }\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static void put_town_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint   townRecno = town_filter(recNo);\n", "\tTown* townPtr   = town_array[townRecno];\n", "\n", "\t//---------- display info ----------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tfont_san.put( x    , y, townPtr->town_name() );\n", "\tfont_san.put( x+175, y, townPtr->population );\n", "\tfont_san.put( x+241, y, townPtr->jobless_population );\n", "\tfont_san.put( x+309, y, townPtr->average_loyalty() );\n", "\n", "\t//------- display race icons -------//\n", "\n", "\tx += 350;\n", "\n", "\tint i;\n", "\tint iconSpacing = RACE_ICON_WIDTH+2;\n", "#if(MAX_RACE > 7)\n", "\tint raceCount = 0;\n", "\tfor( i=0 ; i<MAX_RACE ; i++ )\n", "\t{\n", "\t\tif( townPtr->race_pop_array[i] > 0 )\n", "\t\t{\n", "\t\t\t++raceCount;\n", "\t\t}\n", "\t}\n", "\tif( raceCount > 7 )\n", "\t{\n", "\t\ticonSpacing = 7 * iconSpacing / raceCount;\n", "\t}\n", "#endif\n", "\tfor( i=0 ; i<MAX_RACE ; i++ )\n", "\t{\n", "\t\tif( townPtr->race_pop_array[i] > 0 )\n", "\t\t{\n", "\t\t\tvga_back.put_bitmap( x, y-2, race_res[i+1]->icon_bitmap_ptr );\n", "\t\t\tx += iconSpacing;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void extra_error_handler(void)\n", "\n", "{\n", "  if (game.game_mode != '\\x02') {\n", "    return;\n", "  }\n", "  save_new_game(&game_file_array,\"ERROR.SAV\");\n", "  msg(&box,\"Error encountered. The game has been saved to ERROR.SAV\",1,-1,-1);\n", "  return;\n", "}\n", "\n"], "c": ["static void extra_error_handler()\n", "{\n", "\tif( game.game_mode != GAME_SINGLE_PLAYER )\n", "\t\treturn;\n", "\n", "\tgame_file_array.save_new_game(\"ERROR.SAV\");  // save a new game immediately without prompting menu\n", "\n", "\tbox.msg( \"Error encountered. The game has been saved to ERROR.SAV\" );\n", "}"]}, {"ghidra": ["\n", "int troop_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  int recNo_00;\n", "  int iVar3;\n", "  \n", "  iVar1 = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "  if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < 1) {\n", "    iVar3 = 0;\n", "  }\n", "  else {\n", "    iVar3 = 0;\n", "    recNo_00 = 1;\n", "    do {\n", "      iVar2 = is_deleted(&unit_array,recNo_00);\n", "      if (iVar2 == 0) {\n", "        if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo_00) {\n", "          do {\n", "            invalidInstructionException();\n", "          } while( true );\n", "        }\n", "        if ((short)*(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                       body_buf +\n", "                                      (recNo_00 + -1) *\n", "                                      unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                      ele_size) + 0x2d) == info.viewing_nation_recno) {\n", "          iVar3 = iVar3 + (uint)((byte)(*(char *)(*(long *)(unit_array.super_SpriteArray.\n", "                                                            super_DynArrayB.super_DynArray.body_buf\n", "                                                           + (recNo_00 + -1) *\n", "                                                             unit_array.super_SpriteArray.\n", "                                                             super_DynArrayB.super_DynArray.ele_size\n", "                                                           ) + 0x2b) - 1U) < 2);\n", "        }\n", "        if ((iVar3 == recNo) && (recNo != 0)) {\n", "          return recNo_00;\n", "        }\n", "      }\n", "      recNo_00 = recNo_00 + 1;\n", "    } while (recNo_00 <= iVar1);\n", "  }\n", "  return iVar3;\n", "}\n", "\n"], "c": ["static int troop_filter(int recNo)\n", "{\n", "\tint   i, unitCount=0, totalUnit=unit_array.size();\n", "\tUnit* unitPtr;\n", "\n", "\tfor( i=1 ; i<=totalUnit ; i++ )\n", "\t{\n", "\t\tif( unit_array.is_deleted(i) )\n", "\t\t\tcontinue;\n", "\n", "\t\tunitPtr = unit_array[i];\n", "\n", "\t\tif( unitPtr->nation_recno == info.viewing_nation_recno &&\n", "\t\t\t (unitPtr->rank_id==RANK_GENERAL || unitPtr->rank_id==RANK_KING) )\n", "\t\t{\n", "\t\t\tunitCount++;\n", "\t\t}\n", "\n", "\t\tif( recNo && unitCount==recNo )\n", "\t\t\treturn i;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn unitCount;\n", "}"]}, {"ghidra": ["\n", "void i_disp_marine_select_button(ButtonCustom *button,int repaintBody)\n", "\n", "{\n", "  int rawId;\n", "  char cVar1;\n", "  int y1;\n", "  char *helpCode;\n", "  int x1;\n", "  \n", "  cVar1 = color_down;\n", "  x1 = (int)button->x1;\n", "  y1 = (int)button->y1;\n", "  if (button->pushed_flag == '\\0') {\n", "    d3_panel_up(active_buf,x1,y1,(int)button->x2,(int)button->y2,2,1);\n", "    rawId = (button->custom_para).value;\n", "  }\n", "  else {\n", "    color_down = -0x4c;\n", "    d3_panel_down(active_buf,x1,y1,(int)button->x2,(int)button->y2,2,1);\n", "    rawId = (button->custom_para).value;\n", "    color_down = cVar1;\n", "  }\n", "  if (rawId == 0) {\n", "    helpCode = \"AUTOPICK\";\n", "  }\n", "  else {\n", "    if (rawId != 7) {\n", "      if (rawId - 1U < 3) {\n", "        put_small_raw_icon(&raw_res,x1 + 3,y1 + 3,rawId);\n", "        return;\n", "      }\n", "      if (rawId - 4U < 3) {\n", "        put_small_product_icon(&raw_res,x1 + 3,y1 + 3,rawId + -3);\n", "        return;\n", "      }\n", "      return;\n", "    }\n", "    helpCode = \"NOPICK\";\n", "  }\n", "  set_help(&help,x1 + 3,y1 + 3,x1 + 0xc,y1 + 0xc,helpCode);\n", "  helpCode = read((ResourceIdx *)&image_icon,helpCode);\n", "  put_bitmap_trans(active_buf,x1 + 3,y1 + 3,helpCode);\n", "  return;\n", "}\n", "\n"], "c": ["static void i_disp_marine_select_button(ButtonCustom *button, int repaintBody)\n", "{\n", "\tint x1 = button->x1;\n", "\tint y1 = button->y1;\n", "\tint x2 = button->x2;\n", "\tint y2 = button->y2;\n", "\tint shift;\n", "\n", "\t//------------- modify x1,y1, x2,y2 to the button body ---------------//\n", "\tif(button->pushed_flag)\n", "\t{\n", "\t\tint colorDown = Vga::active_buf->color_down;\t\t// change the color of the body area to yellow to highlight the change\n", "\t\tVga::active_buf->color_down = (char) V_YELLOW;\n", "\n", "\t\tVga::active_buf->d3_panel_down(x1, y1, x2, y2);\n", "\n", "\t\tVga::active_buf->color_down = (char) colorDown;\n", "\n", "\t\tx1++;\n", "\t\ty1++;\n", "\t\tshift = 2;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tVga::active_buf->d3_panel_up(x1, y1, x2, y2);\n", "\t\tx2--;\n", "\t\ty2--;\n", "\t\tshift = 3;\n", "\t}\n", "\n", "\t//-------------- put goods icon ---------------//\n", "\n", "\tint id = button->custom_para.value;\n", "\tconst char *iconName=NULL;\n", "\n", "\tint x = x1+shift;\n", "\tint y = y1+shift;\n", "\n", "\tif(id==AUTO_PICK_UP)\n", "\t{\n", "\t\ticonName = \"AUTOPICK\";\n", "\t}\n", "\telse if(id==NO_PICK_UP)\n", "\t{\n", "\t\ticonName = \"NOPICK\";\n", "\t}\n", "\telse if(id>=PICK_UP_RAW_FIRST && id<=PICK_UP_RAW_LAST)\n", "\t{\n", "\t\traw_res.put_small_raw_icon( x, y, id-PICK_UP_RAW_FIRST+1 );\n", "\t}\n", "\telse if(id>=PICK_UP_PRODUCT_FIRST && id<=PICK_UP_PRODUCT_LAST)\n", "\t{\n", "\t\traw_res.put_small_product_icon( x, y, id-PICK_UP_PRODUCT_FIRST+1 );\n", "\t}\n", "\telse\n", "\t\terr_here();\n", "\n", "\tif( iconName )\n", "\t{\n", "\t\thelp.set_help( x, y, x+9, y+9, iconName );\n", "\t\tVga::active_buf->put_bitmap_trans( x, y, image_icon.get_ptr(iconName) );\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void i_disp_build_button(ButtonCustom *button,int repaintBody)\n", "\n", "{\n", "  UnitInfo *this;\n", "  char cVar1;\n", "  long lVar2;\n", "  char *bitmapPtr;\n", "  int x1;\n", "  int iVar3;\n", "  int y1;\n", "  int x2;\n", "  ButtonCustom *this_00;\n", "  int y2;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  x1 = (int)button->x1;\n", "  y1 = (int)button->y1;\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  x2 = (int)button->x2;\n", "  y2 = (int)button->y2;\n", "  if (button->pushed_flag == '\\0') {\n", "    if (repaintBody != 0) {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      d3_panel2_up(&vga_util,x1,y1,x2,y2,1,0);\n", "      this_00 = (ButtonCustom *)(button->custom_para).ptr;\n", "      iVar3 = x1;\n", "LAB_0044377a:\n", "      this = unit_res.unit_info_array + (long)*(short *)&(button->custom_para).value + -1;\n", "      bitmapPtr = get_large_icon_ptr(this,'\\0');\n", "      put_bitmap(&vga_front,iVar3 + 6,y1 + 4,bitmapPtr);\n", "      String(&str);\n", "      operator_(&str,(char *)this);\n", "      if ((this->unit_class == 'W') &&\n", "         (cVar1 = this->nation_tech_level_array\n", "                  [(int)*(short *)((long)(this_00->custom_para).ptr + 0x13) + -1], 1 < (int)cVar1))\n", "      {\n", "        operator__(&str,\" \");\n", "        bitmapPtr = roman_number(&misc,(int)cVar1);\n", "        operator__(&str,bitmapPtr);\n", "      }\n", "      put(&font_bible,iVar3 + 0x3c,y1 + 0xc,(char *)&str,'\\0',-1);\n", "      goto LAB_004436ef;\n", "    }\n", "  }\n", "  else {\n", "    if (repaintBody != 0) {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      iVar3 = x1 + 1;\n", "      d3_panel2_down(&vga_util,x1,y1,x2,y2,1,0);\n", "      this_00 = (ButtonCustom *)(button->custom_para).ptr;\n", "      y1 = y1 + 1;\n", "      goto LAB_0044377a;\n", "    }\n", "  }\n", "  this_00 = (ButtonCustom *)(button->custom_para).ptr;\n", "LAB_004436ef:\n", "  paint(this_00,-1,repaintBody);\n", "  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["static void i_disp_build_button(ButtonCustom *button, int repaintBody)\n", "{\n", "\tint x1 = button->x1;\n", "\tint y1 = button->y1;\n", "\tint x2 = button->x2;\n", "\tint y2 = button->y2;\n", "\tif( !button->pushed_flag )\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_up( x1, y1, x2, y2, 1 );\n", "\t\t}\n", "\t\tx2--;\n", "\t\ty2--;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_down( x1, y1, x2, y2, 1 );\n", "\t\t}\n", "\t\tx1++;\n", "\t\ty1++;\n", "\t}\n", "\n", "\tButtonCustom *queueButton = (ButtonCustom *)button->custom_para.ptr;\n", "\tif( repaintBody)\n", "\t{\n", "\t\t// display unit large icon\n", "\t\tshort unitId = button->custom_para.value;\n", "\t\tUnitInfo* unitInfo = unit_res[unitId];\n", "\t\tvga_front.put_bitmap(x1+6, y1+4, unitInfo->get_large_icon_ptr(0));\n", "\n", "\t\terr_when( button->custom_para.value != queueButton->custom_para.value);\n", "\n", "\t\t//-------- display unit name --------//\n", "\n", "\t\tString str;\n", "\t\tstr = unitInfo->name;\n", "\n", "\t\tif( unitInfo->unit_class == UNIT_CLASS_WEAPON )\t\t// add version no.\n", "\t\t{\n", "\t\t\tFirmHarbor *harbor = (FirmHarbor *)queueButton->custom_para.ptr;\n", "\t\t\tint techLevel = unitInfo->get_nation_tech_level(harbor->nation_recno);\n", "\n", "\t\t\tif( techLevel > 1 )\n", "\t\t\t{\n", "\t\t\t\tstr += \" \";\n", "\t\t\t\tstr += misc.roman_number(techLevel);\n", "\t\t\t}\n", "\t\t}\n", "\t\t\n", "\t\tfont_bible.put( x1+60, y1+13, str );\n", "\t}\n", "\n", "\t// display small button\n", "\tqueueButton->paint(-1, repaintBody);\n", "}"]}, {"ghidra": ["\n", "void put_god_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  long lVar1;\n", "  long lVar2;\n", "  int iVar3;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar3 = god_filter(recNo);\n", "  if ((0 < iVar3) && (iVar3 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)\n", "     ) {\n", "    lVar2 = *(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                     (iVar3 + -1) *\n", "                     unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "    put(&font_san,x + 3,y + 5,\n", "        (char *)(unit_res.unit_info_array + (long)*(char *)(lVar2 + 0x2a) + -1),'\\0',-1);\n", "    String(&str);\n", "    operator_(&str,(long)(int)*(float *)(lVar2 + 0x60));\n", "    operator__(&str,\"/\");\n", "    operator__(&str,(long)*(short *)(lVar2 + 100));\n", "    put(&font_san,x + 0x12f,y + 5,(char *)&str,'\\0',-1);\n", "    if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "      __stack_chk_fail();\n", "    }\n", "    return;\n", "  }\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static void put_god_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tUnitGod* unitGod = (UnitGod*) unit_array[ god_filter(recNo) ];\n", "\n", "\terr_when( unit_res[unitGod->unit_id]->unit_class != UNIT_CLASS_GOD );\n", "\n", "\t//----------- display info ----------//\n", "\n", "\tx+=3;\n", "\ty+=5;\n", "\n", "\tfont_san.put( x, y, unit_res[unitGod->unit_id]->name );\n", "\n", "\t//--------- display hit points -----------//\n", "\n", "\tString str;\n", "\n", "\tstr  = (int) unitGod->hit_points;\n", "\tstr += \"/\";\n", "\tstr += unitGod->max_hit_points;\n", "\n", "\tfont_san.put( x+300, y, str );\n", "}"]}, {"ghidra": ["\n", "bool __thiscall seek(MemInputStream *this,long offset,int whence)\n", "\n", "{\n", "  if (whence == 1) {\n", "    offset = offset + this->pos;\n", "  }\n", "  else {\n", "    if (whence == 2) {\n", "      offset = offset + this->length;\n", "    }\n", "    else {\n", "      if (whence != 0) {\n", "        return false;\n", "      }\n", "    }\n", "  }\n", "  if ((-1 < offset) && ((ulong)offset < this->length)) {\n", "    this->pos = offset;\n", "    return true;\n", "  }\n", "  return false;\n", "}\n", "\n"], "c": ["bool seek(File *file, long off, int whence)\n", "{\n", "   long target;\n", "   long pos;\n", "\n", "   switch (whence)\n", "   {\n", "      case SEEK_SET: target = off; break;\n", "      case SEEK_CUR: target = file->file_pos() + off; break;\n", "      case SEEK_END: target = file->file_size() + off; break;\n", "      default: abort();\n", "   }\n", "\n", "   pos = file->file_seek(off, whence);\n", "   return (pos == target);\n", "}"]}, {"ghidra": ["\n", "int sort_soldier_function(void *a,void *b)\n", "\n", "{\n", "  return (int)*(char *)((long)b + 7) - (int)*(char *)((long)a + 7);\n", "}\n", "\n"], "c": ["static int sort_soldier_function( const void *a, const void *b )\n", "{\n", "\treturn ((Worker*)b)->skill_level - ((Worker*)a)->skill_level;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Type propagation algorithm not settling */\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "int select_option(void)\n", "\n", "{\n", "  short sVar1;\n", "  bool bVar2;\n", "  uint buttonId;\n", "  ButtonCustom *this;\n", "  char *desStr;\n", "  long lVar3;\n", "  uint uVar4;\n", "  int iVar5;\n", "  int buttonId_00;\n", "  ulong uVar6;\n", "  Config *pCVar7;\n", "  undefined8 *puVar8;\n", "  Config *pCVar9;\n", "  undefined8 *puVar10;\n", "  int iVar11;\n", "  char cVar12;\n", "  ulong unaff_R14;\n", "  long in_FS_OFFSET;\n", "  byte bVar13;\n", "  ulong local_770;\n", "  ulong local_760;\n", "  ulong local_750;\n", "  ulong local_740;\n", "  ulong local_730;\n", "  ulong local_720;\n", "  ulong local_710;\n", "  ulong local_700;\n", "  ulong local_6f0;\n", "  ulong local_6e0;\n", "  ulong local_6d0;\n", "  long local_6c0;\n", "  ButtonCustomGroup raceGroup;\n", "  ButtonCustomGroup colorGroup;\n", "  ButtonCustomGroup diffGroup;\n", "  ButtonCustomGroup terrainGroup;\n", "  ButtonCustomGroup landGroup;\n", "  ButtonCustomGroup exploreGroup;\n", "  ButtonCustomGroup fogGroup;\n", "  ButtonCustomGroup treasureGroup;\n", "  ButtonCustomGroup aiTreasureGroup;\n", "  ButtonCustomGroup aiAggressiveGroup;\n", "  ButtonCustomGroup monsterGroup;\n", "  ButtonCustomGroup randomStartUpGroup;\n", "  ButtonCustomGroup nearRawGroup;\n", "  ButtonCustomGroup townStartGroup;\n", "  ButtonCustomGroup townResistGroup;\n", "  ButtonCustomGroup townEmergeGroup;\n", "  ButtonCustomGroup nationEmergeGroup;\n", "  ButtonCustomGroup randomEventGroup;\n", "  ButtonCustom aiNationInc;\n", "  ButtonCustom aiNationDec;\n", "  ButtonCustom rawSiteInc;\n", "  ButtonCustom rawSiteDec;\n", "  ButtonCustom clearEnemyButton;\n", "  ButtonCustom clearMonsterButton;\n", "  ButtonCustom enoughPeopleButton;\n", "  ButtonCustom enoughIncomeButton;\n", "  ButtonCustom enoughScoreButton;\n", "  ButtonCustom timeLimitButton;\n", "  ButtonCustom peopleInc;\n", "  ButtonCustom peopleDec;\n", "  ButtonCustom incomeInc;\n", "  ButtonCustom incomeDec;\n", "  ButtonCustom scoreInc;\n", "  ButtonCustom scoreDec;\n", "  ButtonCustom yearInc;\n", "  ButtonCustom yearDec;\n", "  GetA playerNameField;\n", "  GetA mapIdField;\n", "  Button3D startButton;\n", "  Button3D returnButton;\n", "  Config tempConfig;\n", "  char menuTitleBitmap [9];\n", "  char mapIdStr [12];\n", "  long local_40;\n", "  short startTownArray [3];\n", "  \n", "  bVar13 = 0;\n", "  lVar3 = 0x14;\n", "  menuTitleBitmap[8] = '\\0';\n", "  pCVar7 = &config;\n", "  pCVar9 = &tempConfig;\n", "  while (cVar12 = tempConfig.ai_nation_count, lVar3 != 0) {\n", "    lVar3 = lVar3 + -1;\n", "    *(undefined8 *)pCVar9 = *(undefined8 *)pCVar7;\n", "    pCVar7 = (Config *)&pCVar7->start_up_independent_town;\n", "    pCVar9 = (Config *)&pCVar9->start_up_independent_town;\n", "  }\n", "  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n", "  menuTitleBitmap._0_8_ = 0x4750534e2d504f54;\n", "  *(undefined4 *)pCVar9 = *(undefined4 *)pCVar7;\n", "  if (cVar12 < '\\x01') {\n", "    tempConfig.ai_nation_count = '\\x06';\n", "  }\n", "  if (tempConfig.difficulty_level != '\\x05') {\n", "    change_difficulty(&tempConfig,(int)tempConfig.difficulty_level);\n", "  }\n", "  ButtonCustomGroup(&raceGroup,10);\n", "  local_6c0 = 0;\n", "  do {\n", "    cVar12 = \"\\x06\\b\\x03\\a\\x02\\t\\x01\\x05\\x04\\n\"[local_6c0];\n", "    buttonId_00 = (int)local_6c0;\n", "    unaff_R14 = unaff_R14 & 0xffffffff00000000 | (ulong)(uint)(int)cVar12;\n", "    iVar11 = (buttonId_00 / 5 + 1) * 0x20;\n", "    iVar5 = (buttonId_00 % 5 + 1) * 0x4e;\n", "                    /* try { // try from 0045740c to 00457466 has its CatchHandler @ 00459b3e */\n", "    this = operator__(&raceGroup,buttonId_00);\n", "    create(this,iVar5 + 0x90,iVar11 + 0xad,iVar5 + 0xdd,iVar11 + 0xcc,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(unaff_R14 >> 8),CONCAT18(cVar12,&raceGroup)),'\\0','\\0')\n", "    ;\n", "    local_6c0 = local_6c0 + 1;\n", "  } while (local_6c0 != 10);\n", "  ButtonCustomGroup(&colorGroup,7);\n", "  buttonId_00 = 0xc3;\n", "  buttonId = 0;\n", "  do {\n", "    uVar4 = buttonId + 1;\n", "    local_6d0 = local_6d0 & 0xffffffff00000000 | (ulong)uVar4;\n", "                    /* try { // try from 004574a8 to 00457599 has its CatchHandler @ 004597b8 */\n", "    this = operator__(&colorGroup,buttonId);\n", "    create(this,buttonId_00,0x11f,buttonId_00 + 0x22,0x13e,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_6d0 >> 8),CONCAT18((char)uVar4,&colorGroup)),'\\0'\n", "           ,'\\0');\n", "    buttonId_00 = buttonId_00 + 0x23;\n", "    buttonId = uVar4;\n", "  } while (uVar4 != 7);\n", "  ButtonCustom(&aiNationInc);\n", "  ButtonCustom(&aiNationDec);\n", "  create(&aiNationInc,0x253,0x11f,0x275,0x13e,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(1) << 0x40),'\\x01','\\0');\n", "  create(&aiNationDec,0x276,0x11f,0x298,0x13e,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0xffffffff) << 0x40),'\\x01','\\0');\n", "  ButtonCustomGroup(&diffGroup,6);\n", "  buttonId_00 = 0xcd;\n", "  uVar6 = 0;\n", "  do {\n", "    local_6e0 = local_6e0 & 0xffffffff00000000 | uVar6;\n", "    buttonId = (int)uVar6 + 1;\n", "                    /* try { // try from 004575e5 to 00457636 has its CatchHandler @ 004597c0 */\n", "    this = operator__(&diffGroup,(int)uVar6);\n", "    create(this,buttonId_00,0x14f,buttonId_00 + 0x4d,0x16e,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_6e0 >> 8),CONCAT18((char)uVar6,&diffGroup)),'\\0',\n", "           '\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    uVar6 = (ulong)buttonId;\n", "  } while (buttonId != 6);\n", "  ButtonCustomGroup(&terrainGroup,3);\n", "  buttonId_00 = 0xa8;\n", "  buttonId = 0;\n", "  do {\n", "    uVar4 = buttonId + 1;\n", "    local_770 = local_770 & 0xffffffff00000000 | (ulong)uVar4;\n", "                    /* try { // try from 00457677 to 004576c5 has its CatchHandler @ 0045971c */\n", "    this = operator__(&terrainGroup,buttonId);\n", "    create(this,buttonId_00,399,buttonId_00 + 0x4d,0x1ae,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_770 >> 8),CONCAT18((char)uVar4,&terrainGroup)),\n", "           '\\0','\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    buttonId = uVar4;\n", "  } while (uVar4 != 3);\n", "  ButtonCustomGroup(&landGroup,3);\n", "  buttonId_00 = 0x1b7;\n", "  buttonId = 0;\n", "  do {\n", "    uVar4 = buttonId + 1;\n", "    local_760 = local_760 & 0xffffffff00000000 | (ulong)uVar4;\n", "                    /* try { // try from 00457706 to 0045780d has its CatchHandler @ 004597b3 */\n", "    this = operator__(&landGroup,buttonId);\n", "    create(this,buttonId_00,399,buttonId_00 + 0x4d,0x1ae,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_760 >> 8),CONCAT18((char)uVar4,&landGroup)),'\\0',\n", "           '\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    buttonId = uVar4;\n", "  } while (uVar4 != 3);\n", "  GetA(&playerNameField);\n", "  init(&playerNameField,0x13e,0x1be,0x2b2,tempConfig.player_name,0x14,&font_bard,'\\0','\\x01');\n", "  init_random_seed(&info,0);\n", "  __sprintf_chk(mapIdStr,1,0xc,&DAT_00533598,(long)info.random_seed);\n", "  GetA(&mapIdField);\n", "  init(&mapIdField,0x234,0xec,700,mapIdStr,0xb,&font_san,'\\0','\\x01');\n", "  ButtonCustomGroup(&exploreGroup,2);\n", "                    /* try { // try from 00457834 to 004578c7 has its CatchHandler @ 00459793 */\n", "  this = operator__(&exploreGroup,0);\n", "  create(this,0x14f,0xe3,0x19c,0x102,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT916(CONCAT18(1,&exploreGroup)),'\\0','\\0');\n", "  this = operator__(&exploreGroup,1);\n", "  create(this,0x19d,0xe3,0x1ea,0x102,disp_virtual_button,(ButtonCustomPara)ZEXT816(&exploreGroup),\n", "         '\\0','\\0');\n", "  ButtonCustomGroup(&fogGroup,2);\n", "                    /* try { // try from 004578ee to 00457981 has its CatchHandler @ 00459af7 */\n", "  this = operator__(&fogGroup,0);\n", "  create(this,0x14f,0x103,0x19c,0x122,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT916(CONCAT18(1,&fogGroup)),'\\0','\\0');\n", "  this = operator__(&fogGroup,1);\n", "  create(this,0x19d,0x103,0x1ea,0x122,disp_virtual_button,(ButtonCustomPara)ZEXT816(&fogGroup),'\\0',\n", "         '\\0');\n", "  ButtonCustomGroup(&treasureGroup,4);\n", "  buttonId_00 = 0x14f;\n", "  buttonId = 0;\n", "  do {\n", "    uVar4 = buttonId + 1;\n", "    local_720 = local_720 & 0xffffffff00000000 | (ulong)uVar4;\n", "                    /* try { // try from 004579c2 to 00457a10 has its CatchHandler @ 00459b39 */\n", "    this = operator__(&treasureGroup,buttonId);\n", "    create(this,buttonId_00,0x123,buttonId_00 + 0x4d,0x142,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_720 >> 8),CONCAT18((char)uVar4,&treasureGroup)),\n", "           '\\0','\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    buttonId = uVar4;\n", "  } while (uVar4 != 4);\n", "  ButtonCustomGroup(&aiTreasureGroup,4);\n", "  buttonId_00 = 0x14f;\n", "  buttonId = 0;\n", "  do {\n", "    uVar4 = buttonId + 1;\n", "    local_710 = local_710 & 0xffffffff00000000 | (ulong)uVar4;\n", "                    /* try { // try from 00457a51 to 00457a9f has its CatchHandler @ 00459b34 */\n", "    this = operator__(&aiTreasureGroup,buttonId);\n", "    create(this,buttonId_00,0x143,buttonId_00 + 0x4d,0x162,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_710 >> 8),CONCAT18((char)uVar4,&aiTreasureGroup))\n", "           ,'\\0','\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    buttonId = uVar4;\n", "  } while (uVar4 != 4);\n", "  ButtonCustomGroup(&aiAggressiveGroup,4);\n", "  buttonId_00 = 0x14f;\n", "  buttonId = 0;\n", "  do {\n", "    uVar4 = buttonId + 1;\n", "    local_700 = local_700 & 0xffffffff00000000 | (ulong)uVar4;\n", "                    /* try { // try from 00457ae0 to 00457b31 has its CatchHandler @ 00459b0b */\n", "    this = operator__(&aiAggressiveGroup,buttonId);\n", "    create(this,buttonId_00,0x163,buttonId_00 + 0x4d,0x182,disp_virtual_button,\n", "           (ButtonCustomPara)\n", "           CONCAT79((int7)(local_700 >> 8),CONCAT18((char)uVar4,&aiAggressiveGroup)),'\\0','\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    buttonId = uVar4;\n", "  } while (uVar4 != 4);\n", "  ButtonCustomGroup(&monsterGroup,3);\n", "  buttonId_00 = 0x14f;\n", "  uVar6 = 0;\n", "  do {\n", "    local_750 = local_750 & 0xffffffff00000000 | uVar6;\n", "    buttonId = (int)uVar6 + 1;\n", "                    /* try { // try from 00457b78 to 00457bc9 has its CatchHandler @ 00459bc8 */\n", "    this = operator__(&monsterGroup,(int)uVar6);\n", "    create(this,buttonId_00,0x183,buttonId_00 + 0x4d,0x1a2,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_750 >> 8),CONCAT18((char)uVar6,&monsterGroup)),\n", "           '\\0','\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    uVar6 = (ulong)buttonId;\n", "  } while (buttonId != 3);\n", "  ButtonCustomGroup(&randomStartUpGroup,2);\n", "                    /* try { // try from 00457bf0 to 00457d25 has its CatchHandler @ 00459bc3 */\n", "  this = operator__(&randomStartUpGroup,0);\n", "  create(this,0x14f,0x1a3,0x19c,0x1c2,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT916(CONCAT18(1,&randomStartUpGroup)),'\\0','\\0');\n", "  this = operator__(&randomStartUpGroup,1);\n", "  create(this,0x19d,0x1a3,0x1ea,0x1c2,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT816(&randomStartUpGroup),'\\0','\\0');\n", "  ButtonCustom(&rawSiteInc);\n", "  ButtonCustom(&rawSiteDec);\n", "  create(&rawSiteInc,0x170,0xe0,0x192,0xff,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  create(&rawSiteDec,0x193,0xe0,0x1b5,0xff,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  ButtonCustomGroup(&nearRawGroup,2);\n", "                    /* try { // try from 00457d4c to 00457ddf has its CatchHandler @ 00459bbe */\n", "  this = operator__(&nearRawGroup,0);\n", "  create(this,0x14c,0x100,0x199,0x11f,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT916(CONCAT18(1,&nearRawGroup)),'\\0','\\0');\n", "  this = operator__(&nearRawGroup,1);\n", "  create(this,0x19a,0x100,0x1e7,0x11f,disp_virtual_button,(ButtonCustomPara)ZEXT816(&nearRawGroup),\n", "         '\\0','\\0');\n", "  ButtonCustomGroup(&townStartGroup,3);\n", "  buttonId_00 = 0x14c;\n", "  lVar3 = 0;\n", "  do {\n", "    sVar1 = startTownArray[lVar3];\n", "    local_740 = local_740 & 0xffffffff00000000 | (ulong)(uint)(int)sVar1;\n", "                    /* try { // try from 00457e2b to 00457e8b has its CatchHandler @ 00459bb9 */\n", "    this = operator__(&townStartGroup,(int)lVar3);\n", "    create(this,buttonId_00,0x120,buttonId_00 + 0x4d,0x13f,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_740 >> 8),CONCAT18((char)sVar1,&townStartGroup)),\n", "           '\\0','\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    lVar3 = lVar3 + 1;\n", "  } while (buttonId_00 != 0x236);\n", "  ButtonCustomGroup(&townResistGroup,3);\n", "  buttonId_00 = 0x14c;\n", "  buttonId = 0;\n", "  do {\n", "    uVar4 = buttonId + 1;\n", "    local_730 = local_730 & 0xffffffff00000000 | (ulong)uVar4;\n", "                    /* try { // try from 00457ecb to 00457f1c has its CatchHandler @ 00459c49 */\n", "    this = operator__(&townResistGroup,buttonId);\n", "    create(this,buttonId_00,0x140,buttonId_00 + 0x4d,0x15f,disp_virtual_button,\n", "           (ButtonCustomPara)CONCAT79((int7)(local_730 >> 8),CONCAT18((char)uVar4,&townResistGroup))\n", "           ,'\\0','\\0');\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "    buttonId = uVar4;\n", "  } while (uVar4 != 3);\n", "  ButtonCustomGroup(&townEmergeGroup,2);\n", "                    /* try { // try from 00457f43 to 00457fd6 has its CatchHandler @ 00459baf */\n", "  this = operator__(&townEmergeGroup,0);\n", "  create(this,0x14c,0x160,0x199,0x17f,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT916(CONCAT18(1,&townEmergeGroup)),'\\0','\\0');\n", "  this = operator__(&townEmergeGroup,1);\n", "  create(this,0x19a,0x160,0x1e7,0x17f,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT816(&townEmergeGroup),'\\0','\\0');\n", "  ButtonCustomGroup(&nationEmergeGroup,2);\n", "                    /* try { // try from 00457ffd to 00458093 has its CatchHandler @ 00459baa */\n", "  this = operator__(&nationEmergeGroup,0);\n", "  create(this,0x14c,0x180,0x199,0x19f,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT916(CONCAT18(1,&nationEmergeGroup)),'\\0','\\0');\n", "  this = operator__(&nationEmergeGroup,1);\n", "  create(this,0x19a,0x180,0x1e7,0x19f,disp_virtual_button,\n", "         (ButtonCustomPara)ZEXT816(&nationEmergeGroup),'\\0','\\0');\n", "  ButtonCustomGroup(&randomEventGroup,4);\n", "  buttonId_00 = 0x14c;\n", "  uVar6 = 0;\n", "  do {\n", "    local_6f0 = local_6f0 & 0xffffffff00000000 | uVar6;\n", "    buttonId = (int)uVar6 + 1;\n", "                    /* try { // try from 004580d2 to 00459115 has its CatchHandler @ 00459b46 */\n", "    this = operator__(&randomEventGroup,(int)uVar6);\n", "    create(this,buttonId_00,0x1a0,buttonId_00 + 0x4d,0x1bf,disp_virtual_button,\n", "           (ButtonCustomPara)\n", "           CONCAT79((int7)(local_6f0 >> 8),CONCAT18((char)uVar6,&randomEventGroup)),'\\0','\\0');\n", "    uVar6 = (ulong)buttonId;\n", "    buttonId_00 = buttonId_00 + 0x4e;\n", "  } while (buttonId != 4);\n", "  ButtonCustom(&clearEnemyButton);\n", "  ButtonCustom(&clearMonsterButton);\n", "  ButtonCustom(&enoughPeopleButton);\n", "  ButtonCustom(&enoughIncomeButton);\n", "  ButtonCustom(&enoughScoreButton);\n", "  ButtonCustom(&timeLimitButton);\n", "  ButtonCustom(&peopleInc);\n", "  ButtonCustom(&peopleDec);\n", "  ButtonCustom(&incomeInc);\n", "  ButtonCustom(&incomeDec);\n", "  ButtonCustom(&scoreInc);\n", "  ButtonCustom(&scoreDec);\n", "  ButtonCustom(&yearInc);\n", "  ButtonCustom(&yearDec);\n", "  create(&clearEnemyButton,0xd6,0x10d,0xe9,0x120,disp_virtual_tick,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\0','\\x01');\n", "  clearEnemyButton.enable_flag = '\\0';\n", "  create(&clearMonsterButton,0xd6,0x12e,0xe9,0x141,disp_virtual_tick,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\0',tempConfig.goal_destroy_monster);\n", "  create(&enoughPeopleButton,0xd6,0x14f,0xe9,0x162,disp_virtual_tick,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\0',tempConfig.goal_population_flag);\n", "  create(&enoughIncomeButton,0xd6,0x170,0xe9,0x183,disp_virtual_tick,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\0',tempConfig.goal_economic_score_flag);\n", "  create(&enoughScoreButton,0xd6,0x191,0xe9,0x1a4,disp_virtual_tick,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\0',tempConfig.goal_total_score_flag);\n", "  create(&timeLimitButton,0xd6,0x1b1,0xe9,0x1c4,disp_virtual_tick,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\0',tempConfig.goal_year_limit_flag);\n", "  create(&peopleInc,0x211,0x14a,0x233,0x169,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  create(&peopleDec,0x234,0x14a,0x256,0x169,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  create(&incomeInc,0x211,0x16a,0x233,0x189,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  create(&incomeDec,0x234,0x16a,0x256,0x189,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  create(&scoreInc,0x211,0x18a,0x233,0x1a9,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  create(&scoreDec,0x234,0x18a,0x256,0x1a9,disp_virtual_button,\n", "         (ButtonCustomPara)(ZEXT816(0) << 0x40),'\\x01','\\0');\n", "  create(&yearInc,0x211,0x1aa,0x233,0x1c9,disp_virtual_button,(ButtonCustomPara)(ZEXT816(0) << 0x40)\n", "         ,'\\x01','\\0');\n", "  create(&yearDec,0x234,0x1aa,0x256,0x1c9,disp_virtual_button,(ButtonCustomPara)(ZEXT816(0) << 0x40)\n", "         ,'\\x01','\\0');\n", "  Button3D(&startButton);\n", "  Button3D(&returnButton);\n", "  create(&startButton,0xc2,0x21a,\"START-U\",\"START-D\",'\\x01','\\0');\n", "  create(&returnButton,0x1b8,0x21a,\"CANCEL-U\",\"CANCEL-D\",'\\x01','\\0');\n", "  unlock_buf(&vga_front);\n", "  uVar6 = 0x7fffffff;\n", "  cVar12 = '\\0';\n", "  do {\n", "    if (sys.need_redraw_flag != '\\0') {\n", "      sys.need_redraw_flag = '\\0';\n", "      uVar6 = 0x7fffffff;\n", "    }\n", "    lock_buf(&vga_front);\n", "    yield(&sys);\n", "    get_event((MouseSDL *)&mouse);\n", "    if (uVar6 != 0) {\n", "      if (cVar12 == '\\0') {\n", "        if ((uVar6 & 0x40000000) != 0) {\n", "          put_to_buf(&image_menu,&vga_back,\"SPG-BSC\");\n", "          put_to_buf(&image_menu_plus,&vga_back,\"SPG-BSC\");\n", "          put_back(&image_menu,0xea,0xf,menuTitleBitmap,0);\n", "          blt_buf(&vga_util,0,0,799,599,0);\n", "        }\n", "        if ((uVar6 & 1) != 0) {\n", "          paint(&raceGroup,(int)\"\\x06\\x04\\x02\\b\\a\"[(int)tempConfig.race_id + -1]);\n", "        }\n", "        if ((uVar6 & 2) != 0) {\n", "          paint(&colorGroup,(int)tempConfig.player_nation_color + -1);\n", "        }\n", "        if ((uVar6 & 4) != 0) {\n", "          desStr = format(&misc,(int)tempConfig.ai_nation_count,1);\n", "          center_put(&font_san,0x234,0x124,0x24d,0x139,desStr,'\\x01');\n", "          paint(&aiNationInc,-1,1);\n", "          paint(&aiNationDec,-1,1);\n", "        }\n", "        if ((uVar6 & 8) != 0) {\n", "          paint(&diffGroup,(int)tempConfig.difficulty_level);\n", "        }\n", "        if ((uVar6 & 0x10) != 0) {\n", "          paint(&terrainGroup,(int)tempConfig.terrain_set + -1);\n", "        }\n", "        if ((uVar6 & 0x20) != 0) {\n", "          paint(&landGroup,(int)tempConfig.land_mass + -1);\n", "        }\n", "        if ((uVar6 & 0x40) != 0) {\n", "          paint(&playerNameField,1);\n", "        }\n", "      }\n", "      else {\n", "        if (cVar12 == '\\x01') {\n", "          if ((uVar6 & 0x40000000) != 0) {\n", "            put_to_buf(&image_menu,&vga_back,\"SPG-O1\");\n", "            put_back(&image_menu,0xea,0xf,menuTitleBitmap,0);\n", "            blt_buf(&vga_util,0,0,799,599,0);\n", "          }\n", "          if ((uVar6 & 0x80) != 0) {\n", "            paint(&mapIdField,1);\n", "          }\n", "          if ((uVar6 & 0x100) != 0) {\n", "            paint(&exploreGroup,1 - (int)tempConfig.explore_whole_map);\n", "          }\n", "          if ((uVar6 & 0x200) != 0) {\n", "            paint(&fogGroup,1 - (int)tempConfig.fog_of_war);\n", "          }\n", "          if ((uVar6 & 0x400) != 0) {\n", "            paint(&treasureGroup,(int)tempConfig.start_up_cash + -1);\n", "          }\n", "          if ((uVar6 & 0x800) != 0) {\n", "            paint(&aiTreasureGroup,(int)tempConfig.ai_start_up_cash + -1);\n", "          }\n", "          if ((uVar6 & 0x1000) != 0) {\n", "            paint(&aiAggressiveGroup,(int)tempConfig.ai_aggressiveness + -1);\n", "          }\n", "          if ((uVar6 & 0x2000) != 0) {\n", "            paint(&monsterGroup,(int)tempConfig.monster_type);\n", "          }\n", "          if ((uVar6 & 0x4000) != 0) {\n", "            paint(&randomStartUpGroup,1 - (int)tempConfig.random_start_up);\n", "          }\n", "        }\n", "        else {\n", "          if (cVar12 == '\\x02') {\n", "            if ((uVar6 & 0x40000000) != 0) {\n", "              put_to_buf(&image_menu,&vga_back,\"SPG-O2\");\n", "              put_back(&image_menu,0xea,0xf,menuTitleBitmap,0);\n", "              blt_buf(&vga_util,0,0,799,599,0);\n", "            }\n", "            if ((uVar6 & 0x10000) != 0) {\n", "              desStr = format(&misc,(int)tempConfig.start_up_raw_site,1);\n", "              center_put(&font_san,0x151,0xe5,0x16a,0xfa,desStr,'\\x01');\n", "              paint(&rawSiteInc,-1,1);\n", "              paint(&rawSiteDec,-1,1);\n", "            }\n", "            if ((uVar6 & 0x20000) != 0) {\n", "              paint(&nearRawGroup,1 - (int)tempConfig.start_up_has_mine_nearby);\n", "            }\n", "            if ((uVar6 & 0x40000) != 0) {\n", "              buttonId = 2;\n", "              if (tempConfig.start_up_independent_town < 0x1e) {\n", "                buttonId = (uint)(7 < tempConfig.start_up_independent_town);\n", "              }\n", "              paint(&townStartGroup,buttonId);\n", "            }\n", "            if ((uVar6 & 0x80000) != 0) {\n", "              paint(&townResistGroup,(int)tempConfig.independent_town_resistance + -1);\n", "            }\n", "            if ((uVar6 & 0x100000) != 0) {\n", "              paint(&townEmergeGroup,1 - (int)tempConfig.new_independent_town_emerge);\n", "            }\n", "            if ((uVar6 & 0x200000) != 0) {\n", "              paint(&nationEmergeGroup,1 - (int)tempConfig.new_nation_emerge);\n", "            }\n", "            if ((uVar6 & 0x400000) != 0) {\n", "              paint(&randomEventGroup,(int)tempConfig.random_event_frequency);\n", "            }\n", "          }\n", "          else {\n", "            if (cVar12 == '\\x03') {\n", "              if ((uVar6 & 0x40000000) != 0) {\n", "                put_to_buf(&image_menu,&vga_back,\"SPG-GOAL\");\n", "                put_back(&image_menu,0xea,0xf,menuTitleBitmap,0);\n", "                blt_buf(&vga_util,0,0,799,599,0);\n", "              }\n", "              if ((uVar6 & 0x1000000) != 0) {\n", "                paint(&clearEnemyButton,-1,1);\n", "              }\n", "              if ((uVar6 & 0x2000000) != 0) {\n", "                paint(&clearMonsterButton,(int)tempConfig.goal_destroy_monster,1);\n", "              }\n", "              if ((uVar6 & 0x4000000) != 0) {\n", "                paint(&enoughPeopleButton,(int)tempConfig.goal_population_flag,1);\n", "                desStr = format(&misc,tempConfig.goal_population,1);\n", "                center_put(&font_san,0x1c8,0x14f,0x20b,0x164,desStr,'\\x01');\n", "                paint(&peopleInc,-1,1);\n", "                paint(&peopleDec,-1,1);\n", "              }\n", "              if ((uVar6 & 0x8000000) != 0) {\n", "                paint(&enoughIncomeButton,(int)tempConfig.goal_economic_score_flag,1);\n", "                desStr = format(&misc,tempConfig.goal_economic_score,1);\n", "                center_put(&font_san,0x1c8,0x16f,0x20b,0x184,desStr,'\\x01');\n", "                paint(&incomeInc,-1,1);\n", "                paint(&incomeDec,-1,1);\n", "              }\n", "              if ((uVar6 & 0x10000000) != 0) {\n", "                paint(&enoughScoreButton,(int)tempConfig.goal_total_score_flag,1);\n", "                desStr = format(&misc,tempConfig.goal_total_score,1);\n", "                center_put(&font_san,0x1c8,399,0x20b,0x1a4,desStr,'\\x01');\n", "                paint(&scoreInc,-1,1);\n", "                paint(&scoreDec,-1,1);\n", "              }\n", "              if ((uVar6 & 0x20000000) != 0) {\n", "                    /* try { // try from 00459839 to 00459af1 has its CatchHandler @ 00459b46 */\n", "                paint(&timeLimitButton,(int)tempConfig.goal_year_limit_flag,1);\n", "                desStr = format(&misc,tempConfig.goal_year_limit,1);\n", "                center_put(&font_san,0x1c8,0x1af,0x1e9,0x1c4,desStr,'\\x01');\n", "                paint(&yearInc,-1,1);\n", "                paint(&yearDec,-1,1);\n", "              }\n", "            }\n", "          }\n", "        }\n", "      }\n", "      if ((uVar6 & 8) != 0) {\n", "        buttonId_00 = single_player_difficulty(&tempConfig);\n", "        desStr = format(&misc,buttonId_00,1);\n", "        center_put(&font_san,0x2ce,0xc6,0x30c,0xe8,desStr,'\\x01');\n", "      }\n", "      if ((uVar6 & 0x40000000) != 0) {\n", "        paint(&startButton,-1);\n", "        paint(&returnButton,-1);\n", "      }\n", "    }\n", "    blt_virtual_buf(&sys);\n", "    if (config.music_flag == '\\0') {\n", "      stop(&music);\n", "      if (cVar12 == '\\0') goto LAB_00458806;\n", "LAB_0045867c:\n", "      if (cVar12 != '\\x01') {\n", "        if (cVar12 == '\\x02') {\n", "          buttonId_00 = detect(&rawSiteInc,0,0,0,0);\n", "          if (buttonId_00 == 0) {\n", "            buttonId_00 = detect(&rawSiteDec,0,0,0,0);\n", "            if (buttonId_00 == 0) {\n", "                    /* try { // try from 0045927f to 00459701 has its CatchHandler @ 00459b46 */\n", "              buttonId_00 = detect(&nearRawGroup);\n", "              if (buttonId_00 < 0) {\n", "                buttonId_00 = detect(&townStartGroup);\n", "                if (buttonId_00 < 0) {\n", "                  buttonId_00 = detect(&townResistGroup);\n", "                  if (buttonId_00 < 0) {\n", "                    buttonId_00 = detect(&townEmergeGroup);\n", "                    if (buttonId_00 < 0) {\n", "                      buttonId_00 = detect(&nationEmergeGroup);\n", "                      if (buttonId_00 < 0) {\n", "                        buttonId_00 = detect(&randomEventGroup);\n", "                        if (buttonId_00 < 0) goto LAB_004589a8;\n", "                        this = operator__(&randomEventGroup,randomEventGroup.button_pressed);\n", "                        tempConfig.difficulty_level = '\\x05';\n", "                        uVar6 = 8;\n", "                        tempConfig.random_event_frequency = (char)(this->custom_para).value;\n", "                      }\n", "                      else {\n", "                        this = operator__(&nationEmergeGroup,nationEmergeGroup.button_pressed);\n", "                        tempConfig.difficulty_level = '\\x05';\n", "                        uVar6 = 8;\n", "                        tempConfig.new_nation_emerge = (char)(this->custom_para).value;\n", "                      }\n", "                    }\n", "                    else {\n", "                      this = operator__(&townEmergeGroup,townEmergeGroup.button_pressed);\n", "                      tempConfig.difficulty_level = '\\x05';\n", "                      uVar6 = 8;\n", "                      tempConfig.new_independent_town_emerge = (char)(this->custom_para).value;\n", "                    }\n", "                  }\n", "                  else {\n", "                    this = operator__(&townResistGroup,townResistGroup.button_pressed);\n", "                    tempConfig.difficulty_level = '\\x05';\n", "                    uVar6 = 8;\n", "                    tempConfig.independent_town_resistance = (char)(this->custom_para).value;\n", "                  }\n", "                }\n", "                else {\n", "                  this = operator__(&townStartGroup,townStartGroup.button_pressed);\n", "                  tempConfig.difficulty_level = '\\x05';\n", "                  uVar6 = 8;\n", "                  tempConfig.start_up_independent_town = (short)(this->custom_para).value;\n", "                }\n", "              }\n", "              else {\n", "                this = operator__(&nearRawGroup,nearRawGroup.button_pressed);\n", "                tempConfig.difficulty_level = '\\x05';\n", "                uVar6 = 8;\n", "                tempConfig.start_up_has_mine_nearby = (char)(this->custom_para).value;\n", "              }\n", "              goto LAB_004586c0;\n", "            }\n", "            tempConfig.start_up_raw_site = tempConfig.start_up_raw_site + -1;\n", "            if (tempConfig.start_up_raw_site < 1) {\n", "              tempConfig.start_up_raw_site = 1;\n", "            }\n", "          }\n", "          else {\n", "            tempConfig.start_up_raw_site = tempConfig.start_up_raw_site + 1;\n", "            if (7 < tempConfig.start_up_raw_site) {\n", "              tempConfig.start_up_raw_site = 7;\n", "            }\n", "          }\n", "          tempConfig.difficulty_level = '\\x05';\n", "          uVar6 = 0x10008;\n", "          goto LAB_004586c0;\n", "        }\n", "        if (cVar12 == '\\x03') {\n", "          buttonId_00 = detect(&clearEnemyButton,0,0,0,0);\n", "          uVar6 = 0;\n", "          if (buttonId_00 == 0) {\n", "            buttonId_00 = detect(&clearMonsterButton,0,0,0,0);\n", "            if (buttonId_00 == 0) {\n", "              buttonId_00 = detect(&enoughPeopleButton,0,0,0,0);\n", "              if (buttonId_00 == 0) {\n", "                buttonId_00 = detect(&enoughIncomeButton,0,0,0,0);\n", "                if (buttonId_00 == 0) {\n", "                  buttonId_00 = detect(&enoughScoreButton,0,0,0,0);\n", "                  if (buttonId_00 == 0) {\n", "                    buttonId_00 = detect(&timeLimitButton,0,0,0,0);\n", "                    if (buttonId_00 == 0) {\n", "                      buttonId_00 = detect(&peopleInc,0,0,0,0);\n", "                      if (buttonId_00 == 0) {\n", "                    /* try { // try from 00459bdd to 00459db8 has its CatchHandler @ 00459b46 */\n", "                        buttonId_00 = detect(&peopleDec,0,0,0,0);\n", "                        if (buttonId_00 == 0) {\n", "                          buttonId_00 = detect(&incomeInc,0,0,0,0);\n", "                          if (buttonId_00 == 0) {\n", "                            buttonId_00 = detect(&incomeDec,0,0,0,0);\n", "                            if (buttonId_00 == 0) {\n", "                              buttonId_00 = detect(&scoreInc,0,0,0,0);\n", "                              if (buttonId_00 == 0) {\n", "                                buttonId_00 = detect(&scoreDec,0,0,0,0);\n", "                                if (buttonId_00 == 0) {\n", "                                  buttonId_00 = detect(&yearInc,0,0,0,0);\n", "                                  if (buttonId_00 == 0) {\n", "                                    buttonId_00 = detect(&yearDec,0,0,0,0);\n", "                                    uVar6 = 0;\n", "                                    if (buttonId_00 == 0) goto LAB_004586c0;\n", "                                    if (tempConfig.goal_year_limit < 0x15) {\n", "                                      tempConfig.goal_year_limit = tempConfig.goal_year_limit + -1;\n", "                                      if (tempConfig.goal_year_limit < 1) {\n", "                                        tempConfig.goal_year_limit = 1;\n", "                                      }\n", "                                    }\n", "                                    else {\n", "                                      tempConfig.goal_year_limit = tempConfig.goal_year_limit + -5;\n", "                                    }\n", "                                  }\n", "                                  else {\n", "                                    if (tempConfig.goal_year_limit < 0x14) {\n", "                                      tempConfig.goal_year_limit = tempConfig.goal_year_limit + 1;\n", "                                    }\n", "                                    else {\n", "                                      tempConfig.goal_year_limit = tempConfig.goal_year_limit + 5;\n", "                                      if (100 < tempConfig.goal_year_limit) {\n", "                                        tempConfig.goal_year_limit = 100;\n", "                                      }\n", "                                    }\n", "                                  }\n", "                                  uVar6 = 0x20000000;\n", "                                  goto LAB_004586c0;\n", "                                }\n", "                                if (tempConfig.goal_total_score < 0x7d1) {\n", "                                  tempConfig.goal_total_score = tempConfig.goal_total_score + -100;\n", "                                  if (tempConfig.goal_total_score < 100) {\n", "                                    tempConfig.goal_total_score = 100;\n", "                                  }\n", "                                }\n", "                                else {\n", "                                  tempConfig.goal_total_score = tempConfig.goal_total_score + -500;\n", "                                }\n", "                              }\n", "                              else {\n", "                                if (tempConfig.goal_total_score < 2000) {\n", "                                  tempConfig.goal_total_score = tempConfig.goal_total_score + 100;\n", "                                }\n", "                                else {\n", "                                  tempConfig.goal_total_score = tempConfig.goal_total_score + 500;\n", "                                  if (10000 < tempConfig.goal_total_score) {\n", "                                    tempConfig.goal_total_score = 10000;\n", "                                  }\n", "                                }\n", "                              }\n", "                              uVar6 = 0x10000000;\n", "                            }\n", "                            else {\n", "                              uVar6 = 0x8000000;\n", "                              tempConfig.goal_economic_score = tempConfig.goal_economic_score + -100\n", "                              ;\n", "                              if (tempConfig.goal_economic_score < 100) {\n", "                                tempConfig.goal_economic_score = 100;\n", "                              }\n", "                            }\n", "                          }\n", "                          else {\n", "                            uVar6 = 0x8000000;\n", "                            tempConfig.goal_economic_score = tempConfig.goal_economic_score + 100;\n", "                            if (5000 < tempConfig.goal_economic_score) {\n", "                              tempConfig.goal_economic_score = 5000;\n", "                            }\n", "                          }\n", "                        }\n", "                        else {\n", "                          uVar6 = 0x4000000;\n", "                          tempConfig.goal_population = tempConfig.goal_population + -100;\n", "                          if (tempConfig.goal_population < 100) {\n", "                            tempConfig.goal_population = 100;\n", "                          }\n", "                        }\n", "                      }\n", "                      else {\n", "                        uVar6 = 0x4000000;\n", "                        tempConfig.goal_population = tempConfig.goal_population + 100;\n", "                        if (5000 < tempConfig.goal_population) {\n", "                          tempConfig.goal_population = 5000;\n", "                        }\n", "                      }\n", "                    }\n", "                    else {\n", "                      tempConfig.goal_year_limit_flag = timeLimitButton.pushed_flag;\n", "                      uVar6 = 0;\n", "                    }\n", "                  }\n", "                  else {\n", "                    tempConfig.goal_total_score_flag = enoughScoreButton.pushed_flag;\n", "                    uVar6 = 0;\n", "                  }\n", "                }\n", "                else {\n", "                  tempConfig.goal_economic_score_flag = enoughIncomeButton.pushed_flag;\n", "                  uVar6 = 0;\n", "                }\n", "              }\n", "              else {\n", "                tempConfig.goal_population_flag = enoughPeopleButton.pushed_flag;\n", "                uVar6 = 0;\n", "              }\n", "            }\n", "            else {\n", "              tempConfig.goal_destroy_monster = clearMonsterButton.pushed_flag;\n", "              uVar6 = 0;\n", "            }\n", "          }\n", "          goto LAB_004586c0;\n", "        }\n", "        goto LAB_004589a8;\n", "      }\n", "      buttonId = detect(&mapIdField);\n", "      uVar6 = 0x80;\n", "      if (buttonId == 0) {\n", "        buttonId_00 = detect(&exploreGroup);\n", "        if (buttonId_00 < 0) {\n", "          buttonId_00 = detect(&fogGroup);\n", "          if (buttonId_00 < 0) {\n", "            buttonId_00 = detect(&treasureGroup);\n", "            if (buttonId_00 < 0) {\n", "              buttonId_00 = detect(&aiTreasureGroup);\n", "              if (buttonId_00 < 0) {\n", "                buttonId_00 = detect(&aiAggressiveGroup);\n", "                if (buttonId_00 < 0) {\n", "                  buttonId_00 = detect(&monsterGroup);\n", "                  if (buttonId_00 < 0) {\n", "                    /* try { // try from 0045975a to 00459778 has its CatchHandler @ 00459b46 */\n", "                    buttonId_00 = detect(&randomStartUpGroup);\n", "                    if (buttonId_00 < 0) goto LAB_004589a8;\n", "                    this = operator__(&randomStartUpGroup,randomStartUpGroup.button_pressed);\n", "                    tempConfig.difficulty_level = '\\x05';\n", "                    uVar6 = 8;\n", "                    tempConfig.random_start_up = (char)(this->custom_para).value;\n", "                  }\n", "                  else {\n", "                    this = operator__(&monsterGroup,monsterGroup.button_pressed);\n", "                    tempConfig.difficulty_level = '\\x05';\n", "                    uVar6 = 8;\n", "                    tempConfig.monster_type = (char)(this->custom_para).value;\n", "                  }\n", "                }\n", "                else {\n", "                  this = operator__(&aiAggressiveGroup,aiAggressiveGroup.button_pressed);\n", "                  tempConfig.difficulty_level = '\\x05';\n", "                  uVar6 = 8;\n", "                  tempConfig.ai_aggressiveness = (char)(this->custom_para).value;\n", "                }\n", "              }\n", "              else {\n", "                this = operator__(&aiTreasureGroup,aiTreasureGroup.button_pressed);\n", "                tempConfig.difficulty_level = '\\x05';\n", "                uVar6 = 8;\n", "                tempConfig.ai_start_up_cash = (short)(this->custom_para).value;\n", "              }\n", "            }\n", "            else {\n", "              this = operator__(&treasureGroup,treasureGroup.button_pressed);\n", "              tempConfig.difficulty_level = '\\x05';\n", "              uVar6 = 8;\n", "              tempConfig.start_up_cash = (short)(this->custom_para).value;\n", "            }\n", "          }\n", "          else {\n", "            this = operator__(&fogGroup,fogGroup.button_pressed);\n", "            tempConfig.difficulty_level = '\\x05';\n", "            uVar6 = 8;\n", "            tempConfig.fog_of_war = (char)(this->custom_para).value;\n", "          }\n", "        }\n", "        else {\n", "          this = operator__(&exploreGroup,exploreGroup.button_pressed);\n", "          tempConfig.difficulty_level = '\\x05';\n", "          uVar6 = 8;\n", "          tempConfig.explore_whole_map = (char)(this->custom_para).value;\n", "        }\n", "      }\n", "    }\n", "    else {\n", "      buttonId_00 = is_playing(&music,1);\n", "      if (buttonId_00 == 0) {\n", "        if (sys.cdrom_drive != '\\0') {\n", "          buttonId_00 = 4;\n", "        }\n", "        play(&music,1,buttonId_00);\n", "      }\n", "      if (cVar12 != '\\0') goto LAB_0045867c;\n", "LAB_00458806:\n", "      buttonId_00 = detect(&raceGroup);\n", "      if (buttonId_00 < 0) {\n", "        buttonId_00 = detect(&colorGroup);\n", "        if (buttonId_00 < 0) {\n", "          buttonId_00 = detect(&aiNationInc,0,0,0,0);\n", "          if (buttonId_00 == 0) {\n", "            buttonId_00 = detect(&aiNationDec,0,0,0,0);\n", "            if (buttonId_00 == 0) {\n", "              buttonId_00 = detect(&diffGroup);\n", "              if (buttonId_00 < 0) {\n", "                buttonId_00 = detect(&terrainGroup);\n", "                if (buttonId_00 < 0) {\n", "                  buttonId_00 = detect(&landGroup);\n", "                  if (buttonId_00 < 0) {\n", "                    buttonId = detect(&playerNameField);\n", "                    uVar6 = 0x40;\n", "                    if (buttonId == 0) goto LAB_004589a8;\n", "                  }\n", "                  else {\n", "                    this = operator__(&landGroup,landGroup.button_pressed);\n", "                    tempConfig.land_mass = (char)(this->custom_para).value;\n", "                    uVar6 = 0;\n", "                  }\n", "                }\n", "                else {\n", "                  this = operator__(&terrainGroup,terrainGroup.button_pressed);\n", "                  tempConfig.terrain_set = (short)(this->custom_para).value;\n", "                  tempConfig.latitude = latitudeArray[(int)tempConfig.terrain_set + -1];\n", "                  uVar6 = 0;\n", "                }\n", "              }\n", "              else {\n", "                this = operator__(&diffGroup,diffGroup.button_pressed);\n", "                if ((this->custom_para).value == 5) {\n", "LAB_004589a8:\n", "                  uVar6 = 0;\n", "                }\n", "                else {\n", "                  this = operator__(&diffGroup,diffGroup.button_pressed);\n", "                  change_difficulty(&tempConfig,(this->custom_para).value);\n", "                  uVar6 = 0x3fffffff;\n", "                }\n", "              }\n", "              goto LAB_004586c0;\n", "            }\n", "            tempConfig.ai_nation_count = tempConfig.ai_nation_count + -1;\n", "            if (tempConfig.ai_nation_count < '\\x01') {\n", "              tempConfig.ai_nation_count = '\\x01';\n", "            }\n", "          }\n", "          else {\n", "            tempConfig.ai_nation_count = tempConfig.ai_nation_count + '\\x01';\n", "            if ('\\x06' < tempConfig.ai_nation_count) {\n", "              tempConfig.ai_nation_count = '\\x06';\n", "            }\n", "          }\n", "          tempConfig.difficulty_level = '\\x05';\n", "          uVar6 = 0xc;\n", "        }\n", "        else {\n", "          this = operator__(&colorGroup,colorGroup.button_pressed);\n", "          tempConfig.player_nation_color = (char)(this->custom_para).value;\n", "          uVar6 = 0;\n", "        }\n", "      }\n", "      else {\n", "        this = operator__(&raceGroup,raceGroup.button_pressed);\n", "        tempConfig.race_id = (char)(this->custom_para).value;\n", "        uVar6 = 0;\n", "      }\n", "    }\n", "LAB_004586c0:\n", "    buttonId_00 = single_click((MouseSDL *)&mouse,0x60,0x88,0xda,0xb2,0);\n", "    if (buttonId_00 == 0) {\n", "      buttonId_00 = single_click((MouseSDL *)&mouse,0xec,0x88,0x16b,0xb2,0);\n", "      if (buttonId_00 == 0) {\n", "        buttonId_00 = single_click((MouseSDL *)&mouse,0x17c,0x88,0x1fa,0xb2,0);\n", "        if (buttonId_00 == 0) {\n", "          buttonId_00 = single_click((MouseSDL *)&mouse,0x20b,0x88,0x289,0xb2,0);\n", "          if ((buttonId_00 != 0) && (cVar12 != '\\x03')) {\n", "            uVar6 = 0x7fffffff;\n", "            cVar12 = '\\x03';\n", "          }\n", "        }\n", "        else {\n", "          if (cVar12 != '\\x02') {\n", "            uVar6 = 0x7fffffff;\n", "            cVar12 = '\\x02';\n", "          }\n", "        }\n", "      }\n", "      else {\n", "        if (cVar12 != '\\x01') {\n", "          uVar6 = 0x7fffffff;\n", "          cVar12 = '\\x01';\n", "        }\n", "      }\n", "    }\n", "    else {\n", "      if (cVar12 != '\\0') {\n", "        uVar6 = 0x7fffffff;\n", "        cVar12 = '\\0';\n", "      }\n", "    }\n", "    buttonId_00 = detect(&startButton,0,0,0,0);\n", "    if (buttonId_00 != 0) {\n", "      if (vga_front.buf_locked != 0) goto LAB_004590ee;\n", "      bVar2 = true;\n", "      goto LAB_0045937e;\n", "    }\n", "    buttonId_00 = detect(&returnButton,0,0,0,0);\n", "    if (buttonId_00 != 0) {\n", "      if (vga_front.buf_locked == 0) {\n", "        bVar2 = false;\n", "LAB_0045937e:\n", "        lock_buf(&vga_front);\n", "        if (bVar2) {\n", "LAB_004590ee:\n", "          lVar3 = strtol(mapIdStr,(char **)0x0,10);\n", "          init_random_seed(&info,(int)lVar3);\n", "          buttonId_00 = single_player_difficulty(&tempConfig);\n", "          tempConfig.difficulty_rating = (short)buttonId_00;\n", "          config._0_8_ = CONCAT17(tempConfig.ai_aggressiveness,\n", "                                  CONCAT25(tempConfig.ai_start_up_cash,\n", "                                           CONCAT23(tempConfig.start_up_cash,\n", "                                                    CONCAT12(tempConfig.ai_nation_count,\n", "                                                             tempConfig.difficulty_rating))));\n", "          buttonId_00 = 1;\n", "          config._156_8_ = tempConfig._156_8_;\n", "          lVar3 = 0x13;\n", "          puVar8 = (undefined8 *)&tempConfig.start_up_independent_town;\n", "          puVar10 = (undefined8 *)&config.start_up_independent_town;\n", "          while (lVar3 != 0) {\n", "            lVar3 = lVar3 + -1;\n", "            *puVar10 = *puVar8;\n", "            puVar8 = puVar8 + (ulong)bVar13 * 0x1ffffffffffffffe + 1;\n", "            puVar10 = puVar10 + (ulong)bVar13 * 0x1ffffffffffffffe + 1;\n", "          }\n", "        }\n", "        else {\n", "          buttonId_00 = 0;\n", "        }\n", "      }\n", "      else {\n", "        buttonId_00 = 0;\n", "      }\n", "                    /* try { // try from 00459169 to 0045916d has its CatchHandler @ 00459baa */\n", "      _ButtonCustomGroup(&randomEventGroup);\n", "                    /* try { // try from 00459175 to 00459179 has its CatchHandler @ 00459baf */\n", "      _ButtonCustomGroup(&nationEmergeGroup);\n", "                    /* try { // try from 00459181 to 00459185 has its CatchHandler @ 00459c49 */\n", "      _ButtonCustomGroup(&townEmergeGroup);\n", "                    /* try { // try from 0045918d to 00459191 has its CatchHandler @ 00459bb9 */\n", "      _ButtonCustomGroup(&townResistGroup);\n", "                    /* try { // try from 00459199 to 0045919d has its CatchHandler @ 00459bbe */\n", "      _ButtonCustomGroup(&townStartGroup);\n", "                    /* try { // try from 004591a5 to 004591a9 has its CatchHandler @ 00459bc3 */\n", "      _ButtonCustomGroup(&nearRawGroup);\n", "                    /* try { // try from 004591b1 to 004591b5 has its CatchHandler @ 00459bc8 */\n", "      _ButtonCustomGroup(&randomStartUpGroup);\n", "                    /* try { // try from 004591bd to 004591c1 has its CatchHandler @ 00459b0b */\n", "      _ButtonCustomGroup(&monsterGroup);\n", "                    /* try { // try from 004591c9 to 004591cd has its CatchHandler @ 00459b34 */\n", "      _ButtonCustomGroup(&aiAggressiveGroup);\n", "                    /* try { // try from 004591d5 to 004591d9 has its CatchHandler @ 00459b39 */\n", "      _ButtonCustomGroup(&aiTreasureGroup);\n", "                    /* try { // try from 004591e1 to 004591e5 has its CatchHandler @ 00459af7 */\n", "      _ButtonCustomGroup(&treasureGroup);\n", "                    /* try { // try from 004591ed to 004591f1 has its CatchHandler @ 00459793 */\n", "      _ButtonCustomGroup(&fogGroup);\n", "                    /* try { // try from 004591f9 to 004591fd has its CatchHandler @ 004597b3 */\n", "      _ButtonCustomGroup(&exploreGroup);\n", "                    /* try { // try from 00459205 to 00459209 has its CatchHandler @ 0045971c */\n", "      _ButtonCustomGroup(&landGroup);\n", "                    /* try { // try from 00459211 to 00459215 has its CatchHandler @ 004597c0 */\n", "      _ButtonCustomGroup(&terrainGroup);\n", "                    /* try { // try from 0045921d to 00459221 has its CatchHandler @ 004597b8 */\n", "      _ButtonCustomGroup(&diffGroup);\n", "                    /* try { // try from 00459225 to 00459229 has its CatchHandler @ 00459b3e */\n", "      _ButtonCustomGroup(&colorGroup);\n", "      _ButtonCustomGroup(&raceGroup);\n", "      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "        return buttonId_00;\n", "      }\n", "                    /* WARNING: Subroutine does not return */\n", "      __stack_chk_fail();\n", "    }\n", "    unlock_buf(&vga_front);\n", "  } while( true );\n", "}\n", "\n"], "c": ["static int select_option()\n", "{\n", "\tconst int offsetY = 124;\n", "\tchar optionMode = OPTION_BASIC;\n", "\tchar menuTitleBitmap[] = \"TOP-NSPG\";\n", "\t\n", "\tConfig tempConfig = config;\n", "\n", "\t// last multi-player game may set ai_nation_count to zero\n", "\tif( tempConfig.ai_nation_count < 1 )\n", "\t\ttempConfig.ai_nation_count = MAX_NATION-1;\n", "\n", "\t// some setting may be modified in the last game\n", "\tif( tempConfig.difficulty_level != OPTION_CUSTOM )\n", "\t\ttempConfig.change_difficulty(tempConfig.difficulty_level);\n", "\n", "\tint i;\n", "\tlong refreshFlag = SGOPTION_ALL;\n", "\tint retFlag = 0;\n", "\n", "\t// --------- initialize race button group ---------- //\n", "\n", "\tButtonCustomGroup raceGroup(MAX_RACE);\n", "\tfor( i = 0; i < MAX_RACE; ++i )\n", "\t{\n", "#if(MAX_RACE == 10)\n", "\t\traceGroup[i].create(222+(i%5)*BASIC_OPTION_X_SPACE, offsetY+81+(i/5)*BASIC_OPTION_HEIGHT,\n", "\t\t\t222+(i%5+1)*BASIC_OPTION_X_SPACE-1, offsetY+81+(i/5+1)*BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&raceGroup, race_table[i]), 0, 0);\n", "\n", "#define Y_SHIFT_FLAG 1\n", "#else\n", "\t\traceGroup[i].create(118+i*BASIC_OPTION_X_SPACE, offsetY+103,\n", "\t\t\t118+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+103+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&raceGroup, race_table[i]), 0, 0);\n", "#define Y_SHIFT_FLAG 0\n", "#endif\n", "\t}\n", "\n", "\t// --------- initialize color button group ---------- //\n", "\n", "\tButtonCustomGroup colorGroup(MAX_COLOR_SCHEME);\n", "\tfor( i = 0; i < MAX_COLOR_SCHEME; ++i )\n", "\t{\n", "\t\t#if(Y_SHIFT_FLAG)\n", "\t\t\t#define Y_SHIFT 14\n", "\t\t#else\n", "\t\t\t#define Y_SHIFT 0\n", "\t\t#endif\n", "\t\tcolorGroup[i].create(195+i*COLOR_OPTION_X_SPACE, offsetY+149+Y_SHIFT,\n", "\t\t\t195+(i+1)*COLOR_OPTION_X_SPACE-1, offsetY+149+Y_SHIFT+COLOR_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&colorGroup, i+1), 0, 0);\n", "\t\t#undef Y_SHIFT\n", "\t}\n", "\n", "\t// ---------- initialize ai_nation_count buttons --------//\n", "\n", "\tButtonCustom aiNationInc, aiNationDec;\n", "\t{\n", "\t\t#if(Y_SHIFT_FLAG)\n", "\t\t\t#define Y_SHIFT 14\n", "\t\t#else\n", "\t\t\t#define Y_SHIFT 0\n", "\t\t#endif\n", "\t\taiNationInc.create(595, offsetY+149+Y_SHIFT, \n", "\t\t\t595+COLOR_OPTION_X_SPACE-1, offsetY+149+Y_SHIFT+COLOR_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(NULL, +1) );\n", "\t\taiNationDec.create(630, offsetY+149+Y_SHIFT, \n", "\t\t\t630+COLOR_OPTION_X_SPACE-1, offsetY+149+Y_SHIFT+COLOR_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(NULL, -1) );\n", "\t\t#undef Y_SHIFT\n", "\t}\n", "\n", "\t// ---------- initialize difficulty_level button group -------//\n", "\n", "\tButtonCustomGroup diffGroup(6);\n", "\tfor( i = 0; i < 6; ++i )\n", "\t{\n", "\t\t#if(Y_SHIFT_FLAG)\n", "\t\t\t#define Y_SHIFT 17\n", "\t\t#else\n", "\t\t\t#define Y_SHIFT 0\n", "\t\t#endif\n", "\t\tdiffGroup[i].create( 205+i*BASIC_OPTION_X_SPACE, offsetY+194+Y_SHIFT,\n", "\t\t\t205+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+194+Y_SHIFT+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&diffGroup, i), 0, 0);\n", "\t\t#undef Y_SHIFT\n", "\t}\n", "\n", "\t// --------- initialize terrain_set button group -------//\n", "\n", "\tButtonCustomGroup terrainGroup(3);\n", "\tfor( i = 0; i < 3; ++i )\n", "\t{\n", "\t\t#if(Y_SHIFT_FLAG)\n", "\t\t\t#define Y_SHIFT 17\n", "\t\t#else\n", "\t\t\t#define Y_SHIFT 0\n", "\t\t#endif\n", "\t\tterrainGroup[i].create(168+i*BASIC_OPTION_X_SPACE, offsetY+258+Y_SHIFT, \n", "\t\t\t168+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+258+Y_SHIFT+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&terrainGroup, i+1), 0, 0);\n", "\t\t#undef Y_SHIFT\n", "\t}\n", "\n", "\t// --------- initialize land_mass button group -------//\n", "\n", "\tButtonCustomGroup landGroup(3);\n", "\tfor( i = 0; i < 3; ++i )\n", "\t{\n", "\t\t#if(Y_SHIFT_FLAG)\n", "\t\t\t#define Y_SHIFT 17\n", "\t\t#else\n", "\t\t\t#define Y_SHIFT 0\n", "\t\t#endif\n", "\t\tlandGroup[i].create(439+i*BASIC_OPTION_X_SPACE, offsetY+258+Y_SHIFT, \n", "\t\t\t439+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+258+Y_SHIFT+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&landGroup, i+1), 0, 0);\n", "\t\t#undef Y_SHIFT\n", "\t}\n", "\n", "\tGetA playerNameField;\n", "\t// ####### begin Gilbert 3/11 #######//\n", "//\tplayerNameField.init( 318, offsetY+327, 690, tempConfig.player_name,\n", "//\t\ttempConfig.PLAYER_NAME_LEN, &font_san, 0, 1);\n", "\tplayerNameField.init( 318, offsetY+322, 690, tempConfig.player_name,\n", "\t\ttempConfig.PLAYER_NAME_LEN, &font_bard, 0, 1);\n", "\t// ####### end Gilbert 3/11 #######//\n", "\n", "\t// --------- initialize info.random_seed field ----------//\n", "\n", "\tconst int mapIdSize = 11;\t\t// enough to hold a dword in decimal\n", "\tchar mapIdStr[mapIdSize+1];\n", "\tinfo.init_random_seed(0);\n", "\tltoa( info.random_seed , mapIdStr, 10);\n", "\tGetA mapIdField;\n", "#if(defined(SPANISH))\n", "\t#define MAPID_X1 586\n", "#elif(defined(FRENCH))\n", "\t#define MAPID_X1 572\n", "#else\n", "\t#define MAPID_X1 564\n", "#endif\n", "\tmapIdField.init( MAPID_X1, offsetY+112, 700, mapIdStr, mapIdSize, &font_san, 0, 1);\n", "#undef MAPID_X1\n", "\t// --------- initialize explore_whole_map button group -------//\n", "\n", "\tButtonCustomGroup exploreGroup(2);\n", "\tfor( i = 0; i < 2; ++i )\n", "\t{\n", "\t\texploreGroup[i].create(335+i*BASIC_OPTION_X_SPACE, offsetY+103, \n", "\t\t\t335+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+103+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&exploreGroup, 1-i), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize fog_of_war button group -------//\n", "\n", "\tButtonCustomGroup fogGroup(2);\n", "\tfor( i = 0; i < 2; ++i )\n", "\t{\n", "\t\tfogGroup[i].create(335+i*BASIC_OPTION_X_SPACE, offsetY+135, \n", "\t\t\t335+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+135+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&fogGroup, 1-i), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize start_up_cash/start_up_food button group -------//\n", "\n", "\tButtonCustomGroup treasureGroup(4);\n", "\tfor( i = 0; i < 4; ++i )\n", "\t{\n", "\t\ttreasureGroup[i].create(335+i*BASIC_OPTION_X_SPACE, offsetY+167,\n", "\t\t\t335+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+167+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&treasureGroup, i+1), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize ai_start_up_cash/food button group -------//\n", "\n", "\tButtonCustomGroup aiTreasureGroup(4);\n", "\tfor( i = 0; i < 4; ++i )\n", "\t{\n", "\t\taiTreasureGroup[i].create(335+i*BASIC_OPTION_X_SPACE, offsetY+199,\n", "\t\t\t335+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+199+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&aiTreasureGroup, i+1), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize ai_aggressiveness -------//\n", "\n", "\tButtonCustomGroup aiAggressiveGroup(4);\n", "\tfor( i = 0; i < 4; ++i )\n", "\t{\n", "\t\taiAggressiveGroup[i].create(335+i*BASIC_OPTION_X_SPACE, offsetY+231, \n", "\t\t\t335+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+231+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&aiAggressiveGroup, i+1), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize monster_type -------//\n", "\n", "\tButtonCustomGroup monsterGroup(3);\n", "\tfor( i = 0; i < 3; ++i )\n", "\t{\n", "\t\tmonsterGroup[i].create(335+i*BASIC_OPTION_X_SPACE, offsetY+263,\n", "\t\t\t335+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+263+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&monsterGroup, i), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize random startup button group -------//\n", "\n", "\tButtonCustomGroup randomStartUpGroup(2);\n", "\tfor( i = 0; i < 2; ++i )\n", "\t{\n", "\t\trandomStartUpGroup[i].create(335+i*BASIC_OPTION_X_SPACE, offsetY+295, \n", "\t\t\t335+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+295+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&randomStartUpGroup, 1-i), 0, 0);\n", "\t}\n", "\n", "\t//  -------- initialize start_up_raw_site buttons --------- //\n", "\n", "\tButtonCustom rawSiteInc, rawSiteDec;\n", "\trawSiteInc.create( 368, offsetY+100, \n", "\t\t368+COLOR_OPTION_X_SPACE-1, offsetY+100+COLOR_OPTION_HEIGHT-1,\n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL,0));\n", "\trawSiteDec.create( 403, offsetY+100, \n", "\t\t403+COLOR_OPTION_X_SPACE-1, offsetY+100+COLOR_OPTION_HEIGHT-1,\n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL,0));\n", "\n", "\t// --------- initialize start_up_has_mine_nearby button group --------//\n", "\n", "\tButtonCustomGroup nearRawGroup(2);\n", "\tfor( i = 0; i < 2; ++i )\n", "\t{\n", "\t\tnearRawGroup[i].create(332+i*BASIC_OPTION_X_SPACE, offsetY+132,\n", "\t\t\t332+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+132+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&nearRawGroup, 1-i), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize start_up_independent_town button group --------//\n", "\n", "\tstatic short startTownArray[3] = { 7, 15, 30 };\n", "\n", "\tButtonCustomGroup townStartGroup(3);\n", "\tfor( i = 0; i < 3; ++i )\n", "\t{\n", "\t\ttownStartGroup[i].create(332+i*BASIC_OPTION_X_SPACE, offsetY+164, \n", "\t\t\t332+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+164+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&townStartGroup, startTownArray[i]), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize independent_town_resistance button group --------//\n", "\n", "\tButtonCustomGroup townResistGroup(3);\n", "\tfor( i = 0; i < 3; ++i )\n", "\t{\n", "\t\ttownResistGroup[i].create(332+i*BASIC_OPTION_X_SPACE, offsetY+196, \n", "\t\t\t332+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+196+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&townResistGroup, i+1), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize new_independent_town_emerge button group --------//\n", "\n", "\tButtonCustomGroup townEmergeGroup(2);\n", "\tfor( i = 0; i < 2; ++i )\n", "\t{\n", "\t\ttownEmergeGroup[i].create(332+i*BASIC_OPTION_X_SPACE, offsetY+228,\n", "\t\t\t332+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+228+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&townEmergeGroup, 1-i), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize new_nation_emerge button group --------//\n", "\n", "\tButtonCustomGroup nationEmergeGroup(2);\n", "\tfor( i = 0; i < 2; ++i )\n", "\t{\n", "\t\tnationEmergeGroup[i].create(332+i*BASIC_OPTION_X_SPACE, offsetY+260, \n", "\t\t\t332+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+260+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&nationEmergeGroup, 1-i), 0, 0);\n", "\t}\n", "\n", "\t// --------- initialize random_event_frequency button group --------//\n", "\n", "\tButtonCustomGroup randomEventGroup(4);\n", "\tfor( i = 0; i < 4; ++i )\n", "\t{\n", "\t\trandomEventGroup[i].create(332+i*BASIC_OPTION_X_SPACE, offsetY+292, \n", "\t\t\t332+(i+1)*BASIC_OPTION_X_SPACE-1, offsetY+292+BASIC_OPTION_HEIGHT-1,\n", "\t\t\tdisp_virtual_button, ButtonCustomPara(&randomEventGroup, i), 0, 0);\n", "\t}\n", "\n", "\t// ---------- initialize goal buttons ----------//\n", "\n", "\tButtonCustom clearEnemyButton, clearMonsterButton, enoughPeopleButton, enoughIncomeButton, enoughScoreButton, timeLimitButton;\n", "\tButtonCustom peopleInc, peopleDec, incomeInc, incomeDec, scoreInc, scoreDec, yearInc, yearDec;\n", "\n", "\tclearEnemyButton.create( 214, offsetY+145, 214+19, offsetY+145+19,\n", "\t\tdisp_virtual_tick, ButtonCustomPara(NULL, 0), 0, 1);\n", "\tclearEnemyButton.enable_flag = 0;;\n", "\tclearMonsterButton.create( 214, offsetY+178, 214+19, offsetY+178+19,\n", "\t\tdisp_virtual_tick, ButtonCustomPara(NULL, 0), 0, \n", "\t\ttempConfig.goal_destroy_monster);\n", "\tenoughPeopleButton.create( 214, offsetY+211, 214+19, offsetY+211+19,\n", "\t\tdisp_virtual_tick, ButtonCustomPara(NULL, 0), 0, \n", "\t\ttempConfig.goal_population_flag);\n", "\tenoughIncomeButton.create( 214, offsetY+244, 214+19, offsetY+244+19,\t// -9\n", "\t\tdisp_virtual_tick, ButtonCustomPara(NULL, 0), 0,\n", "\t\ttempConfig.goal_economic_score_flag);\n", "\tenoughScoreButton.create( 214, offsetY+277, 214+19, offsetY+277+19,\n", "\t\tdisp_virtual_tick, ButtonCustomPara(NULL, 0), 0,\n", "\t\ttempConfig.goal_total_score_flag);\n", "\ttimeLimitButton.create( 214, offsetY+309, 214+19, offsetY+309+19,\t\t// +23\n", "\t\tdisp_virtual_tick, ButtonCustomPara(NULL, 0), 0,\n", "\t\ttempConfig.goal_year_limit_flag);\n", "\n", "\tpeopleInc.create( 529, offsetY+206, \n", "\t\t529+COLOR_OPTION_X_SPACE-1, offsetY+206+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\tpeopleDec.create( 564, offsetY+206, \n", "\t\t564+COLOR_OPTION_X_SPACE-1, offsetY+206+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\tincomeInc.create( 529, offsetY+238,\n", "\t\t529+COLOR_OPTION_X_SPACE-1, offsetY+238+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\tincomeDec.create( 564, offsetY+238,\n", "\t\t564+COLOR_OPTION_X_SPACE-1, offsetY+238+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\tscoreInc.create( 529, offsetY+270,\n", "\t\t529+COLOR_OPTION_X_SPACE-1, offsetY+270+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\tscoreDec.create( 564, offsetY+270,\n", "\t\t564+COLOR_OPTION_X_SPACE-1, offsetY+270+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\tyearInc.create( 529, offsetY+302,\n", "\t\t529+COLOR_OPTION_X_SPACE-1, offsetY+302+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\tyearDec.create( 564, offsetY+302,\n", "\t\t564+COLOR_OPTION_X_SPACE-1, offsetY+302+COLOR_OPTION_HEIGHT-1, \n", "\t\tdisp_virtual_button, ButtonCustomPara(NULL, 0) );\n", "\n", "\tButton3D startButton, returnButton;\n", "\t// startButton.create(250, 553, \"BB-START\", \"BB-START\", 1, 0);\n", "\t// returnButton.create(440, 553, \"BB-RETURN\", \"BB-RETURN\", 1, 0);\n", "\tstartButton.create(194, 538, \"START-U\", \"START-D\", 1, 0);\n", "\treturnButton.create(440, 538, \"CANCEL-U\", \"CANCEL-D\", 1, 0);\n", "\n", "\tvga_front.unlock_buf();\n", "\n", "\twhile(1)\n", "\t{\n", "#ifndef NO_WINDOWS  // FIXME\n", "\t\tMSG msg;\n", "\t\tif (PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE))\n", "\t\t{\n", "\t\t\tif (!GetMessage( &msg, NULL, 0, 0))\n", "\t\t\t{\n", "\t\t\t\tsys.signal_exit_flag = 1;\n", "\t\t\t\t// BUGHERE : vga_front is unlocked\n", "\t\t\t\treturn 0;\n", "\t\t\t}\n", "\t\t\tTranslateMessage(&msg);\n", "\t\t\tDispatchMessage(&msg);\n", "\t\t\tcontinue;\n", "\t\t}\n", "#endif\n", "\t\tif( sys.need_redraw_flag )\n", "\t\t{\n", "\t\t\trefreshFlag = SGOPTION_ALL;\n", "\t\t\tsys.need_redraw_flag = 0;\n", "\t\t}\n", "\n", "\t\tvga_front.lock_buf();\n", "\n", "\t\tsys.yield();\n", "\t\tmouse.get_event();\n", "\n", "\t\t// -------- display ----------//\n", "\t\tif( refreshFlag )\n", "\t\t{\n", "\t\t\t// ------- display basic option ---------//\n", "\t\t\tif( optionMode == OPTION_BASIC )\n", "\t\t\t{\n", "\t\t\t\tif( refreshFlag & SGOPTION_PAGE )\n", "\t\t\t\t{\n", "\t\t\t\t\timage_menu.put_to_buf( &vga_back, \"SPG-BSC\");\n", "#if(MAX_RACE == 10)\n", "\t\t\t\t\t// protection : image_menu.put_to_buf( &vga_back, \"SPG-BSC\");\n", "\t\t\t\t\t// ensure the user has the release version (I_MENU.RES)\n", "\t\t\t\t\t// image_menu2.put_to_buf( &vga_back, \"SPG-BSC\") get the real one\n", "\t\t\t\t\timage_menu2.put_to_buf( &vga_back, \"SPG-BSC\");\n", "#endif\n", "\t\t\t\t\timage_menu.put_back( 234, 15, menuTitleBitmap);\n", "\t\t\t\t\tvga_util.blt_buf(0,0,VGA_WIDTH-1,VGA_HEIGHT-1,0);\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_RACE )\n", "\t\t\t\t\traceGroup.paint( reverse_race_table[tempConfig.race_id-1] );\n", "\t\t\t\tif( refreshFlag & SGOPTION_COLOR )\n", "\t\t\t\t\tcolorGroup.paint( tempConfig.player_nation_color-1 );\n", "\t\t\t\tif( refreshFlag & SGOPTION_AI_NATION )\n", "\t\t\t\t{\n", "\t\t\t\t\t#if(Y_SHIFT_FLAG)\n", "\t\t\t\t\t\t#define Y_SHIFT 14\n", "\t\t\t\t\t#else\n", "\t\t\t\t\t\t#define Y_SHIFT 0\n", "\t\t\t\t\t#endif\n", "\t\t\t\t\tfont_san.center_put(564, offsetY+154+Y_SHIFT, 564+25, offsetY+154+Y_SHIFT+21,\n", "\t\t\t\t\t\tmisc.format(tempConfig.ai_nation_count), 1);\n", "\t\t\t\t\taiNationInc.paint();\n", "\t\t\t\t\taiNationDec.paint();\n", "\t\t\t\t\t#undef Y_SHIFT\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_DIFFICULTY )\n", "\t\t\t\t\tdiffGroup.paint(tempConfig.difficulty_level);\n", "\t\t\t\tif( refreshFlag & SGOPTION_TERRAIN )\n", "\t\t\t\t\tterrainGroup.paint(tempConfig.terrain_set-1);\n", "\t\t\t\tif( refreshFlag & SGOPTION_LAND_MASS )\n", "\t\t\t\t\tlandGroup.paint(tempConfig.land_mass-1);\n", "\t\t\t\tif( refreshFlag & SGOPTION_NAME_FIELD )\n", "\t\t\t\t\tplayerNameField.paint();\n", "\t\t\t}\n", "\n", "\t\t\t// ------- display advanced option ---------//\n", "\t\t\tif( optionMode == OPTION_ADVANCED )\n", "\t\t\t{\n", "\t\t\t\tif( refreshFlag & SGOPTION_PAGE )\n", "\t\t\t\t{\n", "\t\t\t\t\timage_menu.put_to_buf( &vga_back, \"SPG-O1\");\n", "\t\t\t\t\timage_menu.put_back( 234, 15, menuTitleBitmap);\n", "\t\t\t\t\tvga_util.blt_buf(0,0,VGA_WIDTH-1,VGA_HEIGHT-1,0);\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_MAP_ID )\n", "\t\t\t\t\tmapIdField.paint();\n", "\t\t\t\tif( refreshFlag & SGOPTION_EXPLORED )\n", "\t\t\t\t\texploreGroup.paint(1-tempConfig.explore_whole_map);\n", "\t\t\t\tif( refreshFlag & SGOPTION_FOG )\n", "\t\t\t\t\tfogGroup.paint(1-tempConfig.fog_of_war);\n", "\t\t\t\tif( refreshFlag & SGOPTION_TREASURE )\n", "\t\t\t\t\ttreasureGroup.paint( tempConfig.start_up_cash-1 );\n", "\t\t\t\tif( refreshFlag & SGOPTION_AI_TREASURE )\n", "\t\t\t\t\taiTreasureGroup.paint( tempConfig.ai_start_up_cash-1 );\n", "\t\t\t\tif( refreshFlag & SGOPTION_AI_AGGRESSIVE )\n", "\t\t\t\t\taiAggressiveGroup.paint(tempConfig.ai_aggressiveness-1);\n", "\t\t\t\tif( refreshFlag & SGOPTION_FRYHTANS )\n", "\t\t\t\t\tmonsterGroup.paint(tempConfig.monster_type);\n", "\t\t\t\tif( refreshFlag & SGOPTION_RANDOM_STARTUP )\n", "\t\t\t\t\trandomStartUpGroup.paint(1-tempConfig.random_start_up);\n", "\t\t\t}\n", "\n", "\t\t\t// ------- display advanced option ---------//\n", "\t\t\tif( optionMode == OPTION_ADVANCE2 )\n", "\t\t\t{\n", "\t\t\t\tif( refreshFlag & SGOPTION_PAGE )\n", "\t\t\t\t{\n", "\t\t\t\t\timage_menu.put_to_buf( &vga_back, \"SPG-O2\");\n", "\t\t\t\t\timage_menu.put_back( 234, 15, menuTitleBitmap);\n", "\t\t\t\t\tvga_util.blt_buf(0,0,VGA_WIDTH-1,VGA_HEIGHT-1,0);\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_RAW )\n", "\t\t\t\t{\n", "\t\t\t\t\tfont_san.center_put(337, offsetY+105, 337+25, offsetY+105+21,\n", "\t\t\t\t\t\tmisc.format(tempConfig.start_up_raw_site), 1);\n", "\t\t\t\t\trawSiteInc.paint();\n", "\t\t\t\t\trawSiteDec.paint();\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_NEAR_RAW )\n", "\t\t\t\t\tnearRawGroup.paint(1-tempConfig.start_up_has_mine_nearby);\n", "\t\t\t\tif( refreshFlag & SGOPTION_START_TOWN )\n", "\t\t\t\t\ttownStartGroup.paint(\n", "\t\t\t\t\ttempConfig.start_up_independent_town >= 30 ? 2 :\n", "\t\t\t\t\ttempConfig.start_up_independent_town <= 7 ? 0 :\n", "\t\t\t\t\t1\n", "\t\t\t\t\t);\n", "\t\t\t\tif( refreshFlag & SGOPTION_TOWN_STRENGTH )\n", "\t\t\t\t\ttownResistGroup.paint(tempConfig.independent_town_resistance-1);\n", "\t\t\t\tif( refreshFlag & SGOPTION_TOWN_EMERGE )\n", "\t\t\t\t\ttownEmergeGroup.paint(1-tempConfig.new_independent_town_emerge);\n", "\t\t\t\tif( refreshFlag & SGOPTION_KINGDOM_EMERGE )\n", "\t\t\t\t\tnationEmergeGroup.paint(1-tempConfig.new_nation_emerge);\n", "\t\t\t\tif( refreshFlag & SGOPTION_RANDOM_EVENT )\n", "\t\t\t\t\trandomEventGroup.paint(tempConfig.random_event_frequency);\n", "\t\t\t}\n", "\n", "\t\t\t// ------- display goal option ---------//\n", "\t\t\tif( optionMode == OPTION_GOAL )\n", "\t\t\t{\n", "\t\t\t\tif( refreshFlag & SGOPTION_PAGE )\n", "\t\t\t\t{\n", "\t\t\t\t\timage_menu.put_to_buf( &vga_back, \"SPG-GOAL\");\n", "\t\t\t\t\timage_menu.put_back( 234, 15, menuTitleBitmap);\n", "\t\t\t\t\tvga_util.blt_buf(0,0,VGA_WIDTH-1,VGA_HEIGHT-1,0);\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_CLEAR_ENEMY )\n", "\t\t\t\t\tclearEnemyButton.paint();\n", "\t\t\t\tif( refreshFlag & SGOPTION_CLEAR_MONSTER )\n", "\t\t\t\t\tclearMonsterButton.paint(tempConfig.goal_destroy_monster);\n", "\t\t\t\tif( refreshFlag & SGOPTION_ENOUGH_PEOPLE )\n", "\t\t\t\t{\n", "\t\t\t\t\tenoughPeopleButton.paint(tempConfig.goal_population_flag);\n", "\t\t\t\t\tfont_san.center_put( 456, offsetY+211, 456+67, offsetY+211+21,\n", "\t\t\t\t\t\tmisc.format(tempConfig.goal_population) ,1);\n", "\t\t\t\t\tpeopleInc.paint();\n", "\t\t\t\t\tpeopleDec.paint();\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_ENOUGH_INCOME )\n", "\t\t\t\t{\n", "\t\t\t\t\tenoughIncomeButton.paint(tempConfig.goal_economic_score_flag);\n", "\t\t\t\t\tfont_san.center_put( 456, offsetY+243, 456+67, offsetY+243+21,\n", "\t\t\t\t\t\tmisc.format(tempConfig.goal_economic_score), 1);\n", "\t\t\t\t\tincomeInc.paint();\n", "\t\t\t\t\tincomeDec.paint();\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_ENOUGH_SCORE )\n", "\t\t\t\t{\n", "\t\t\t\t\tenoughScoreButton.paint(tempConfig.goal_total_score_flag);\n", "\t\t\t\t\tfont_san.center_put( 456, offsetY+275, 456+67, offsetY+275+21,\n", "\t\t\t\t\t\tmisc.format(tempConfig.goal_total_score), 1);\n", "\t\t\t\t\tscoreInc.paint();\n", "\t\t\t\t\tscoreDec.paint();\n", "\t\t\t\t}\n", "\t\t\t\tif( refreshFlag & SGOPTION_TIME_LIMIT )\n", "\t\t\t\t{\n", "\t\t\t\t\ttimeLimitButton.paint(tempConfig.goal_year_limit_flag);\n", "\t\t\t\t\tfont_san.center_put( 456, offsetY+307, 456+33, offsetY+307+21,\n", "\t\t\t\t\t\tmisc.format(tempConfig.goal_year_limit), 1);\n", "\t\t\t\t\tyearInc.paint();\n", "\t\t\t\t\tyearDec.paint();\n", "\t\t\t\t}\n", "\t\t\t}\n", "\n", "\t\t\t// ------- display difficulty -------//\n", "\t\t\tif( refreshFlag & SGOPTION_DIFFICULTY )\n", "\t\t\t{\n", "\t\t\t\tfont_san.center_put( 718, offsetY+74, 780, offsetY+108,\n", "\t\t\t\t\tmisc.format(tempConfig.single_player_difficulty()), 1 );\n", "\t\t\t}\n", "\n", "\t\t\t// -------- repaint button -------//\n", "\t\t\tif( refreshFlag & SGOPTION_PAGE )\n", "\t\t\t{\n", "\t\t\t\tstartButton.paint();\n", "\t\t\t\treturnButton.paint();\n", "\t\t\t}\n", "\n", "\t\t\trefreshFlag = 0;\n", "\t\t}\n", "\t\tsys.blt_virtual_buf();\n", "\n", "\t\tif( config.music_flag )\n", "\t\t{\n", "\t\t\tif( !music.is_playing(1) )\n", "\t\t\t\tmusic.play(1, sys.cdrom_drive ? MUSIC_CD_THEN_WAV : 0 );\n", "\t\t}\n", "\t\telse\n", "\t\t\tmusic.stop();\n", "\n", "\t\t// --------- detect basic option -------- //\n", "\t\tif( optionMode == OPTION_BASIC )\n", "\t\t{\n", "\t\t\tif( raceGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.race_id = raceGroup[raceGroup()].custom_para.value;\n", "\t\t\t\t//refreshFlag |= SGOPTION_RACE;\n", "\t\t\t}\n", "\t\t\telse if( colorGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.player_nation_color = colorGroup[colorGroup()].custom_para.value;\n", "\t\t\t\t//refreshFlag |= SGOPTION_COLOR;\n", "\t\t\t}\n", "\t\t\telse if( aiNationInc.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.ai_nation_count++;\n", "\t\t\t\tif( tempConfig.ai_nation_count >= MAX_NATION )\n", "\t\t\t\t\ttempConfig.ai_nation_count = MAX_NATION-1;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\trefreshFlag |= SGOPTION_AI_NATION | SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( aiNationDec.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.ai_nation_count--;\n", "\t\t\t\tif( tempConfig.ai_nation_count <= 0 )\n", "\t\t\t\t\ttempConfig.ai_nation_count = 1;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\trefreshFlag |= SGOPTION_AI_NATION | SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( diffGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\tif( diffGroup[diffGroup()].custom_para.value != OPTION_CUSTOM )\n", "\t\t\t\t{\n", "\t\t\t\t\ttempConfig.change_difficulty(diffGroup[diffGroup()].custom_para.value);\n", "\t\t\t\t\t// all but SGOPTION_PAGE;\n", "\t\t\t\t\trefreshFlag |= SGOPTION_ALL & ~SGOPTION_PAGE;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\telse if( terrainGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.terrain_set = terrainGroup[terrainGroup()].custom_para.value;\n", "\t\t\t\tstatic short latitudeArray[3] = { 45, 70, 20 };\n", "\t\t\t\terr_when( tempConfig.terrain_set <= 0 || tempConfig.terrain_set > 3 );\n", "\t\t\t\ttempConfig.latitude = latitudeArray[tempConfig.terrain_set-1];\n", "\t\t\t\t//refreshFlag |= SGOPTION_TERRAIN;\n", "\t\t\t}\n", "\t\t\telse if( landGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.land_mass = landGroup[landGroup()].custom_para.value;\n", "\t\t\t\t//refreshFlag |= SGOPTION_LAND_MASS;\n", "\t\t\t}\n", "\t\t\telse if( playerNameField.detect() )\n", "\t\t\t{\n", "\t\t\t\trefreshFlag |= SGOPTION_NAME_FIELD;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\t// -------- detect advanced option ---------//\n", "\n", "\t\tif( optionMode == OPTION_ADVANCED )\n", "\t\t{\n", "\t\t\tif( mapIdField.detect() )\n", "\t\t\t{\n", "\t\t\t\trefreshFlag |= SGOPTION_MAP_ID;\n", "\t\t\t}\n", "\t\t\telse\n", "\t\t\tif( exploreGroup.detect() >= 0 )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.explore_whole_map = exploreGroup[exploreGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_EXPLORED;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( fogGroup.detect() >= 0 )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.fog_of_war = fogGroup[fogGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_FOG\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( treasureGroup.detect() >= 0 )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.start_up_cash = treasureGroup[treasureGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_TREASURE;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( aiTreasureGroup.detect() >= 0 )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.ai_start_up_cash = aiTreasureGroup[aiTreasureGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_AI_TREASURE;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( aiAggressiveGroup.detect() >= 0 )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.ai_aggressiveness = \n", "\t\t\t\t\taiAggressiveGroup[aiAggressiveGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_AI_AGGRESSIVE;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( monsterGroup.detect() >= 0 )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.monster_type = monsterGroup[monsterGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_FRYHTANS;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( randomStartUpGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.random_start_up = randomStartUpGroup[randomStartUpGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_RANDOM_STARTUP;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\t// -------- detect advanced option ---------//\n", "\n", "\t\tif( optionMode == OPTION_ADVANCE2 )\n", "\t\t{\n", "\t\t\tif( rawSiteInc.detect() )\n", "\t\t\t{\n", "\t\t\t\tif( ++tempConfig.start_up_raw_site > 7 )\n", "\t\t\t\t\ttempConfig.start_up_raw_site = 7;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\trefreshFlag |= SGOPTION_RAW | SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( rawSiteDec.detect() )\n", "\t\t\t{\n", "\t\t\t\tif( --tempConfig.start_up_raw_site < 1 )\n", "\t\t\t\t\ttempConfig.start_up_raw_site = 1;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\trefreshFlag |= SGOPTION_RAW | SGOPTION_DIFFICULTY;\n", "\n", "\t\t\t}\n", "\t\t\telse if( nearRawGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.start_up_has_mine_nearby = nearRawGroup[nearRawGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_NEAR_RAW;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\n", "\t\t\t}\n", "\t\t\telse if( townStartGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.start_up_independent_town = townStartGroup[townStartGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// resfreshFlag |= SGOPTION_START_TOWN;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( townResistGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.independent_town_resistance = townResistGroup[townResistGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// resfreshFlag |= SGOPTION_TOWN_RESIST;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( townEmergeGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.new_independent_town_emerge = townEmergeGroup[townEmergeGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_TOWN_EMERGE;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( nationEmergeGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.new_nation_emerge = nationEmergeGroup[nationEmergeGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_NATION_EMERGE;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t\telse if( randomEventGroup.detect() >= 0)\n", "\t\t\t{\n", "\t\t\t\ttempConfig.random_event_frequency = randomEventGroup[randomEventGroup()].custom_para.value;\n", "\t\t\t\ttempConfig.difficulty_level = OPTION_CUSTOM;\n", "\t\t\t\t// refreshFlag |= SGOPTION_RANDOM_EVENT;\n", "\t\t\t\trefreshFlag |= SGOPTION_DIFFICULTY;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\t// -------- detect goal option ----------//\n", "\n", "\t\tif( optionMode == OPTION_GOAL )\n", "\t\t{\n", "\t\t\tif( clearEnemyButton.detect() )\n", "\t\t\t{\n", "\t\t\t}\n", "\t\t\telse if( clearMonsterButton.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_destroy_monster = clearMonsterButton.pushed_flag;\n", "\t\t\t}\n", "\t\t\telse if( enoughPeopleButton.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_population_flag = enoughPeopleButton.pushed_flag;\n", "\t\t\t}\n", "\t\t\telse if( enoughIncomeButton.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_economic_score_flag = enoughIncomeButton.pushed_flag;\n", "\t\t\t}\n", "\t\t\telse if( enoughScoreButton.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_total_score_flag = enoughScoreButton.pushed_flag;\n", "\t\t\t}\n", "\t\t\telse if( timeLimitButton.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_year_limit_flag = timeLimitButton.pushed_flag;\n", "\t\t\t}\n", "\t\t\telse if( peopleInc.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_population += 100;\n", "\t\t\t\tif( tempConfig.goal_population > 5000 )\n", "\t\t\t\t\ttempConfig.goal_population = 5000;\n", "\t\t\t\trefreshFlag |= SGOPTION_ENOUGH_PEOPLE;\n", "\t\t\t}\n", "\t\t\telse if( peopleDec.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_population -= 100;\n", "\t\t\t\tif( tempConfig.goal_population < 100 )\n", "\t\t\t\t\ttempConfig.goal_population = 100;\n", "\t\t\t\trefreshFlag |= SGOPTION_ENOUGH_PEOPLE;\n", "\t\t\t}\n", "\t\t\telse if( incomeInc.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_economic_score += 100;\n", "\t\t\t\tif( tempConfig.goal_economic_score > 5000 )\n", "\t\t\t\t{\n", "\t\t\t\t\ttempConfig.goal_economic_score = 5000;\n", "\t\t\t\t}\n", "\t\t\t\trefreshFlag |= SGOPTION_ENOUGH_INCOME;\n", "\t\t\t}\n", "\t\t\telse if( incomeDec.detect() )\n", "\t\t\t{\n", "\t\t\t\ttempConfig.goal_economic_score -= 100;\n", "\t\t\t\tif( tempConfig.goal_economic_score < 100 )\n", "\t\t\t\t{\n", "\t\t\t\t\ttempConfig.goal_economic_score = 100;\n", "\t\t\t\t}\n", "\t\t\t\trefreshFlag |= SGOPTION_ENOUGH_INCOME;\n", "\t\t\t}\n", "\t\t\telse if( scoreInc.detect() )\n", "\t\t\t{\n", "\t\t\t\tif( tempConfig.goal_total_score >= 2000 )\n", "\t\t\t\t\ttempConfig.goal_total_score += 500;\n", "\t\t\t\telse\n", "\t\t\t\t\ttempConfig.goal_total_score += 100;\n", "\t\t\t\tif( tempConfig.goal_total_score > 10000 )\n", "\t\t\t\t\ttempConfig.goal_total_score = 10000;\n", "\t\t\t\trefreshFlag |= SGOPTION_ENOUGH_SCORE;\n", "\t\t\t}\n", "\t\t\telse if( scoreDec.detect() )\n", "\t\t\t{\n", "\t\t\t\tif( tempConfig.goal_total_score > 2000 )\n", "\t\t\t\t\ttempConfig.goal_total_score -= 500;\n", "\t\t\t\telse\n", "\t\t\t\t\ttempConfig.goal_total_score -= 100;\n", "\t\t\t\tif( tempConfig.goal_total_score < 100 )\n", "\t\t\t\t\ttempConfig.goal_total_score = 100;\n", "\t\t\t\trefreshFlag |= SGOPTION_ENOUGH_SCORE;\n", "\t\t\t}\n", "\t\t\telse if( yearInc.detect() )\n", "\t\t\t{\n", "\t\t\t\tif( tempConfig.goal_year_limit >= 20 )\n", "\t\t\t\t\ttempConfig.goal_year_limit += 5;\n", "\t\t\t\telse\n", "\t\t\t\t\ttempConfig.goal_year_limit++;\n", "\t\t\t\tif( tempConfig.goal_year_limit > 100 )\n", "\t\t\t\t{\n", "\t\t\t\t\ttempConfig.goal_year_limit = 100;\n", "\t\t\t\t}\n", "\t\t\t\trefreshFlag |= SGOPTION_TIME_LIMIT;\n", "\t\t\t}\n", "\t\t\telse if( yearDec.detect() )\n", "\t\t\t{\n", "\t\t\t\tif( tempConfig.goal_year_limit > 20 )\n", "\t\t\t\t\ttempConfig.goal_year_limit -= 5;\n", "\t\t\t\telse\n", "\t\t\t\t\ttempConfig.goal_year_limit--;\n", "\t\t\t\tif( tempConfig.goal_year_limit < 1 )\n", "\t\t\t\t{\n", "\t\t\t\t\ttempConfig.goal_year_limit = 1;\n", "\t\t\t\t}\n", "\t\t\t\trefreshFlag |= SGOPTION_TIME_LIMIT;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\t// --------- detect switch option button ------//\n", "\n", "\t\tif( mouse.single_click(96, offsetY+12, 218, offsetY+54) )\n", "\t\t{\n", "\t\t\tif( optionMode != OPTION_BASIC )\n", "\t\t\t{\n", "\t\t\t\toptionMode = OPTION_BASIC;\n", "\t\t\t\trefreshFlag = SGOPTION_ALL;\n", "\t\t\t}\n", "\t\t}\n", "\t\telse if( mouse.single_click(236, offsetY+12, 363, offsetY+54) )\n", "\t\t{\n", "\t\t\tif( optionMode != OPTION_ADVANCED )\n", "\t\t\t{\n", "\t\t\t\toptionMode = OPTION_ADVANCED;\n", "\t\t\t\trefreshFlag = SGOPTION_ALL;\n", "\t\t\t}\n", "\t\t}\n", "\t\telse if( mouse.single_click(380, offsetY+12, 506, offsetY+54) )\n", "\t\t{\n", "\t\t\tif( optionMode != OPTION_ADVANCE2 )\n", "\t\t\t{\n", "\t\t\t\toptionMode = OPTION_ADVANCE2;\n", "\t\t\t\trefreshFlag = SGOPTION_ALL;\n", "\t\t\t}\n", "\t\t}\n", "\t\telse if( mouse.single_click(523, offsetY+12, 649, offsetY+54) )\n", "\t\t{\n", "\t\t\tif( optionMode != OPTION_GOAL )\n", "\t\t\t{\n", "\t\t\t\toptionMode = OPTION_GOAL;\n", "\t\t\t\trefreshFlag = SGOPTION_ALL;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\t// --------- detect input name --------//\n", "\n", "\t\t// --------- detect start button --------//\n", "\t\tif( startButton.detect() )\n", "\t\t{\n", "\t\t\tretFlag = 1;\n", "\t\t\tbreak;\t\t\t// break while(1)\n", "\t\t}\n", "\t\telse if( returnButton.detect() )\n", "\t\t{\n", "\t\t\tretFlag = 0;\n", "\t\t\tbreak;\t\t\t// break while(1)\n", "\t\t}\n", "\n", "\t\tvga_front.unlock_buf();\n", "\n", "\t}\n", "\n", "\tif( !vga_front.buf_locked )\n", "\t\tvga_front.lock_buf();\n", "\n", "\tif( retFlag )\n", "\t{\n", "\t\tinfo.init_random_seed( atol(mapIdStr) );\n", "\t\ttempConfig.difficulty_rating = tempConfig.single_player_difficulty();\n", "\n", "\t\tconfig = tempConfig;\n", "\t}\n", "\n", "\treturn retFlag;\n", "}"]}, {"ghidra": ["\n", "void put_ship_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  int y_00;\n", "  long lVar1;\n", "  long *plVar2;\n", "  short sVar3;\n", "  int iVar4;\n", "  char *textPtr;\n", "  int iVar5;\n", "  long lVar6;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  sVar3 = get_report_data2(&info,recNo);\n", "  if ((sVar3 < 1) ||\n", "     (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < (int)sVar3)) {\n", "    String(&str);\n", "    do {\n", "      invalidInstructionException();\n", "    } while( true );\n", "  }\n", "  y_00 = y + 3;\n", "  plVar2 = *(long **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                     ((int)sVar3 + -1) *\n", "                     unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "  iVar4 = x + -3 + (int)browse_ship.super_VBrowse.rec_width;\n", "  String(&str);\n", "  operator_(&str,(long)(int)*(float *)(plVar2 + 0xc));\n", "  operator__(&str,\"/\");\n", "  operator__(&str,(long)*(short *)((long)plVar2 + 100));\n", "  textPtr = (char *)(**(code **)(*plVar2 + 0x78))(plVar2);\n", "  put(&font_san,x + 3,y_00,textPtr,'\\0',-1);\n", "  put(&font_san,x + 0x5d,y_00,(char *)&str,'\\0',-1);\n", "  if ((('\\0' < *(char *)((long)plVar2 + 0x104)) &&\n", "      (put_stop_info(x + 0xa3,y_00,(TradeStop *)((long)plVar2 + 0x10f)),\n", "      '\\x01' < *(char *)((long)plVar2 + 0x104))) &&\n", "     (put_stop_info(x + 0xdf,y_00,(TradeStop *)((long)plVar2 + 0x11c)),\n", "     '\\x02' < *(char *)((long)plVar2 + 0x104))) {\n", "    put_stop_info(x + 0x11b,y_00,(TradeStop *)((long)plVar2 + 0x129));\n", "  }\n", "  x = x + 0x157;\n", "  lVar6 = 0;\n", "  do {\n", "    if (*(short *)((long)plVar2 + lVar6 * 2 + 0x136) != 0) {\n", "      textPtr = read(&raw_res.res_icon,(int)lVar6 + 10);\n", "      put_bitmap(&vga_back,x,y_00,textPtr);\n", "      disp(&font_san,x + 0xe,y + 2,(int)*(short *)((long)plVar2 + lVar6 * 2 + 0x136),1,x + 0x2d);\n", "      iVar5 = x + 0x47;\n", "      x = x + 0x24;\n", "      if (iVar4 <= iVar5) goto LAB_0049c13f;\n", "    }\n", "    lVar6 = lVar6 + 1;\n", "  } while (lVar6 != 3);\n", "  lVar6 = 0;\n", "  do {\n", "    if (*(short *)((long)plVar2 + lVar6 * 2 + 0x13c) != 0) {\n", "      textPtr = read(&raw_res.res_icon,(int)lVar6 + 4);\n", "      put_bitmap(&vga_back,x,y_00,textPtr);\n", "      disp(&font_san,x + 0xe,y + 2,(int)*(short *)((long)plVar2 + lVar6 * 2 + 0x13c),1,x + 0x2d);\n", "      iVar5 = x + 0x47;\n", "      x = x + 0x24;\n", "      if (iVar4 <= iVar5) break;\n", "    }\n", "    lVar6 = lVar6 + 1;\n", "  } while (lVar6 != 3);\n", "LAB_0049c13f:\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_ship_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tUnitMarine* unitPtr  = (UnitMarine*) unit_array[ firm_harbor_ptr->ship_recno_array[recNo-1] ];\n", "\tUnitInfo*   unitInfo = unit_res[unitPtr->unit_id];\n", "\n", "\t//-------- display unit icon -------//\n", "\n", "\tvga_front.d3_panel_down(x+1, y+1, x+UNIT_SMALL_ICON_WIDTH+4, y+UNIT_SMALL_ICON_HEIGHT+4, 2, 0 );\n", "\t// ###### begin Gilbert 17/10 #######//\n", "\tvga_front.put_bitmap(x+3, y+3, unit_res[unitPtr->unit_id]->get_small_icon_ptr(unitPtr->rank_id) );\n", "\t// ###### end Gilbert 17/10 #######//\n", "\n", "\ty+=6;\n", "\n", "\t//---------- display unit name ----------//\n", "\n", "\tfont_san.put( x+32 , y, unitInfo->name, 1, x+119 );\t\t// 1-use short words\n", "\n", "\t//------- display unit hit points -------//\n", "\n", "\tString str;\n", "\n", "\tstr  = (int) unitPtr->hit_points;\n", "\tstr += \"/\";\n", "\tstr += unitPtr->max_hit_points;\n", "\n", "\tfont_san.put( x+125, y, str, 1, x+browse_ship.rec_width-3 );\n", "}"]}, {"ghidra": ["\n", "short validate_town(short townRecno,uint flags)\n", "\n", "{\n", "  int iVar1;\n", "  int recNo;\n", "  \n", "  if (townRecno != 0) {\n", "    recNo = (int)townRecno;\n", "    iVar1 = is_deleted(&town_array,recNo);\n", "    if (iVar1 == 0) {\n", "      if (townRecno < 1) {\n", "        return (short)iVar1;\n", "      }\n", "      if (town_array.super_DynArrayB.super_DynArray.last_ele < recNo) {\n", "        return (short)iVar1;\n", "      }\n", "      if (*(long *)(town_array.super_DynArrayB.super_DynArray.body_buf +\n", "                   (recNo + -1) * town_array.super_DynArrayB.super_DynArray.ele_size) != 0) {\n", "        if ((flags & 1) != 0) {\n", "          return townRecno;\n", "        }\n", "        if (*(short *)(*(long *)(town_array.super_DynArrayB.super_DynArray.body_buf +\n", "                                (recNo + -1) * town_array.super_DynArrayB.super_DynArray.ele_size) +\n", "                      4) == remote.nation_processing) {\n", "          return townRecno;\n", "        }\n", "      }\n", "    }\n", "  }\n", "  return 0;\n", "}\n", "\n"], "c": ["static short validate_town(short townRecno, unsigned flags)\n", "{\n", "\tTown* townPtr;\n", "\terr_when( !(flags & 1) && remote.nation_processing == 0);\n", "\tif( townRecno && !town_array.is_deleted(townRecno) \n", "\t\t&& (townPtr = town_array[townRecno]) \n", "\t\t&& ((flags & 1) || townPtr->nation_recno == remote.nation_processing) )\n", "\t\treturn townRecno;\n", "\telse\n", "\t\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void put_talk_msg_rec(int recNo,int x1,int y,int refreshFlag)\n", "\n", "{\n", "  char cVar1;\n", "  long lVar2;\n", "  int x;\n", "  int iVar3;\n", "  TalkMsg *this;\n", "  char *textPtr;\n", "  short *psVar4;\n", "  NationBase *this_00;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if ((recNo < 1) || (info.talk_msg_disp_array.last_ele < recNo)) {\n", "    do {\n", "      invalidInstructionException();\n", "    } while( true );\n", "  }\n", "  psVar4 = (short *)(info.talk_msg_disp_array.body_buf +\n", "                    (recNo + -1) * info.talk_msg_disp_array.ele_size);\n", "  this = get_talk_msg(&talk_res,(int)*psVar4);\n", "  if (*(char *)(psVar4 + 4) == '\\0') {\n", "    if ((short)this->from_nation_recno != info.viewing_nation_recno) goto LAB_004971b5;\n", "  }\n", "  else {\n", "    if ((short)this->from_nation_recno == info.viewing_nation_recno) {\n", "LAB_004971b5:\n", "      textPtr = process(&translate,\"From\");\n", "      goto LAB_0049703d;\n", "    }\n", "  }\n", "  textPtr = process(&translate,\"To\");\n", "LAB_0049703d:\n", "  put(&font_san,x1 + 3,y + 2,textPtr,'\\0',-1);\n", "  x = text_width(&font_san,textPtr,-1,0);\n", "  x = x1 + 8 + x;\n", "  iVar3 = (int)this->from_nation_recno;\n", "  if ((short)this->from_nation_recno == info.viewing_nation_recno) {\n", "    cVar1 = this->to_nation_recno;\n", "    this_00 = (NationBase *)0x0;\n", "    if (('\\0' < cVar1) &&\n", "       (this_00 = (NationBase *)0x0,\n", "       (int)cVar1 <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "      this_00 = *(NationBase **)\n", "                 (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                 ((int)cVar1 + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    }\n", "  }\n", "  else {\n", "    this_00 = (NationBase *)0x0;\n", "    if ((0 < iVar3) && (iVar3 <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "      this_00 = *(NationBase **)\n", "                 (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                 (iVar3 + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    }\n", "  }\n", "  disp_nation_color(this_00,x,y + 4);\n", "  String(&str);\n", "  textPtr = process(&translate,\"on \");\n", "  operator_(&str,textPtr);\n", "  if (*(char *)(psVar4 + 4) == '\\0') {\n", "    iVar3 = this->date;\n", "  }\n", "  else {\n", "    iVar3 = this->reply_date;\n", "  }\n", "  textPtr = date_str(&date,(long)iVar3,0);\n", "  operator__(&str,textPtr);\n", "  operator__(&str,\" :\");\n", "  put(&font_san,x + 0x12,y + 2,(char *)&str,'\\0',-1);\n", "  x = (int)browse_talk_msg.super_VBrowse.ix2;\n", "  textPtr = msg_str(this,(int)info.viewing_nation_recno,(int)*(char *)(psVar4 + 4),0);\n", "  put(&font_san,x1,y + 0xf,textPtr,'\\0',x);\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_talk_msg_rec(int recNo, int x1, int y, int refreshFlag)\n", "{\n", "\tTalkMsgDisp* talkMsgDisp = (TalkMsgDisp*) info.talk_msg_disp_array.get(recNo);\n", "\tTalkMsg*\t\t talkMsg = talk_res.get_talk_msg(talkMsgDisp->recno);\n", "\n", "\tint x=x1, isTo;\n", "\n", "\tx+=3;\n", "\ty+=2;\n", "\n", "\tif( !talkMsgDisp->is_reply )\t\t// if not a replying message\n", "\t\tisTo = talkMsg->from_nation_recno == info.viewing_nation_recno;\t// you send a message to a nation\n", "\telse\n", "\t\tisTo = talkMsg->from_nation_recno != info.viewing_nation_recno;\n", "\n", "\t//---------------------------------------//\n", "\n", "\tconst char* str1;\n", "\n", "\tif( isTo )\n", "\t\tstr1 = translate.process(\"To\");\n", "\telse\n", "\t\tstr1 = translate.process(\"From\");\n", "\n", "\tfont_san.put( x , y, str1 );\n", "\n", "\tx += font_san.text_width(str1)+5;\n", "\n", "\t//---------------------------------------//\n", "\n", "\tif( talkMsg->from_nation_recno == info.viewing_nation_recno )\n", "\t\tnation_array[talkMsg->to_nation_recno]->disp_nation_color(x, y+2);\n", "\telse\n", "\t\tnation_array[talkMsg->from_nation_recno]->disp_nation_color(x, y+2);\n", "\n", "\tx+=18;\n", "\n", "\tString str;\n", "\n", "\tstr = translate.process(\"on \");\n", "\n", "\tif( talkMsgDisp->is_reply )\n", "\t\tstr += date.date_str(talkMsg->reply_date);\n", "\telse\n", "\t\tstr += date.date_str(talkMsg->date);\n", "\n", "\tstr += \" :\";\n", "\n", "\tfont_san.put( x , y, str );\n", "\n", "\tfont_san.put( x1, y+13, talkMsg->msg_str(info.viewing_nation_recno, talkMsgDisp->is_reply), 0, browse_talk_msg.ix2 );\n", "}"]}, {"ghidra": ["\n", "void put_race_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  long lVar1;\n", "  long lVar2;\n", "  long lVar3;\n", "  int raceId;\n", "  int x1;\n", "  int iVar4;\n", "  int y2;\n", "  int y1;\n", "  RaceInfo *pRVar5;\n", "  char *textPtr;\n", "  int x2;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  x2 = x + 0x1c;\n", "  y2 = y + 0x18;\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  raceId = race_filter(recNo);\n", "  pRVar5 = operator__(&race_res,raceId);\n", "  x1 = x + 1;\n", "  y1 = y + 1;\n", "  if (refreshFlag == 10) {\n", "    d3_panel_down(&vga_util,x1,y1,x2,y2,0,0);\n", "    put_bitmap(&vga_front,x + 3,y + 3,pRVar5->icon_bitmap_ptr);\n", "  }\n", "  iVar4 = in_area((MouseSDL *)&mouse,x1,y1,x2,y2);\n", "  if (iVar4 != 0) {\n", "    set_unit_help(&help,(int)pRVar5->basic_unit_id,0,x1,y1,x2,y2);\n", "  }\n", "  y2 = (int)if_town_recno;\n", "  if ((y2 < 1) || (town_array.super_DynArrayB.super_DynArray.last_ele < y2)) {\n", "    do {\n", "      invalidInstructionException();\n", "    } while( true );\n", "  }\n", "  x1 = raceId + -1;\n", "  y1 = y + 6;\n", "  lVar3 = *(long *)(town_array.super_DynArrayB.super_DynArray.body_buf +\n", "                   (y2 + -1) * town_array.super_DynArrayB.super_DynArray.ele_size);\n", "  lVar1 = lVar3 + (long)raceId * 2;\n", "  textPtr = format(&misc,(int)*(short *)(lVar1 + 0x74),1);\n", "  put(&font_mid,x + 0x2e,y1,textPtr,'\\x01',x + 0x57);\n", "  textPtr = format(&misc,(int)*(short *)(lVar1 + 0x92),1);\n", "  put(&font_mid,x + 0x58,y1,textPtr,'\\x01',x + 0x81);\n", "  y2 = x + -1 + (int)browse_race.super_VBrowse.rec_width;\n", "  if (*(short *)(lVar3 + 4) == 0) {\n", "    raceId = (int)*(float *)(lVar3 + 0xe +\n", "                            ((long)((int)nation_array.player_recno + -1) + 0x38 + (long)x1 * 7) * 4)\n", "    ;\n", "    x1 = (int)*(char *)((long)((int)nation_array.player_recno + -1) + 0x206 + lVar3 + (long)x1 * 7);\n", "    if (x1 <= raceId) goto LAB_004c8a8b;\n", "    String(&str);\n", "  }\n", "  else {\n", "    raceId = (int)*(float *)(lVar3 + 0xa8 + (long)x1 * 4);\n", "    x1 = (int)*(char *)(lVar3 + 0xd0 + (long)x1);\n", "LAB_004c8a8b:\n", "    String(&str);\n", "    if ((x1 != -1) && (raceId != x1)) {\n", "      operator_(&str,(long)raceId);\n", "      operator__(&str,\" \");\n", "      operator__(&str,(long)x1);\n", "      y2 = center_put(&font_mid,x + 0x6e,y1,y2,y + 5 + (int)font_mid.font_height,(char *)&str,'\\x01'\n", "                     );\n", "      textPtr = format(&misc,x1,1);\n", "      y1 = text_width(&font_mid,textPtr,-1,0);\n", "      if (raceId < x1) {\n", "        put_join(&image_icon,(y2 - y1) + -7,y + 9,\"ARROWUP\");\n", "      }\n", "      else {\n", "        if (x1 < raceId) {\n", "          put_join(&image_icon,(y2 - y1) + -7,y + 9,\"ARROWDWN\");\n", "        }\n", "      }\n", "      goto LAB_004c8bcf;\n", "    }\n", "  }\n", "  operator_(&str,(long)raceId);\n", "  center_put(&font_mid,x + 0x6e,y1,y2,y + 5 + (int)font_mid.font_height,(char *)&str,'\\x01');\n", "LAB_004c8bcf:\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_race_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\t//-------- display race icon -------//\n", "\n", "\tint       raceId   = race_filter(recNo);\n", "\tRaceInfo* raceInfo = race_res[raceId];\n", "\n", "\tif( refreshFlag == INFO_REPAINT )\n", "\t{\n", "\t\tvga_util.d3_panel_down(x+1, y+1, x+RACE_ICON_WIDTH+4, y+RACE_ICON_HEIGHT+4 );\n", "\t\tvga_front.put_bitmap(x+3, y+3, raceInfo->icon_bitmap_ptr);\n", "\t}\n", "\n", "\t//--------- set help parameters --------//\n", "\n", "\tif( mouse.in_area(x+1, y+1, x+RACE_ICON_WIDTH+4, y+RACE_ICON_HEIGHT+4) )\n", "\t\thelp.set_unit_help( raceInfo->basic_unit_id, 0, x+1, y+1, x+RACE_ICON_WIDTH+4, y+RACE_ICON_HEIGHT+4 );\n", "\n", "\t//-------- display race name --------//\n", "\n", "\tTown* townPtr = town_array[Town::if_town_recno];\n", "\n", "\tfont_mid.put( x+46, y+6, townPtr->race_pop_array[raceId-1],1, x+87 );\n", "\tfont_mid.put( x+88, y+6, townPtr->jobless_race_pop_array[raceId-1], 1, x+129 );\n", "\n", "\t//---- only display loyalty if this town is controlled by a nation ----//\n", "\n", "\tint curLoyalty, targetLoyalty;\n", "\tint x2 = x+browse_race.rec_width-1;\n", "\n", "\tif( townPtr->nation_recno )\n", "\t{\n", "\t\tcurLoyalty    = (int) townPtr->race_loyalty_array[raceId-1];\n", "\t\ttargetLoyalty = (int) townPtr->race_target_loyalty_array[raceId-1];\n", "\t}\n", "\telse\n", "\t{\n", "\t\tcurLoyalty    = (int) townPtr->race_resistance_array[raceId-1][nation_array.player_recno-1];\n", "\t\ttargetLoyalty = (int) townPtr->race_target_resistance_array[raceId-1][nation_array.player_recno-1];\n", "\n", "\t\tif( targetLoyalty > curLoyalty )\t\t// resistance only decrease, won't increase\n", "\t\t\ttargetLoyalty = -1;\t\t\t\t\t// don't display the decrease target\n", "\t}\n", "\n", "\t//---------- display loyalty/resistance ------------//\n", "\n", "\tint    dispArrow=0;\n", "\tString str;\n", "\n", "\tif( curLoyalty == targetLoyalty || targetLoyalty == -1 )\t\t\t\t\t// only display up and down arrow for independent town's resistance\n", "\t{\n", "\t\tstr = curLoyalty;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tstr  = curLoyalty;\n", "\t\tstr += \" \";\n", "\t\tstr += targetLoyalty;\n", "\n", "\t\tdispArrow=1;\n", "\t}\n", "\n", "\tx2 = font_mid.center_put( x+110, y+6, x2, y+5+font_mid.height(), str, 1 );\n", "\n", "\t//--------- display up/down arrow -----------//\n", "\n", "\tif( dispArrow )\n", "\t{\n", "\t\tx = x2-font_mid.text_width( misc.format(targetLoyalty) ) - 8;\n", "\n", "\t\tif( (int) targetLoyalty > (int) curLoyalty )\n", "\t\t\timage_icon.put_join( x+1, y+9, \"ARROWUP\" );\n", "\n", "\t\telse if( (int) targetLoyalty < (int) curLoyalty )\n", "\t\t\timage_icon.put_join( x+1, y+9, \"ARROWDWN\" );\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int unit_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  char *pcVar3;\n", "  \n", "  if (recNo == 1) {\n", "    return -1;\n", "  }\n", "  iVar1 = 1;\n", "  iVar2 = 1;\n", "  pcVar3 = &(unit_res.unit_info_array)->race_id;\n", "  while( true ) {\n", "    if (*pcVar3 == '\\0') {\n", "      iVar2 = iVar2 + (uint)(0 < *(short *)(pcVar3 + (long)((int)info.viewing_nation_recno + -1) * 2\n", "                                                     + 0x5a));\n", "    }\n", "    if ((iVar2 == recNo) && (recNo != 0)) break;\n", "    pcVar3 = pcVar3 + 0x90;\n", "    iVar1 = iVar1 + 1;\n", "    if (pcVar3 == &unit_res.unit_info_array[0x2c].race_id) {\n", "      return iVar2;\n", "    }\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["static int unit_filter(int recNo)\n", "{\n", "\tint \t\t unitTypeCount=0;\n", "\tUnitInfo* unitInfo;\n", "\n", "\t//------- count human units -------//\n", "\n", "\tNation* nationPtr = nation_array[info.viewing_nation_recno];\n", "\n", "\tunitTypeCount++;\n", "\n", "\tif( recNo && unitTypeCount==recNo )\n", "\t\treturn -1;\n", "\n", "\t//------- count non-human unit types -------//\n", "\n", "\tfor( int unitId=1 ; unitId<=MAX_UNIT_TYPE ; unitId++ )\n", "\t{\n", "\t\tunitInfo = unit_res[unitId];\n", "\n", "\t\t//---- if this is not a human unit -----//\n", "\n", "\t\tif( !unitInfo->race_id &&\n", "\t\t\t unitInfo->nation_unit_count_array[info.viewing_nation_recno-1] > 0 )\n", "\t\t{\n", "\t\t\tunitTypeCount++;\n", "\t\t}\n", "\n", "\t\tif( recNo && unitTypeCount==recNo )\n", "\t\t\treturn unitId;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn unitTypeCount;\n", "}"]}, {"ghidra": ["\n", "int sort_game_file_function(void *a,void *b)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = strcmp((char *)((long)a + 4),(char *)((long)b + 4));\n", "  return iVar1;\n", "}\n", "\n"], "c": ["static int sort_game_file_function( const void *a, const void *b )\n", "{\n", "\treturn strcmp( ((GameFile*)a)->file_name, ((GameFile*)b)->file_name );\n", "}"]}, {"ghidra": ["\n", "int detect_sub_class_button(int n,int firstButton)\n", "\n", "{\n", "  int iVar1;\n", "  int y2;\n", "  \n", "  if ((firstButton < 0xb) && (y2 = firstButton * 0x1f + 0xeb, firstButton <= n)) {\n", "    do {\n", "      iVar1 = single_click((MouseSDL *)&mouse,0xe,y2 + -0x1e,0x9f,y2,0);\n", "      if (iVar1 != 0) {\n", "        put_front(&image_encyc,0xe,y2 + -0x1e,\"B_DOWN\",0);\n", "        return firstButton;\n", "      }\n", "      firstButton = firstButton + 1;\n", "      y2 = y2 + 0x1f;\n", "    } while ((firstButton < 0xb) && (firstButton <= n));\n", "  }\n", "  return 0;\n", "}\n", "\n"], "c": ["static int detect_sub_class_button(int n, int firstButton)\n", "{\n", "\tenum { BUTTON_X = 14, BUTTON_Y = 236, BUTTON_WIDTH = 146, BUTTON_HEIGHT = 28 };\n", "\tenum { BUTTON_Y_SPACING = 31, MAX_BUTTON = 10 };\n", "\n", "\tfor( int c=firstButton ; c<=n && c<=SUB_CLASS_BUTTON_MAX ; c++ )\n", "\t{\n", "\t\t//if( mouse.press_area( BUTTON_X, BUTTON_Y + (c-1)*BUTTON_Y_SPACING, BUTTON_X + BUTTON_WIDTH-1,\n", "\t\t//\tBUTTON_Y + c*BUTTON_Y_SPACING-1) )\n", "\t\tif( mouse.single_click( BUTTON_X, BUTTON_Y + (c-1)*BUTTON_Y_SPACING, BUTTON_X + BUTTON_WIDTH-1,\n", "\t\t\tBUTTON_Y + c*BUTTON_Y_SPACING-1) )\n", "\t\t{\n", "\t\t\t// int subClassId = sub_class_id_array[main_class_id-1];\n", "\n", "\t\t\t// vga_util.blt_buf( BUTTON_X, BUTTON_Y + (subClassId-1)*BUTTON_Y_SPACING, BUTTON_X + BUTTON_WIDTH-1,\n", "\t\t\t// BUTTON_Y + subClassId*BUTTON_Y_SPACING-1, 0);\n", "\n", "\t\t\t// ###### begin Gilbert 22/9 #######//\n", "\t\t\t// image_encyc.put_front(BUTTON_X-2, BUTTON_Y + (c-1)*BUTTON_Y_SPACING-2, \"B_DOWN\");\n", "\t\t\timage_encyc.put_front(BUTTON_X, BUTTON_Y + (c-1)*BUTTON_Y_SPACING, \"B_DOWN\");\n", "\t\t\t// ###### end Gilbert 22/9 #######//\n", "\t\t\treturn c;\n", "\t\t}\n", "\t}\n", "\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void disp_virtual_tick(ButtonCustom *button,int param_2)\n", "\n", "{\n", "  hide_area((MouseSDL *)&mouse,(int)button->x1,(int)button->y1,(int)button->x2,(int)button->y2);\n", "  IMGcopy((char *)(vga_front.surface)->surface->pixels,(uint)(vga_front.surface)->surface->pitch,\n", "          (char *)(vga_back.surface)->surface->pixels,(uint)(vga_back.surface)->surface->pitch,\n", "          (int)button->x1,(int)button->y1,(int)button->x2,(int)button->y2);\n", "  if (button->pushed_flag != '\\0') {\n", "    put_front(&image_menu,(int)button->x1 + 3,(int)button->y1 + 3,\"NMPG-RCH\",0);\n", "  }\n", "  show_area((MouseSDL *)&mouse);\n", "  return;\n", "}\n", "\n"], "c": ["static void disp_virtual_tick(ButtonCustom *button, int )\n", "{\n", "\tmouse.hide_area(button->x1, button->y1, button->x2, button->y2);\n", "\n", "\t// copy from back buffer to front buffer\n", "\tIMGcopy(vga_front.buf_ptr(), vga_front.buf_pitch(),\n", "\t\tvga_back.buf_ptr(), vga_back.buf_pitch(),\n", "\t\tbutton->x1, button->y1, button->x2, button->y2 );\n", "\n", "\tif( button->pushed_flag )\n", "\t\timage_menu.put_front( button->x1+3, button->y1+3, \"NMPG-RCH\" );\n", "\n", "\tmouse.show_area();\n", "}"]}, {"ghidra": ["\n", "void disp_bribe_button(int y,int bribeAmount,int buttonUp)\n", "\n", "{\n", "  long lVar1;\n", "  char *s;\n", "  int y2;\n", "  char *desStr;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  y2 = y + 0x12;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (buttonUp == 0) {\n", "    d3_panel_down(&vga_util,0x24a,y,0x316,y2,0,0);\n", "  }\n", "  else {\n", "    d3_panel_up(&vga_util,0x24a,y,0x316,y2,0,0);\n", "  }\n", "  if (bribeAmount == 0) {\n", "    desStr = \"Cancel\";\n", "  }\n", "  else {\n", "    desStr = (char *)&str;\n", "    String(&str);\n", "    s = process(&translate,\"Offer \");\n", "    operator_(&str,s);\n", "    s = format(&misc,bribeAmount,2);\n", "    operator__(&str,s);\n", "  }\n", "  center_put(&font_san,0x24a,y,0x316,y2,desStr,'\\0');\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void disp_bribe_button(int y, int bribeAmount, int buttonUp)\n", "{\n", "\tif( buttonUp )\n", "\t\tvga_util.d3_panel_up( INFO_X1, y, INFO_X2, y+BRIBE_OPTION_HEIGHT-1 );\n", "\telse\n", "\t\tvga_util.d3_panel_down( INFO_X1, y, INFO_X2, y+BRIBE_OPTION_HEIGHT-1 );\n", "\n", "\t//--------- if display cancel button ---------//\n", "\n", "\tif( bribeAmount==0 )\n", "\t\tfont_san.center_put( INFO_X1, y, INFO_X2, y+BRIBE_OPTION_HEIGHT-1, \"Cancel\" );\n", "\telse\n", "\t{\n", "\t\tString str;\n", "\n", "\t\t#ifdef GERMAN\n", "\t\t\tstr  = misc.format(bribeAmount,2);\n", "\t\t\tstr += \" anbieten\";\n", "\t\t#else\n", "\t\t\tstr  = translate.process(\"Offer \");\n", "\t\t\tstr += misc.format(bribeAmount,2);\n", "\t\t#endif\n", "\n", "\t\tfont_san.center_put( INFO_X1, y, INFO_X2, y+BRIBE_OPTION_HEIGHT-1, str );\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int sort_capture_town_function(void *a,void *b)\n", "\n", "{\n", "  return (int)*(short *)((long)a + 2) - (int)*(short *)((long)b + 2);\n", "}\n", "\n"], "c": ["static int sort_capture_town_function( const void *a, const void *b )\n", "{\n", "\treturn ((CaptureTown*)a)->min_resistance - ((CaptureTown*)b)->min_resistance;\n", "}"]}, {"ghidra": ["\n", "int disp_picture(int selClass,int selSubClass,int firstDisp)\n", "\n", "{\n", "  int iVar1;\n", "  undefined4 *puVar2;\n", "  undefined8 *puVar3;\n", "  char *fileName;\n", "  undefined8 *puVar4;\n", "  undefined4 *puVar5;\n", "  char *pcVar6;\n", "  long in_FS_OFFSET;\n", "  bool bVar7;\n", "  VgaFrontLock vgaLock;\n", "  File pictFile;\n", "  char filename [64];\n", "  char palname [64];\n", "  char filename2 [64];\n", "  char palname2 [64];\n", "  long local_40;\n", "  \n", "  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (sys.dir_encyc[0] == '\\0') {\n", "switchD_00450b18_caseD_0:\n", "    iVar1 = 0;\n", "    goto LAB_00450b22;\n", "  }\n", "  filename[0] = '\\0';\n", "  filename2[0] = '\\0';\n", "  switch(selClass) {\n", "  default:\n", "    goto switchD_00450b18_caseD_0;\n", "  case 1:\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename,0x7867a3,0x40);\n", "    pcVar6 = race_name[selSubClass + -1];\n", "    *puVar2 = 0x74696e75;\n", "    *(undefined2 *)(puVar2 + 1) = 0x2f;\n", "    goto LAB_00450c89;\n", "  case 2:\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename,0x7867a3,0x40);\n", "    *puVar2 = 0x74696e75;\n", "    pcVar6 = weapon_name[selSubClass + -1];\n", "    *(undefined2 *)(puVar2 + 1) = 0x2f;\n", "    goto LAB_00450c89;\n", "  case 3:\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename,0x7867a3,0x40);\n", "    *puVar2 = 0x74696e75;\n", "    pcVar6 = ship_name[selSubClass + -1];\n", "    *(undefined2 *)(puVar2 + 1) = 0x2f;\n", "LAB_00450c89:\n", "    puVar2 = (undefined4 *)__stpcpy_chk((long)puVar2 + 5,pcVar6,0x40);\n", "    puVar5 = (undefined4 *)((long)puVar2 - (long)filename);\n", "    __memcpy_chk(palname,filename,(long)puVar5 + 1);\n", "    *(undefined4 *)(palname + (long)puVar5) = 0x4c4f432e;\n", "    *(undefined *)((long)register0x00000020 + -0x104 + (long)puVar5) = 0;\n", "    *puVar2 = 0x4e43492e;\n", "    *(undefined *)(puVar2 + 1) = 0;\n", "    if (sys.dir_encyc2[0] != '\\0') {\n", "      puVar2 = (undefined4 *)__stpcpy_chk(filename2,0x7868a8,0x40);\n", "      puVar4 = (undefined8 *)((long)puVar2 + 5);\n", "      *puVar2 = 0x74696e75;\n", "      *(undefined *)(puVar2 + 1) = 0x2f;\n", "      break;\n", "    }\n", "LAB_00450bf0:\n", "    pictFile.file_handle = (FILE *)0x0;\n", "    goto LAB_00450c01;\n", "  case 4:\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename,0x7867a3,0x40);\n", "    pcVar6 = firm_name[selSubClass + -1];\n", "    *(undefined2 *)(puVar2 + 1) = 0x2f;\n", "    *puVar2 = 0x6d726966;\n", "    puVar2 = (undefined4 *)__stpcpy_chk((long)puVar2 + 5,pcVar6,0x40);\n", "    puVar5 = (undefined4 *)((long)puVar2 - (long)filename);\n", "    __memcpy_chk(palname,filename,(long)puVar5 + 1);\n", "    bVar7 = sys.dir_encyc2[0] != '\\0';\n", "    *(undefined4 *)(palname + (long)puVar5) = 0x4c4f432e;\n", "    *(undefined *)((long)register0x00000020 + -0x104 + (long)puVar5) = 0;\n", "    *puVar2 = 0x4e43492e;\n", "    *(undefined *)(puVar2 + 1) = 0;\n", "    if (bVar7) {\n", "      puVar2 = (undefined4 *)__stpcpy_chk(filename2,0x7868a8,0x40);\n", "      *puVar2 = 0x6d726966;\n", "      *(undefined *)(puVar2 + 1) = 0x2f;\n", "      puVar4 = (undefined8 *)((long)puVar2 + 5);\n", "      break;\n", "    }\n", "    goto LAB_00450bf0;\n", "  case 5:\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename,0x7867a3,0x40);\n", "    pcVar6 = race_name[selSubClass + -1];\n", "    *(undefined2 *)(puVar2 + 1) = 0x2f;\n", "    *puVar2 = 0x74616573;\n", "    puVar2 = (undefined4 *)__stpcpy_chk((long)puVar2 + 5,pcVar6,0x40);\n", "    puVar5 = (undefined4 *)((long)puVar2 - (long)filename);\n", "    __memcpy_chk(palname,filename,(long)puVar5 + 1);\n", "    bVar7 = sys.dir_encyc2[0] == '\\0';\n", "    *(undefined4 *)(palname + (long)puVar5) = 0x4c4f432e;\n", "    *(undefined *)((long)register0x00000020 + -0x104 + (long)puVar5) = 0;\n", "    *puVar2 = 0x4e43492e;\n", "    *(undefined *)(puVar2 + 1) = 0;\n", "    if (bVar7) goto LAB_00450bf0;\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename2,0x7868a8,0x40);\n", "    *puVar2 = 0x74616573;\n", "    *(undefined *)(puVar2 + 1) = 0x2f;\n", "    puVar4 = (undefined8 *)((long)puVar2 + 5);\n", "    break;\n", "  case 6:\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename,0x7867a3,0x40);\n", "    pcVar6 = god_name[selSubClass + -1];\n", "    *puVar2 = 0x2f646f67;\n", "    *(undefined *)(puVar2 + 1) = 0;\n", "    puVar2 = (undefined4 *)__stpcpy_chk(puVar2 + 1,pcVar6,0x40);\n", "    puVar5 = (undefined4 *)((long)puVar2 - (long)filename);\n", "    __memcpy_chk(palname,filename,(long)puVar5 + 1);\n", "    bVar7 = sys.dir_encyc2[0] == '\\0';\n", "    *(undefined4 *)(palname + (long)puVar5) = 0x4c4f432e;\n", "    *(undefined *)((long)register0x00000020 + -0x104 + (long)puVar5) = 0;\n", "    *puVar2 = 0x4e43492e;\n", "    *(undefined *)(puVar2 + 1) = 0;\n", "    if (bVar7) goto LAB_00450bf0;\n", "    puVar2 = (undefined4 *)__stpcpy_chk(filename2,0x7868a8,0x40);\n", "    *puVar2 = 0x2f646f67;\n", "    puVar4 = (undefined8 *)(puVar2 + 1);\n", "    break;\n", "  case 7:\n", "    puVar4 = (undefined8 *)__stpcpy_chk(filename,0x7867a3,0x40);\n", "    pcVar6 = monster_name[selSubClass + -1];\n", "    *puVar4 = 0x2f726574736e6f6d;\n", "    *(undefined *)(puVar4 + 1) = 0;\n", "    puVar2 = (undefined4 *)__stpcpy_chk(puVar4 + 1,pcVar6,0x40);\n", "    puVar5 = (undefined4 *)((long)puVar2 - (long)filename);\n", "    __memcpy_chk(palname,filename,(long)puVar5 + 1);\n", "    bVar7 = sys.dir_encyc2[0] == '\\0';\n", "    *(undefined4 *)(palname + (long)puVar5) = 0x4c4f432e;\n", "    *(undefined *)((long)register0x00000020 + -0x104 + (long)puVar5) = 0;\n", "    *puVar2 = 0x4e43492e;\n", "    *(undefined *)(puVar2 + 1) = 0;\n", "    if (bVar7) goto LAB_00450bf0;\n", "    puVar3 = (undefined8 *)__stpcpy_chk(filename2,0x7868a8,0x40);\n", "    puVar4 = puVar3 + 1;\n", "    *puVar3 = 0x2f726574736e6f6d;\n", "  }\n", "  fileName = palname2;\n", "  puVar2 = (undefined4 *)__stpcpy_chk(puVar4,pcVar6,0x40);\n", "  puVar5 = (undefined4 *)((long)puVar2 - (long)filename2);\n", "  __memcpy_chk(fileName,filename2,(long)puVar5 + 1);\n", "  *(undefined4 *)(palname2 + (long)puVar5) = 0x4c4f432e;\n", "  *(undefined *)((long)register0x00000020 + -0x84 + (long)puVar5) = 0;\n", "  *puVar2 = 0x4e43492e;\n", "  *(undefined *)(puVar2 + 1) = 0;\n", "  pictFile.file_handle = (FILE *)0x0;\n", "  if (filename2[0] == '\\0') {\n", "LAB_00450c01:\n", "    fileName = palname;\n", "    if ((filename[0] != '\\0') &&\n", "       ((iVar1 = is_file_exist(&misc,filename), iVar1 != 0\n", "                    /* try { // try from 00450c28 to 00450e01 has its CatchHandler @ 004511a5 */ &&\n", "        (iVar1 = file_open(&pictFile,filename,0,0), iVar1 != 0)))) goto LAB_00450dc8;\n", "    iVar1 = 0;\n", "  }\n", "  else {\n", "    iVar1 = is_file_exist(&misc,filename2);\n", "    if ((iVar1 == 0) || (iVar1 = file_open(&pictFile,filename2,0,0), iVar1 == 0)) goto LAB_00450c01;\n", "LAB_00450dc8:\n", "    put_large_bitmap(&vga_back,0xae,0xc,&pictFile);\n", "    if (firstDisp == 0) {\n", "      bar(&vga_front,0xae,0xc,0x313,0x24b,0);\n", "    }\n", "    iVar1 = is_file_exist(&misc,fileName);\n", "    if (iVar1 != 0) {\n", "      VgaFrontLock(&vgaLock);\n", "                    /* try { // try from 00450e0a to 00450e0e has its CatchHandler @ 004511b8 */\n", "      set_custom_palette((VgaSDL *)&vga,fileName);\n", "                    /* try { // try from 00450e14 to 00451161 has its CatchHandler @ 004511a5 */\n", "      _VgaFrontLock(&vgaLock);\n", "    }\n", "    if (firstDisp == 0) {\n", "      blt_buf(&vga_util,0xae,0xc,0x313,0x24b,0);\n", "    }\n", "    iVar1 = 1;\n", "  }\n", "  _File(&pictFile);\n", "LAB_00450b22:\n", "  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar1;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["static int disp_picture( int selClass, int selSubClass, int firstDisp)\n", "{\n", "\tif( !DIR_ENCYC[0] )\n", "\t\treturn 0;\n", "\n", "\tchar filename[64];\n", "\tchar palname[64];\n", "\tfilename[0] = '\\0';\n", "\n", "\t// alternative path\n", "\tchar filename2[64];\n", "\tchar palname2[64];\n", "\tfilename2[0] = '\\0';\n", "\n", "\tswitch( selClass )\n", "\t{\n", "\t\tcase ENCYC_PEOPLE:\n", "\t\t\tstrcpy( filename, DIR_ENCYC );\n", "\t\t\tstrcat( filename, DEFAULT_DIR_ENCYC_UNIT );\n", "\t\t\tstrcat( filename, race_name[selSubClass-1] );\n", "\t\t\tstrcpy( palname, filename);\n", "\t\t\tstrcat( palname, pal_extension);\n", "\t\t\tstrcat( filename, std_extension );\n", "\t\t\tif( DIR_ENCYC2[0] )\n", "\t\t\t{\n", "\t\t\t\tstrcpy( filename2, DIR_ENCYC2 );\n", "\t\t\t\tstrcat( filename2, DEFAULT_DIR_ENCYC_UNIT );\n", "\t\t\t\tstrcat( filename2, race_name[selSubClass-1] );\n", "\t\t\t\tstrcpy( palname2, filename2);\n", "\t\t\t\tstrcat( palname2, pal_extension);\n", "\t\t\t\tstrcat( filename2, std_extension );\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\n", "\t\tcase ENCYC_WEAPONS:\n", "\t\t\tstrcpy( filename, DIR_ENCYC );\n", "\t\t\tstrcat( filename, DEFAULT_DIR_ENCYC_UNIT );\n", "\t\t\tstrcat( filename, weapon_name[selSubClass-1] );\n", "\t\t\tstrcpy( palname, filename);\n", "\t\t\tstrcat( palname, pal_extension);\n", "\t\t\tstrcat( filename, std_extension );\n", "\t\t\tif( DIR_ENCYC2[0] )\n", "\t\t\t{\n", "\t\t\t\tstrcpy( filename2, DIR_ENCYC2 );\n", "\t\t\t\tstrcat( filename2, DEFAULT_DIR_ENCYC_UNIT );\n", "\t\t\t\tstrcat( filename2, weapon_name[selSubClass-1] );\n", "\t\t\t\tstrcpy( palname2, filename2);\n", "\t\t\t\tstrcat( palname2, pal_extension);\n", "\t\t\t\tstrcat( filename2, std_extension );\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\n", "\t\tcase ENCYC_SHIPS:\n", "\t\t\tstrcpy( filename, DIR_ENCYC );\n", "\t\t\tstrcat( filename, DEFAULT_DIR_ENCYC_UNIT );\n", "\t\t\tstrcat( filename, ship_name[selSubClass-1] );\n", "\t\t\tstrcpy( palname, filename);\n", "\t\t\tstrcat( palname, pal_extension);\n", "\t\t\tstrcat( filename, std_extension );\n", "\t\t\tif( DIR_ENCYC2[0] )\n", "\t\t\t{\n", "\t\t\t\tstrcpy( filename2, DIR_ENCYC2 );\n", "\t\t\t\tstrcat( filename2, DEFAULT_DIR_ENCYC_UNIT );\n", "\t\t\t\tstrcat( filename2, ship_name[selSubClass-1] );\n", "\t\t\t\tstrcpy( palname2, filename2);\n", "\t\t\t\tstrcat( palname2, pal_extension);\n", "\t\t\t\tstrcat( filename2, std_extension );\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\n", "\t\tcase ENCYC_STRUCTURES:\n", "\t\t\tstrcpy( filename, DIR_ENCYC );\n", "\t\t\tstrcat( filename, DEFAULT_DIR_ENCYC_FIRM );\n", "\t\t\tstrcat( filename, firm_name[selSubClass-1] );\n", "\t\t\tstrcpy( palname, filename);\n", "\t\t\tstrcat( palname, pal_extension);\n", "\t\t\tstrcat( filename, std_extension );\n", "\t\t\tif( DIR_ENCYC2[0] )\n", "\t\t\t{\n", "\t\t\t\tstrcpy( filename2, DIR_ENCYC2 );\n", "\t\t\t\tstrcat( filename2, DEFAULT_DIR_ENCYC_FIRM );\n", "\t\t\t\tstrcat( filename2, firm_name[selSubClass-1] );\n", "\t\t\t\tstrcpy( palname2, filename2);\n", "\t\t\t\tstrcat( palname2, pal_extension);\n", "\t\t\t\tstrcat( filename2, std_extension );\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\n", "\t\tcase ENCYC_PALACE:\n", "\t\t\tstrcpy( filename, DIR_ENCYC );\n", "\t\t\tstrcat( filename, DEFAULT_DIR_ENCYC_SEAT );\n", "\t\t\tstrcat( filename, race_name[selSubClass-1] );\n", "\t\t\tstrcpy( palname, filename);\n", "\t\t\tstrcat( palname, pal_extension);\n", "\t\t\tstrcat( filename, std_extension );\n", "\t\t\tif( DIR_ENCYC2[0] )\n", "\t\t\t{\n", "\t\t\t\tstrcpy( filename2, DIR_ENCYC2 );\n", "\t\t\t\tstrcat( filename2, DEFAULT_DIR_ENCYC_SEAT );\n", "\t\t\t\tstrcat( filename2, race_name[selSubClass-1] );\n", "\t\t\t\tstrcpy( palname2, filename2);\n", "\t\t\t\tstrcat( palname2, pal_extension);\n", "\t\t\t\tstrcat( filename2, std_extension );\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\n", "\t\tcase ENCYC_GOD:\n", "\t\t\tstrcpy( filename, DIR_ENCYC );\n", "\t\t\tstrcat( filename, DEFAULT_DIR_ENCYC_GOD );\n", "\t\t\tstrcat( filename, god_name[selSubClass-1] );\n", "\t\t\tstrcpy( palname, filename);\n", "\t\t\tstrcat( palname, pal_extension);\n", "\t\t\tstrcat( filename, std_extension );\n", "\t\t\tif( DIR_ENCYC2[0] )\n", "\t\t\t{\n", "\t\t\t\tstrcpy( filename2, DIR_ENCYC2 );\n", "\t\t\t\tstrcat( filename2, DEFAULT_DIR_ENCYC_GOD );\n", "\t\t\t\tstrcat( filename2, god_name[selSubClass-1] );\n", "\t\t\t\tstrcpy( palname2, filename2);\n", "\t\t\t\tstrcat( palname2, pal_extension);\n", "\t\t\t\tstrcat( filename2, std_extension );\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\n", "\t\tcase ENCYC_FRYHTANS:\n", "\t\t\tstrcpy( filename, DIR_ENCYC );\n", "\t\t\tstrcat( filename, DEFAULT_DIR_ENCYC_MONSTER );\n", "\t\t\tstrcat( filename, monster_name[selSubClass-1] );\n", "\t\t\tstrcpy( palname, filename);\n", "\t\t\tstrcat( palname, pal_extension);\n", "\t\t\tstrcat( filename, std_extension );\n", "\t\t\tif( DIR_ENCYC2[0] )\n", "\t\t\t{\n", "\t\t\t\tstrcpy( filename2, DIR_ENCYC2 );\n", "\t\t\t\tstrcat( filename2, DEFAULT_DIR_ENCYC_MONSTER );\n", "\t\t\t\tstrcat( filename2, monster_name[selSubClass-1] );\n", "\t\t\t\tstrcpy( palname2, filename2);\n", "\t\t\t\tstrcat( palname2, pal_extension);\n", "\t\t\t\tstrcat( filename2, std_extension );\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\n", "\t\tdefault:\n", "\t\t\terr_here();\n", "\t\t\treturn 0;\n", "\t}\n", "\n", "\tFile pictFile;\n", "\tchar *palNamePtr = NULL;\n", "\n", "\tif( \n", "\t\t// search DIR_ENCYC2 first\n", "\t\tfilename2[0] && misc.is_file_exist(filename2) && pictFile.file_open(filename2,0) && (palNamePtr = palname2) ||\n", "\t\tfilename[0] && misc.is_file_exist(filename) && pictFile.file_open(filename,0) && (palNamePtr = palname) )\n", "\t{\n", "\t\tvga_back.put_large_bitmap(174, 12, &pictFile);\n", "\n", "\t\tif( !firstDisp )\n", "\t\t\tvga_front.bar(174,12,787,587, 0x00);\t\t// wipe the picture screen\n", "\n", "\t\tif( palNamePtr && misc.is_file_exist(palNamePtr) )\n", "\t\t{\n", "\t\t\tVgaFrontLock vgaLock;\n", "\t\t\tvga.set_custom_palette(palNamePtr);\n", "\t\t}\n", "\n", "\t\tif( !firstDisp )\n", "\t\t\tvga_util.blt_buf(174,12,787,587, 0);\n", "\n", "\t\treturn 1;\n", "\t}\n", "\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void disp_goal_str(int winNationRecno)\n", "\n", "{\n", "  long lVar1;\n", "  int y1;\n", "  char *s;\n", "  int y2;\n", "  long value;\n", "  NationBase *this;\n", "  int y2_00;\n", "  NationBase *this_00;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  String str2;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (winNationRecno < 1) {\n", "    this_00 = (NationBase *)0x0;\n", "    String(&str);\n", "    String(&str2);\n", "    if ((int)nation_array.player_recno == winNationRecno) goto LAB_00451a00;\n", "    this = (NationBase *)0x0;\n", "LAB_00451741:\n", "    s = nation_name(this);\n", "    operator_(&str,s);\n", "  }\n", "  else {\n", "    this_00 = (NationBase *)0x0;\n", "    if (winNationRecno <= nation_array.super_DynArrayB.super_DynArray.last_ele) {\n", "      this_00 = *(NationBase **)\n", "                 (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                 (winNationRecno + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    }\n", "    String(&str);\n", "    String(&str2);\n", "    if ((int)nation_array.player_recno != winNationRecno) {\n", "      this = (NationBase *)0x0;\n", "      if (winNationRecno <= nation_array.super_DynArrayB.super_DynArray.last_ele) {\n", "        this = *(NationBase **)\n", "                (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                (winNationRecno + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "      }\n", "      goto LAB_00451741;\n", "    }\n", "LAB_00451a00:\n", "    s = process(&translate,\"Your Kingdom\");\n", "    operator_(&str,s);\n", "  }\n", "  operator_(&str2,\"\");\n", "  y1 = goal_destroy_monster_achieved(this_00);\n", "  if (y1 == 0) {\n", "    y1 = goal_population_achieved(this_00);\n", "    if (y1 == 0) {\n", "      y1 = goal_economic_score_achieved(this_00);\n", "      if (y1 == 0) {\n", "        y1 = goal_total_score_achieved(this_00);\n", "        if (y1 == 0) {\n", "          s = process(&translate,\" has Defeated All Other Kingdoms !\");\n", "          operator__(&str,s);\n", "          goto joined_r0x004518c9;\n", "        }\n", "        s = process(&translate,\" has Reached\");\n", "        operator__(&str,s);\n", "        s = process(&translate,\"its Total Score Goal of \");\n", "        operator_(&str2,s);\n", "        value = (long)config.goal_total_score;\n", "      }\n", "      else {\n", "        s = process(&translate,\" has Reached\");\n", "        operator__(&str,s);\n", "        s = process(&translate,\"its Economic Score Goal of \");\n", "        operator_(&str2,s);\n", "        value = (long)config.goal_economic_score;\n", "      }\n", "    }\n", "    else {\n", "      s = process(&translate,\" has Reached\");\n", "      operator__(&str,s);\n", "      s = process(&translate,\"its Population Goal of \");\n", "      operator_(&str2,s);\n", "      value = (long)config.goal_population;\n", "    }\n", "    operator__(&str2,value);\n", "    operator__(&str2,\" !\");\n", "  }\n", "  else {\n", "    operator_(&str2,&str);\n", "    s = process(&translate,\"All Fryhtans have been Destroyed !\");\n", "    operator_(&str,s);\n", "    s = process(&translate,\" has Achieved the Highest Fryhtan Battling Score !\");\n", "    operator__(&str2,s);\n", "  }\n", "joined_r0x004518c9:\n", "  if ((int)nation_array.player_recno == winNationRecno) {\n", "    y2_00 = 100;\n", "    y2 = 0x46;\n", "    y1 = 0x28;\n", "  }\n", "  else {\n", "    y2_00 = 0x78;\n", "    center_put(&font_bible,0,0x1e,799,0x3c,\"You Have Lost the Game !\",'\\0');\n", "    y2 = 0x5a;\n", "    y1 = 0x3c;\n", "  }\n", "  center_put(&font_bible,0,y1,799,y2,(char *)&str,'\\0');\n", "  center_put(&font_bible,0,y2,799,y2_00,(char *)&str2,'\\0');\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["static void disp_goal_str(int winNationRecno)\n", "{\n", "\tNation* winNation = nation_array[winNationRecno];\n", "\tString  str, str2;\n", "\n", "\tif( winNationRecno == nation_array.player_recno )\n", "\t\tstr = translate.process(\"Your Kingdom\");\n", "\telse\n", "\t\tstr = nation_array[winNationRecno]->nation_name();\n", "\n", "\tstr2 = \"\";\n", "\n", "\t//---- if the player has achieved one of its goals ----//\n", "\n", "\tif( winNation->goal_destroy_monster_achieved() )\n", "\t{\n", "\t\tstr2  = str;\n", "\t\tstr   = translate.process(\"All Fryhtans have been Destroyed !\");\n", "\t\tstr2 += translate.process(\" has Achieved the Highest Fryhtan Battling Score !\");\n", "\t}\n", "\n", "\t//-----------------------------------//\n", "\n", "\telse if( winNation->goal_population_achieved() )\n", "\t{\n", "\t\tstr  += translate.process( \" has Reached\" );\n", "\n", "\t\tstr2  = translate.process( \"its Population Goal of \" );\n", "\t\tstr2 += config.goal_population;\n", "\t\tstr2 += \" !\";\n", "\t}\n", "\n", "\t//-----------------------------------//\n", "\n", "\telse if( winNation->goal_economic_score_achieved() )\n", "\t{\n", "\t\tstr  += translate.process( \" has Reached\" );\n", "\n", "\t\tstr2  = translate.process( \"its Economic Score Goal of \" );\n", "\t\tstr2 += config.goal_economic_score;\n", "\t\tstr2 += \" !\";\n", "\t}\n", "\n", "\t//-----------------------------------//\n", "\n", "\telse if( winNation->goal_total_score_achieved() )\n", "\t{\n", "\t\tstr  += translate.process( \" has Reached\" );\n", "\n", "\t\tstr2  = translate.process( \"its Total Score Goal of \" );\n", "\t\tstr2 += config.goal_total_score;\n", "\t\tstr2 += \" !\";\n", "\t}\n", "\n", "\t//-----------------------------------//\n", "\n", "\telse\t\t\t// ( winNation->goal_destroy_nation_achieved() )\n", "\t{\n", "\t\tstr += translate.process( \" has Defeated All Other Kingdoms !\" );\n", "\t}\n", "\n", "\t//-----------------------------------//\n", "\n", "\tint y=40;\n", "\n", "\tif( winNationRecno != nation_array.player_recno )\n", "\t{\n", "\t\tfont_bible.center_put(0, 30, VGA_WIDTH-1, 60, \"You Have Lost the Game !\" );\n", "\t\ty=60;\n", "\t}\n", "\n", "\tfont_bible.center_put(0, y   , VGA_WIDTH-1, y+30, str  );\n", "\tfont_bible.center_put(0, y+30, VGA_WIDTH-1, y+60, str2 );\n", "}"]}, {"ghidra": ["\n", "void sys_yield(void)\n", "\n", "{\n", "  return;\n", "}\n", "\n"], "c": ["static void sys_yield()\n", "{\n", "\t#ifdef DEBUG\n", "\t\tis_yielding++;\n", "\t#endif\n", "\t\n", "\t//sys.yield();\n", "\t\n", "\t#ifdef DEBUG\n", "\t\tis_yielding = 0;\n", "\t#endif\n", "}"]}, {"ghidra": ["\n", "int sort_unit(void *a,void *b)\n", "\n", "{\n", "  short sVar1;\n", "  long lVar2;\n", "  \n", "  sVar1 = *(short *)a;\n", "  lVar2 = 0;\n", "  if ((0 < sVar1) &&\n", "     ((int)sVar1 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)) {\n", "    lVar2 = *(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                     ((int)sVar1 + -1) *\n", "                     unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  sVar1 = *(short *)b;\n", "  if ((0 < sVar1) &&\n", "     ((int)sVar1 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)) {\n", "    return (int)((uint)*(ushort *)(lVar2 + 0x2f) -\n", "                (uint)*(ushort *)\n", "                       (*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                  body_buf +\n", "                                 ((int)sVar1 + -1) *\n", "                                 unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                 ele_size) + 0x2f));\n", "  }\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static int sort_unit( const void *a, const void *b )\n", "{\n", "\tUnit* unitPtr1 = (Unit*) unit_array[*((short*)a)];\n", "\tUnit* unitPtr2 = (Unit*) unit_array[*((short*)b)];\n", "\n", "\treturn unitPtr1->name_id - unitPtr2->name_id;\n", "}"]}, {"ghidra": ["\n", "void put_attack_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  char *textPtr;\n", "  short *psVar1;\n", "  \n", "  y = y + 3;\n", "  psVar1 = &cur_nation_ptr->ai_attack_target_x_loc + (long)recNo * 5;\n", "  textPtr = format(&misc,(int)psVar1[-2],1);\n", "  put(&font_san,x + 3,y,textPtr,'\\0',-1);\n", "  textPtr = format(&misc,(int)psVar1[-1],1);\n", "  put(&font_san,x + 0x7b,y,textPtr,'\\0',-1);\n", "  textPtr = format(&misc,(int)*psVar1,1);\n", "  put(&font_san,x + 0xdf,y,textPtr,'\\0',-1);\n", "  textPtr = date_str(&date,(long)*(int *)(psVar1 + 1),0);\n", "  put(&font_san,x + 0x157,y,textPtr,'\\0',-1);\n", "  return;\n", "}\n", "\n"], "c": ["static void put_attack_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tAttackCamp* attackCamp = cur_nation_ptr->attack_camp_array+recNo-1;\n", "\n", "\t//---------- display info ----------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tfont_san.put( x\t , y, attackCamp->firm_recno );\n", "\tfont_san.put( x+120, y, attackCamp->combat_level );\n", "\tfont_san.put( x+220, y, attackCamp->distance );\n", "\tfont_san.put( x+340, y, date.date_str(attackCamp->patrol_date) );\n", "}"]}, {"ghidra": ["\n", "int spy_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  int iVar3;\n", "  short *psVar4;\n", "  \n", "  if (spy_array.super_DynArrayB.super_DynArray.last_ele < 1) {\n", "    return 0;\n", "  }\n", "  iVar2 = 0;\n", "  psVar4 = (short *)(spy_array.super_DynArrayB.super_DynArray.body_buf +\n", "                    spy_array.super_DynArrayB.super_DynArray.ele_size *\n", "                    (spy_array.super_DynArrayB.super_DynArray.last_ele + -1));\n", "  iVar3 = spy_array.super_DynArrayB.super_DynArray.last_ele;\n", "  do {\n", "    iVar1 = iVar3 + -1;\n", "    if (*psVar4 != 0) {\n", "      if ((*(char *)(psVar4 + 1) == '\\x02') && (*(short *)((long)psVar4 + 3) == if_town_recno)) {\n", "        iVar2 = iVar2 + (uint)((short)*(char *)((long)psVar4 + 7) == nation_array.player_recno);\n", "      }\n", "      if ((iVar2 == recNo) && (recNo != 0)) {\n", "        return iVar3;\n", "      }\n", "    }\n", "    psVar4 = (short *)((long)psVar4 + (long)-spy_array.super_DynArrayB.super_DynArray.ele_size);\n", "    if (iVar1 == 0) {\n", "      return iVar2;\n", "    }\n", "    iVar3 = iVar1;\n", "  } while (iVar1 <= spy_array.super_DynArrayB.super_DynArray.last_ele);\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static int spy_filter(int recNo)\n", "{\n", "\tint  totalSpy = spy_array.size();\n", "\tint  spyCount=0;\n", "\tSpy* spyPtr;\n", "\n", "\tfor( int spyRecno=1 ; spyRecno<=totalSpy ; spyRecno++ )\n", "\t{\n", "\t\tif( spy_array.is_deleted(spyRecno) )\n", "\t\t\tcontinue;\n", "\n", "\t\tspyPtr = spy_array[spyRecno];\n", "\n", "\t\tif( spyPtr->true_nation_recno==info.viewing_nation_recno )\n", "\t\t\tspyCount++;\n", "\n", "\t\tif( recNo && spyCount==recNo )\n", "\t\t\treturn spyRecno;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn spyCount;\n", "}"]}, {"ghidra": ["\n", "void put_expense_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  char *textPtr;\n", "  char *expense_des_array [16];\n", "  \n", "  y = y + 3;\n", "  iVar2 = (int)info.viewing_nation_recno;\n", "  if ((0 < iVar2) && (iVar2 <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    lVar1 = *(long *)(nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (iVar2 + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    put(&font_san,x + 3,y,expense_des_array[recNo + -1],'\\0',-1);\n", "    lVar1 = lVar1 + (long)recNo * 4;\n", "    textPtr = format(&misc,(int)(((float)(0x16d - info.year_day) * *(float *)(lVar1 + 0x126)) /\n", "                                 365.00000000 + *(float *)(lVar1 + 0xe6)),2);\n", "    put(&font_san,x + 0x175,y,textPtr,'\\0',-1);\n", "    return;\n", "  }\n", "  put(&font_san,x + 3,y,expense_des_array[recNo + -1],'\\0',-1);\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static void put_expense_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\t//----- define expense descriptions -------//\n", "\n", "\tstatic const char* expense_des_array[EXPENSE_TYPE_COUNT] =\n", "\t{\n", "\t\t\"General Costs\",\n", "\t\t\"Spy Costs\",\n", "\t\t\"Other Mobile Human Unit Costs\",\n", "\t\t\"Caravan Costs\",\n", "\t\t\"Weapons Costs\",\n", "\t\t\"Ship Costs\",\n", "\t\t\"Buildings Costs\",\n", "\t\t\"Training Units\",\n", "\t\t\"Hiring Units\",\n", "\t\t\"Honoring Units\",\n", "\t\t\"Foreign Worker Salaries\",\n", "\t\t\"Grants to Your Villagers\",\n", "\t\t\"Grants to Other Villagers\",\n", "\t\t\"Imports\",\n", "\t\t\"Aid/Tribute to Other Kingdoms\",\n", "\t\t\"Bribes\",\n", "\t};\n", "\n", "\t//---------------------------------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tNation* nationPtr = nation_array[info.viewing_nation_recno];\n", "\n", "\tfont_san.put( x    , y, expense_des_array[recNo-1] );\n", "\tfont_san.put( x+370, y, misc.format( (int) nationPtr->expense_365days(recNo-1), 2 ) );\n", "}"]}, {"ghidra": ["\n", "void write_ai_info(File *filePtr,short *aiInfoArray,short aiInfoCount,short aiInfoSize)\n", "\n", "{\n", "  file_put_short(filePtr,aiInfoCount);\n", "  file_put_short(filePtr,aiInfoSize);\n", "  file_write(filePtr,aiInfoArray,(int)aiInfoCount * 2);\n", "  return;\n", "}\n", "\n"], "c": ["static void write_ai_info(File* filePtr, short* aiInfoArray, short aiInfoCount, short aiInfoSize)\n", "{\n", "\tfilePtr->file_put_short( aiInfoCount );\n", "\tfilePtr->file_put_short( aiInfoSize  );\n", "\tfilePtr->file_write( aiInfoArray, sizeof(short) * aiInfoCount );\n", "}"]}, {"ghidra": ["\n", "void i_disp_queue_button(ButtonCustom *button,int repaintBody)\n", "\n", "{\n", "  char cVar1;\n", "  void *pvVar2;\n", "  char *desStr;\n", "  int x1;\n", "  int iVar3;\n", "  int y1;\n", "  short sVar4;\n", "  int x2;\n", "  int y2;\n", "  \n", "  pvVar2 = (button->custom_para).ptr;\n", "  x1 = (int)button->x1;\n", "  y1 = (int)button->y1;\n", "  x2 = (int)button->x2;\n", "  y2 = (int)button->y2;\n", "  if (button->pushed_flag == '\\0') {\n", "    if (repaintBody != 0) {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      d3_panel2_up(&vga_util,x1,y1,x2,y2,1,1);\n", "    }\n", "    x2 = x2 + -1;\n", "    y2 = y2 + -1;\n", "    iVar3 = x1;\n", "  }\n", "  else {\n", "    if (repaintBody == 0) {\n", "      iVar3 = x1 + 1;\n", "      y1 = y1 + 1;\n", "    }\n", "    else {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      iVar3 = x1 + 1;\n", "      d3_panel2_down(&vga_util,x1,y1,x2,y2,1,1);\n", "      y1 = y1 + 1;\n", "    }\n", "  }\n", "  sVar4 = (short)(button->custom_para).value;\n", "  if (*(char *)((long)pvVar2 + 0x124) < '\\x01') {\n", "    x1 = 0;\n", "  }\n", "  else {\n", "    desStr = (char *)((long)pvVar2 + 0x110);\n", "    x1 = 0;\n", "    do {\n", "      cVar1 = *desStr;\n", "      desStr = desStr + 1;\n", "      x1 = x1 + (uint)((short)cVar1 == sVar4);\n", "    } while (desStr != (char *)((long)pvVar2 +\n", "                               (ulong)((int)*(char *)((long)pvVar2 + 0x124) - 1) + 0x111));\n", "  }\n", "  desStr = format(&misc,x1 + (uint)(*(short *)((long)pvVar2 + 0x106) == sVar4),1);\n", "  center_put(&font_mid,iVar3 + 3,y1 + 3,x2 + -3,y2 + -3,desStr,'\\x01');\n", "  return;\n", "}\n", "\n"], "c": ["static void i_disp_queue_button(ButtonCustom *button, int repaintBody)\n", "{\n", "\tFirmHarbor *harbor= (FirmHarbor *)button->custom_para.ptr;\n", "\n", "\tint x1 = button->x1;\n", "\tint y1 = button->y1;\n", "\tint x2 = button->x2;\n", "\tint y2 = button->y2;\n", "\tif( !button->pushed_flag )\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_up( x1, y1, x2, y2, 1, 1);\n", "\t\t}\n", "\t\tx2--;\n", "\t\ty2--;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_down( x1, y1, x2, y2, 1, 1);\n", "\t\t}\n", "\t\tx1++;\n", "\t\ty1++;\n", "\t}\n", "\n", "\t//----- count the no. of units queued for this weapon ------//\n", "\n", "\tshort unitId = button->custom_para.value;\n", "\tint queuedCount=0;\n", "\tfor( int i=0 ; i<harbor->build_queue_count ; i++ )\n", "\t{\n", "\t\tif( harbor->build_queue_array[i] == unitId )\n", "\t\t\tqueuedCount++;\n", "\t}\n", "\tif( harbor->build_unit_id == unitId)\n", "\t\tqueuedCount++;\n", "\n", "\tfont_mid.center_put( x1+3, y1+3, x2-3, y2-3, misc.format(queuedCount), 1);\n", "}"]}, {"ghidra": ["\n", "void put_troop_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  short sVar1;\n", "  long lVar2;\n", "  Unit *this;\n", "  int inNum;\n", "  char *bitmapPtr;\n", "  undefined4 extraout_var;\n", "  int y_00;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  inNum = troop_filter(recNo);\n", "  if ((inNum < 1) || (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < inNum))\n", "  {\n", "    do {\n", "      invalidInstructionException();\n", "    } while( true );\n", "  }\n", "  this = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                   (inNum + -1) *\n", "                   unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "  bitmapPtr = get_small_icon_ptr(unit_res.unit_info_array + (long)this->unit_id + -1,this->rank_id);\n", "  y_00 = y + 5;\n", "  put_bitmap(&vga_back,x + 3,y + 1,bitmapPtr);\n", "  inNum = (*(this->super_Sprite)._vptr_Sprite[0xf])(this);\n", "  put(&font_san,x + 0x1f,y_00,(char *)CONCAT44(extraout_var,inNum),'\\0',0xee);\n", "  inNum = get_skill(&this->skill,2);\n", "  bitmapPtr = format(&misc,inNum,1);\n", "  put(&font_san,x + 0xf3,y_00,bitmapPtr,'\\0',-1);\n", "  if (this->rank_id != '\\x02') {\n", "    bitmapPtr = format(&misc,(int)this->loyalty,1);\n", "    put(&font_san,x + 0x12a,y_00,bitmapPtr,'\\0',-1);\n", "  }\n", "  String(&str);\n", "  operator_(&str,(long)(int)this->hit_points);\n", "  operator__(&str,\"/\");\n", "  operator__(&str,(long)this->max_hit_points);\n", "  put(&font_san,x + 0x163,y_00,(char *)&str,'\\0',-1);\n", "  inNum = commanded_soldier_count(this);\n", "  bitmapPtr = format(&misc,inNum,1);\n", "  put(&font_san,x + 0x1c0,y_00,bitmapPtr,'\\0',-1);\n", "  if (this->unit_mode == '\\x01') {\n", "    sVar1 = this->unit_mode_para;\n", "    if ((sVar1 < 1) || (firm_array.super_DynArrayB.super_DynArray.last_ele < (int)sVar1)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    if (*(char *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                           ((int)sVar1 + -1) * firm_array.super_DynArrayB.super_DynArray.ele_size) +\n", "                 8) == '\\x05') {\n", "      bitmapPtr = \"In Fort\";\n", "    }\n", "    else {\n", "      bitmapPtr = (char *)0x0;\n", "      if (*(char *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                             ((int)sVar1 + -1) * firm_array.super_DynArrayB.super_DynArray.ele_size)\n", "                   + 8) == '\\x01') {\n", "        bitmapPtr = \"In Seat\";\n", "      }\n", "    }\n", "  }\n", "  else {\n", "    bitmapPtr = \"Mobile\";\n", "    if (this->unit_mode == '\\x06') {\n", "      bitmapPtr = \"On Ship\";\n", "    }\n", "  }\n", "  put(&font_san,x + 0x1e9,y_00,bitmapPtr,'\\0',-1);\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_troop_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint   unitRecno = troop_filter(recNo);\n", "\tUnit* unitPtr   = unit_array[unitRecno];\n", "\n", "\t//---------- display bitmap ----------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tvga_back.put_bitmap( x, y-2, unit_res[unitPtr->unit_id]->get_small_icon_ptr(unitPtr->rank_id) );\n", "\n", "\t//-------- display name & team size -------//\n", "\n", "\ty+=2;\n", "\n", "\tfont_san.put( x+28 , y, unitPtr->unit_name(), 0, 238 );\n", "\tfont_san.put( x+240, y, unitPtr->skill.get_skill(SKILL_LEADING) );\n", "\n", "\tif( unitPtr->rank_id != RANK_KING )\n", "\t\tfont_san.put( x+295, y, unitPtr->loyalty );\n", "\n", "\t//--------- display hit points -----------//\n", "\n", "\tString str;\n", "\n", "\tstr  = (int) unitPtr->hit_points;\n", "\tstr += \"/\";\n", "\tstr += unitPtr->max_hit_points;\n", "\n", "\tfont_san.put( x+352, y, str );\n", "\n", "\t//---- display the no. of soldiers led by this general ---//\n", "\n", "\tfont_san.put( x+445, y, unitPtr->commanded_soldier_count() );\n", "\n", "\t//---- display the status of the general ----//\n", "\n", "\tconst char* statusStr;\n", "\n", "\tif( unitPtr->unit_mode == UNIT_MODE_OVERSEE )\n", "\t{\n", "\t\tint firmId = firm_array[ unitPtr->unit_mode_para ]->firm_id;\n", "\n", "\t\tif( firmId == FIRM_CAMP )\n", "\t\t\tstatusStr = \"In Fort\";\n", "\n", "\t\telse if( firmId == FIRM_BASE )\n", "\t\t\tstatusStr = \"In Seat\";\n", "\n", "\t\telse\n", "\t\t\terr_here();\n", "\t}\n", "\telse if( unitPtr->unit_mode == UNIT_MODE_ON_SHIP )\n", "\t{\n", "\t\tstatusStr = \"On Ship\";\n", "\t}\n", "\telse\n", "\t{\n", "\t\tstatusStr = \"Mobile\";\n", "\t}\n", "\n", "#if(defined(FRENCH))\n", "\tfont_san.put( x+470, y, statusStr );\n", "#else\n", "\t// German and US\n", "\tfont_san.put( x+486, y, statusStr );\n", "#endif\n", "}"]}, {"ghidra": ["\n", "void put_unit_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  int iVar1;\n", "  char *textPtr;\n", "  int inNum;\n", "  long lVar2;\n", "  \n", "  lVar2 = 0;\n", "  inNum = (int)info.viewing_nation_recno;\n", "  if ((inNum < 1) || (nation_array.super_DynArrayB.super_DynArray.last_ele < inNum)) {\n", "    iVar1 = unit_filter(recNo);\n", "  }\n", "  else {\n", "    lVar2 = *(long *)(nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (inNum + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    iVar1 = unit_filter(recNo);\n", "  }\n", "  if (iVar1 == -1) {\n", "    inNum = *(int *)(lVar2 + 0x5b0);\n", "    textPtr = \"Human General\";\n", "  }\n", "  else {\n", "    textPtr = (char *)(unit_res.unit_info_array + (long)iVar1 + -1);\n", "    inNum = (int)*(short *)(((UnitInfo *)textPtr)->name + ((long)(inNum + -1) + 0x38) * 2);\n", "  }\n", "  put(&font_san,x + 3,y + 3,textPtr,'\\0',-1);\n", "  textPtr = format(&misc,inNum,1);\n", "  put(&font_san,x + 0x143,y + 3,textPtr,'\\0',-1);\n", "  return;\n", "}\n", "\n"], "c": ["static void put_unit_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint   \t unitId = unit_filter(recNo);\n", "\tint   \t unitCount;\n", "\tconst char* \t str;\n", "\tUnitInfo* unitInfo;\n", "\tNation* nationPtr = nation_array[info.viewing_nation_recno];\n", "\tint rc = unit_filter(recNo);\n", "\n", "\tswitch( rc )\n", "\t{\n", "\t\t//------- count human units -------//\n", "\n", "\t\tcase -1:\n", "\t\t\tstr\t\t  = \"Human General\";\n", "\t\t\tunitCount  = nationPtr->total_general_count;\n", "\t\t\tbreak;\n", "\n", "\t\tdefault:\n", "\t\t\tunitInfo   = unit_res[rc];\n", "\t\t\tstr \t\t  = unitInfo->name;\n", "\t\t\tunitCount  = unitInfo->nation_unit_count_array[ info.viewing_nation_recno-1 ];\n", "\t}\n", "\n", "\t//---------- display info --------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tfont_san.put( x   , y, str );\n", "\tfont_san.put( x+320, y, misc.format(unitCount,1) );\n", "}"]}, {"ghidra": ["\n", "int sort_scenario_func(void *arg1,void *arg2)\n", "\n", "{\n", "  return (int)*(short *)((long)arg1 + 0x5a) - (int)*(short *)((long)arg2 + 0x5a);\n", "}\n", "\n"], "c": ["int sort_scenario_func(const void *arg1, const void *arg2)\n", "{\n", "\treturn ((ScenInfo *)arg1)->goal_difficulty - ((ScenInfo *)arg2)->goal_difficulty;\n", "}"]}, {"ghidra": ["\n", "void put_spy_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  int y2;\n", "  int x2;\n", "  int y1;\n", "  int iVar1;\n", "  RaceInfo *pRVar2;\n", "  char *textPtr;\n", "  Spy *this;\n", "  int x2_00;\n", "  int local_3c;\n", "  \n", "  this = (Spy *)0x0;\n", "  x2 = x + -1 + (int)browse_spy.super_VBrowse.rec_width;\n", "  y1 = spy_filter(recNo);\n", "  if ((0 < y1) && (y1 <= spy_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    this = (Spy *)(spy_array.super_DynArrayB.super_DynArray.body_buf +\n", "                  (y1 + -1) * spy_array.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  y1 = y + 1;\n", "  x2_00 = x + 0x1c;\n", "  y2 = y + 0x18;\n", "  if (refreshFlag == 10) {\n", "    d3_panel_down(&vga_util,x + 1,y1,x2_00,y2,0,0);\n", "    pRVar2 = operator__(&race_res,(int)this->race_id);\n", "    put_bitmap(&vga_front,x + 3,y + 3,pRVar2->icon_bitmap_ptr);\n", "  }\n", "  local_3c = x + 1;\n", "  iVar1 = in_area((MouseSDL *)&mouse,local_3c,y1,x2_00,y2);\n", "  if (iVar1 != 0) {\n", "    pRVar2 = operator__(&race_res,(int)this->race_id);\n", "    set_unit_help(&help,(int)pRVar2->basic_unit_id,0,local_3c,y1,x2_00,y2);\n", "  }\n", "  y1 = y + 6;\n", "  textPtr = format(&misc,(int)this->spy_skill,1);\n", "  put(&font_san,x + 0x28,y1,textPtr,'\\x01',x + 0x42);\n", "  textPtr = format(&misc,(int)this->spy_loyalty,1);\n", "  put(&font_san,x + 0x43,y1,textPtr,'\\x01',x + 0x5e);\n", "  blt_buf(&vga_util,x + 0x5f,y1,x2,y + 5 + (int)font_san.font_height,0);\n", "  textPtr = action_str(this);\n", "  center_put(&font_san,x + 0x5f,y1,x2,y + 5 + (int)font_san.font_height,textPtr,'\\0');\n", "  return;\n", "}\n", "\n"], "c": ["static void put_spy_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint  spyRecno = spy_filter(recNo);\n", "\tSpy* spyPtr   = spy_array[spyRecno];\n", "\n", "\tx+=3;\n", "\ty+=5;\n", "\n", "\t//------ display rank/skill icon -------//\n", "\n", "\tint \t cloakedRankId  = spyPtr->cloaked_rank_id();\n", "\tint \t cloakedSkillId = spyPtr->cloaked_skill_id();\n", "\tString str;\n", "\n", "\tswitch( cloakedRankId )\n", "\t{\n", "\t\tcase RANK_KING:\n", "\t\t\tstr = \"U_KING\";\n", "\t\t\tbreak;\n", "\n", "\t\tcase RANK_GENERAL:\n", "\t\t\tstr = \"U_GENE\";\n", "\t\t\tbreak;\n", "\n", "\t\tcase RANK_SOLDIER:\n", "\t\t\tif( cloakedSkillId )\n", "\t\t\t{\n", "\t\t\t\tstr  = \"U_\";\n", "\t\t\t\tstr += Skill::skill_code_array[cloakedSkillId-1];\n", "\t\t\t}\n", "\t\t\telse\n", "\t\t\t{\n", "\t\t\t\tstr = \"\";\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t}\n", "\n", "\tif( str.len() > 0 )\n", "\t\timage_icon.put_back(x, y+1, str);\n", "\n", "\t//------ display race icon -------------//\n", "\n", "\tvga_back.put_bitmap( x+13, y-4, race_res[spyPtr->race_id]->icon_bitmap_ptr );\n", "\n", "\t//----------- display name -----------//\n", "\n", "\tfont_san.put( x+39, y, race_res[spyPtr->race_id]->get_name(spyPtr->name_id), 0, 185 );\n", "\n", "\t//------- display cloaked nation color ------//\n", "\n", "\tint tx = x+170;\n", "\n", "\tif( spyPtr->cloaked_nation_recno==0 )\t\t// independent nation\n", "\t{\n", "\t\tvga_back.bar( tx, y, tx+12, y+12, V_WHITE );\n", "\t\tvga_back.rect( tx, y, tx+12, y+12, 1, VGA_GRAY+8 );\n", "\t}\n", "\telse\n", "\t{\n", "\t\tnation_array[spyPtr->cloaked_nation_recno]->disp_nation_color(tx, y+2);\n", "\t}\n", "\n", "\t//---------- display other info ----------//\n", "\n", "\tswitch( spyPtr->spy_place )\n", "\t{\n", "\t\tcase SPY_FIRM:\n", "\t\t\tstr = firm_res[firm_array[spyPtr->spy_place_para]->firm_id]->name;\n", "\t\t\tbreak;\n", "\n", "\t\tcase SPY_TOWN:\n", "\t\t\tstr = town_array[spyPtr->spy_place_para]->town_name();\n", "\t\t\tbreak;\n", "\n", "\t\tcase SPY_MOBILE:\n", "\t\t{\n", "\t\t\tUnit* unitPtr = unit_array[spyPtr->spy_place_para];\n", "\n", "\t\t\tswitch( unitPtr->unit_mode )\n", "\t\t\t{\n", "\t\t\t\tcase UNIT_MODE_CONSTRUCT:\n", "\t\t\t\t\tstr = firm_res[firm_array[unitPtr->unit_mode_para]->firm_id]->name;\n", "\t\t\t\t\tbreak;\n", "\n", "\t\t\t\tcase UNIT_MODE_ON_SHIP:\n", "\t\t\t\t\tstr = \"On Ship\";\n", "\t\t\t\t\tbreak;\n", "\n", "\t\t\t\tdefault:\n", "\t\t\t\t\tstr = \"Mobile\";\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\t}\n", "\n", "\t\tdefault:\n", "\t\t\tstr = \"\";\n", "\t}\n", "\n", "\tfont_san.put( x+205, y, str );\n", "\n", "\tfont_san.put( x+335, y, spyPtr->spy_skill );\n", "\tfont_san.put( x+385, y, spyPtr->spy_loyalty );\n", "\tfont_san.put( x+435, y, spyPtr->action_str() );\n", "}"]}, {"ghidra": ["\n", "void i_disp_caravan_select_button(ButtonCustom *button,int repaintBody)\n", "\n", "{\n", "  int rawId;\n", "  char cVar1;\n", "  int y1;\n", "  char *helpCode;\n", "  int x1;\n", "  \n", "  cVar1 = color_down;\n", "  x1 = (int)button->x1;\n", "  y1 = (int)button->y1;\n", "  if (button->pushed_flag == '\\0') {\n", "    d3_panel_up(active_buf,x1,y1,(int)button->x2,(int)button->y2,2,1);\n", "    rawId = (button->custom_para).value;\n", "  }\n", "  else {\n", "    color_down = -0x4c;\n", "    d3_panel_down(active_buf,x1,y1,(int)button->x2,(int)button->y2,2,1);\n", "    rawId = (button->custom_para).value;\n", "    color_down = cVar1;\n", "  }\n", "  if (rawId == 0) {\n", "    helpCode = \"AUTOPICK\";\n", "  }\n", "  else {\n", "    if (rawId != 7) {\n", "      if (rawId - 1U < 3) {\n", "        put_small_raw_icon(&raw_res,x1 + 3,y1 + 3,rawId);\n", "        return;\n", "      }\n", "      if (rawId - 4U < 3) {\n", "        put_small_product_icon(&raw_res,x1 + 3,y1 + 3,rawId + -3);\n", "        return;\n", "      }\n", "      return;\n", "    }\n", "    helpCode = \"NOPICK\";\n", "  }\n", "  set_help(&help,x1 + 3,y1 + 3,x1 + 0xc,y1 + 0xc,helpCode);\n", "  helpCode = read((ResourceIdx *)&image_icon,helpCode);\n", "  put_bitmap_trans(active_buf,x1 + 3,y1 + 3,helpCode);\n", "  return;\n", "}\n", "\n"], "c": ["static void i_disp_caravan_select_button(ButtonCustom *button, int repaintBody)\n", "{\n", "\tint x1 = button->x1;\n", "\tint y1 = button->y1;\n", "\tint x2 = button->x2;\n", "\tint y2 = button->y2;\n", "\tint shift;\n", "\n", "\t//------------- modify x1,y1, x2,y2 to the button body --------------//\n", "\tif(button->pushed_flag)\n", "\t{\n", "\t\tint colorDown = Vga::active_buf->color_down;\t\t// change the color of the body area to yellow to highlight the change\n", "\t\tVga::active_buf->color_down = (char) V_YELLOW;\n", "\n", "\t\tVga::active_buf->d3_panel_down(x1, y1, x2, y2);\n", "\n", "\t\tVga::active_buf->color_down = (char) colorDown;\n", "\n", "\t\tx1++;\n", "\t\ty1++;\n", "\t\tshift = 2;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tVga::active_buf->d3_panel_up(x1, y1, x2, y2);\n", "\t\tx2--;\n", "\t\ty2--;\n", "\t\tshift = 3;\n", "\t}\n", "\n", "\t//-------------- put goods icon ---------------//\n", "\n", "\tint id = button->custom_para.value;\n", "\tconst char *iconName=NULL;\n", "\n", "\tint x = x1+shift;\n", "\tint y = y1+shift;\n", "\n", "\tif(id==AUTO_PICK_UP)\n", "\t{\n", "\t\ticonName = \"AUTOPICK\";\n", "\t}\n", "\telse if(id==NO_PICK_UP)\n", "\t{\n", "\t\ticonName = \"NOPICK\";\n", "\t}\n", "\telse if(id>=PICK_UP_RAW_FIRST && id<=PICK_UP_RAW_LAST)\n", "\t{\n", "\t\traw_res.put_small_raw_icon( x, y, id-PICK_UP_RAW_FIRST+1 );\n", "\t}\n", "\telse if(id>=PICK_UP_PRODUCT_FIRST && id<=PICK_UP_PRODUCT_LAST)\n", "\t{\n", "\t\traw_res.put_small_product_icon( x, y, id-PICK_UP_PRODUCT_FIRST+1 );\n", "\t}\n", "\telse\n", "\t\terr_here();\n", "\n", "\tif( iconName )\n", "\t{\n", "\t\thelp.set_help( x, y, x+9, y+9, iconName );\n", "\t\tVga::active_buf->put_bitmap_trans( x, y, image_icon.get_ptr(iconName) );\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  bool bVar1;\n", "  bool bVar2;\n", "  int iVar3;\n", "  long lVar4;\n", "  long lVar5;\n", "  char *game_host;\n", "  EVP_PKEY_CTX *ctx;\n", "  EVP_PKEY_CTX *pEVar6;\n", "  EVP_PKEY_CTX *pEVar7;\n", "  EVP_PKEY_CTX *pEVar8;\n", "  bool bVar9;\n", "  byte bVar10;\n", "  \n", "  bVar10 = 0;\n", "  set_config_dir(&sys);\n", "  game_host = \"CONFIG.DAT\";\n", "  iVar3 = load(&config,\"CONFIG.DAT\");\n", "  if (iVar3 == 0) {\n", "    new_config_dat_flag = '\\x01';\n", "    init(&config,(EVP_PKEY_CTX *)game_host);\n", "  }\n", "  if (argc < 1) {\n", "    iVar3 = init(&sys,(EVP_PKEY_CTX *)game_host);\n", "    if (iVar3 == 0) {\n", "      return 0;\n", "    }\n", "  }\n", "  else {\n", "    iVar3 = 0;\n", "    bVar1 = false;\n", "    game_host = (char *)0x0;\n", "    bVar9 = true;\n", "LAB_0040351d:\n", "    do {\n", "      lVar4 = (long)iVar3;\n", "      lVar5 = 6;\n", "      pEVar7 = (EVP_PKEY_CTX *)argv[lVar4];\n", "      pEVar6 = pEVar7;\n", "      pEVar8 = (EVP_PKEY_CTX *)\"-join\";\n", "      do {\n", "        ctx = pEVar6;\n", "        if (lVar5 == 0) break;\n", "        lVar5 = lVar5 + -1;\n", "        ctx = pEVar6 + (ulong)bVar10 * -2 + 1;\n", "        bVar9 = *pEVar6 == *pEVar8;\n", "        pEVar6 = ctx;\n", "        pEVar8 = pEVar8 + (ulong)bVar10 * -2 + 1;\n", "      } while (bVar9);\n", "      if (bVar9) {\n", "        if (bVar1) {\n", "          return 1;\n", "        }\n", "        if (argc + -1 <= iVar3) {\n", "          return 1;\n", "        }\n", "        game_host = argv[lVar4 + 1];\n", "        iVar3 = iVar3 + 1;\n", "        bVar1 = true;\n", "LAB_00403515:\n", "        iVar3 = iVar3 + 1;\n", "        bVar9 = argc == iVar3;\n", "        bVar2 = bVar1;\n", "        if (argc <= iVar3) break;\n", "        goto LAB_0040351d;\n", "      }\n", "      lVar5 = 6;\n", "      pEVar6 = pEVar7;\n", "      pEVar8 = (EVP_PKEY_CTX *)\"-host\";\n", "      do {\n", "        ctx = pEVar6;\n", "        if (lVar5 == 0) break;\n", "        lVar5 = lVar5 + -1;\n", "        ctx = pEVar6 + (ulong)bVar10 * -2 + 1;\n", "        bVar9 = *pEVar6 == *pEVar8;\n", "        pEVar6 = ctx;\n", "        pEVar8 = pEVar8 + (ulong)bVar10 * -2 + 1;\n", "      } while (bVar9);\n", "      if (!bVar9) {\n", "        lVar5 = 6;\n", "        pEVar6 = (EVP_PKEY_CTX *)\"-name\";\n", "        do {\n", "          ctx = pEVar7;\n", "          if (lVar5 == 0) break;\n", "          lVar5 = lVar5 + -1;\n", "          ctx = pEVar7 + (ulong)bVar10 * -2 + 1;\n", "          bVar9 = *pEVar7 == *pEVar6;\n", "          pEVar7 = ctx;\n", "          pEVar6 = pEVar6 + (ulong)bVar10 * -2 + 1;\n", "        } while (bVar9);\n", "        if (bVar9) {\n", "          if (argc + -1 <= iVar3) {\n", "            return 1;\n", "          }\n", "          ctx = (EVP_PKEY_CTX *)argv[lVar4 + 1];\n", "          iVar3 = iVar3 + 1;\n", "          strncpy(config.player_name,(char *)ctx,0x14);\n", "          config.player_name[20] = '\\0';\n", "        }\n", "        goto LAB_00403515;\n", "      }\n", "      if (bVar1) {\n", "        return 1;\n", "      }\n", "      iVar3 = iVar3 + 1;\n", "      bVar1 = true;\n", "      bVar9 = argc == iVar3;\n", "      bVar2 = true;\n", "    } while (iVar3 < argc);\n", "    iVar3 = init(&sys,ctx);\n", "    if (iVar3 == 0) {\n", "      return 0;\n", "    }\n", "    err = extra_error_handler;\n", "    if (bVar2) {\n", "      multi_player_menu(&game,1,game_host);\n", "      goto LAB_004035a3;\n", "    }\n", "  }\n", "  err = extra_error_handler;\n", "  main_menu(&game);\n", "LAB_004035a3:\n", "  deinit(&sys);\n", "  return 1;\n", "}\n", "\n"], "c": ["int main(int argc, char **argv)\n", "{\n", "\tconst char *lobbyJoinCmdLine = \"-join\";\n", "\tconst char *lobbyHostCmdLine = \"-host\";\n", "\tconst char *lobbyNameCmdLine = \"-name\";\n", "\tchar *join_host = NULL;\n", "\tint lobbied = 0;\n", "\n", "\tsys.set_config_dir();\n", "\n", "\t//try to read from CONFIG.DAT, moved to AM.CPP\n", "\n", "\tif( !config.load(\"CONFIG.DAT\") )\n", "\t{\n", "\t\tnew_config_dat_flag = 1;\n", "\t\tconfig.init();\n", "\t}\n", "\n", "\t//----- read command line arguments -----//\n", "\n", "\tfor (int i = 0; i < argc; i++) {\n", "\t\tif (!strcmp(argv[i], lobbyJoinCmdLine)) {\n", "\t\t\tif (lobbied) {\n", "\t\t\t\tERR(\"You cannot specify multiple -host or -join options.\\n\");\n", "\t\t\t\treturn 1;\n", "\t\t\t}\n", "\t\t\tif (i >= argc - 1) {\n", "\t\t\t\tERR(\"The %s switch requires a hostname parameter.\\n\", lobbyJoinCmdLine);\n", "\t\t\t\treturn 1;\n", "\t\t\t}\n", "\t\t\tlobbied = 1;\n", "\t\t\tjoin_host = argv[i+1];\n", "\t\t\ti++;\n", "\t\t} else if (!strcmp(argv[i], lobbyHostCmdLine)) {\n", "\t\t\tif (lobbied) {\n", "\t\t\t\tERR(\"You cannot specify multiple -host or -join options.\\n\");\n", "\t\t\t\treturn 1;\n", "\t\t\t}\n", "\t\t\tlobbied = 1;\n", "\t\t} else if (!strcmp(argv[i], lobbyNameCmdLine)) {\n", "\t\t\tif (i >= argc - 1) {\n", "\t\t\t\tERR(\"The %s switch requires a hostname parameter.\\n\", lobbyNameCmdLine);\n", "\t\t\t\treturn 1;\n", "\t\t\t}\n", "\t\t\tstrncpy(config.player_name, argv[i+1], config.PLAYER_NAME_LEN);\n", "\t\t\tconfig.player_name[config.PLAYER_NAME_LEN] = 0;\n", "\t\t\ti++;\n", "\t\t}\n", "\t}\n", "\n", "#ifdef ENABLE_INTRO_VIDEO\n", "\t//----------- play movie ---------------//\n", "\n", "\tif (!sys.set_game_dir())\n", "\t\treturn 1;\n", "\n", "\tif (!lobbied)\n", "\t{\n", "\t\tString movieFileStr;\n", "\t\tmovieFileStr = DIR_MOVIE;\n", "\t\tmovieFileStr += \"INTRO.AVI\";\n", "\n", "\t\tvideo.set_skip_on_fail();\n", "\n", "\t\t// ###### begin Gilbert 29/10 #####//\n", "\t\tif( !misc.is_file_exist(\"SKIPAVI.SYS\") && misc.is_file_exist(movieFileStr) )\n", "\t\t// ###### end Gilbert 29/10 #####//\n", "\t\t{\n", "\t\t\t//---------- play the movie now ---------//\n", "\n", "\t\t\tvideo.init();\n", "\n", "\t\t\tif( video.init_success )\n", "\t\t\t{\n", "\t\t\t\tvideo.play_until_end( movieFileStr, hInstance, 60 );\n", "\t\t\t}\n", "\t\t\telse\n", "\t\t\t{\n", "\t\t\t\t// display a message box (note:sys.main_hwnd is not valid)\n", "\t\t\t\t// MessageBox( NULL, \"Cannot initialize ActiveMovie\",\n", "\t\t\t\t//   \"Seven Kingdoms\", MB_OK | MB_ICONWARNING | MB_DEFBUTTON1 | MB_TASKMODAL );\n", "\t\t\t}\n", "\n", "\t\t\tvideo.deinit();\n", "\t\t}\n", "\t}\n", "#endif // ENABLE_INTRO_VIDEO\n", "\n", "\tif( !sys.init() )\n", "\t\treturn FALSE;\n", "\n", "\terr.set_extra_handler( extra_error_handler );   // set extra error handler, save the game when a error happens\n", "\n", "\tif (!lobbied)\n", "\t\tgame.main_menu();\n", "#ifndef DISABLE_MULTI_PLAYER\n", "\telse\n", "\t\tgame.multi_player_menu(lobbied, join_host);\n", "#endif // DISABLE_MULTI_PLAYER\n", "\n", "\tsys.deinit();\n", "\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "int firm_filter(int recNo)\n", "\n", "{\n", "  FirmInfo *pFVar1;\n", "  int firmId;\n", "  int iVar2;\n", "  \n", "  firmId = 1;\n", "  iVar2 = 0;\n", "  while( true ) {\n", "    pFVar1 = operator__(&firm_res,firmId);\n", "    iVar2 = (iVar2 + 1) -\n", "            (uint)(*(short *)(pFVar1->name +\n", "                             ((long)((int)info.viewing_nation_recno + -1) + 0x28) * 2) == 0);\n", "    if ((iVar2 == recNo) && (recNo != 0)) break;\n", "    firmId = firmId + 1;\n", "    if (firmId == 0xb) {\n", "      return iVar2;\n", "    }\n", "  }\n", "  return firmId;\n", "}\n", "\n"], "c": ["static int firm_filter(int recNo)\n", "{\n", "\tint \t\t firmTypeCount=0;\n", "\tFirmInfo* firmInfo;\n", "\n", "\tfor( int firmId=1 ; firmId<=MAX_FIRM_TYPE ; firmId++ )\n", "\t{\n", "\t\tfirmInfo = firm_res[firmId];\n", "\n", "\t\tif( firmInfo->nation_firm_count_array[info.viewing_nation_recno-1] )\n", "\t\t\tfirmTypeCount++;\n", "\n", "\t\tif( recNo && firmTypeCount==recNo )\n", "\t\t\treturn firmId;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn firmTypeCount;\n", "}"]}, {"ghidra": ["\n", "void i_disp_research_button(ButtonCustom *button,int repaintBody)\n", "\n", "{\n", "  long lVar1;\n", "  char *bitmapPtr;\n", "  int inNum;\n", "  int x1;\n", "  int y1;\n", "  TechInfo *this;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  x1 = (int)button->x1;\n", "  y1 = (int)button->y1;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (button->pushed_flag == '\\0') {\n", "    d3_panel2_up(&vga_util,x1,y1,(int)button->x2,(int)button->y2,0,0);\n", "  }\n", "  else {\n", "    d3_panel2_down(&vga_util,x1,y1,(int)button->x2,(int)button->y2,0,0);\n", "    x1 = x1 + 1;\n", "    y1 = y1 + 1;\n", "  }\n", "  this = tech_res.tech_info_array + (long)(button->custom_para).value + -1;\n", "  bitmapPtr = tech_large_icon(this);\n", "  put_bitmap(active_buf,x1 + 4,y1 + 4,bitmapPtr);\n", "  String(&str);\n", "  bitmapPtr = tech_des(this);\n", "  operator_(&str,bitmapPtr);\n", "  inNum = (int)this->nation_tech_level_array\n", "               [(int)*(short *)((long)(button->custom_para).ptr + 0x13) + -1] + 1;\n", "  if (1 < inNum) {\n", "    operator__(&str,\" \");\n", "    bitmapPtr = roman_number(&misc,inNum);\n", "    operator__(&str,bitmapPtr);\n", "  }\n", "  put(&font_bible,x1 + 0x3a,y1 + 0xe,(char *)&str,'\\0',-1);\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void i_disp_research_button(ButtonCustom *button, int repaintBody)\n", "{\n", "\tint x1 = button->x1;\n", "\tint y1 = button->y1;\n", "\tint x2 = button->x2;\n", "\tint y2 = button->y2;\n", "\n", "\tif( button->pushed_flag )\n", "\t{\n", "\t\tvga_util.d3_panel2_down(x1, y1, x2, y2);\n", "\t\tx1++;\n", "\t\ty1++;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tvga_util.d3_panel2_up(x1, y1, x2, y2);\n", "\t\tx2--;\n", "\t\ty2--;\n", "\t}\n", "\n", "\t//--------------------------------------------//\n", "\n", "\tTechInfo* techInfo = tech_res[button->custom_para.value];\n", "\n", "\t// Vga::active_buf->d3_panel_down(x1+2, y1+2, x1+TECH_LARGE_ICON_WIDTH+7, y1+TECH_LARGE_ICON_HEIGHT+7, 2, 0 );\n", "\tVga::active_buf->put_bitmap(x1+4, y1+4, techInfo->tech_large_icon() );\n", "\n", "\t//------ display research description -------//\n", "\n", "\tString str;\n", "\n", "\tstr = techInfo->tech_des();\n", "\n", "\tFirm *firmPtr = (Firm *) button->custom_para.ptr;\n", "\tint researchVersion = techInfo->get_nation_tech_level(firmPtr->nation_recno)+1;\t\t// research the next non-researched version\n", "\n", "\tif( researchVersion > 1 )\n", "\t{\n", "\t\tstr += \" \";\n", "\t\tstr += misc.roman_number(researchVersion);\n", "\t}\n", "\n", "\tfont_bible.put( x1+TECH_LARGE_ICON_WIDTH+12, y1+14, str );\n", "}"]}, {"ghidra": ["\n", "int misc_mkdir(char *path)\n", "\n", "{\n", "  int iVar1;\n", "  int *piVar2;\n", "  uint uVar3;\n", "  \n", "  iVar1 = mkdir(path,0x1ff);\n", "  uVar3 = 1;\n", "  if (iVar1 == -1) {\n", "    piVar2 = __errno_location();\n", "    uVar3 = (uint)(*piVar2 == 0x11);\n", "  }\n", "  return (int)uVar3;\n", "}\n", "\n"], "c": ["int misc_mkdir(char *path)\n", "{\n", "#ifdef NO_WINDOWS\n", "   return mkdir(path, 0777) == -1 ? errno == EEXIST : 1;\n", "#else // WINDOWS\n", "   if (!path[2] && path[1] == ':' && isalpha(path[0]))\n", "   {\n", "      // don't try to make a drive letter path\n", "      // this actually works on windows, but not on Wine\n", "      return 1;\n", "   }\n", "   return !CreateDirectory(path, NULL) ?\n", "       GetLastError() == ERROR_ALREADY_EXISTS : 1;\n", "#endif\n", "}"]}, {"ghidra": ["\n", "short validate_firm(short firmRecno,uint flags)\n", "\n", "{\n", "  short sVar1;\n", "  \n", "  sVar1 = 0;\n", "  if ((((firmRecno != 0) && (0 < firmRecno)) &&\n", "      ((int)firmRecno <= firm_array.super_DynArrayB.super_DynArray.last_ele)) &&\n", "     (((*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                 ((int)firmRecno + -1) * firm_array.super_DynArrayB.super_DynArray.ele_size) != 0 &&\n", "       (sVar1 = firmRecno, (flags & 1) == 0)) &&\n", "      (sVar1 = 0,\n", "      *(short *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                          ((int)firmRecno + -1) * firm_array.super_DynArrayB.super_DynArray.ele_size\n", "                          ) + 0x13) == remote.nation_processing)))) {\n", "    sVar1 = firmRecno;\n", "  }\n", "  return sVar1;\n", "}\n", "\n"], "c": ["static short validate_firm(short firmRecno, unsigned flags)\n", "{\n", "\terr_when( !(flags & 1) && remote.nation_processing == 0);\n", "\tFirm* firmPtr;\n", "\tif( firmRecno && !firm_array.is_deleted(firmRecno) \n", "\t\t&& (firmPtr = firm_array[firmRecno]) \n", "\t\t&& ((flags & 1) || firmPtr->nation_recno == remote.nation_processing) )\n", "\t\treturn firmRecno;\n", "\telse\n", "\t\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int sort_attack_camp_function(void *a,void *b)\n", "\n", "{\n", "  return ((int)*(short *)((long)b + 2) - (int)*(short *)((long)b + 4)) -\n", "         ((int)*(short *)((long)a + 2) - (int)*(short *)((long)a + 4));\n", "}\n", "\n"], "c": ["static int sort_attack_camp_function( const void *a, const void *b )\n", "{\n", "\tint ratingA = ((AttackCamp*)a)->combat_level - ((AttackCamp*)a)->distance;\n", "\tint ratingB = ((AttackCamp*)b)->combat_level - ((AttackCamp*)b)->distance;\n", "\n", "\treturn ratingB - ratingA;\n", "}"]}, {"ghidra": ["\n", "void i_disp_queue_skill_button(ButtonCustom *button,int repaintBody)\n", "\n", "{\n", "  char cVar1;\n", "  void *pvVar2;\n", "  int iVar3;\n", "  char *desStr;\n", "  int x1;\n", "  int iVar4;\n", "  int y1;\n", "  short sVar5;\n", "  int x2;\n", "  int y2;\n", "  \n", "  pvVar2 = (button->custom_para).ptr;\n", "  x1 = (int)button->x1;\n", "  y1 = (int)button->y1;\n", "  x2 = (int)button->x2;\n", "  y2 = (int)button->y2;\n", "  if (button->pushed_flag == '\\0') {\n", "    if (repaintBody != 0) {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      d3_panel2_up(&vga_util,x1,y1,x2,y2,1,1);\n", "    }\n", "    x2 = x2 + -1;\n", "    y2 = y2 + -1;\n", "    iVar4 = x1;\n", "  }\n", "  else {\n", "    if (repaintBody == 0) {\n", "      iVar4 = x1 + 1;\n", "      y1 = y1 + 1;\n", "    }\n", "    else {\n", "      blt_buf(&vga_util,x1,y1,x2,y2,0);\n", "      iVar4 = x1 + 1;\n", "      d3_panel2_down(&vga_util,x1,y1,x2,y2,1,1);\n", "      y1 = y1 + 1;\n", "    }\n", "  }\n", "  sVar5 = (short)(button->custom_para).value;\n", "  if (*(char *)((long)pvVar2 + 0x26a) < '\\x01') {\n", "    x1 = 0;\n", "  }\n", "  else {\n", "    desStr = (char *)((long)pvVar2 + 0x256);\n", "    x1 = 0;\n", "    do {\n", "      cVar1 = *desStr;\n", "      desStr = desStr + 1;\n", "      x1 = x1 + (uint)((short)cVar1 == sVar5);\n", "    } while (desStr != (char *)((long)pvVar2 +\n", "                               (ulong)((int)*(char *)((long)pvVar2 + 0x26a) - 1) + 599));\n", "  }\n", "  iVar3 = (int)*(short *)((long)pvVar2 + 0x26b);\n", "  if (*(short *)((long)pvVar2 + 0x26b) != 0) {\n", "    if ((iVar3 < 1) ||\n", "       (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < iVar3)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    cVar1 = *(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf\n", "                               + (iVar3 + -1) *\n", "                                 unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                 ele_size) + 0x67);\n", "    if (((short)cVar1 == sVar5) ||\n", "       (((sVar5 == 6 &&\n", "         (*(short *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf\n", "                              + (iVar3 + -1) *\n", "                                unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size\n", "                              ) + 0x6f) != 0)) && (cVar1 == '\\0')))) {\n", "      x1 = x1 + 1;\n", "    }\n", "  }\n", "  desStr = format(&misc,x1,1);\n", "  center_put(&font_mid,iVar4 + 3,y1 + 3,x2 + -3,y2 + -3,desStr,'\\x01');\n", "  return;\n", "}\n", "\n"], "c": ["static void i_disp_queue_skill_button(ButtonCustom *button, int repaintBody)\n", "{\n", "\tTown *townPtr= (Town *)button->custom_para.ptr;\n", "\n", "\tint x1 = button->x1;\n", "\tint y1 = button->y1;\n", "\tint x2 = button->x2;\n", "\tint y2 = button->y2;\n", "\tif( !button->pushed_flag )\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_up( x1, y1, x2, y2, 1, 1);\n", "\t\t}\n", "\t\tx2--;\n", "\t\ty2--;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tif( repaintBody )\n", "\t\t{\n", "\t\t\tvga_util.blt_buf(x1, y1, x2, y2, 0);\n", "\t\t\tvga_util.d3_panel2_down( x1, y1, x2, y2, 1, 1);\n", "\t\t}\n", "\t\tx1++;\n", "\t\ty1++;\n", "\t}\n", "\n", "\t//----- count the no. of units queued for this skill ------//\n", "\n", "\tshort skillId = button->custom_para.value;\n", "\tint queuedCount=0;\n", "\tfor( int i=0 ; i<townPtr->train_queue_count ; i++ )\n", "\t{\n", "\t\tif( townPtr->train_queue_skill_array[i] == skillId )\n", "\t\t\tqueuedCount++;\n", "\t}\n", "\tif(townPtr->train_unit_recno)\n", "\t{\n", "\t\tUnit *unitPtr = unit_array[townPtr->train_unit_recno];\n", "\t\t// ##### begin Gilbert 10/10 #######//\n", "\t\tif(unitPtr->skill.skill_id==skillId\n", "\t\t\t//### begin alex 17/3 ###//\n", "\t\t\t//|| (unitPtr->spy_recno && skillId == SKILL_SPYING) )\n", "\t\t\t|| (skillId == SKILL_SPYING && unitPtr->spy_recno && unitPtr->skill.skill_id == 0) ) // 0 for spying-training\n", "\t\t\t //#### end alex 17/3 ####//\n", "\t\t\tqueuedCount++;\n", "\t\t// ##### end Gilbert 10/10 #######//\n", "\t}\n", "\n", "\tfont_mid.center_put( x1+3, y1+3, x2-3, y2-3, misc.format(queuedCount), 1);\n", "}"]}, {"ghidra": ["\n", "int cal_rectangle_lower_right_y(int refYLoc)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  \n", "  iVar1 = (int)rec_height;\n", "  if (move_scale != 1) {\n", "    iVar2 = iVar1 + -2;\n", "    if (iVar1 + -2 < 0) {\n", "      iVar2 = iVar1 + 1;\n", "    }\n", "    return refYLoc + (iVar2 >> 2) * 2;\n", "  }\n", "  return refYLoc + (iVar1 + -1) / 2;\n", "}\n", "\n"], "c": ["static int cal_rectangle_lower_right_y(int refYLoc)\n", "{\n", "\t// the rule:\trefYLoc + ((rec_height-move_scale)/(move_scale*2))*move_scale\n", "\tif(move_scale==1)\n", "\t\treturn refYLoc + (rec_height-1)/2;\n", "\telse // move_scale == 2\n", "\t\treturn refYLoc + ((rec_height-2)/4)*2;\n", "}"]}, {"ghidra": ["\n", "int sort_talk_msg(void *a,void *b)\n", "\n", "{\n", "  if (*(short *)b != *(short *)a) {\n", "    return *(int *)((long)b + 4) - *(int *)((long)a + 4);\n", "  }\n", "  return (int)(-(uint)(*(char *)((long)b + 8) == '\\0') | 1);\n", "}\n", "\n"], "c": ["static int sort_talk_msg( const void *a, const void *b )\n", "{\n", "\tif( ((TalkMsgDisp*)b)->recno == ((TalkMsgDisp*)a)->recno )\n", "\t\treturn ((TalkMsgDisp*)b)->is_reply ? 1 : -1;\n", "\n", "\treturn ((TalkMsgDisp*)b)->date - ((TalkMsgDisp*)a)->date;\n", "}"]}, {"ghidra": ["\n", "void put_ranking(int y,int nationRecno)\n", "\n", "{\n", "  char *textPtr;\n", "  int y2;\n", "  NationBase *this;\n", "  \n", "  this = (NationBase *)0x0;\n", "  if ((0 < nationRecno) && (nationRecno <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    this = *(NationBase **)\n", "            (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "            (nationRecno + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  disp_nation_color(this,0x14,y + 5);\n", "  textPtr = nation_name(this);\n", "  put(&font_bible,0x28,y,textPtr,'\\0',-1);\n", "  y2 = y + -1 + (int)font_bible.font_height;\n", "  textPtr = get_rank_pos_str(&info,1,nationRecno);\n", "  center_put(&font_bible,0x118,y,0x168,y2,textPtr,'\\0');\n", "  textPtr = get_rank_pos_str(&info,2,nationRecno);\n", "  center_put(&font_bible,0x186,y,0x1c7,y2,textPtr,'\\0');\n", "  textPtr = get_rank_pos_str(&info,3,nationRecno);\n", "  center_put(&font_bible,0x1ea,y,0x230,y2,textPtr,'\\0');\n", "  textPtr = get_rank_pos_str(&info,4,nationRecno);\n", "  center_put(&font_bible,0x246,y,0x294,y2,textPtr,'\\0');\n", "  textPtr = get_rank_pos_str(&info,5,nationRecno);\n", "  center_put(&font_bible,0x2b2,y,0x2ee,y2,textPtr,'\\0');\n", "  return;\n", "}\n", "\n"], "c": ["static void put_ranking(int y, int nationRecno)\n", "{\n", "\tNation* nationPtr = nation_array[nationRecno];\n", "\n", "\tint x=20;\n", "\n", "\tnationPtr->disp_nation_color(x, y+5);\n", "\n", "\tfont_bible.put( x+20, y, nationPtr->nation_name() );\n", "\n", "\tint y2 = y+font_bible.height()-1;\n", "\n", "\tfont_bible.center_put( x+260, y, x+340, y2, info.get_rank_pos_str(1, nationRecno) );\n", "\tfont_bible.center_put( x+370, y, x+435, y2, info.get_rank_pos_str(2, nationRecno) );\n", "\tfont_bible.center_put( x+470, y, x+540, y2, info.get_rank_pos_str(3, nationRecno) );\n", "\tfont_bible.center_put( x+562, y, x+640, y2, info.get_rank_pos_str(4, nationRecno) );\n", "\tfont_bible.center_put( x+670, y, x+730, y2, info.get_rank_pos_str(5, nationRecno) );\n", "}"]}, {"ghidra": ["\n", "int percent_to_slide_volume(int percentVolume)\n", "\n", "{\n", "  switch(percentVolume / 10) {\n", "  case 0:\n", "  case 1:\n", "  case 2:\n", "  case 3:\n", "  case 4:\n", "    return percentVolume / 5;\n", "  case 5:\n", "  case 6:\n", "  case 7:\n", "    return percentVolume + -0x28;\n", "  case 8:\n", "    return percentVolume * 2 + -0x78;\n", "  case 9:\n", "  case 10:\n", "    return percentVolume * 4 + -300;\n", "  default:\n", "    return percentVolume;\n", "  }\n", "}\n", "\n"], "c": ["static int percent_to_slide_volume(int percentVolume)\n", "{\n", "\tswitch(percentVolume/10)\n", "\t{\n", "\tcase 0:\n", "\tcase 1:\n", "\tcase 2:\n", "\tcase 3:\n", "\tcase 4:\n", "\t\treturn percentVolume/5;\n", "\n", "\tcase 5:\n", "\tcase 6:\n", "\tcase 7:\n", "\t\treturn percentVolume - 40;\n", "\n", "\tcase 8:\n", "\t\treturn (percentVolume-60) * 2;\n", "\n", "\tcase 9:\n", "\tcase 10:\n", "\t\treturn (percentVolume-75) * 4;\n", "\n", "\tdefault:\n", "\t\terr_here();\n", "\t\treturn percentVolume;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int locate_visible_ship(void)\n", "\n", "{\n", "  long lVar1;\n", "  Unit *this;\n", "  int iVar2;\n", "  int recNo;\n", "  int iVar3;\n", "  long in_FS_OFFSET;\n", "  short xLoc;\n", "  short yLoc;\n", "  \n", "  recNo = (int)unit_array.super_SpriteArray._58_2_;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar3 = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele + -1 +\n", "          (uint)(recNo == 0);\n", "  if (0 < iVar3) {\n", "    do {\n", "      recNo = recNo + 1;\n", "      if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo) {\n", "        recNo = 1;\n", "        iVar2 = is_deleted(&unit_array,1);\n", "        if (iVar2 == 0) goto LAB_004b0b20;\n", "      }\n", "      else {\n", "        iVar2 = is_deleted(&unit_array,recNo);\n", "        if (iVar2 == 0) {\n", "          if (recNo < 1) {\n", "code_r0x004b0b82:\n", "            do {\n", "              invalidInstructionException();\n", "            } while( true );\n", "          }\n", "LAB_004b0b20:\n", "          if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo)\n", "          goto code_r0x004b0b82;\n", "          this = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                           (recNo + -1) *\n", "                           unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "          if ((((-1 < (this->super_Sprite).cur_x) &&\n", "               ((short)this->nation_recno == nation_array.player_recno)) &&\n", "              (unit_res.unit_info_array[(long)this->unit_id + -1].unit_class == 'S')) &&\n", "             (iVar2 = get_cur_loc(this,&xLoc,&yLoc), iVar2 != 0)) {\n", "            go_loc(&world,(int)xLoc,(int)yLoc,1);\n", "            recNo = 1;\n", "            goto LAB_004b0bda;\n", "          }\n", "        }\n", "      }\n", "      iVar3 = iVar3 + -1;\n", "    } while (iVar3 != 0);\n", "  }\n", "  recNo = 0;\n", "LAB_004b0bda:\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return recNo;\n", "}\n", "\n"], "c": ["static int locate_visible_ship()\n", "{\n", "   int unitRecno = unit_array.selected_recno;\n", "   int checkSize = unit_array.size();\n", "   if(unitRecno)\n", "      checkSize--; // not include the selected unit\n", "\n", "   for( int i=checkSize ; i>0 ; i-- )\n", "   {\n", "      if( ++unitRecno > unit_array.size() )\n", "         unitRecno = 1;\n", "\n", "      if( unit_array.is_deleted(unitRecno) )\n", "         continue;\n", "\n", "      Unit* unitPtr = unit_array[unitRecno];\n", "      if(!unitPtr->is_visible()) // skip the case unit_mode==UNIT_MODE_IN_HARBOR in calling Unit::get_cur_loc()\n", "         continue;\n", "\n", "      if( unitPtr->nation_recno == nation_array.player_recno &&\n", "          unit_res[unitPtr->unit_id]->unit_class == UNIT_CLASS_SHIP )\n", "      {\n", "         short xLoc, yLoc;\n", "\n", "         if( unitPtr->get_cur_loc(xLoc, yLoc) )\n", "         {\n", "            world.go_loc(xLoc, yLoc, 1);\n", "            return 1;\n", "         }\n", "      }\n", "   }\n", "\n", "   return 0;\n", "}"]}, {"ghidra": ["\n", "void IMGbar16x16(char *imageBuf,int pitch,int x,int y,int color)\n", "\n", "{\n", "  int iVar1;\n", "  long *plVar2;\n", "  long lVar3;\n", "  \n", "  iVar1 = 0x10;\n", "  plVar2 = (long *)(imageBuf + (x + pitch * y));\n", "  lVar3 = (ulong)(byte)color * 0x101010101010101;\n", "  do {\n", "    *plVar2 = lVar3;\n", "    plVar2[1] = lVar3;\n", "    plVar2 = (long *)((long)plVar2 + (long)pitch);\n", "    iVar1 = iVar1 + -1;\n", "  } while (iVar1 != 0);\n", "  return;\n", "}\n", "\n"], "c": ["void IMGbar16x16(char* imageBuf, int pitch, int x, int y, int color)\n", "{\n", "\tint dest = y*pitch + x;\n", "\tfor (int j=0; j<16; ++j, dest+=pitch)\n", "\t{\n", "\t\tmemset( &imageBuf[dest], color, 16 );\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void disp_scroll_bar_func(SlideVBar *scroll,int param_2)\n", "\n", "{\n", "  short sVar1;\n", "  int y1;\n", "  int y2;\n", "  \n", "  sVar1 = rect_top(scroll);\n", "  y1 = (int)sVar1;\n", "  sVar1 = rect_bottom(scroll);\n", "  y2 = (int)sVar1;\n", "  bar(&vga_front,(int)scroll->scrn_x1,y1,(int)scroll->scrn_x2,y2,0xb5);\n", "  if (6 < y2 - y1) {\n", "    d3_panel_up(&vga_front,(int)scroll->scrn_x1,y1,(int)scroll->scrn_x2,y2,2,0);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void disp_scroll_bar_func(SlideVBar *scroll, int)\n", "{\n", "\tshort rectTop = scroll->rect_top();\n", "\tshort rectBottom = scroll->rect_bottom();\n", "\tvga_util.blt_buf(scroll->scrn_x1, scroll->scrn_y1, scroll->scrn_x2, scroll->scrn_y2, 0);\n", "\tvga_front.bar( scroll->scrn_x1, rectTop, scroll->scrn_x2, rectBottom, VGA_YELLOW+1);\n", "\tif( rectBottom - rectTop > 6 )\n", "\t{\n", "\t\tvga_front.d3_panel_up(scroll->scrn_x1, rectTop, scroll->scrn_x2, rectBottom,2,0);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void __thiscall disp_button(Unit *this,int dispY1)\n", "\n", "{\n", "  BYTE BVar1;\n", "  short sVar2;\n", "  BYTE BVar3;\n", "  int firmId;\n", "  int iVar4;\n", "  FirmInfo *this_00;\n", "  uint pX1;\n", "  uint pX1_00;\n", "  char *buttonName;\n", "  \n", "  if (((nation_array.player_recno != 0) && (nation_array.player_recno == (short)this->nation_recno))\n", "     && (((nation_array.player_ptr)->super_NationBase).king_unit_recno == 0)) {\n", "    if (this->race_id == '\\0') {\n", "      return;\n", "    }\n", "    create(&button_succeed_king,0x24a,dispY1,'A',\"SUCCEED\",'\\x01','\\0');\n", "    paint(&button_succeed_king,-1);\n", "    return;\n", "  }\n", "  buttonName = \"AGGRESS0\";\n", "  if (this->aggressive_mode != '\\0') {\n", "    buttonName = \"AGGRESS1\";\n", "  }\n", "  create(&button_aggressive_mode,0x24a,dispY1,'A',buttonName,'\\x01','\\0');\n", "  paint(&button_aggressive_mode,-1);\n", "  pX1_00 = 0x27e;\n", "  if ((unit_res.unit_info_array[(long)this->unit_id + -1].unit_class != 'H') ||\n", "     (this->race_id == '\\0')) goto LAB_004ed917;\n", "  firmId = 1;\n", "  do {\n", "    sVar2 = (this->super_Sprite).sprite_recno;\n", "    this_00 = operator__(&firm_res,firmId);\n", "    iVar4 = can_build(this_00,(int)sVar2);\n", "    if (iVar4 != 0) {\n", "      if ((short)this->nation_recno == nation_array.player_recno) {\n", "        pX1 = 0x2b2;\n", "        create(&button_build,0x27e,dispY1,'A',\"BUILD\",'\\x01','\\0');\n", "        paint(&button_build,-1);\n", "        goto LAB_004edaf8;\n", "      }\n", "      break;\n", "    }\n", "    firmId = firmId + 1;\n", "  } while (firmId != 0xb);\n", "  button_build.init_flag = '\\0';\n", "  pX1 = 0x27e;\n", "LAB_004edaf8:\n", "  if (((this->super_Sprite).mobile_type == 'L') && (this->rank_id != '\\x02')) {\n", "    pX1_00 = pX1 + 0x34;\n", "    create(&button_settle,pX1,dispY1,'A',\"SETTLE\",'\\x01','\\0');\n", "    paint(&button_settle,-1);\n", "  }\n", "  else {\n", "    button_settle.init_flag = '\\0';\n", "    pX1_00 = pX1;\n", "  }\n", "  button_promote.init_flag = '\\0';\n", "  button_demote.init_flag = '\\0';\n", "  if ((short)this->nation_recno == nation_array.player_recno) {\n", "    if (this->rank_id == '\\0') {\n", "      pX1 = pX1_00;\n", "      if ((this->skill).skill_id == '\\x02') {\n", "        if (unit_array.selected_count == 1) {\n", "          create(&button_promote,pX1_00,dispY1,'A',\"PROMOTE\",'\\x01','\\0');\n", "          paint(&button_promote,-1);\n", "          goto LAB_004edd86;\n", "        }\n", "        goto LAB_004edd22;\n", "      }\n", "    }\n", "    else {\n", "      if ((this->rank_id == '\\x01') && (unit_array.selected_count == 1)) {\n", "        create(&button_demote,pX1_00,dispY1,'A',\"DEMOTE\",'\\x01','\\0');\n", "        paint(&button_demote,-1);\n", "LAB_004edd86:\n", "        pX1_00 = pX1_00 + 0x34;\n", "        if (0x2e7 < pX1_00) {\n", "          dispY1 = dispY1 + 0x2b;\n", "          pX1_00 = 0x24a;\n", "        }\n", "        if (nation_array.player_recno != (short)this->nation_recno) goto LAB_004edb29;\n", "      }\n", "LAB_004edd22:\n", "      pX1 = pX1_00;\n", "      if (this->rank_id == '\\x02') goto LAB_004edb29;\n", "    }\n", "    pX1_00 = pX1 + 0x34;\n", "    create(&button_reward,pX1,dispY1,'A',\"REWARD\",'\\x01','\\0');\n", "    paint(&button_reward,-1);\n", "    if (0x2e7 < pX1_00) {\n", "      dispY1 = dispY1 + 0x2b;\n", "      pX1_00 = 0x24a;\n", "    }\n", "  }\n", "  else {\n", "LAB_004edb29:\n", "    button_reward.init_flag = '\\0';\n", "  }\n", "  firmId = (int)this->home_camp_firm_recno;\n", "  if (this->home_camp_firm_recno != 0) {\n", "    if ((firmId < 1) || (firm_array.super_DynArrayB.super_DynArray.last_ele < firmId)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    BVar1 = *(BYTE *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                               (firmId + -1) * firm_array.super_DynArrayB.super_DynArray.ele_size) +\n", "                     0x2d);\n", "    BVar3 = region_id(this);\n", "    if (BVar1 == BVar3) {\n", "      pX1 = pX1_00 + 0x34;\n", "      create(&button_return_camp,pX1_00,dispY1,'A',\"RETCAMP\",'\\x01','\\0');\n", "      paint(&button_return_camp,-1);\n", "      pX1_00 = pX1;\n", "      if (0x2e7 < pX1) {\n", "        dispY1 = dispY1 + 0x2b;\n", "        pX1_00 = 0x24a;\n", "      }\n", "      goto LAB_004ed917;\n", "    }\n", "  }\n", "  button_return_camp.init_flag = '\\0';\n", "LAB_004ed917:\n", "  if ((this->spy_recno == 0) ||\n", "     (firmId = true_nation_recno(this), firmId != (int)nation_array.player_recno)) {\n", "    button_spy_notify.init_flag = '\\0';\n", "    button_spy_drop_identity.init_flag = '\\0';\n", "  }\n", "  else {\n", "    sVar2 = this->spy_recno;\n", "    if ((sVar2 < 1) || (spy_array.super_DynArrayB.super_DynArray.last_ele < (int)sVar2)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    buttonName = \"SPYNOTI0\";\n", "    if (spy_array.super_DynArrayB.super_DynArray.body_buf\n", "        [(long)(((int)sVar2 + -1) * spy_array.super_DynArrayB.super_DynArray.ele_size) + 9] != '\\0')\n", "    {\n", "      buttonName = \"SPYNOTI1\";\n", "    }\n", "    create(&button_spy_notify,pX1_00,dispY1,'A',buttonName,'\\x01','\\0');\n", "    paint(&button_spy_notify,-1);\n", "    pX1_00 = pX1_00 + 0x34;\n", "    if (0x2e7 < pX1_00) {\n", "      dispY1 = dispY1 + 0x2b;\n", "      pX1_00 = 0x24a;\n", "    }\n", "    create(&button_spy_drop_identity,pX1_00,dispY1,'A',\"NOSPY\",'\\x01','\\0');\n", "    paint(&button_spy_drop_identity,-1);\n", "  }\n", "  if (sys.debug_session == '\\0') {\n", "    return;\n", "  }\n", "  paint_text(&button_change_color,0x24a,0x239,\"Change Nation Color\",'\\x01','\\0');\n", "  return;\n", "}\n", "\n"], "c": ["static void disp_button()\n", "{\n", "\tint x=REPORT_BUTTON_X1;\n", "\n", "\tfor( int i=1 ; i<=MAX_NATION_REPORT_MODE ; i++ )\n", "\t{\n", "\t\tif( i==NATION_REPORT_DEBUG )\n", "\t\t{\n", "\t\t\tif( remote.is_enable() ||\n", "\t\t\t\t ( !sys.debug_session && !sys.testing_session ) )\n", "\t\t\t{\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t}\n", "\t\telse if( !sys.debug_session && i==NATION_REPORT_CHAT )\n", "\t\t{\n", "\t\t\tif( !remote.is_enable() )\n", "\t\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\t//-----------------------------------------//\n", "\n", "\t\tif( info.nation_report_mode == i )\n", "\t\t\tvga_util.d3_panel_down( x, REPORT_BUTTON_Y1, x+REPORT_BUTTON_WIDTH-1, REPORT_BUTTON_Y2 );\n", "\t\telse\n", "\t\t\tvga_util.d3_panel_up( x, REPORT_BUTTON_Y1, x+REPORT_BUTTON_WIDTH-1, REPORT_BUTTON_Y2 );\n", "\n", "\t\tfont_san.center_put( x, REPORT_BUTTON_Y1, x+REPORT_BUTTON_WIDTH-1, REPORT_BUTTON_Y2, report_mode_str_array[i-1] );\n", "\n", "\t\tx+=REPORT_BUTTON_WIDTH;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int town_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  int recNo_00;\n", "  int iVar3;\n", "  \n", "  iVar1 = town_array.super_DynArrayB.super_DynArray.last_ele;\n", "  if (town_array.super_DynArrayB.super_DynArray.last_ele < 1) {\n", "    iVar3 = 0;\n", "  }\n", "  else {\n", "    recNo_00 = 1;\n", "    iVar3 = 0;\n", "    do {\n", "      iVar2 = is_deleted(&town_array,recNo_00);\n", "      if (iVar2 == 0) {\n", "        if (town_array.super_DynArrayB.super_DynArray.last_ele < recNo_00) {\n", "          do {\n", "            invalidInstructionException();\n", "          } while( true );\n", "        }\n", "        iVar3 = iVar3 + (uint)(*(short *)(*(long *)(town_array.super_DynArrayB.super_DynArray.\n", "                                                    body_buf +\n", "                                                   (recNo_00 + -1) *\n", "                                                   town_array.super_DynArrayB.super_DynArray.\n", "                                                   ele_size) + 4) == info.viewing_nation_recno);\n", "        if ((iVar3 == recNo) && (recNo != 0)) {\n", "          return recNo_00;\n", "        }\n", "      }\n", "      recNo_00 = recNo_00 + 1;\n", "    } while (recNo_00 <= iVar1);\n", "  }\n", "  return iVar3;\n", "}\n", "\n"], "c": ["static int town_filter(int recNo)\n", "{\n", "\tint   totalTown = town_array.size();\n", "\tint   townCount=0;\n", "\tTown* townPtr;\n", "\n", "\tfor( int townRecno=1 ; townRecno<=totalTown ; townRecno++ )\n", "\t{\n", "\t\tif( town_array.is_deleted(townRecno) )\n", "\t\t\tcontinue;\n", "\n", "\t\ttownPtr = town_array[townRecno];\n", "\n", "\t\tif( townPtr->nation_recno==info.viewing_nation_recno )\n", "\t\t\ttownCount++;\n", "\n", "\t\tif( recNo && townCount==recNo )\n", "\t\t\treturn townRecno;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn townCount;\n", "}"]}, {"ghidra": ["\n", "void read_ai_info(File *filePtr,short **aiInfoArrayPtr,short *aiInfoCount,short *aiInfoSize)\n", "\n", "{\n", "  short sVar1;\n", "  int16_t iVar2;\n", "  short *dataBuf;\n", "  \n", "  iVar2 = file_get_short(filePtr);\n", "  *aiInfoCount = iVar2;\n", "  iVar2 = file_get_short(filePtr);\n", "  *aiInfoSize = iVar2;\n", "  dataBuf = (short *)add(&mem,(int)iVar2 + (int)iVar2,\"OGFILE3.cpp\",0x7db);\n", "  sVar1 = *aiInfoCount;\n", "  *aiInfoArrayPtr = dataBuf;\n", "  file_read(filePtr,dataBuf,(int)sVar1 * 2);\n", "  return;\n", "}\n", "\n"], "c": ["static void read_ai_info(File* filePtr, short** aiInfoArrayPtr, short& aiInfoCount, short& aiInfoSize)\n", "{\n", "\taiInfoCount = filePtr->file_get_short();\n", "\taiInfoSize  = filePtr->file_get_short();\n", "\n", "\t*aiInfoArrayPtr = (short*) mem_add( aiInfoSize * sizeof(short) );\n", "\n", "\tfilePtr->file_read( *aiInfoArrayPtr, sizeof(short) * aiInfoCount );\n", "}"]}, {"ghidra": ["\n", "void put_action_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  FirmInfo *pFVar1;\n", "  char *textPtr;\n", "  char *textPtr_00;\n", "  \n", "  if ((0 < recNo) && (recNo <= (cur_nation_ptr->action_array).last_ele)) {\n", "    y = y + 3;\n", "    textPtr_00 = (cur_nation_ptr->action_array).body_buf +\n", "                 (recNo + -1) * (cur_nation_ptr->action_array).ele_size;\n", "    put(&font_san,x + 3,y,action_mode_str_array[(int)*textPtr_00 + -1],'\\0',-1);\n", "    if ((byte)(*textPtr_00 - 1U) < 4) {\n", "      pFVar1 = operator__(&firm_res,(int)*(short *)(textPtr_00 + 2));\n", "      put(&font_san,x + 0x7b,y,pFVar1->name,'\\0',x + 0xdb);\n", "    }\n", "    textPtr = date_str(&date,(long)*(int *)(textPtr_00 + 8),1);\n", "    put(&font_san,x + 0xdf,y,textPtr,'\\0',-1);\n", "    textPtr = format(&misc,(int)textPtr_00[0x17],1);\n", "    put(&font_san,x + 0x157,y,textPtr,'\\0',-1);\n", "    textPtr = format(&misc,(int)textPtr_00[0x2a],1);\n", "    put(&font_san,x + 0x19d,y,textPtr,'\\0',-1);\n", "    textPtr_00 = format(&misc,(int)textPtr_00[0x2b],1);\n", "    put(&font_san,x + 0x1ed,y,textPtr_00,'\\0',-1);\n", "    return;\n", "  }\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static void put_action_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tActionNode* actionNode = cur_nation_ptr->get_action(recNo);\n", "\n", "\t//---------- display info ----------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tfont_san.put( x, y, action_mode_str_array[actionNode->action_mode-1] );\n", "\n", "\tif( actionNode->action_mode >= ACTION_AI_BUILD_FIRM &&\n", "\t\t actionNode->action_mode <= ACTION_AI_ASSIGN_WORKER )\n", "\t{\n", "\t\tfont_san.put( x+120, y, firm_res[actionNode->action_para]->name, 0, x+216 );\n", "\t}\n", "\n", "\tfont_san.put( x+220, y, date.date_str(actionNode->add_date, 1) );\t\t// short month string\n", "\tfont_san.put( x+340, y, actionNode->instance_count );\n", "\tfont_san.put( x+410, y, actionNode->processing_instance_count );\n", "\tfont_san.put( x+490, y, actionNode->processed_instance_count );\n", "/*\n", "   font_san.put( x+220, y, actionNode->action_x_loc );\t\t// short month string\n", "\tfont_san.put( x+340, y, actionNode->action_y_loc );\n", "\tfont_san.put( x+410, y, actionNode->ref_x_loc );\n", "\tfont_san.put( x+490, y, actionNode->ref_y_loc );\n", "*/\n", "}"]}, {"ghidra": ["\n", "int get_target_nation_recno(int targetXLoc,int targetYLoc)\n", "\n", "{\n", "  short sVar1;\n", "  ushort uVar2;\n", "  int iVar3;\n", "  Location *this;\n", "  \n", "  this = world.loc_matrix + (long)targetXLoc + (long)(targetYLoc * max_x_loc);\n", "  uVar2 = this->loc_flag & 0xf00;\n", "  if (uVar2 == 0x400) {\n", "    sVar1 = this->cargo_recno;\n", "    if ((0 < sVar1) && ((int)sVar1 <= firm_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "      return (int)*(short *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                                      ((int)sVar1 + -1) *\n", "                                      firm_array.super_DynArrayB.super_DynArray.ele_size) + 0x13);\n", "    }\n", "    do {\n", "      invalidInstructionException();\n", "    } while( true );\n", "  }\n", "  if (uVar2 == 0x300) {\n", "    sVar1 = this->cargo_recno;\n", "    if ((0 < sVar1) && ((int)sVar1 <= town_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "      return (int)*(short *)(*(long *)(town_array.super_DynArrayB.super_DynArray.body_buf +\n", "                                      ((int)sVar1 + -1) *\n", "                                      town_array.super_DynArrayB.super_DynArray.ele_size) + 4);\n", "    }\n", "    do {\n", "      invalidInstructionException();\n", "    } while( true );\n", "  }\n", "  iVar3 = has_unit(this,0x4c);\n", "  if (iVar3 != 0) {\n", "    sVar1 = this->cargo_recno;\n", "    if ((sVar1 < 1) ||\n", "       (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < (int)sVar1)) {\n", "      do {\n", "        invalidInstructionException();\n", "      } while( true );\n", "    }\n", "    iVar3 = (int)*(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                     body_buf +\n", "                                    ((int)sVar1 + -1) *\n", "                                    unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                    ele_size) + 0x2d);\n", "  }\n", "  return iVar3;\n", "}\n", "\n"], "c": ["static int get_target_nation_recno(int targetXLoc, int targetYLoc)\n", "{\n", "   Location* locPtr = world.get_loc(targetXLoc, targetYLoc);\n", "\n", "   if( locPtr->is_firm() )\n", "   {\n", "\t\treturn firm_array[locPtr->firm_recno()]->nation_recno;\n", "   }\n", "   else if( locPtr->is_town() )\n", "   {\n", "\t\treturn town_array[locPtr->town_recno()]->nation_recno;\n", "\t}\n", "   else if( locPtr->has_unit(UNIT_LAND) )\n", "   {\n", "      return unit_array[locPtr->unit_recno(UNIT_LAND)]->nation_recno;\n", "   }\n", "\n", "   return 0;\n", "}"]}, {"ghidra": ["\n", "void IMGfogRemap16x16(char *imageBuf,int pitch,int x,int y,char **colorTableArray,uchar a,uchar b,\n", "                     uchar c,uchar d)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  byte *pbVar3;\n", "  byte *pbVar4;\n", "  int iVar5;\n", "  int iVar6;\n", "  byte *pbVar7;\n", "  int iVar8;\n", "  \n", "  iVar8 = (uint)a << 8;\n", "  pbVar7 = (byte *)(imageBuf + (y * pitch + x));\n", "  iVar5 = ((uint)b - (uint)a) * 0x10;\n", "  iVar6 = 0x10;\n", "  do {\n", "    pbVar3 = pbVar7;\n", "    iVar2 = iVar8;\n", "    do {\n", "      iVar1 = iVar2 + 0x7ff;\n", "      if (-1 < iVar2) {\n", "        iVar1 = iVar2;\n", "      }\n", "      pbVar4 = pbVar3 + 1;\n", "      iVar2 = iVar2 + iVar5;\n", "      *pbVar3 = colorTableArray[(iVar1 >> 0xb) + -10][*pbVar3];\n", "      pbVar3 = pbVar4;\n", "    } while (pbVar7 + 0x10 != pbVar4);\n", "    iVar8 = iVar8 + ((uint)d - (uint)a) * 0x10;\n", "    pbVar7 = pbVar7 + pitch;\n", "    iVar5 = iVar5 + (((uint)c - (uint)b) - ((uint)d - (uint)a));\n", "    iVar6 = iVar6 + -1;\n", "  } while (iVar6 != 0);\n", "  return;\n", "}\n", "\n"], "c": ["void IMGfogRemap16x16(char* imageBuf, int pitch, int x, int y, char**colorTableArray, unsigned char a, unsigned char b, unsigned char c, unsigned char d)\n", "{\n", "\tuint8_t *buf = reinterpret_cast<uint8_t *>(imageBuf);\n", "\tint c1 = 16*a;\t\t// C1(0)\n", "\tint c2 = 16*b;\t\t// C2(0)\n", "\tint bxy;\t\t\t// B uses fixed point 24.8 arithmetic\n", "\tint C2subC1;\n", "\tint remap;\n", "\tint dest = y*pitch + x;\n", "\tfor ( int j=0; j<16; ++j, dest+=pitch, c1+=(d-a), c2+=(c-b) )\n", "\t{\n", "\t\tbxy = (16*c1);\t\t// into 24.8: (c1<<4)\n", "\t\tC2subC1 = c2-c1;\n", "\t\tfor (int i=0; i<16; ++i, bxy+=C2subC1)\n", "\t\t{\n", "\t\t\tremap = bxy / 256 / 8     // bxy >> 11, 256 for fix point, 8 for visibility levels\n", "\t\t\t        - MAX_VISIBILITY;\n", "\t\t\tbuf[dest + i] = colorTableArray[remap][buf[dest + i]];\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void disp_slide_bar(SlideBar *slideBar,int param_2)\n", "\n", "{\n", "  short sVar1;\n", "  short sVar2;\n", "  \n", "  blt_buf(&vga_util,(int)slideBar->scrn_x1,(int)slideBar->scrn_y1,(int)slideBar->scrn_x2,\n", "          (int)slideBar->scrn_y2,0);\n", "  sVar1 = slideBar->scrn_y1;\n", "  sVar2 = rect_left(slideBar);\n", "  put_front(&image_interface,(int)sVar2,(int)sVar1,\"SLIDBALL\",0);\n", "  return;\n", "}\n", "\n"], "c": ["static void disp_slide_bar(SlideBar *slideBar, int)\n", "{\n", "\tvga_util.blt_buf(slideBar->scrn_x1, slideBar->scrn_y1, \n", "\t\tslideBar->scrn_x2, slideBar->scrn_y2, 0 );\n", "\n", "\timage_interface.put_front(slideBar->rect_left(), slideBar->scrn_y1, \"SLIDBALL\");\n", "}"]}, {"ghidra": ["\n", "int slide_to_percent_volume(int slideVolume)\n", "\n", "{\n", "  switch(slideVolume / 10) {\n", "  case 0:\n", "    return slideVolume * 5;\n", "  case 1:\n", "  case 2:\n", "  case 3:\n", "    return slideVolume + 0x28;\n", "  case 4:\n", "  case 5:\n", "    return slideVolume / 2 + 0x3c;\n", "  case 6:\n", "  case 7:\n", "  case 8:\n", "  case 9:\n", "  case 10:\n", "    break;\n", "  default:\n", "    return slideVolume;\n", "  }\n", "  if (slideVolume < 0) {\n", "    slideVolume = slideVolume + 3;\n", "  }\n", "  return (slideVolume >> 2) + 0x4b;\n", "}\n", "\n"], "c": ["static int slide_to_percent_volume(int slideVolume)\n", "{\n", "\tswitch( slideVolume / 10)\n", "\t{\n", "\tcase 0:\n", "\t\treturn slideVolume * 5;\n", "\tcase 1:\n", "\tcase 2:\n", "\tcase 3:\n", "\t\treturn slideVolume+40;\n", "\t\tbreak;\n", "\n", "\tcase 4:\n", "\tcase 5:\n", "\t\treturn slideVolume/2 + 60;\n", "\t\tbreak;\n", "\n", "\tcase 6:\n", "\tcase 7:\n", "\tcase 8:\n", "\tcase 9:\n", "\tcase 10:\n", "\t\treturn slideVolume/4+75;\n", "\t\tbreak;\n", "\n", "\tdefault:\n", "\t\terr_here();\n", "\t\treturn slideVolume;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int sort_soldier_id_function(void *a,void *b)\n", "\n", "{\n", "  return (int)cur_firm_ptr->worker_array[(long)*(short *)b + -1].skill_level -\n", "         (int)cur_firm_ptr->worker_array[(long)*(short *)a + -1].skill_level;\n", "}\n", "\n"], "c": ["static int sort_soldier_id_function( const void *a, const void *b )\n", "{\n", "\tint workerId1 = *((short*)a);\n", "\tint workerId2 = *((short*)b);\n", "\n", "\treturn cur_firm_ptr->worker_array[workerId2-1].skill_level -\n", "\t\t\t cur_firm_ptr->worker_array[workerId1-1].skill_level;\n", "}"]}, {"ghidra": ["\n", "void update_caravan_stop_and_goods_to_dummy(UnitCaravan *caravanPtr)\n", "\n", "{\n", "  int iVar1;\n", "  CaravanStop *this;\n", "  char *enableFlag;\n", "  char *pcVar2;\n", "  \n", "  pcVar2 = dummyCaravanGoodsNum;\n", "  this = caravanPtr->stop_array;\n", "  enableFlag = dummyCaravanEnableFlag;\n", "  do {\n", "    if ((this->super_TradeStop).firm_recno != 0) {\n", "      iVar1 = update_pick_up(this,enableFlag);\n", "      *pcVar2 = (char)iVar1;\n", "    }\n", "    enableFlag = enableFlag + 8;\n", "    this = this + 1;\n", "    pcVar2 = pcVar2 + 1;\n", "  } while (enableFlag != goods_num);\n", "  return;\n", "}\n", "\n"], "c": ["static void update_caravan_stop_and_goods_to_dummy(UnitCaravan *caravanPtr)\n", "{\n", "\tCaravanStop *stopPtr = caravanPtr->stop_array;\n", "\tfor(int i=0; i<MAX_STOP_FOR_CARAVAN; i++, stopPtr++)\n", "\t{\n", "\t\tif(!stopPtr->firm_recno)\n", "\t\t\tcontinue;\n", "\n", "\t\terr_when(firm_array.is_deleted(stopPtr->firm_recno));\n", "\t\tdummyCaravanGoodsNum[i] = stopPtr->update_pick_up(dummyCaravanEnableFlag[i]);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "char * create_rebel_func(void)\n", "\n", "{\n", "  long lVar1;\n", "  long in_FS_OFFSET;\n", "  Rebel *rebelPtr;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  rebelPtr = (Rebel *)operator_new(0xe);\n", "                    /* try { // try from 00464856 to 0046485a has its CatchHandler @ 0046488c */\n", "  Rebel(rebelPtr);\n", "  linkin((DynArrayB *)&rebel_array,&rebelPtr);\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return (char *)rebelPtr;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["static char* create_rebel_func()\n", "{\n", "\tRebel *rebelPtr = new Rebel;\n", "\n", "\trebel_array.linkin(&rebelPtr);\n", "\n", "\treturn (char*) rebelPtr;\n", "}"]}, {"ghidra": ["\n", "void new_func_handler(void)\n", "\n", "{\n", "  Error *pEVar1;\n", "  \n", "  if (error_flag != '\\0') {\n", "    return;\n", "  }\n", "  pEVar1 = &err;\n", "  mem(&err);\n", "  set_new_handler(new_func_handler);\n", "  pEVar1->extra_handler = (ExtraHandler *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["static void new_func_handler()\n", "{\n", "\terr.mem();\n", "}"]}, {"ghidra": ["\n", "void draw_unit_path_on_zoom_map(int displayLayer)\n", "\n", "{\n", "  char cVar1;\n", "  short sVar2;\n", "  short sVar3;\n", "  short sVar4;\n", "  Unit *this;\n", "  short sVar5;\n", "  int iVar6;\n", "  uint uVar7;\n", "  short sVar8;\n", "  short sVar9;\n", "  int iVar10;\n", "  int recNo;\n", "  int nationRecno;\n", "  int iVar11;\n", "  int iVar12;\n", "  ResultNode *pRVar13;\n", "  short x2;\n", "  int iVar14;\n", "  short y2;\n", "  int iVar15;\n", "  \n", "  sVar8 = nation_array.player_recno;\n", "  nationRecno = (int)nation_array.player_recno;\n", "  recNo = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "  if (0 < unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele) {\n", "    do {\n", "      iVar6 = recNo + -1;\n", "      iVar10 = is_deleted(&unit_array,recNo);\n", "      if (iVar10 == 0) {\n", "        if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo) {\n", "          do {\n", "            invalidInstructionException();\n", "          } while( true );\n", "        }\n", "        this = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                         unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size *\n", "                         iVar6);\n", "        if (((((-1 < (this->super_Sprite).cur_x) && (this->selected_flag != '\\0')) &&\n", "             ((config.show_ai_info != '\\0' ||\n", "              ((sVar8 == 0 || (recNo = is_nation(this,nationRecno), recNo != 0)))))) &&\n", "            ((cVar1 = (this->super_Sprite).mobile_type, uVar7 = displayLayer & 1, cVar1 == 'S' ||\n", "             ((cVar1 == 'L' || (uVar7 = displayLayer & 8, cVar1 == 'A')))))) && (uVar7 != 0)) {\n", "          x2 = this->result_node_recno;\n", "          recNo = this->result_node_count;\n", "          if (((int)x2 <= recNo) && (recNo != 0)) {\n", "            y2 = (this->super_Sprite).cur_x;\n", "            sVar2 = (this->super_Sprite).go_x;\n", "            if (y2 == sVar2) {\n", "              sVar4 = (this->super_Sprite).cur_y;\n", "              sVar3 = (this->super_Sprite).go_y;\n", "              if (sVar4 != sVar3) goto LAB_0050c848;\n", "            }\n", "            else {\n", "              sVar3 = (this->super_Sprite).go_y;\n", "              sVar4 = (this->super_Sprite).cur_y;\n", "LAB_0050c848:\n", "              sVar5 = (short)((world.zoom_matrix)->super_Matrix).top_y_loc * -0x20 + 0x48;\n", "              sVar9 = *(short *)&((world.zoom_matrix)->super_Matrix).top_x_loc * -0x20;\n", "              draw_line(&anim_line,&vga_back,sVar9 + sVar2 + 0x10,sVar3 + sVar5,y2 + 0x10 + sVar9,\n", "                        sVar4 + sVar5,1,0);\n", "            }\n", "            pRVar13 = this->result_node_array + (long)x2 + -1;\n", "            iVar10 = (int)x2 + 1;\n", "            iVar11 = ((world.zoom_matrix)->super_Matrix).top_x_loc;\n", "            iVar12 = ((world.zoom_matrix)->super_Matrix).top_y_loc;\n", "            iVar14 = (pRVar13->node_x - iVar11) * 0x20 + 0x10;\n", "            iVar15 = (pRVar13->node_y - iVar12) * 0x20 + 0x48;\n", "            if (iVar10 <= recNo) {\n", "              while( true ) {\n", "                y2 = (short)iVar15;\n", "                x2 = (short)iVar14;\n", "                iVar10 = iVar10 + 1;\n", "                iVar14 = (pRVar13[1].node_x - iVar11) * 0x20 + 0x10;\n", "                iVar15 = (pRVar13[1].node_y - iVar12) * 0x20 + 0x48;\n", "                draw_line(&anim_line,&vga_back,(short)iVar14,(short)iVar15,x2,y2,1,0);\n", "                if (recNo < iVar10) break;\n", "                iVar11 = ((world.zoom_matrix)->super_Matrix).top_x_loc;\n", "                iVar12 = ((world.zoom_matrix)->super_Matrix).top_y_loc;\n", "                pRVar13 = pRVar13 + 1;\n", "              }\n", "            }\n", "          }\n", "        }\n", "      }\n", "      recNo = iVar6;\n", "    } while (0 < iVar6);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void draw_unit_path_on_zoom_map(int displayLayer)\n", "// ##### end Gilbert 9/10 #######//\n", "{\n", "\t// ###### begin Gilbert 29/8 ######//\n", "\tif( !(config.show_unit_path & 1) )\n", "\t\treturn;\n", "\t// ###### end Gilbert 29/8 ######//\n", "\n", "\tshort nationRecno = nation_array.player_recno;\n", "\n", "\tUnit *unitPtr;\n", "\tint i, j, resultNodeCount, resultNodeRecno;\n", "\tshort lineFromX, lineFromY, lineToX, lineToY;\n", "\tResultNode *resultNode1, *resultNode2;\n", "\n", "\tfor(i=unit_array.size(); i>0; --i)\n", "\t{\n", "\t\tif(unit_array.is_deleted(i))\n", "\t\t\tcontinue;\n", "\n", "\t\tunitPtr = unit_array[i];\n", "\t\tif(!unitPtr->is_visible())\n", "\t\t\tcontinue;\n", "\n", "\t\tif(!unitPtr->selected_flag)\n", "\t\t\tcontinue;\n", "\n", "\t\t// ####### begin Gilbert 11/9 #######//\n", "\t\tif( !config.show_ai_info && nationRecno && !unitPtr->is_nation(nationRecno) )\n", "\t\t\tcontinue;\n", "\t\t// ####### end Gilbert 11/9 #######//\n", "\n", "\t\t// ##### begin Gilbert 9/10 #######//\n", "\t\tif( unitPtr->mobile_type == UNIT_LAND || unitPtr->mobile_type == UNIT_SEA )\n", "\t\t{\n", "\t\t\tif( !(displayLayer & LAND_DISP_LAYER_MASK) )\n", "\t\t\t\tcontinue;\n", "\t\t}\n", "\t\telse if( unitPtr->mobile_type == UNIT_AIR )\n", "\t\t{\n", "\t\t\tif( !(displayLayer & AIR_DISP_LAYER_MASK) )\n", "\t\t\t\tcontinue;\n", "\t\t}\n", "\t\telse\n", "\t\t{\n", "\t\t\terr_here();\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\t// ##### end Gilbert 9/10 #######//\n", "\n", "\t\t//--------------- draw unit's path ----------------//\n", "\n", "\t\tresultNodeRecno = unitPtr->result_node_recno;\n", "\t\tresultNodeCount = unitPtr->result_node_count;\n", "\t\tif(!resultNodeCount || resultNodeRecno>resultNodeCount)\n", "\t\t\tcontinue;\n", "\n", "\t\t//-----------------------------------------------------------//\n", "\t\tif(unitPtr->cur_x!=unitPtr->go_x || unitPtr->cur_y!=unitPtr->go_y)\n", "\t\t{\n", "\t\t\tlineFromX = unitPtr->go_x - world.zoom_matrix->top_x_loc*ZOOM_LOC_WIDTH + ZOOM_X1 + ZOOM_LOC_WIDTH/2;\n", "\t\t\tlineFromY = unitPtr->go_y - world.zoom_matrix->top_y_loc*ZOOM_LOC_HEIGHT + ZOOM_Y1 + ZOOM_LOC_HEIGHT/2;\n", "\t\t\tlineToX = unitPtr->cur_x - world.zoom_matrix->top_x_loc*ZOOM_LOC_WIDTH + ZOOM_X1 + ZOOM_LOC_WIDTH/2;\n", "\t\t\tlineToY = unitPtr->cur_y - world.zoom_matrix->top_y_loc*ZOOM_LOC_HEIGHT + ZOOM_Y1 + ZOOM_LOC_HEIGHT/2;\n", "\t\t\tanim_line.draw_line(&vga_back, lineFromX, lineFromY, lineToX, lineToY);\n", "\t\t}\n", "\n", "\t\t//-----------------------------------------------------------//\n", "\t\terr_when(resultNodeRecno<1);\n", "\t\tresultNode1 = unitPtr->result_node_array + resultNodeRecno - 1;\n", "\t\tresultNode2 = resultNode1 + 1;\n", "\t\tlineToX = (resultNode1->node_x - world.zoom_matrix->top_x_loc)*ZOOM_LOC_WIDTH + ZOOM_X1 + ZOOM_LOC_WIDTH/2;\n", "\t\tlineToY = (resultNode1->node_y - world.zoom_matrix->top_y_loc)*ZOOM_LOC_HEIGHT\t+ ZOOM_Y1 + ZOOM_LOC_HEIGHT/2;\n", "\t\tfor(j=resultNodeRecno+1; j<=resultNodeCount; j++, resultNode1++, resultNode2++)\n", "\t\t{\n", "\t\t\tlineFromX = (resultNode2->node_x - world.zoom_matrix->top_x_loc)*ZOOM_LOC_WIDTH + ZOOM_X1 + ZOOM_LOC_WIDTH/2;\n", "\t\t\tlineFromY = (resultNode2->node_y - world.zoom_matrix->top_y_loc)*ZOOM_LOC_HEIGHT + ZOOM_Y1 + ZOOM_LOC_HEIGHT/2;\n", "\t\t\tanim_line.draw_line(&vga_back, lineFromX, lineFromY, lineToX, lineToY);\n", "\t\t\tlineToX = lineFromX;\n", "\t\t\tlineToY = lineFromY;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void put_hire_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  char cVar1;\n", "  int x1;\n", "  int iVar2;\n", "  char *bitmapPtr;\n", "  long lVar3;\n", "  int y1;\n", "  int x2;\n", "  int y2;\n", "  \n", "  y2 = y + 0x18;\n", "  x1 = x + 1;\n", "  x2 = x + 0x1c;\n", "  lVar3 = (long)&(firm_inn_ptr->super_Firm).last_attacked_date + (long)recNo * 0xd + 1;\n", "  y1 = y + 1;\n", "  d3_panel_down(&vga_front,x1,y1,x2,y2,2,0);\n", "  bitmapPtr = get_small_icon_ptr(unit_res.unit_info_array + (long)*(char *)(lVar3 + -5) + -1,'\\0');\n", "  put_bitmap(&vga_front,x + 3,y + 3,bitmapPtr);\n", "  iVar2 = in_area((MouseSDL *)&mouse,x1,y1,x2,y2);\n", "  if (iVar2 != 0) {\n", "    set_unit_help(&help,(int)*(char *)(lVar3 + -5),0,x1,y1,x2,y2);\n", "  }\n", "  font_san.font_height = font_san.max_font_height;\n", "  y = y + 6;\n", "  if (*(char *)(lVar3 + -2) < '\\x01') {\n", "    put(&font_san,x + 0x20,y,\"Combat\",'\\x01',x + 0x7a);\n", "    cVar1 = *(char *)(lVar3 + -4);\n", "  }\n", "  else {\n", "    bitmapPtr = skill_des((Skill *)(lVar3 + -4),1);\n", "    put(&font_san,x + 0x20,y,bitmapPtr,'\\x01',x + 0x7a);\n", "    cVar1 = *(char *)(lVar3 + -2);\n", "  }\n", "  bitmapPtr = format(&misc,(int)cVar1,1);\n", "  put(&font_san,x + 0x74,y,bitmapPtr,'\\x01',x + 0x92);\n", "  font_san.font_height = font_san.std_font_height;\n", "  x1 = (int)browse_hire.super_VBrowse.rec_width;\n", "  bitmapPtr = format(&misc,(int)*(short *)(lVar3 + 2),2);\n", "  put(&font_san,x + 0x8c,y,bitmapPtr,'\\x01',x + -3 + x1);\n", "  return;\n", "}\n", "\n"], "c": ["static void put_hire_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tInnUnit* innUnit = firm_inn_ptr->inn_unit_array+recNo-1;\n", "\n", "\t//-------- display unit icon -------//\n", "\n", "\tvga_front.d3_panel_down(x+1, y+1, x+UNIT_SMALL_ICON_WIDTH+4, y+UNIT_SMALL_ICON_HEIGHT+4, 2, 0 );\n", "\t// ##### begin Gilbert 17/10 #######//\n", "\tvga_front.put_bitmap(x+3, y+3, unit_res[innUnit->unit_id]->get_small_icon_ptr(RANK_SOLDIER) );\n", "\t// ##### end Gilbert 17/10 #######//\n", "\n", "\t//--------- set help parameters --------//\n", "\n", "\tif( mouse.in_area(x+1, y+1, x+UNIT_SMALL_ICON_WIDTH+4, y+UNIT_SMALL_ICON_HEIGHT+4) )\n", "\t\thelp.set_unit_help( innUnit->unit_id, 0, x+1, y+1, x+UNIT_SMALL_ICON_WIDTH+4, y+UNIT_SMALL_ICON_HEIGHT+4 );\n", "\n", "\t//---------- display info ----------//\n", "\n", "\ty+=6;\n", "\n", "   font_san.use_max_height();\n", "\n", "\tif( innUnit->skill.skill_level > 0 )\n", "\t{\n", "\t\tfont_san.put( x+32 , y, innUnit->skill.skill_des(1), 1, x+122 );\t\t// 1-use short words\n", "\t\tfont_san.put( x+116, y, innUnit->skill.skill_level, 1, x+146 );\n", "\t}\n", "\telse\n", "\t{\n", "\t\tfont_san.put( x+32 , y, \"Combat\", 1, x+122 );\t\t// 1-use short words\n", "\t\tfont_san.put( x+116, y, innUnit->skill.combat_level, 1, x+146 );\n", "\t}\n", "\n", "\tfont_san.use_std_height();\n", "\n", "\tfont_san.put( x+140, y, misc.format(innUnit->hire_cost,2), 1, x+browse_hire.rec_width-3 );\n", "}"]}, {"ghidra": ["\n", "int tech_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  uint uVar2;\n", "  ulong uVar3;\n", "  char *pcVar4;\n", "  \n", "  uVar3 = SEXT28(tech_res.tech_count);\n", "  if (tech_res.tech_count < 1) {\n", "    return 0;\n", "  }\n", "  iVar1 = 0;\n", "  pcVar4 = tech_res.tech_info_array[uVar3 - 1].nation_is_researching_array +\n", "           ((int)info.viewing_nation_recno + -1);\n", "  while( true ) {\n", "    if ((*pcVar4 != '\\0') || ('\\0' < pcVar4[-7])) {\n", "      iVar1 = iVar1 + 1;\n", "    }\n", "    if ((iVar1 == recNo) && (recNo != 0)) break;\n", "    pcVar4 = pcVar4 + -0x3d;\n", "    uVar2 = (int)uVar3 - 1;\n", "    uVar3 = (ulong)uVar2;\n", "    if (uVar2 == 0) {\n", "      return iVar1;\n", "    }\n", "  }\n", "  return (int)uVar3;\n", "}\n", "\n"], "c": ["static int tech_filter(int recNo)\n", "{\n", "\tint \t\t techCount=0;\n", "\tTechInfo* techInfo;\n", "\n", "\tfor( int techId=tech_res.tech_count ; techId>0 ; techId-- )\n", "\t{\n", "\t\ttechInfo = tech_res[techId];\n", "\n", "\t\tif( techInfo->is_nation_researching(info.viewing_nation_recno) ||\n", "\t\t\t techInfo->get_nation_tech_level(info.viewing_nation_recno) > 0 )\n", "\t\t{\n", "\t\t\ttechCount++;\n", "\t\t}\n", "\n", "\t\tif( recNo && techCount==recNo )\n", "\t\t\treturn techId;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn techCount;\n", "}"]}, {"ghidra": ["\n", "int get_mouse_loc_in_zoom_map(int *x,int *y)\n", "\n", "{\n", "  ZoomMatrix *pZVar1;\n", "  uint uVar2;\n", "  \n", "  pZVar1 = world.zoom_matrix;\n", "  uVar2 = mouse.cur_y - 0x38;\n", "  if ((uVar2 < 0x220) && ((uint)mouse.cur_x < 0x240)) {\n", "    *x = (mouse.cur_x >> 5) + ((world.zoom_matrix)->super_Matrix).top_x_loc;\n", "    *y = ((int)uVar2 >> 5) + (pZVar1->super_Matrix).top_y_loc;\n", "    return 1;\n", "  }\n", "  return 0;\n", "}\n", "\n"], "c": ["static int get_mouse_loc_in_zoom_map(int &x, int &y)\n", "{\n", "   int mouseX = mouse.cur_x;\n", "   int mouseY = mouse.cur_y;\n", "   if(mouseX >= ZOOM_X1 && mouseX <= ZOOM_X2 && mouseY >= ZOOM_Y1 && mouseY <= ZOOM_Y2)\n", "   {\n", "      x = world.zoom_matrix->top_x_loc + (mouseX-ZOOM_X1)/ZOOM_LOC_WIDTH;\n", "      y = world.zoom_matrix->top_y_loc + (mouseY-ZOOM_Y1)/ZOOM_LOC_HEIGHT;\n", "      return 1;\n", "   }\n", "\n", "   return 0; // out of zoom map boundary\n", "}"]}, {"ghidra": ["\n", "void put_income_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  char *textPtr;\n", "  char *income_des_array [8];\n", "  \n", "  y = y + 3;\n", "  iVar2 = (int)info.viewing_nation_recno;\n", "  if ((0 < iVar2) && (iVar2 <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    lVar1 = *(long *)(nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (iVar2 + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "    put(&font_san,x + 3,y,income_des_array[recNo + -1],'\\0',-1);\n", "    lVar1 = lVar1 + (long)recNo * 4;\n", "    textPtr = format(&misc,(int)(((float)(0x16d - info.year_day) * *(float *)(lVar1 + 0xbe)) /\n", "                                 365.00000000 + *(float *)(lVar1 + 0x9e)),2);\n", "    put(&font_san,x + 0x175,y,textPtr,'\\0',-1);\n", "    return;\n", "  }\n", "  put(&font_san,x + 3,y,income_des_array[recNo + -1],'\\0',-1);\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static void put_income_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\t//----- define income descriptions ------//\n", "\n", "\tstatic const char* income_des_array[INCOME_TYPE_COUNT] =\n", "\t{\n", "\t\t\"Sale of Goods\",\n", "\t\t\"Exports\",\n", "\t\t\"Taxes\",\n", "\t\t\"Recovered Treasure\",\n", "\t\t\"Worker Income\",\n", "\t\t\"Sale of Buildings\",\n", "\t\t\"Aid/Tribute from Other Kingdoms\",\n", "\t\t\"Cheating\",\n", "\t};\n", "\n", "\t//---------------------------------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tNation* nationPtr = nation_array[info.viewing_nation_recno];\n", "\n", "\tfont_san.put( x    , y, income_des_array[recNo-1] );\n", "\tfont_san.put( x+370, y, misc.format( (int) nationPtr->income_365days(recNo-1), 2 ) );\n", "}"]}, {"ghidra": ["\n", "int cal_rectangle_upper_left_x(int refXLoc)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  if (move_scale != 1) {\n", "    iVar1 = (int)rec_width + -2;\n", "    if (iVar1 < 0) {\n", "      iVar1 = (int)rec_width + 1;\n", "    }\n", "    return refXLoc + (iVar1 >> 2) * -2;\n", "  }\n", "  return refXLoc - ((int)rec_width + -1) / 2;\n", "}\n", "\n"], "c": ["static int cal_rectangle_upper_left_x(int refXLoc)\n", "{\n", "\t// the rule:\trefXLoc - ((rec_width-move_scale)/(move_scale*2))*move_scale\n", "\tif(move_scale==1)\n", "\t\treturn refXLoc - (rec_width-1)/2;\n", "\telse // move_scale == 2\n", "\t\treturn refXLoc - ((rec_width-2)/4)*2;\n", "}"]}, {"ghidra": ["\n", "int race_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  long lVar2;\n", "  long lVar3;\n", "  \n", "  iVar1 = (int)if_town_recno;\n", "  lVar3 = 0;\n", "  if ((0 < iVar1) && (iVar1 <= town_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    lVar3 = *(long *)(town_array.super_DynArrayB.super_DynArray.body_buf +\n", "                     (iVar1 + -1) * town_array.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  lVar2 = 0;\n", "  iVar1 = 0;\n", "  while ((iVar1 = iVar1 + (uint)(0 < *(short *)(lVar3 + 0x76 + lVar2 * 2)), iVar1 != recNo ||\n", "         (recNo == 0))) {\n", "    lVar2 = lVar2 + 1;\n", "    if (lVar2 == 10) {\n", "      return iVar1;\n", "    }\n", "  }\n", "  return (int)lVar2 + 1;\n", "}\n", "\n"], "c": ["static int race_filter(int recNo)\n", "{\n", "\terr_when( recNo && recNo < 1 );\n", "\terr_when( recNo && recNo > recruit_race_count );\n", "\terr_when( recNo && recNo > browse_race.total_rec() );\n", "\n", "\tint \ti, recCount=0;\n", "\tTown* townPtr = town_array[Town::if_town_recno];\n", "\n", "\tfor( i=0 ; i<MAX_RACE ; i++ )\n", "\t{\n", "\t\tif( townPtr->race_pop_array[i] > 0 )\n", "\t\t\trecCount++;\n", "\n", "\t\tif( recNo && recCount==recNo )\n", "\t\t\treturn i+1;\n", "\t}\n", "\n", "\terr_when( recNo );\n", "\n", "\treturn recCount;\n", "}"]}, {"ghidra": ["\n", "void put_news_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  int iVar1;\n", "  News *this;\n", "  char *textPtr;\n", "  \n", "  this = operator__(&news_array,(news_array.super_DynArray.last_ele - recNo) + 1);\n", "  textPtr = date_str(&date,(long)this->news_date,1);\n", "  put(&font_san,x + 0x14,y,textPtr,'\\0',-1);\n", "  talk_res.msg_add_nation_color = '\\x01';\n", "  textPtr = msg(this);\n", "  put_paragraph(&font_san,x + 0x6e,y,(int)browse_news.super_VBrowse.ix2 + -0x1e,y + 0x1e,textPtr,2,1\n", "                ,'\\x01');\n", "  talk_res.msg_add_nation_color = '\\0';\n", "  iVar1 = is_loc_valid(this);\n", "  if (iVar1 != 0) {\n", "    put_back(&image_icon,x + 2,y + 1,\"NEWS_GO\",0);\n", "    iVar1 = single_click((MouseSDL *)&mouse,x + 2,y + 1,x + 0xc,y + 0xb,0);\n", "    if (iVar1 != 0) {\n", "      use_back_buf = '\\0';\n", "      active_buf = &vga_front;\n", "      go_loc(&world,(int)this->loc_x,(int)this->loc_y,1);\n", "      active_buf = &vga_back;\n", "      use_back_buf = '\\x01';\n", "      return;\n", "    }\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_news_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tNews* newsPtr = news_array[ news_array.size()-recNo+1 ]; \t// display in reversed order\n", "\n", "\tfont_san.put( x+20, y, date.date_str(newsPtr->news_date, 1) );\n", "\n", "   talk_res.msg_add_nation_color = 1; \n", "\tfont_san.put_paragraph( x+110, y, browse_news.ix2-30, y+30, newsPtr->msg() );\n", "\ttalk_res.msg_add_nation_color = 0;\n", "\n", "\t//----- display and detect the go icon -----//\n", "\n", "\tif( newsPtr->is_loc_valid() )\n", "\t{\n", "\t\timage_icon.put_back( x+2, y+1, \"NEWS_GO\" );\n", "\n", "\t\tif( mouse.single_click(x+2, y+1, x+12, y+11) )\n", "\t\t{\n", "\t\t\tvga.use_front();\n", "\t\t\tworld.go_loc( newsPtr->loc_x, newsPtr->loc_y, 1 );\t\t// 1-select object on the location if there is any\n", "\t\t\tvga.use_back();\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int god_filter(int recNo)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  int recNo_00;\n", "  int iVar3;\n", "  \n", "  iVar1 = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "  if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < 1) {\n", "    iVar3 = 0;\n", "  }\n", "  else {\n", "    recNo_00 = 1;\n", "    iVar3 = 0;\n", "    do {\n", "      iVar2 = is_deleted(&unit_array,recNo_00);\n", "      if (iVar2 == 0) {\n", "        if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo_00) {\n", "          do {\n", "            invalidInstructionException();\n", "          } while( true );\n", "        }\n", "        if ((short)*(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                       body_buf +\n", "                                      (recNo_00 + -1) *\n", "                                      unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                      ele_size) + 0x2d) == info.viewing_nation_recno) {\n", "          iVar3 = iVar3 + (uint)(unit_res.unit_info_array\n", "                                 [(long)*(char *)(*(long *)(unit_array.super_SpriteArray.\n", "                                                            super_DynArrayB.super_DynArray.body_buf\n", "                                                           + (recNo_00 + -1) *\n", "                                                             unit_array.super_SpriteArray.\n", "                                                             super_DynArrayB.super_DynArray.ele_size\n", "                                                           ) + 0x2a) + -1].unit_class == 'G');\n", "        }\n", "        if ((iVar3 == recNo) && (recNo != 0)) {\n", "          return recNo_00;\n", "        }\n", "      }\n", "      recNo_00 = recNo_00 + 1;\n", "    } while (recNo_00 <= iVar1);\n", "  }\n", "  return iVar3;\n", "}\n", "\n"], "c": ["static int god_filter(int recNo)\n", "{\n", "\tint \tgodCount=0, totalUnit=unit_array.size();\n", "\tUnit* unitPtr;\n", "\n", "\tfor( int i=1 ; i<=totalUnit ; i++ )\n", "\t{\n", "\t\tif( unit_array.is_deleted(i) )\n", "\t\t\tcontinue;\n", "\n", "\t\tunitPtr = unit_array[i];\n", "\n", "\t\tif( unitPtr->nation_recno == info.viewing_nation_recno &&\n", "\t\t\t unit_res[ unitPtr->unit_id ]->unit_class == UNIT_CLASS_GOD )\n", "\t\t{\n", "\t\t\tgodCount++;\n", "\t\t}\n", "\n", "\t\tif( recNo && godCount==recNo )\n", "\t\t\treturn i;\n", "\t}\n", "\n", "\terr_when( recNo );   // the recNo is not found, it is out of range\n", "\n", "\treturn godCount;\n", "}"]}, {"ghidra": ["\n", "void put_tech_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  int y_00;\n", "  char cVar1;\n", "  char cVar2;\n", "  int iVar3;\n", "  char *bitmapPtr;\n", "  TechInfo *this;\n", "  float curValue;\n", "  \n", "  y_00 = y + 5;\n", "  iVar3 = tech_filter(recNo);\n", "  this = tech_res.tech_info_array + (long)iVar3 + -1;\n", "  bitmapPtr = tech_small_icon(this);\n", "  put_bitmap(&vga_back,x + 3,y + 1,bitmapPtr);\n", "  cVar1 = this->nation_tech_level_array[(int)info.viewing_nation_recno + -1];\n", "  bitmapPtr = tech_des(this);\n", "  put(&font_san,x + 0x1f,y_00,bitmapPtr,'\\0',-1);\n", "  if ('\\0' < cVar1) {\n", "    bitmapPtr = roman_number(&misc,(int)cVar1);\n", "    put(&font_san,x + 0xb7,y_00,bitmapPtr,'\\0',-1);\n", "  }\n", "  cVar2 = this->nation_is_researching_array[(int)info.viewing_nation_recno + -1];\n", "  if (cVar2 != '\\0') {\n", "    bitmapPtr = roman_number(&misc,(int)cVar1 + 1);\n", "    put(&font_san,x + 0x107,y_00,bitmapPtr,'\\0',-1);\n", "    bitmapPtr = format(&misc,(int)cVar2,1);\n", "    put(&font_san,x + 0x1e3,y_00,bitmapPtr,'\\0',-1);\n", "    d3_panel_down(&vga_util,x + 0x143,y + 3,x + 0x1bb,y + 0x13,0,0);\n", "    curValue = get_progress(this,(int)info.viewing_nation_recno);\n", "    indicator(&vga_back,x + 0x144,y + 4,x + 0x1ba,y + 0x12,curValue,100.00000000,0x90,-1);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_tech_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint   \t techId   = tech_filter(recNo);\n", "\tTechInfo* techInfo = tech_res[techId];\n", "\n", "\t//---------- display bitmap ----------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tvga_back.put_bitmap( x, y-2, techInfo->tech_small_icon() );\n", "\n", "\t//----------- display info ----------//\n", "\n", "\ty+=2;\n", "\n", "\tint curLevel = techInfo->get_nation_tech_level(info.viewing_nation_recno);\n", "\n", "\tfont_san.put( x+28 , y, techInfo->tech_des() );\n", "\n", "\tif( curLevel > 0 )\n", "\t\tfont_san.put( x+180, y, misc.roman_number(curLevel) );\n", "\n", "\t//----- if the nation is researching this technology -----//\n", "\n", "\tint isResearching = techInfo->is_nation_researching(info.viewing_nation_recno);\n", "\n", "\tif( isResearching )\n", "\t{\n", "\t\terr_when( curLevel >= techInfo->max_tech_level );\n", "\n", "\t\tfont_san.put( x+260, y, misc.roman_number(curLevel+1) );\n", "\t\tfont_san.put( x+480, y, isResearching );\t\t//isResearching tells the no. of towers of science researching this technology\n", "\n", "\t\t//----- display the research progress bar -----//\n", "\n", "\t\tvga_util.d3_panel_down( x+320, y-2, x+440, y+14 );\n", "\t\tvga_back.indicator( x+321, y-1, x+439, y+13, techInfo->get_progress(info.viewing_nation_recno), (float)100, VGA_GRAY );\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void validate_selected_unit_array(short *selectedUnitArray,short *selectedUnitCount)\n", "\n", "{\n", "  short *__dest;\n", "  short sVar1;\n", "  Unit *this;\n", "  int iVar2;\n", "  int iVar3;\n", "  \n", "  iVar3 = 0;\n", "  if (0 < *selectedUnitCount) {\n", "    do {\n", "      while( true ) {\n", "        __dest = selectedUnitArray + (long)iVar3;\n", "        iVar2 = is_deleted(&unit_array,(int)*__dest);\n", "        if ((((iVar2 == 0) && (sVar1 = *__dest, 0 < sVar1)) &&\n", "            ((int)sVar1 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)) &&\n", "           (((this = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf\n", "                               + ((int)sVar1 + -1) *\n", "                                 unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                 ele_size), this != (Unit *)0x0 && (-1 < (this->super_Sprite).cur_x)\n", "             ) && (iVar2 = is_nation(this,(int)remote.nation_processing), iVar2 != 0)))) break;\n", "        memmove(__dest,selectedUnitArray + (long)iVar3 + 1,\n", "                (long)((*selectedUnitCount - iVar3) + -1) * 2);\n", "        sVar1 = *selectedUnitCount;\n", "        *selectedUnitCount = sVar1 + -1;\n", "        if ((short)(sVar1 + -1) <= iVar3) {\n", "          return;\n", "        }\n", "      }\n", "      iVar3 = iVar3 + 1;\n", "    } while (iVar3 < *selectedUnitCount);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void validate_selected_unit_array(short* selectedUnitArray, short& selectedUnitCount)\n", "{\n", "\tfor( int i=0 ; i<selectedUnitCount ; i++ )\n", "\t{\n", "\t\tUnit* unitPtr;\n", "\t\tif( unit_array.is_deleted(selectedUnitArray[i]) || \n", "\t\t\t!(unitPtr = unit_array[selectedUnitArray[i]]) ||\n", "\t\t\t!unitPtr->is_visible() || !unitPtr->is_nation(remote.nation_processing) )\n", "\t\t{\n", "\t\t\tmemmove( selectedUnitArray+i, selectedUnitArray+i+1, sizeof(short) * (selectedUnitCount-i-1) );\n", "\t\t\tselectedUnitCount--;\n", "\t\t\ti--;\t\t\t\t\t\t\t// stay with the current recno as the records have been moved. The recno in the current position is actually the next record.\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int seinfo_cmp(void *r1,void *r2)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = memcmp(r1,r2,0x1a);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["static int seinfo_cmp(const void *r1, const void *r2)\n", "{\n", "\treturn memcmp(r1, r2, sizeof(SEInfo));\n", "}"]}, {"ghidra": ["\n", "void put_caravan_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  int y_00;\n", "  long lVar1;\n", "  long *plVar2;\n", "  short sVar3;\n", "  int iVar4;\n", "  char *textPtr;\n", "  int iVar5;\n", "  long lVar6;\n", "  long in_FS_OFFSET;\n", "  String str;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  sVar3 = get_report_data(&info,recNo);\n", "  if ((sVar3 < 1) ||\n", "     (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < (int)sVar3)) {\n", "    String(&str);\n", "    do {\n", "      invalidInstructionException();\n", "    } while( true );\n", "  }\n", "  y_00 = y + 3;\n", "  plVar2 = *(long **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                     ((int)sVar3 + -1) *\n", "                     unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "  iVar4 = x + -3 + (int)browse_caravan.super_VBrowse.rec_width;\n", "  String(&str);\n", "  operator_(&str,(long)(int)*(float *)(plVar2 + 0xc));\n", "  operator__(&str,\"/\");\n", "  operator__(&str,(long)*(short *)((long)plVar2 + 100));\n", "  textPtr = (char *)(**(code **)(*plVar2 + 0x78))(plVar2);\n", "  put(&font_san,x + 3,y_00,textPtr,'\\0',-1);\n", "  put(&font_san,x + 0x5d,y_00,(char *)&str,'\\0',-1);\n", "  if ((('\\0' < *(char *)((long)plVar2 + 0xc5)) &&\n", "      (put_stop_info(x + 0xa3,y_00,(TradeStop *)((long)plVar2 + 0xcb)),\n", "      '\\x01' < *(char *)((long)plVar2 + 0xc5))) &&\n", "     (put_stop_info(x + 0xdf,y_00,(TradeStop *)((long)plVar2 + 0xd9)),\n", "     '\\x02' < *(char *)((long)plVar2 + 0xc5))) {\n", "    put_stop_info(x + 0x11b,y_00,(TradeStop *)((long)plVar2 + 0xe7));\n", "  }\n", "  x = x + 0x157;\n", "  lVar6 = 0;\n", "  do {\n", "    if (*(short *)((long)plVar2 + lVar6 * 2 + 0xfd) != 0) {\n", "      textPtr = read(&raw_res.res_icon,(int)lVar6 + 10);\n", "      put_bitmap(&vga_back,x,y_00,textPtr);\n", "      disp(&font_san,x + 0xe,y + 2,(int)*(short *)((long)plVar2 + lVar6 * 2 + 0xfd),1,x + 0x2d);\n", "      iVar5 = x + 0x47;\n", "      x = x + 0x24;\n", "      if (iVar4 <= iVar5) goto LAB_0049c3df;\n", "    }\n", "    lVar6 = lVar6 + 1;\n", "  } while (lVar6 != 3);\n", "  lVar6 = 0;\n", "  do {\n", "    if (*(short *)((long)plVar2 + lVar6 * 2 + 0x103) != 0) {\n", "      textPtr = read(&raw_res.res_icon,(int)lVar6 + 4);\n", "      put_bitmap(&vga_back,x,y_00,textPtr);\n", "      disp(&font_san,x + 0xe,y + 2,(int)*(short *)((long)plVar2 + lVar6 * 2 + 0x103),1,x + 0x2d);\n", "      iVar5 = x + 0x47;\n", "      x = x + 0x24;\n", "      if (iVar4 <= iVar5) break;\n", "    }\n", "    lVar6 = lVar6 + 1;\n", "  } while (lVar6 != 3);\n", "LAB_0049c3df:\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void put_caravan_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint   \t\t unitRecno = info.get_report_data(recNo);\n", "\tUnitCaravan* unitPtr   = (UnitCaravan*) unit_array[unitRecno];\n", "\n", "\tint x2 = x+browse_caravan.rec_width-3;\n", "\n", "\t//---------- display info ----------//\n", "\n", "\tx+=3;\n", "\ty+=3;\n", "\n", "\tString str;\n", "\tstr  = (int) unitPtr->hit_points;\n", "\tstr += \"/\";\n", "\tstr += unitPtr->max_hit_points;\n", "\n", "\tfont_san.put( x    , y, unitPtr->unit_name() );\n", "\tfont_san.put( x+90 , y, str );\n", "\n", "\t//------- display pick up type of each stop -------//\n", "\n", "\tif( unitPtr->stop_defined_num >= 1 )\n", "\t\tput_stop_info( x+160, y, unitPtr->stop_array );\n", "\n", "\tif( unitPtr->stop_defined_num >= 2 )\n", "\t\tput_stop_info( x+220, y, unitPtr->stop_array+1 );\n", "\n", "\tif( unitPtr->stop_defined_num >= 3 )\n", "\t\tput_stop_info( x+280, y, unitPtr->stop_array+2 );\n", "\n", "\t//------- display goods carried -------//\n", "\n", "\tx += 340;\n", "\n", "\tchar *bitmapPtr;\n", "\n", "\tint i;\n", "\tfor(i=0; i<MAX_RAW; i++)\n", "\t{\n", "\t\tif( unitPtr->raw_qty_array[i]==0 )\n", "\t\t\tcontinue;\n", "\n", "\t\tbitmapPtr = raw_res.small_raw_icon(i+1);\n", "\t\tvga_back.put_bitmap( x, y, bitmapPtr );\n", "\n", "\t\tfont_san.disp( x+14, y-1, unitPtr->raw_qty_array[i], 1, x+45 );\n", "\t\tx+=36;\n", "\n", "\t\tif( x+36 > x2 )\n", "\t\t\treturn;\n", "\t}\n", "\n", "\tfor( i=0; i<MAX_PRODUCT; i++)\n", "\t{\n", "\t\tif( unitPtr->product_raw_qty_array[i]==0 )\n", "\t\t\tcontinue;\n", "\n", "\t\tbitmapPtr = raw_res.small_product_icon(i+1);\n", "\t\tvga_back.put_bitmap( x, y, bitmapPtr );\n", "\n", "\t\tfont_san.disp( x+14, y-1, unitPtr->product_raw_qty_array[i], 1, x+45 );\n", "\t\tx+=36;\n", "\n", "\t\tif( x+36 > x2 )\n", "\t\t\treturn;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void put_nation_rec(int recNo,int x,int y,int refreshFlag)\n", "\n", "{\n", "  int y_00;\n", "  int nationRecno;\n", "  char *textPtr;\n", "  NationBase *this;\n", "  \n", "  this = (NationBase *)0x0;\n", "  nationRecno = nation_filter(recNo);\n", "  if ((0 < nationRecno) && (nationRecno <= nation_array.super_DynArrayB.super_DynArray.last_ele)) {\n", "    this = *(NationBase **)\n", "            (nation_array.super_DynArrayB.super_DynArray.body_buf +\n", "            (nationRecno + -1) * nation_array.super_DynArrayB.super_DynArray.ele_size);\n", "  }\n", "  y_00 = y + 5;\n", "  disp_nation_color(this,x + 3,y + 9);\n", "  textPtr = nation_name(this);\n", "  put(&font_san,x + 0x17,y_00,textPtr,'\\0',-1);\n", "  textPtr = get_rank_pos_str(&info,1,nationRecno);\n", "  put(&font_san,x + 0xd5,y_00,textPtr,'\\0',-1);\n", "  textPtr = get_rank_pos_str(&info,2,nationRecno);\n", "  put(&font_san,x + 0x111,y_00,textPtr,'\\0',-1);\n", "  textPtr = get_rank_pos_str(&info,3,nationRecno);\n", "  put(&font_san,x + 0x163,y_00,textPtr,'\\0',-1);\n", "  textPtr = get_rank_pos_str(&info,4,nationRecno);\n", "  put(&font_san,x + 0x1b6,y_00,textPtr,'\\0',-1);\n", "  textPtr = get_rank_pos_str(&info,5,nationRecno);\n", "  put(&font_san,x + 0x1f7,y_00,textPtr,'\\0',-1);\n", "  return;\n", "}\n", "\n"], "c": ["static void put_nation_rec(int recNo, int x, int y, int refreshFlag)\n", "{\n", "\tint\t  nationRecno = nation_filter(recNo);\n", "\tNation* nationPtr   = nation_array[nationRecno];\n", "\n", "\tx+=3;\n", "\ty+=5;\n", "\n", "\tnationPtr->disp_nation_color(x, y+4);\n", "\n", "\tfont_san.put( x+20, y, nationPtr->nation_name() );\n", "\n", "\tfont_san.put( x+210, y, info.get_rank_pos_str(1, nationRecno) );\n", "\tfont_san.put( x+270, y, info.get_rank_pos_str(2, nationRecno) );\n", "\tfont_san.put( x+352, y, info.get_rank_pos_str(3, nationRecno) );\n", "\tfont_san.put( x+435, y, info.get_rank_pos_str(4, nationRecno) );\n", "  \tfont_san.put( x+500, y, info.get_rank_pos_str(5, nationRecno) );\n", "}"]}, {"ghidra": ["\n", "int locate_ship_in_harbor(void)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  int iVar3;\n", "  int iVar4;\n", "  \n", "  iVar2 = firm_array.super_DynArrayB.super_DynArray.last_ele + -1 +\n", "          (uint)(firm_array.selected_recno == 0);\n", "  iVar4 = firm_array.selected_recno;\n", "  if (iVar2 < 1) {\n", "    return 0;\n", "  }\n", "  do {\n", "    while (iVar3 = iVar4 + 1, firm_array.super_DynArrayB.super_DynArray.last_ele < iVar3) {\n", "      if (0 < firm_array.super_DynArrayB.super_DynArray.last_ele) {\n", "        iVar4 = 0;\n", "        iVar3 = 1;\n", "        goto LAB_004b0c3b;\n", "      }\n", "      iVar3 = 1;\n", "LAB_004b0c55:\n", "      iVar2 = iVar2 + -1;\n", "      iVar4 = iVar3;\n", "      if (iVar2 == 0) {\n", "        return 0;\n", "      }\n", "    }\n", "    if (0 < iVar3) {\n", "LAB_004b0c3b:\n", "      lVar1 = *(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                       iVar4 * firm_array.super_DynArrayB.super_DynArray.ele_size);\n", "      if (lVar1 != 0) {\n", "        if (firm_array.super_DynArrayB.super_DynArray.last_ele < iVar3) {\n", "          do {\n", "            invalidInstructionException();\n", "          } while( true );\n", "        }\n", "        if (((*(char *)(lVar1 + 8) == '\\t') &&\n", "            (*(short *)(lVar1 + 0x13) == nation_array.player_recno)) &&\n", "           (*(short *)(lVar1 + 0x10e) != 0)) {\n", "          go_loc(&world,(int)*(short *)(lVar1 + 0x29),(int)*(short *)(lVar1 + 0x2b),1);\n", "          return 1;\n", "        }\n", "      }\n", "      goto LAB_004b0c55;\n", "    }\n", "    iVar2 = iVar2 + -1;\n", "    iVar4 = iVar3;\n", "    if (iVar2 == 0) {\n", "      return 0;\n", "    }\n", "  } while( true );\n", "}\n", "\n"], "c": ["static int locate_ship_in_harbor()\n", "{\n", "   int firmRecno = firm_array.selected_recno;\n", "   int checkSize = firm_array.size();\n", "   if(firmRecno)\n", "      checkSize--; // not include the selected firm\n", "\n", "   for( int i=checkSize ; i>0 ; i-- )\n", "   {\n", "      if( ++firmRecno > firm_array.size() )\n", "         firmRecno = 1;\n", "\n", "      if( firm_array.is_deleted(firmRecno) )\n", "         continue;\n", "\n", "      Firm* firmPtr = firm_array[firmRecno];\n", "      if(firmPtr->firm_id!=FIRM_HARBOR ||\n", "         firmPtr->nation_recno != nation_array.player_recno)\n", "         continue;\n", "\n", "      if(((FirmHarbor*)firmPtr)->ship_count==0)\n", "         continue; // not interested\n", "\n", "      world.go_loc(firmPtr->center_x, firmPtr->center_y, 1);\n", "      return 1;\n", "   }\n", "   return 0;\n", "}"]}, {"ghidra": ["\n", "int can_move_to(int xLoc,int yLoc)\n", "\n", "{\n", "  char cVar1;\n", "  short sVar2;\n", "  long lVar3;\n", "  int iVar4;\n", "  Location *pLVar5;\n", "  ulong uVar6;\n", "  bool bVar7;\n", "  \n", "  pLVar5 = world_loc_matrix + (long)xLoc + (long)(max_x_loc * yLoc);\n", "  if (mobile_type != 'L') {\n", "    if (mobile_type == 'S') {\n", "      if (search_mode < 7) {\n", "        if ((*(byte *)&pLVar5->loc_flag & 2) == 0) {\n", "          return 0;\n", "        }\n", "        sVar2 = pLVar5->cargo_recno;\n", "        iVar4 = (int)sVar2;\n", "        if (sVar2 == 0) {\n", "          return 1;\n", "        }\n", "        if (search_mode == 2) {\n", "          if (iVar4 < 1) goto code_r0x004a26d0;\n", "          goto joined_r0x004a26bd;\n", "        }\n", "        if ((search_mode == 3) && (sVar2 == target_recno)) {\n", "          return 1;\n", "        }\n", "      }\n", "      else {\n", "        switch(search_mode) {\n", "        case 7:\n", "        case 8:\n", "        case 0xb:\n", "        case 0xc:\n", "        case 0xd:\n", "        case 0xe:\n", "          if ((*(byte *)&pLVar5->loc_flag & 2) == 0) goto LAB_004a2665;\n", "        default:\n", "          iVar4 = (int)pLVar5->cargo_recno;\n", "          if (pLVar5->cargo_recno == 0) {\n", "            return 1;\n", "          }\n", "          break;\n", "        case 0xf:\n", "          if ((pLVar5->loc_flag & 2) == 0) {\n", "            if ((pLVar5->loc_flag & 1) == 0) {\n", "              return 0;\n", "            }\n", "            return (int)(uint)(pLVar5->region_id == region_id);\n", "          }\n", "          iVar4 = (int)pLVar5->cargo_recno;\n", "          if (pLVar5->cargo_recno == 0) {\n", "            return 1;\n", "          }\n", "          if ((0 < iVar4) &&\n", "             (iVar4 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)) {\n", "            lVar3 = *(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                             (iVar4 + -1) *\n", "                             unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "            if (*(DWORD *)(lVar3 + 0x31) != group_id) {\n", "              return (uint)(*(char *)(lVar3 + 0xd) == '\\x03');\n", "            }\n", "            if (*(char *)(lVar3 + 0xd) == '\\x05') {\n", "              return 0;\n", "            }\n", "            return (int)(uint)(*(char *)(lVar3 + 0x4a) != '\\t');\n", "          }\n", "          goto code_r0x004a26d0;\n", "        }\n", "      }\n", "    }\n", "    else {\n", "      if (mobile_type != 'A') {\n", "        return 0;\n", "      }\n", "      sVar2 = pLVar5->air_cargo_recno;\n", "      iVar4 = (int)sVar2;\n", "      if (sVar2 == 0) {\n", "        return 1;\n", "      }\n", "      if (0xd < (ushort)((uint)(ushort)search_mode - 1)) {\n", "        return 0;\n", "      }\n", "      uVar6 = 1 << ((byte)((uint)(ushort)search_mode - 1) & 0x3f);\n", "      if ((uVar6 & 0x3fcd) == 0) {\n", "        if ((uVar6 & 2) == 0) {\n", "          return 0;\n", "        }\n", "        if (sVar2 < 1) goto code_r0x004a26d0;\n", "joined_r0x004a26bd:\n", "        if (iVar4 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele) {\n", "          return (int)(uint)(*(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.\n", "                                                 super_DynArray.body_buf +\n", "                                                (iVar4 + -1) *\n", "                                                unit_array.super_SpriteArray.super_DynArrayB.\n", "                                                super_DynArray.ele_size) + 0xd) == '\\x03');\n", "        }\n", "        goto code_r0x004a26d0;\n", "      }\n", "    }\n", "    if ((0 < iVar4) &&\n", "       (iVar4 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)) {\n", "      lVar3 = *(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                       (iVar4 + -1) *\n", "                       unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "      cVar1 = *(char *)(lVar3 + 0xd);\n", "      if (*(DWORD *)(lVar3 + 0x31) == group_id) {\n", "        if (cVar1 != '\\x05') {\n", "          return 1;\n", "        }\n", "      }\n", "      else {\n", "        if (cVar1 == '\\x03') {\n", "          return 1;\n", "        }\n", "      }\n", "      return (int)(uint)(*(char *)(lVar3 + 0x2d) == seek_nation_recno && cVar1 == '\\x01');\n", "    }\n", "    goto code_r0x004a26d0;\n", "  }\n", "  if (((search_sub_mode == '\\x01') && (pLVar5->power_nation_recno != '\\0')) &&\n", "     (nation_passable[pLVar5->power_nation_recno] == '\\0')) {\n", "    return 0;\n", "  }\n", "  if (search_mode < 7) {\n", "    if ((*(byte *)&pLVar5->loc_flag & 1) == 0) {\n", "      return 0;\n", "    }\n", "    sVar2 = pLVar5->cargo_recno;\n", "    iVar4 = (int)sVar2;\n", "    if (sVar2 == 0) {\n", "      return 1;\n", "    }\n", "    if (search_mode == 3) {\n", "LAB_004a25b2:\n", "      if (sVar2 == target_recno) {\n", "        return 1;\n", "      }\n", "    }\n", "    else {\n", "      if (search_mode < 4) {\n", "        if (search_mode == 2) {\n", "          if ((0 < iVar4) &&\n", "             (iVar4 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)) {\n", "            if (*(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                    body_buf +\n", "                                   (iVar4 + -1) *\n", "                                   unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                   ele_size) + 0xd) != '\\x03') {\n", "              return 0;\n", "            }\n", "            return (int)(uint)(*(char *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.\n", "                                                   super_DynArray.body_buf +\n", "                                                  (iVar4 + -1) *\n", "                                                  unit_array.super_SpriteArray.super_DynArrayB.\n", "                                                  super_DynArray.ele_size) + 0x2a) != '\\b');\n", "          }\n", "          goto code_r0x004a26d0;\n", "        }\n", "      }\n", "      else {\n", "        if (search_mode == 5) {\n", "          if ((0 < sVar2) &&\n", "             (iVar4 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)) {\n", "            if (*(DWORD *)(*(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                     body_buf +\n", "                                    (iVar4 + -1) *\n", "                                    unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.\n", "                                    ele_size) + 0x31) != group_id) {\n", "              return 0;\n", "            }\n", "            return (int)(uint)((byte)(*(char *)(*(long *)(unit_array.super_SpriteArray.\n", "                                                          super_DynArrayB.super_DynArray.body_buf +\n", "                                                         (iVar4 + -1) *\n", "                                                         unit_array.super_SpriteArray.\n", "                                                         super_DynArrayB.super_DynArray.ele_size) +\n", "                                               0xd) - 2U) < 2);\n", "          }\n", "          do {\n", "            invalidInstructionException();\n", "          } while( true );\n", "        }\n", "        if (search_mode == 6) goto LAB_004a25b2;\n", "      }\n", "    }\n", "  }\n", "  else {\n", "    if ((ushort)(search_mode - 7U) < 8) {\n", "      bVar7 = (*(byte *)&pLVar5->loc_flag & 1) == 0;\n", "      switch(search_mode) {\n", "      default:\n", "        if (bVar7) {\n", "LAB_004a2665:\n", "          if (xLoc < building_x1) {\n", "            return 0;\n", "          }\n", "          if (building_x2 < xLoc) {\n", "            return 0;\n", "          }\n", "          if (yLoc < building_y1) {\n", "            return 0;\n", "          }\n", "          return (int)(uint)(yLoc <= building_y2);\n", "        }\n", "        break;\n", "      case 9:\n", "        if (bVar7) goto LAB_004a2756;\n", "        break;\n", "      case 10:\n", "        if ((!bVar7) && (pLVar5->cargo_recno == 0)) {\n", "          return 1;\n", "        }\n", "LAB_004a2756:\n", "        if ((int)final_dest_x != xLoc) {\n", "          return 0;\n", "        }\n", "        return (int)(uint)(yLoc == (int)final_dest_y);\n", "      }\n", "    }\n", "    iVar4 = (int)pLVar5->cargo_recno;\n", "    if (pLVar5->cargo_recno == 0) {\n", "      return 1;\n", "    }\n", "  }\n", "  if ((0 < iVar4) && (iVar4 <= unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele)\n", "     ) {\n", "    lVar3 = *(long *)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                     (iVar4 + -1) *\n", "                     unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "    cVar1 = *(char *)(lVar3 + 0xd);\n", "    if (*(DWORD *)(lVar3 + 0x31) == group_id) {\n", "      if (cVar1 != '\\x05') {\n", "        return 1;\n", "      }\n", "    }\n", "    else {\n", "      if (((cVar1 == '\\x03') &&\n", "          ((int)*(short *)(lVar3 + 0x16) - (int)*(short *)(lVar3 + 0x1e) < 0x11)) &&\n", "         ((int)*(short *)(lVar3 + 0x18) - (int)*(short *)(lVar3 + 0x20) < 0x11)) {\n", "        return 1;\n", "      }\n", "    }\n", "    return (int)(uint)(cVar1 == '\\x01' && *(char *)(lVar3 + 0x2d) == seek_nation_recno);\n", "  }\n", "code_r0x004a26d0:\n", "  do {\n", "    invalidInstructionException();\n", "  } while( true );\n", "}\n", "\n"], "c": ["static int can_move_to(int xLoc, int yLoc)\n", "{\n", "\tLocation\t*locPtr = world_loc_matrix+yLoc*MAX_WORLD_X_LOC+xLoc;\n", "\tUnit\t\t*unitPtr;\n", "\tshort\t\trecno;\n", "\tchar\t\tpowerNationRecno;\n", "\tUCHAR\t\tunitCurAction;\n", "\n", "\t//------ check terrain id. -------//\n", "\tswitch(mobile_type)\n", "\t{\n", "\t\tcase UNIT_LAND:\n", "\t\t\tif(search_sub_mode==SEARCH_SUB_MODE_PASSABLE && (powerNationRecno=locPtr->power_nation_recno) &&\n", "\t\t\t\t!nation_passable[powerNationRecno])\n", "\t\t\t\treturn 0;\n", "\n", "\t\t\tif(search_mode<SEARCH_MODE_TO_FIRM)  //------ be careful for the checking for search_mode>=SEARCH_MODE_TO_FIRM\n", "\t\t\t{\n", "\t\t\t\t//------------------------------------------------------------------------//\n", "\t\t\t\tif(!locPtr->walkable())\n", "\t\t\t\t\treturn 0;\n", "\t\t\t\t\n", "\t\t\t\trecno = locPtr->cargo_recno;\n", "\t\t\t\tif(!recno)\n", "\t\t\t\t\treturn 1;\n", "\n", "\t\t\t\tswitch(search_mode)\n", "\t\t\t\t{\n", "\t\t\t\t\tcase SEARCH_MODE_IN_A_GROUP:\t// group move\n", "\t\t\t\t\tcase SEARCH_MODE_REUSE:\t\t// path-reuse\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_A_UNIT_IN_GROUP:\t// a unit in a group\n", "\t\t\t\t\t\t\tunitPtr = unit_array[recno];\n", "\t\t\t\t\t\t\treturn unitPtr->cur_action==SPRITE_MOVE && unitPtr->unit_id!=UNIT_CARAVAN;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_TO_ATTACK:\t// to attack target\n", "\t\t\t\t\tcase SEARCH_MODE_TO_VEHICLE:\t// move to a vehicle\n", "\t\t\t\t\t\t\tif(recno==target_recno)\n", "\t\t\t\t\t\t\t\treturn 1;\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_BLOCKING:\t// 2x2 unit blocking\n", "\t\t\t\t\t\t\tunitPtr = unit_array[recno];\n", "\t\t\t\t\t\t\treturn unitPtr->unit_group_id==group_id && (unitPtr->cur_action==SPRITE_MOVE || unitPtr->cur_action==SPRITE_READY_TO_MOVE);\n", "\t\t\t\t\t\n", "\t\t\t\t\tdefault: err_here();\n", "\t\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\telse\n", "\t\t\t{\n", "\t\t\t\t//--------------------------------------------------------------------------------//\n", "\t\t\t\t// for the following search_mode, location may be treated as walkable although it is not.\n", "\t\t\t\t//--------------------------------------------------------------------------------//\n", "\t\t\t\tswitch(search_mode)\n", "\t\t\t\t{\n", "\t\t\t\t\tcase SEARCH_MODE_TO_FIRM:\t// move to a firm, (location may be not walkable)\n", "\t\t\t\t\tcase SEARCH_MODE_TO_TOWN:\t// move to a town zone, (location may be not walkable)\n", "\t\t\t\t\t\t\tif(!locPtr->walkable())\n", "\t\t\t\t\t\t\t\treturn (xLoc>=building_x1 && xLoc<=building_x2 && yLoc>=building_y1 && yLoc<=building_y2);\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_TO_WALL_FOR_GROUP:\t// move to wall for a group, (location may be not walkable)\n", "\t\t\t\t\t\t\tif(!locPtr->walkable())\n", "\t\t\t\t\t\t\t\treturn (xLoc==final_dest_x && yLoc==final_dest_y);\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_TO_WALL_FOR_UNIT:\t// move to wall for a unit only, (location may be not walkable)\n", "\t\t\t\t\t\t\treturn (locPtr->walkable() && locPtr->cargo_recno==0) || (xLoc==final_dest_x && yLoc==final_dest_y);\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_UNIT_BY_RANGE: // same as that used in SEARCH_MODE_TO_FIRM\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_FIRM_BY_RANGE:\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_TOWN_BY_RANGE:\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_WALL_BY_RANGE:\n", "\t\t\t\t\t\t\tif(!locPtr->walkable())\n", "\t\t\t\t\t\t\t\treturn (xLoc>=building_x1 && xLoc<=building_x2 && yLoc>=building_y1 && yLoc<=building_y2);\n", "\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t\t\t\t\n", "\t\t\t\t\tdefault: err_here();\n", "\t\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\n", "\t\t\t\trecno = (mobile_type!=UNIT_AIR) ? locPtr->cargo_recno : locPtr->air_cargo_recno;\n", "\t\t\t\tif(!recno)\n", "\t\t\t\t\treturn 1;\n", "\t\t\t}\n", "\n", "\t\t\t//------- checking for unit's group_id, cur_action, nation_recno and position --------//\n", "\t\t\tunitPtr = unit_array[recno];\n", "\t\t\tunitCurAction = unitPtr->cur_action;\n", "\t\t\treturn (unitPtr->unit_group_id==group_id && unitCurAction!=SPRITE_ATTACK) ||\n", "\t\t\t\t\t (unitCurAction==SPRITE_MOVE && unitPtr->cur_x-unitPtr->next_x<=ZOOM_LOC_HALF_WIDTH &&\n", "\t\t\t\t\t  unitPtr->cur_y-unitPtr->next_y<=ZOOM_LOC_HALF_HEIGHT) ||\n", "\t\t\t\t\t (unitPtr->nation_recno==seek_nation_recno && unitCurAction==SPRITE_IDLE);\n", "\t\t\tbreak;\n", "\n", "\t\tcase UNIT_SEA:\n", "\t\t\tif(search_mode<SEARCH_MODE_TO_FIRM) //--------- be careful for the search_mode>=SEARCH_MODE_TO_FIRM\n", "\t\t\t{\n", "\t\t\t\tif(!locPtr->sailable())\n", "\t\t\t\t\treturn 0;\n", "\n", "\t\t\t\trecno = locPtr->cargo_recno;\n", "\t\t\t\tif(!recno)\n", "\t\t\t\t\treturn 1;\n", "\n", "\t\t\t\tswitch(search_mode)\n", "\t\t\t\t{\n", "\t\t\t\t\tcase SEARCH_MODE_IN_A_GROUP:\t// group move\n", "\t\t\t\t\tcase SEARCH_MODE_REUSE:\t\t// path-reuse\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_A_UNIT_IN_GROUP:\t// a unit in a group\n", "\t\t\t\t\t\t\treturn unit_array[recno]->cur_action==SPRITE_MOVE;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_TO_ATTACK:\n", "\t\t\t\t\t\t\tif(recno==target_recno)\n", "\t\t\t\t\t\t\t\treturn 1;\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "\t\t\t\t\tdefault:\terr_here();\n", "\t\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\telse\n", "\t\t\t{\n", "\t\t\t\t//--------------------------------------------------------------------------------//\n", "\t\t\t\t// for the following search_mode, location may be treated as sailable although it is not.\n", "\t\t\t\t//--------------------------------------------------------------------------------//\n", "\t\t\t\tswitch(search_mode)\n", "\t\t\t\t{\n", "\t\t\t\t\tcase SEARCH_MODE_TO_FIRM:\t// move to a firm, (location may be not walkable)\n", "\t\t\t\t\tcase SEARCH_MODE_TO_TOWN:\t// move to a town zone, (location may be not walkable)\n", "\t\t\t\t\t\t\tif(!locPtr->sailable())\n", "\t\t\t\t\t\t\t\treturn (xLoc>=building_x1 && xLoc<=building_x2 && yLoc>=building_y1 && yLoc<=building_y2);\n", "\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t\t\n", "\t\t\t\t\t//case SEARCH_MODE_TO_WALL_FOR_GROUP:\t// move to wall for a group, (location may be not walkable)\n", "\t\t\t\t\t//case SEARCH_MODE_TO_WALL_FOR_UNIT:\t// move to wall for a unit only, (location may be not walkable)\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_UNIT_BY_RANGE: // same as that used in SEARCH_MODE_TO_FIRM\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_FIRM_BY_RANGE:\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_TOWN_BY_RANGE:\n", "\t\t\t\t\tcase SEARCH_MODE_ATTACK_WALL_BY_RANGE:\n", "\t\t\t\t\t\t\tif(!locPtr->sailable())\n", "\t\t\t\t\t\t\t\treturn (xLoc>=building_x1 && xLoc<=building_x2 && yLoc>=building_y1 && yLoc<=building_y2);\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "\t\t\t\t\tcase SEARCH_MODE_TO_LAND_FOR_SHIP:\n", "\t\t\t\t\t\t\tif(locPtr->sailable())\n", "\t\t\t\t\t\t\t{\n", "\t\t\t\t\t\t\t\trecno = locPtr->cargo_recno;\n", "\t\t\t\t\t\t\t\tif(!recno)\n", "\t\t\t\t\t\t\t\t\treturn 1;\n", "\n", "\t\t\t\t\t\t\t\tunitPtr = unit_array[recno];\n", "\t\t\t\t\t\t\t\tunitCurAction = unitPtr->cur_action;\n", "\t\t\t\t\t\t\t\treturn (unitPtr->unit_group_id==group_id && unitCurAction!=SPRITE_ATTACK &&\n", "\t\t\t\t\t\t\t\t\t\t  unitPtr->action_mode2!=ACTION_SHIP_TO_BEACH) || \n", "\t\t\t\t\t\t\t\t\t\t (unitPtr->unit_group_id!=group_id && unitCurAction==SPRITE_MOVE);\n", "\t\t\t\t\t\t\t}\n", "\t\t\t\t\t\t\telse if(locPtr->walkable() && locPtr->region_id==region_id)\n", "\t\t\t\t\t\t\t\treturn 1;\n", "\t\t\t\t\t\t\telse\n", "\t\t\t\t\t\t\t\treturn 0;\n", "\n", "\t\t\t\t\tdefault: err_here();\n", "\t\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t\trecno = locPtr->cargo_recno;\n", "\t\t\t\tif(!recno)\n", "\t\t\t\t\treturn 1;\n", "\t\t\t}\n", "\t\t\t\n", "\t\t\t//------- checking for unit's group_id, cur_action, nation_recno and position --------//\n", "\t\t\tunitPtr = unit_array[recno];\n", "\t\t\tunitCurAction = unitPtr->cur_action;\n", "\t\t\treturn (unitPtr->unit_group_id==group_id && unitCurAction!=SPRITE_ATTACK) ||\n", "\t\t\t\t\t unitCurAction==SPRITE_MOVE ||\n", "\t\t\t\t\t (unitPtr->nation_recno==seek_nation_recno && unitCurAction==SPRITE_IDLE);\n", "\t\t\tbreak;\n", "\n", "\t\tcase UNIT_AIR:\n", "\t\t\trecno = locPtr->air_cargo_recno;\n", "\t\t\tif(!recno)\n", "\t\t\t\treturn 1;\n", "\t\t\tswitch(search_mode)\n", "\t\t\t{\n", "\t\t\t\tcase SEARCH_MODE_IN_A_GROUP:\n", "\t\t\t\tcase SEARCH_MODE_REUSE:\n", "\t\t\t\tcase SEARCH_MODE_TO_ATTACK:\n", "\t\t\t\tcase SEARCH_MODE_TO_FIRM:\n", "\t\t\t\tcase SEARCH_MODE_TO_TOWN:\n", "\t\t\t\tcase SEARCH_MODE_TO_WALL_FOR_GROUP:\n", "\t\t\t\tcase SEARCH_MODE_TO_WALL_FOR_UNIT:\n", "\t\t\t\tcase SEARCH_MODE_ATTACK_UNIT_BY_RANGE:\n", "\t\t\t\tcase SEARCH_MODE_ATTACK_FIRM_BY_RANGE:\n", "\t\t\t\tcase SEARCH_MODE_ATTACK_TOWN_BY_RANGE:\n", "\t\t\t\tcase SEARCH_MODE_ATTACK_WALL_BY_RANGE:\n", "\t\t\t\t\t\tunitPtr = unit_array[recno];\n", "\t\t\t\t\t\tunitCurAction = unitPtr->cur_action;\n", "\t\t\t\t\t\treturn (unitPtr->unit_group_id==group_id && unitCurAction!=SPRITE_ATTACK) ||\n", "\t\t\t\t\t\t\t\t unitCurAction==SPRITE_MOVE ||\n", "\t\t\t\t\t\t\t\t (unitPtr->nation_recno==seek_nation_recno && unitCurAction==SPRITE_IDLE);\n", "\n", "\t\t\t\tcase SEARCH_MODE_A_UNIT_IN_GROUP: // a unit in a group\n", "\t\t\t\t\t\treturn unit_array[recno]->cur_action==SPRITE_MOVE;\n", "\n", "\t\t\t\tdefault: err_here();\n", "\t\t\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t}\n", "\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void disp_virtual_button(ButtonCustom *button,int param_2)\n", "\n", "{\n", "  int iVar1;\n", "  BYTE *colorTable;\n", "  int x;\n", "  \n", "  hide_area((MouseSDL *)&mouse,(int)button->x1,(int)button->y1,(int)button->x2,(int)button->y2);\n", "  if (button->pushed_flag != '\\0') {\n", "    colorTable = get_table(vga.vga_color_table,-2);\n", "    IMGcopyRemap((char *)(vga_front.surface)->surface->pixels,\n", "                 (uint)(vga_front.surface)->surface->pitch,\n", "                 (char *)(vga_back.surface)->surface->pixels,\n", "                 (uint)(vga_back.surface)->surface->pitch,(int)button->x1,(int)button->y1,\n", "                 (int)button->x2,(int)button->y2,colorTable);\n", "    x = (int)button->x1;\n", "    iVar1 = button->x2 - x;\n", "    if (iVar1 == 0x4d) {\n", "      if ((int)button->y2 - (int)button->y1 == 0x1f) {\n", "        put_front(&image_interface,x,(int)button->y1,\"BAS_DOWN\",0);\n", "      }\n", "    }\n", "    else {\n", "      if (iVar1 == 0x22) {\n", "        if ((int)button->y2 - (int)button->y1 == 0x1f) {\n", "          put_front(&image_interface,x,(int)button->y1,\"COL_DOWN\",0);\n", "        }\n", "      }\n", "      else {\n", "        if ((iVar1 == 0xb3) && ((int)button->y2 - (int)button->y1 == 0x8a)) {\n", "          put_front(&image_interface,x,(int)button->y1,\"NMPG-1BD\",0);\n", "        }\n", "      }\n", "    }\n", "    show_area((MouseSDL *)&mouse);\n", "    return;\n", "  }\n", "  IMGcopy((char *)(vga_front.surface)->surface->pixels,(uint)(vga_front.surface)->surface->pitch,\n", "          (char *)(vga_back.surface)->surface->pixels,(uint)(vga_back.surface)->surface->pitch,\n", "          (int)button->x1,(int)button->y1,(int)button->x2,(int)button->y2);\n", "  show_area((MouseSDL *)&mouse);\n", "  return;\n", "}\n", "\n"], "c": ["static void disp_virtual_button(ButtonCustom *button, int)\n", "{\n", "\tmouse.hide_area(button->x1, button->y1, button->x2, button->y2);\n", "\tif( !button->pushed_flag )\n", "\t{\n", "\t\t// copy from back buffer to front buffer\n", "\t\tIMGcopy(vga_front.buf_ptr(), vga_front.buf_pitch(),\n", "\t\t\tvga_back.buf_ptr(), vga_back.buf_pitch(),\n", "\t\t\tbutton->x1, button->y1, button->x2, button->y2 );\n", "\t}\n", "\telse\n", "\t{\n", "\t\t// copy from back buffer to front buffer, but the area is\n", "\t\t// darkened by 2 scale\n", "\t\tIMGcopyRemap(vga_front.buf_ptr(), vga_front.buf_pitch(),\n", "\t\t\tvga_back.buf_ptr(), vga_back.buf_pitch(),\n", "\t\t\tbutton->x1, button->y1, button->x2, button->y2,\n", "\t\t\tvga.vga_color_table->get_table(-2) );\n", "\n", "\t\t// draw black frame\n", "\t\tif( button->x2-button->x1+1 == BASIC_OPTION_X_SPACE &&\n", "\t\t\tbutton->y2-button->y1+1 == BASIC_OPTION_HEIGHT )\n", "\t\t{\n", "\t\t\timage_interface.put_front(button->x1, button->y1, \"BAS_DOWN\");\n", "\t\t}\n", "\t\telse if( button->x2-button->x1+1 == COLOR_OPTION_X_SPACE &&\n", "\t\t\tbutton->y2-button->y1+1 == COLOR_OPTION_HEIGHT )\n", "\t\t{\n", "\t\t\timage_interface.put_front(button->x1, button->y1, \"COL_DOWN\");\n", "\t\t}\n", "\t\telse if( button->x2-button->x1+1 == SERVICE_OPTION_X_SPACE &&\n", "\t\t\tbutton->y2-button->y1+1 == SERVICE_OPTION_HEIGHT )\n", "\t\t{\n", "\t\t\timage_menu.put_front(button->x1, button->y1, \"NMPG-1BD\");\n", "\t\t}\n", "\t}\n", "\tmouse.show_area();\n", "}"]}, {"ghidra": ["\n", "int sort_session_name(void *a,void *b)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = strcmp((char *)a,(char *)b);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["static int sort_session_name(const void *a, const void *b)\n", "{\n", "\treturn strcmp( ((SessionDesc *)a)->name_str(), ((SessionDesc *)b)->name_str() );\n", "}"]}, {"ghidra": ["\n", "int sort_translate_table(void *a,void *b)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = strcmp(*(char **)a,*(char **)b);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["static int sort_translate_table( const void *a, const void *b )\n", "{\n", "   return strcmp( ((TranslateRec*)a)->from_text_ptr, ((TranslateRec*)b)->from_text_ptr );\n", "}"]}, {"ghidra": ["\n", "void locate_king_general(int rankId)\n", "\n", "{\n", "  short sVar1;\n", "  long lVar2;\n", "  Unit *this;\n", "  int iVar3;\n", "  int recNo;\n", "  int iVar4;\n", "  long in_FS_OFFSET;\n", "  short xLoc;\n", "  short yLoc;\n", "  \n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  recNo = (int)unit_array.super_SpriteArray._58_2_;\n", "  if (unit_array.super_SpriteArray._58_2_ == 0) {\n", "    if ((rankId == 2) || (firm_array.selected_recno == 0)) {\n", "      recNo = 0;\n", "    }\n", "    else {\n", "      if ((firm_array.selected_recno < 1) ||\n", "         (firm_array.super_DynArrayB.super_DynArray.last_ele < firm_array.selected_recno)) {\n", "        do {\n", "          invalidInstructionException();\n", "        } while( true );\n", "      }\n", "      recNo = 0;\n", "      if (((*(byte *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                               (firm_array.selected_recno + -1) *\n", "                               firm_array.super_DynArrayB.super_DynArray.ele_size) + 8) & 0xfb) == 1\n", "          ) && (sVar1 = *(short *)(*(long *)(firm_array.super_DynArrayB.super_DynArray.body_buf +\n", "                                            (firm_array.selected_recno + -1) *\n", "                                            firm_array.super_DynArrayB.super_DynArray.ele_size) +\n", "                                  0x3a), recNo = 0, sVar1 != 0)) {\n", "        recNo = (int)sVar1;\n", "      }\n", "    }\n", "  }\n", "  iVar4 = unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele;\n", "  if (0 < unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele) {\n", "    do {\n", "      recNo = recNo + 1;\n", "      if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo) {\n", "        recNo = 1;\n", "        iVar3 = is_deleted(&unit_array,1);\n", "        if (iVar3 == 0) goto LAB_004b0d90;\n", "      }\n", "      else {\n", "        iVar3 = is_deleted(&unit_array,recNo);\n", "        if (iVar3 == 0) {\n", "          if (recNo < 1) {\n", "code_r0x004b0dee:\n", "            do {\n", "              invalidInstructionException();\n", "            } while( true );\n", "          }\n", "LAB_004b0d90:\n", "          if (unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.last_ele < recNo)\n", "          goto code_r0x004b0dee;\n", "          this = *(Unit **)(unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.body_buf +\n", "                           (recNo + -1) *\n", "                           unit_array.super_SpriteArray.super_DynArrayB.super_DynArray.ele_size);\n", "          if ((((short)this->nation_recno == nation_array.player_recno) &&\n", "              (rankId == (int)this->rank_id)) && (iVar3 = get_cur_loc(this,&xLoc,&yLoc), iVar3 != 0)\n", "             ) {\n", "            go_loc(&world,(int)xLoc,(int)yLoc,1);\n", "            break;\n", "          }\n", "        }\n", "      }\n", "      iVar4 = iVar4 + -1;\n", "    } while (iVar4 != 0);\n", "  }\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["static void locate_king_general(int rankId)\n", "{\n", "   if( !nation_array.player_recno )\n", "      return;\n", "\n", "   int unitRecno = 0;\n", "   if(unit_array.selected_recno)\n", "      unitRecno = unit_array.selected_recno;\n", "   else if(rankId!=RANK_KING && firm_array.selected_recno)\n", "   {\n", "      Firm *firmPtr = firm_array[firm_array.selected_recno];\n", "      if((firmPtr->firm_id==FIRM_CAMP || firmPtr->firm_id==FIRM_BASE) && firmPtr->overseer_recno)\n", "         unitRecno = firmPtr->overseer_recno;\n", "   }\n", "\n", "   for( int i=unit_array.size() ; i>0 ; i-- )\n", "   {\n", "      if( ++unitRecno > unit_array.size() )\n", "         unitRecno = 1;\n", "\n", "      if( unit_array.is_deleted(unitRecno) )\n", "         continue;\n", "\n", "      Unit* unitPtr = unit_array[unitRecno];\n", "\n", "      if( unitPtr->nation_recno == nation_array.player_recno &&\n", "          unitPtr->rank_id == rankId )\n", "      {\n", "         short xLoc, yLoc;\n", "\n", "         if( unitPtr->get_cur_loc(xLoc, yLoc) )\n", "         {\n", "            world.go_loc(xLoc, yLoc, 1);\n", "            return;\n", "         }\n", "      }\n", "   }\n", "}"]}, {"ghidra": ["\n", "void disp_class_buttons(void)\n", "\n", "{\n", "  int iVar1;\n", "  char *bitmapPtr;\n", "  int iVar2;\n", "  \n", "  iVar2 = sub_class_id_array[main_class_id + -1];\n", "  if (main_class_id == 7) {\n", "    if (iVar2 < 8) {\n", "      iVar1 = 0;\n", "    }\n", "    else {\n", "      if (iVar2 < 0xe) {\n", "        iVar1 = 1;\n", "      }\n", "      else {\n", "        iVar1 = (uint)(0x11 < iVar2) + 2;\n", "      }\n", "    }\n", "    bitmapPtr = read((ResourceIdx *)&image_encyc,monster_button_name_array[iVar1]);\n", "    put_bitmap(&vga_back,0xc,0xe9,bitmapPtr);\n", "    iVar2 = iVar2 - \"\"[iVar1];\n", "  }\n", "  else {\n", "    bitmapPtr = read((ResourceIdx *)&image_encyc,button_name_array[main_class_id + -1]);\n", "    put_bitmap(&vga_back,0xc,0xe9,bitmapPtr);\n", "  }\n", "  blt_buf(&vga_util,0xe,0xe,0x9f,0x230,0);\n", "  put_front(&image_encyc,0xe,(main_class_id + -1) * 0x1e + 0xe,\"B_DOWN\",0);\n", "  put_front(&image_encyc,0xe,(iVar2 + -1) * 0x1f + 0xec,\"B_DOWN\",0);\n", "  return;\n", "}\n", "\n"], "c": ["static void disp_class_buttons()\n", "{\n", "\tenum { BUTTON_X=14, BUTTON_WIDTH=146, CLASS_BUTTON_Y=14, CLASS_BUTTON_Y_SPACING=30, \n", "\t\tSUBCLASS_BUTTON_Y=236, SUBCLASS_TOP_BORDER=3, BUTTON_Y_SPACING=31 };\n", "\n", "\tint subClassId = sub_class_id_array[main_class_id-1];\n", "\n", "\tif( main_class_id != ENCYC_FRYHTANS )\n", "\t{\n", "\t\tvga_back.put_bitmap(12, SUBCLASS_BUTTON_Y-SUBCLASS_TOP_BORDER,\n", "\t\t\timage_encyc.get_ptr(button_name_array[main_class_id-1]) );\n", "\t}\n", "\telse\n", "\t{\n", "\t\t// if in monster class, find out which page \n", "\t\tint monsterSubClass;\n", "\t\tfor( monsterSubClass = 1; monsterSubClass <= FRYHTAN_MAX_PAGE &&\n", "\t\t\tsub_class_id_array[main_class_id-1]-1 >= monster_page_index[monsterSubClass];\n", "\t\t\t++monsterSubClass);\n", "\t\terr_when( monsterSubClass > FRYHTAN_MAX_PAGE );\n", "\t\tvga_back.put_bitmap(12, SUBCLASS_BUTTON_Y-SUBCLASS_TOP_BORDER, \n", "\t\t\timage_encyc.get_ptr(monster_button_name_array[monsterSubClass-1]) );\n", "\n", "\t\t// modify subClassId\n", "\t\tsubClassId -= monster_page_index[monsterSubClass-1];\n", "\t}\n", "\n", "\tvga_util.blt_buf( BUTTON_X, 14, BUTTON_X+BUTTON_WIDTH-1, VGA_HEIGHT-40, 0 );\n", "\n", "\tint y=CLASS_BUTTON_Y;\n", "\t// ###### begin Gilbert 22/9 #######//\n", "\timage_encyc.put_front( BUTTON_X, y + (main_class_id-1)*CLASS_BUTTON_Y_SPACING, \"B_DOWN\");\n", "\t// ###### end Gilbert 22/9 #######//\n", "\n", "\ty=SUBCLASS_BUTTON_Y;\n", "\t// #### begin Gilbert 22/9 #######//\n", "\timage_encyc.put_front( BUTTON_X, y + (subClassId-1)*BUTTON_Y_SPACING, \"B_DOWN\");\n", "\t// #### end Gilbert 22/9 #######//\n", "}"]}, {"ghidra": ["\n", "void put_stat(int y,char *desStr,int dispValue)\n", "\n", "{\n", "  char *textPtr;\n", "  \n", "  put(&font_bible,0x8c,y,desStr,'\\0',-1);\n", "  textPtr = format(&misc,dispValue,1);\n", "  put(&font_bible,0x23a,y,textPtr,'\\0',-1);\n", "  return;\n", "}\n", "\n"], "c": ["static void put_stat(int y, const char* desStr, int dispValue)\n", "{\n", "\tfont_bible.put( 140, y, desStr );\n", "\tfont_bible.put( 570, y, misc.format(dispValue) );\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  undefined8 uVar1;\n", "  __uid_t __uid;\n", "  int iVar2;\n", "  passwd *ppVar3;\n", "  char *rel;\n", "  FILE *__stream;\n", "  mntent *mnt;\n", "  char *__s2;\n", "  undefined auVar4 [16];\n", "  undefined8 uStack72;\n", "  undefined auStack64 [4];\n", "  int local_3c;\n", "  \n", "  __uid = getuid();\n", "  ppVar3 = getpwuid(__uid);\n", "  if (ppVar3 != (passwd *)0x0) {\n", "    local_3c = 0;\n", "    do {\n", "      argv = argv + 1;\n", "      rel = *argv;\n", "      while( true ) {\n", "        if (rel == (char *)0x0) {\n", "          return local_3c;\n", "        }\n", "        rel = canonpath(rel);\n", "        if (rel == (char *)0x0) break;\n", "        __stream = fopen(\"/proc/mounts\",\"r\");\n", "        if (__stream == (FILE *)0x0) goto LAB_00400c1a;\n", "        do {\n", "          mnt = (mntent *)getmntent(__stream);\n", "          if (mnt == (mntent *)0x0) {\n", "            warnx(\"%s not found in /proc/mounts\",rel);\n", "            local_3c = 1;\n", "            goto done;\n", "          }\n", "          __s2 = mnt->mnt_dir;\n", "          iVar2 = strcmp(rel,__s2);\n", "        } while (iVar2 != 0);\n", "        iVar2 = indir(mnt,ppVar3->pw_dir);\n", "        if (iVar2 == 0) {\n", "          __s2 = mnt->mnt_type;\n", "          if (((*__s2 == '9') && (__s2[1] == 'p')) && (__s2[2] == '\\0')) {\n", "            iVar2 = mountedby(mnt,ppVar3->pw_name);\n", "            if (iVar2 != 0) {\n", "              __s2 = mnt->mnt_dir;\n", "              goto LAB_00400ba7;\n", "            }\n", "            warnx(\"%s: not mounted by you\",rel);\n", "            local_3c = 1;\n", "          }\n", "          else {\n", "            warnx(\"%s: refusing to unmount non-9p fs\",rel);\n", "            local_3c = 1;\n", "          }\n", "        }\n", "        else {\n", "LAB_00400ba7:\n", "          iVar2 = umount(__s2);\n", "          if (iVar2 != 0) {\n", "            warn(\"umount %s\",mnt->mnt_dir);\n", "            local_3c = 1;\n", "          }\n", "        }\n", "done:\n", "        argv = argv + 1;\n", "        free(rel);\n", "        fclose(__stream);\n", "        rel = *argv;\n", "      }\n", "      warn(\"%s: canonpath\",*argv);\n", "    } while( true );\n", "  }\n", "  err(1,\"who are you?? getpwuid failed\");\n", "LAB_00400c1a:\n", "  auVar4 = err(1,\"couldn\\'t open /proc/mounts\");\n", "  uVar1 = uStack72;\n", "  uStack72 = SUB168(auVar4,0);\n", "  __libc_start_main(main,uVar1,auStack64,__libc_csu_init,__libc_csu_fini,SUB168(auVar4 >> 0x40,0),\n", "                    &uStack72);\n", "  do {\n", "                    /* WARNING: Do nothing block with infinite loop */\n", "  } while( true );\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tint ret = 0;\n", "\tchar *path;\n", "\tFILE *fp;\n", "\tstruct mntent *mnt;\n", "\tstruct passwd *pw;\n", "\n", "\tif (!(pw=getpwuid(getuid()))) {\n", "\t\terr(1, \"who are you?? getpwuid failed\");\n", "\t}\n", "\n", "\twhile (*++argv) {\n", "\t\tif (!(path=canonpath(*argv))) {\n", "\t\t\twarn(\"%s: canonpath\", *argv);\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\tif (!(fp=fopen(\"/proc/mounts\", \"r\"))) {\n", "\t\t\terr(1, \"couldn't open /proc/mounts\");\n", "\t\t}\n", "\t\twhile ((mnt=getmntent(fp))) {\n", "\t\t\tif (strcmp(path, mnt->mnt_dir) == 0) {\n", "\t\t\t\tint inhomedir;\n", "\t\t\t\tinhomedir = indir(mnt, pw->pw_dir);\n", "\t\t\t\tif (!inhomedir && strcmp(mnt->mnt_type, \"9p\") != 0) {\n", "\t\t\t\t\twarnx(\"%s: refusing to unmount non-9p fs\", path);\n", "\t\t\t\t\tret = 1;\n", "\t\t\t\t} else if (!inhomedir && !mountedby(mnt, pw->pw_name)) {\n", "\t\t\t\t\twarnx(\"%s: not mounted by you\", path);\n", "\t\t\t\t\tret = 1;\n", "\t\t\t\t} else if (umount(mnt->mnt_dir)) {\n", "\t\t\t\t\twarn(\"umount %s\", mnt->mnt_dir);\n", "\t\t\t\t\tret = 1;\n", "\t\t\t\t}\n", "\t\t\t\tgoto done;\n", "\t\t\t}\n", "\t\t}\n", "\t\twarnx(\"%s not found in /proc/mounts\", path);\n", "\t\tret = 1;\n", "\n", "done:\n", "\t\tfree(path);\n", "\t\tfclose(fp);\n", "\t}\n", "\treturn ret;\n", "}"]}, {"ghidra": ["\n", "int indir(mntent *mnt,char *dir)\n", "\n", "{\n", "  int iVar1;\n", "  size_t __n;\n", "  \n", "  __n = strlen(dir);\n", "  iVar1 = strncmp(mnt->mnt_dir,dir,__n);\n", "  return (int)(uint)(iVar1 == 0);\n", "}\n", "\n"], "c": ["int\n", "indir(struct mntent *mnt, char *dir)\n", "{\n", "\treturn (strncmp(mnt->mnt_dir, dir, strlen(dir)) == 0);\n", "}"]}, {"ghidra": ["\n", "char * canonpath(char *rel)\n", "\n", "{\n", "  char cVar1;\n", "  uint uVar2;\n", "  uint uVar3;\n", "  char *__s;\n", "  size_t __n;\n", "  size_t __n_00;\n", "  char *pcVar4;\n", "  uint *__src;\n", "  long lVar5;\n", "  long lVar6;\n", "  uint *__src_00;\n", "  uint *__dest;\n", "  uint *puVar7;\n", "  uint *__dest_00;\n", "  bool bVar8;\n", "  byte bVar9;\n", "  \n", "  bVar9 = 0;\n", "  if (*rel == '/') {\n", "    __n = strlen(rel);\n", "    __dest_00 = (uint *)malloc(__n + 2);\n", "    if (__dest_00 != (uint *)0x0) {\n", "      memcpy(__dest_00,rel,__n);\n", "      *(undefined2 *)((long)__dest_00 + __n) = 0x2f;\n", "LAB_00400dc0:\n", "      __src_00 = (uint *)((long)__dest_00 + 1);\n", "      __dest = __dest_00;\n", "LAB_00400dd0:\n", "      do {\n", "        while( true ) {\n", "          __src = (uint *)strchr((char *)__src_00,0x2f);\n", "          puVar7 = __dest_00;\n", "          if (__src == (uint *)0x0) {\n", "            do {\n", "              __dest = puVar7;\n", "              uVar2 = *__dest + 0xfefefeff & ~*__dest;\n", "              uVar3 = uVar2 & 0x80808080;\n", "              bVar9 = (byte)uVar3;\n", "              puVar7 = __dest + 1;\n", "            } while (uVar3 == 0);\n", "            bVar8 = (uVar2 & 0x8080) == 0;\n", "            if (bVar8) {\n", "              bVar9 = (byte)(uVar3 >> 0x10);\n", "            }\n", "            __src_00 = __dest + 1;\n", "            if (bVar8) {\n", "              __src_00 = (uint *)((long)__dest + 6);\n", "            }\n", "            *(undefined *)((long)__src_00 + (-4 - (ulong)CARRY1(bVar9,bVar9))) = 0;\n", "            return (char *)__dest_00;\n", "          }\n", "          if (__src_00 != __src) break;\n", "          __n = strlen((char *)__src_00);\n", "          memmove(__dest,__src_00,__n + 1);\n", "        }\n", "        lVar6 = (long)__src + (1 - (long)__dest);\n", "        lVar5 = 4;\n", "        if (lVar6 < 5) {\n", "          lVar5 = lVar6;\n", "        }\n", "        bVar8 = true;\n", "        puVar7 = __dest;\n", "        __s = \"/./\";\n", "        do {\n", "          if (lVar5 == 0) break;\n", "          lVar5 = lVar5 + -1;\n", "          bVar8 = *(char *)puVar7 == *__s;\n", "          puVar7 = (uint *)((long)puVar7 + (ulong)bVar9 * -2 + 1);\n", "          __s = __s + (ulong)bVar9 * -2 + 1;\n", "        } while (bVar8);\n", "        if (bVar8) {\n", "LAB_00400e65:\n", "          __n = strlen((char *)__src);\n", "          memmove(__dest,__src,__n + 1);\n", "          goto LAB_00400dd0;\n", "        }\n", "        lVar5 = 5;\n", "        if (lVar6 < 6) {\n", "          lVar5 = lVar6;\n", "        }\n", "        bVar8 = true;\n", "        puVar7 = __dest;\n", "        __s = \"/../\";\n", "        do {\n", "          if (lVar5 == 0) break;\n", "          lVar5 = lVar5 + -1;\n", "          bVar8 = *(char *)puVar7 == *__s;\n", "          puVar7 = (uint *)((long)puVar7 + (ulong)bVar9 * -2 + 1);\n", "          __s = __s + (ulong)bVar9 * -2 + 1;\n", "        } while (bVar8);\n", "        if (bVar8) {\n", "          if (__dest != __dest_00) {\n", "            cVar1 = *(char *)((long)__dest + -1);\n", "            __dest = (uint *)((long)__dest + -1);\n", "            while (cVar1 != '/') {\n", "              __dest = (uint *)((long)__dest + -1);\n", "              cVar1 = *(char *)__dest;\n", "            }\n", "            __src_00 = (uint *)((long)__dest + 1);\n", "          }\n", "          goto LAB_00400e65;\n", "        }\n", "        __src_00 = (uint *)((long)__src + 1);\n", "        __dest = __src;\n", "      } while( true );\n", "    }\n", "  }\n", "  else {\n", "    __s = getcwd((char *)0x0,0);\n", "    if (__s != (char *)0x0) {\n", "      __n = strlen(__s);\n", "      __n_00 = strlen(rel);\n", "      __dest_00 = (uint *)malloc(__n + 3 + __n_00);\n", "      if (__dest_00 != (uint *)0x0) {\n", "        pcVar4 = stpcpy((char *)__dest_00,__s);\n", "        *pcVar4 = '/';\n", "        memcpy(pcVar4 + -(long)__dest_00 + (long)__dest_00 + 1,rel,__n_00);\n", "        *(undefined2 *)((long)__dest_00 + (long)(pcVar4 + -(long)__dest_00) + __n_00 + 1) = 0x2f;\n", "        free(__s);\n", "        goto LAB_00400dc0;\n", "      }\n", "      free(__s);\n", "    }\n", "  }\n", "  return (char *)0x0;\n", "}\n", "\n"], "c": ["char*\n", "canonpath(char *rel)\n", "{\n", "\tchar *abs, *cp, *prev;\n", "\n", "\tif (rel[0] == '/') {\n", "\t\tif (!(abs=malloc(strlen(rel) + 2))) {\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\t\tabs[0] = '\\0';\n", "\t\tstrcat(abs, rel);\n", "\t\tstrcat(abs, \"/\");\n", "\t} else {\n", "\t\tchar *cwd = NULL;\n", "\t\tif (!(cwd=getcwd(NULL, 0))) {\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\t\tif (!(abs=malloc(strlen(cwd) + 1 + strlen(rel) + 2))) {\n", "\t\t\tfree(cwd);\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\t\tabs[0] = '\\0';\n", "\t\tstrcat(abs, cwd);\n", "\t\tstrcat(abs, \"/\");\n", "\t\tstrcat(abs, rel);\n", "\t\tstrcat(abs, \"/\");\n", "\t\tfree(cwd);\n", "\t}\n", "\n", "\t/* abs is now an absolute path which begins and ends with a slash */\n", "\tprev = abs;\n", "\twhile ((cp=strchr(prev+1, '/'))) {\n", "\t\tif (cp == prev+1) {\n", "\t\t\t/* remove consecutive slashes */ \n", "\t\t\tmemmove(prev, cp, strlen(cp)+1);\n", "\t\t} else if (strncmp(prev, \"/./\", cp-prev+1) == 0) {\n", "\t\t\tmemmove(prev, cp, strlen(cp)+1);\n", "\t\t} else if (strncmp(prev, \"/../\", cp-prev+1) == 0) {\n", "\t\t\tchar *parent;\n", "\t\t\tif (prev == abs) {\n", "\t\t\t\tparent = abs; /* just eat .. in root dir */\n", "\t\t\t} else {\n", "\t\t\t\tfor (parent=prev-1; *parent != '/'; --parent);\n", "\t\t\t}\n", "\t\t\tmemmove(parent, cp, strlen(cp)+1);\n", "\t\t\tprev = parent;\n", "\t\t} else {\n", "\t\t\tprev = cp;\n", "\t\t}\n", "\t}\n", "\tabs[strlen(abs)-1] = '\\0'; /* remove trailing slash */\n", "\n", "\treturn abs;\n", "}"]}, {"ghidra": ["\n", "int mountedby(mntent *mnt,char *username)\n", "\n", "{\n", "  int iVar1;\n", "  char *pcVar2;\n", "  long lVar3;\n", "  undefined8 extraout_RDX;\n", "  char *pcVar4;\n", "  char *__s;\n", "  char *pcVar5;\n", "  EVP_PKEY_CTX *ctx;\n", "  bool bVar6;\n", "  byte bVar7;\n", "  \n", "  bVar7 = 0;\n", "  __s = (char *)__strdup(mnt->mnt_opts);\n", "  if (__s == (char *)0x0) {\n", "    __s = \"out of memory\";\n", "    ctx = (EVP_PKEY_CTX *)0x1;\n", "    errx(1,\"out of memory\");\n", "    lVar3 = 0;\n", "    _init(ctx);\n", "    do {\n", "      iVar1 = (*(code *)(&__frame_dummy_init_array_entry)[lVar3])\n", "                        ((ulong)ctx & 0xffffffff,__s,extraout_RDX);\n", "      lVar3 = lVar3 + 1;\n", "    } while (lVar3 != 1);\n", "    return iVar1;\n", "  }\n", "  pcVar2 = strtok(__s,\",\");\n", "  do {\n", "    bVar6 = pcVar2 == (char *)0x0;\n", "    if (bVar6) {\n", "      free(__s);\n", "      return 0;\n", "    }\n", "    lVar3 = 5;\n", "    pcVar4 = pcVar2;\n", "    pcVar5 = \"name=\";\n", "    do {\n", "      if (lVar3 == 0) break;\n", "      lVar3 = lVar3 + -1;\n", "      bVar6 = *pcVar4 == *pcVar5;\n", "      pcVar4 = pcVar4 + (ulong)bVar7 * -2 + 1;\n", "      pcVar5 = pcVar5 + (ulong)bVar7 * -2 + 1;\n", "    } while (bVar6);\n", "    if (bVar6) {\n", "      iVar1 = strcmp(pcVar2 + 5,username);\n", "      free(__s);\n", "      return (int)(uint)(iVar1 == 0);\n", "    }\n", "    pcVar2 = strtok((char *)0x0,\",\");\n", "  } while( true );\n", "}\n", "\n"], "c": ["int\n", "mountedby(struct mntent *mnt, char *username)\n", "{\n", "\tchar *s, *cp;\n", "\tif (!(s=strdup(mnt->mnt_opts))) {\n", "\t\terrx(1, \"out of memory\");\n", "\t}\n", "\tfor (cp=strtok(s, \",\"); cp; cp=strtok(NULL, \",\")) {\n", "\t\tif (strncmp(cp, \"name=\", 5) == 0) {\n", "\t\t\tint eq = (strcmp(cp+5, username) == 0);\n", "\t\t\tfree(s);\n", "\t\t\treturn eq;\n", "\t\t}\n", "\t}\n", "\tfree(s);\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  long lVar1;\n", "  char *pcVar2;\n", "  __dev_t _Var3;\n", "  int iVar4;\n", "  char *__filename;\n", "  char *__special_file;\n", "  long in_FS_OFFSET;\n", "  bool bVar5;\n", "  undefined auVar6 [16];\n", "  stat stbuf;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  __filename = (char *)0;\n", "  pcVar2 = (char *)0;\n", "  do {\n", "    __special_file = pcVar2;\n", "    argv = argv + 1;\n", "    pcVar2 = *argv;\n", "    if (pcVar2 == (char *)0x0) {\n", "      if ((__filename != (char *)0x0) && (__special_file != (char *)0x0)) {\n", "        iVar4 = __xstat(1,__filename,(stat *)&stbuf);\n", "        if ((iVar4 == 0) && (iVar4 = access(__filename,2), iVar4 == 0)) {\n", "          if ((stbuf.st_mode._1_1_ & 2) == 0) {\n", "            iVar4 = mount(__special_file,__filename,(char *)0x0,0x1000,(void *)0x0);\n", "            if (iVar4 == 0) {\n", "              if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "                return 0;\n", "              }\n", "              goto LAB_004006ab;\n", "            }\n", "            err(1,\"mount\");\n", "          }\n", "          errx(1,\"%s: refusing to bind over sticky directory\",__filename);\n", "        }\n", "        err(1,&DAT_004008b0,__filename);\n", "      }\n", "      auVar6 = errx(1,\"usage: 9bind old new\");\n", "      _Var3 = stbuf.st_dev;\n", "      stbuf.st_dev = SUB168(auVar6,0);\n", "      __libc_start_main(main,_Var3,&stbuf.st_ino,__libc_csu_init,__libc_csu_fini,\n", "                        SUB168(auVar6 >> 0x40,0),&stbuf);\n", "      do {\n", "                    /* WARNING: Do nothing block with infinite loop */\n", "      } while( true );\n", "    }\n", "  } while ((__special_file == (char *)0x0) ||\n", "          (bVar5 = __filename == (char *)0x0, __filename = pcVar2, pcVar2 = __special_file, bVar5));\n", "  errx(1,\"%s: too many arguments\");\n", "LAB_004006ab:\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tchar *old = NULL, *new = NULL;\n", "\tstruct stat stbuf;\n", "\n", "\twhile (*++argv) {\n", "\t\tif (!old) {\n", "\t\t\told = *argv;\n", "\t\t} else if (!new) {\n", "\t\t\tnew = *argv;\n", "\t\t} else {\n", "\t\t\terrx(1, \"%s: too many arguments\", *argv);\n", "\t\t}\n", "\t}\n", "\n", "\tif (!old || !new) {\n", "\t\terrx(1, \"usage: 9bind old new\");\n", "\t}\n", "\n", "\t/* Make sure mount exists, is writable, and not sticky */\n", "\tif (stat(new, &stbuf) || access(new, W_OK)) {\n", "\t\terr(1, \"%s\", new);\n", "\t}\n", "\tif (stbuf.st_mode & S_ISVTX) {\n", "\t\terrx(1, \"%s: refusing to bind over sticky directory\", new);\n", "\t}\n", "\n", "\tif (mount(old, new, NULL, MS_BIND, NULL)) {\n", "\t\terr(1, \"mount\");\n", "\t}\n", "\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void parsedial(char *dial,char **network,char **netaddr,int *port)\n", "\n", "{\n", "  ushort uVar1;\n", "  char *__s;\n", "  size_t sVar2;\n", "  size_t sVar3;\n", "  servent *psVar4;\n", "  long lVar5;\n", "  char *pcVar6;\n", "  char *pcVar7;\n", "  bool bVar8;\n", "  byte bVar9;\n", "  \n", "  bVar9 = 0;\n", "  __s = strtok(dial,\"!\");\n", "  bVar8 = __s == (char *)0x0;\n", "  *network = __s;\n", "  if (bVar8) {\n", "                    /* WARNING: Subroutine does not return */\n", "    errx(1,\"empty dial string\");\n", "  }\n", "  lVar5 = 5;\n", "  pcVar6 = __s;\n", "  pcVar7 = \"unix\";\n", "  do {\n", "    if (lVar5 == 0) break;\n", "    lVar5 = lVar5 + -1;\n", "    bVar8 = *pcVar6 == *pcVar7;\n", "    pcVar6 = pcVar6 + (ulong)bVar9 * -2 + 1;\n", "    pcVar7 = pcVar7 + (ulong)bVar9 * -2 + 1;\n", "  } while (bVar8);\n", "  if ((!bVar8) &&\n", "     ((((bVar8 = *__s == 't', !bVar8 || (bVar8 = __s[1] == 'c', !bVar8)) ||\n", "       (bVar8 = __s[2] == 'p', !bVar8)) || (bVar8 = __s[3] == '\\0', !bVar8)))) {\n", "    lVar5 = 7;\n", "    pcVar6 = __s;\n", "    pcVar7 = \"virtio\";\n", "    do {\n", "      if (lVar5 == 0) break;\n", "      lVar5 = lVar5 + -1;\n", "      bVar8 = *pcVar6 == *pcVar7;\n", "      pcVar6 = pcVar6 + (ulong)bVar9 * -2 + 1;\n", "      pcVar7 = pcVar7 + (ulong)bVar9 * -2 + 1;\n", "    } while (bVar8);\n", "    if (!bVar8) {\n", "                    /* WARNING: Subroutine does not return */\n", "      errx(1,\"%s: unknown network (expecting unix, tcp or virtio)\",__s);\n", "    }\n", "  }\n", "  __s = strtok((char *)0x0,\"!\");\n", "  *netaddr = __s;\n", "  if (__s == (char *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "    errx(1,\"missing dial netaddress\");\n", "  }\n", "  __s = *network;\n", "  if (((*__s == 't') && (__s[1] == 'c')) && ((__s[2] == 'p' && (__s[3] == '\\0')))) {\n", "    __s = strtok((char *)0x0,\"!\");\n", "    if (__s != (char *)0x0) {\n", "      sVar2 = strspn(__s,\"0123456789\");\n", "      sVar3 = strlen(__s);\n", "      if (sVar2 == sVar3) {\n", "        lVar5 = strtol(__s,(char **)0x0,10);\n", "        *port = (int)lVar5;\n", "      }\n", "      else {\n", "        psVar4 = getservbyname(__s,*network);\n", "        if (psVar4 == (servent *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "          errx(1,\"%s: unknown service\",__s);\n", "        }\n", "        uVar1 = (ushort)psVar4->s_port;\n", "        *port = (uint)(ushort)(uVar1 >> 8 | uVar1 << 8);\n", "        endservent();\n", "      }\n", "    }\n", "  }\n", "  __s = strtok((char *)0x0,\"!\");\n", "  if (__s == (char *)0x0) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  errx(1,\"%s: junk trailing dial string\",__s);\n", "}\n", "\n"], "c": ["void\n", "parsedial(char *dial, char **network, char **netaddr, int *port)\n", "{\n", "\tchar *cp;\n", "\tif (!(*network=strtok(dial, \"!\"))) {\n", "\t\terrx(1, \"empty dial string\");\n", "\t}\n", "\tif (strcmp(*network, \"unix\") != 0\n", "\t&& strcmp(*network, \"tcp\") != 0\n", "\t&& strcmp(*network, \"virtio\") != 0) {\n", "\t\terrx(1, \"%s: unknown network (expecting unix, tcp or virtio)\", *network);\n", "\t}\n", "\tif (!(*netaddr=strtok(NULL, \"!\"))) {\n", "\t\terrx(1, \"missing dial netaddress\");\n", "\t}\n", "\tif (strcmp(*network, \"tcp\") == 0) {\n", "\t\tchar *service;\n", "\t\tif ((service=strtok(NULL, \"!\"))) {\n", "\t\t\tif (strspn(service, \"0123456789\") == strlen(service)) {\n", "\t\t\t\t*port = atoi(service);\n", "\t\t\t} else {\n", "\t\t\t\tstruct servent *sv;\n", "\t\t\t\tif ((sv=getservbyname(service, *network))) {\n", "\t\t\t\t\t/* sv->s_port is a 16-bit big endian masquerading as an int */\n", "\t\t\t\t\t*port = ntohs((uint16_t)sv->s_port);\n", "\t\t\t\t\tendservent();\n", "\t\t\t\t} else {\n", "\t\t\t\t\terrx(1, \"%s: unknown service\", service);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\tif ((cp=strtok(NULL, \"!\"))) {\n", "\t\terrx(1, \"%s: junk trailing dial string\", cp);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "char * getarg(char opt,char *cp,char ***argv)\n", "\n", "{\n", "  char **ppcVar1;\n", "  \n", "  if (cp[1] != '\\0') {\n", "    return cp + 1;\n", "  }\n", "  ppcVar1 = *argv;\n", "  if (ppcVar1[1] != (char *)0x0) {\n", "    *argv = ppcVar1 + 1;\n", "    return ppcVar1[1];\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  errx(1,\"-%c: expected argument\",(ulong)(uint)(int)opt);\n", "}\n", "\n"], "c": ["char*\n", "getarg(char opt, char *cp, char*** argv)\n", "{\n", "\tif (*(cp+1)) {\n", "\t\treturn cp+1;\n", "\t} else if (*(*argv+1)) {\n", "\t\treturn *++(*argv);\n", "\t} else {\n", "\t\terrx(1, \"-%c: expected argument\", opt);\n", "\t}\n", "\treturn NULL;\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  long lVar1;\n", "  char *pcVar2;\n", "  int *destlen;\n", "  char cVar3;\n", "  __uid_t __uid;\n", "  int __ecode;\n", "  __gid_t _Var4;\n", "  __uid_t _Var5;\n", "  char *__s;\n", "  char *pcVar6;\n", "  char *__s1;\n", "  size_t sVar7;\n", "  size_t sVar8;\n", "  char *__filename;\n", "  long lVar9;\n", "  char **dest;\n", "  uint uVar10;\n", "  char *dial;\n", "  long in_FS_OFFSET;\n", "  bool bVar11;\n", "  byte bVar12;\n", "  undefined auVar13 [16];\n", "  undefined4 uVar14;\n", "  int *local_248;\n", "  char **local_240;\n", "  char *local_238;\n", "  int local_230;\n", "  int local_22c;\n", "  char *local_228;\n", "  int local_220;\n", "  int local_21c;\n", "  passwd *local_218;\n", "  char **local_210 [2];\n", "  int optlen;\n", "  int port;\n", "  char *opts;\n", "  char *proto;\n", "  char *addr;\n", "  addrinfo *ai;\n", "  stat stbuf;\n", "  char buf [256];\n", "  \n", "  bVar12 = 0;\n", "  optlen = 0x40;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  port = 0;\n", "  local_210[0] = argv;\n", "  opts = (char *)calloc(0x40,1);\n", "  if (opts == (char *)0x0) {\n", "    auVar13 = err(1,\"calloc\");\n", "    destlen = local_248;\n", "    local_248 = SUB168(auVar13,0);\n", "    __libc_start_main(main,destlen,&local_240,__libc_csu_init,__libc_csu_fini,\n", "                      SUB168(auVar13 >> 0x40,0),&local_248);\n", "    do {\n", "                    /* WARNING: Do nothing block with infinite loop */\n", "    } while( true );\n", "  }\n", "  __s = (char *)0x0;\n", "  pcVar6 = (char *)0x0;\n", "  local_238 = (char *)0x0;\n", "  local_228 = (char *)0x0;\n", "  _Var5 = 0;\n", "  local_230 = 0;\n", "  local_21c = 0;\n", "  local_220 = 0;\n", "  local_22c = 0;\n", "  __filename = (char *)0;\n", "  __s1 = (char *)0x0;\n", "LAB_00400d08:\n", "  do {\n", "    dial = __s1;\n", "    pcVar2 = local_210[0][1];\n", "    local_210[0] = local_210[0] + 1;\n", "    if (pcVar2 == (char *)0x0) {\n", "      if ((__filename != (char *)0x0) && (dial != (char *)0x0)) {\n", "        __uid = getuid();\n", "        local_218 = getpwuid(__uid);\n", "        if (local_218 != (passwd *)0x0) {\n", "          __ecode = __xstat(1,__filename,(stat *)&stbuf);\n", "          if ((__ecode != 0) || (__ecode = access(__filename,2), __ecode != 0)) {\n", "            err(1,0x401c2d,__filename);\n", "            goto LAB_004015f5;\n", "          }\n", "          if ((stbuf.st_mode._1_1_ & 2) != 0) {\n", "                    /* WARNING: Subroutine does not return */\n", "            errx(1,\"%s: refusing to mount over sticky directory\",__filename);\n", "          }\n", "          if ((*dial == '-') && (dial[1] == '\\0')) {\n", "            local_248 = &optlen;\n", "            local_240 = &opts;\n", "            proto = \"fd\";\n", "            addr = \"nodev\";\n", "            append(local_240,\"rfdno=0,wrfdno=1\",local_248);\n", "          }\n", "          else {\n", "            parsedial(dial,&proto,&addr,&port);\n", "            local_248 = &optlen;\n", "            local_240 = &opts;\n", "          }\n", "          dest = local_240;\n", "          destlen = local_248;\n", "          append(local_240,proto,local_248);\n", "          __snprintf_chk(buf,0x100,1,0x100,\"trans=%s\",proto);\n", "          append(dest,buf,destlen);\n", "          if (__s != (char *)0x0) {\n", "            __s1 = strchr(__s,0x2c);\n", "            if (__s1 != (char *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "              errx(1,\"%s: spec can\\'t contain commas\",__s);\n", "            }\n", "            __snprintf_chk(buf,0x100,1,0x100,\"aname=%s\",__s);\n", "            append(local_240,buf,local_248);\n", "          }\n", "          bVar11 = pcVar6 == (char *)0x0;\n", "          if (bVar11) goto LAB_00401018;\n", "          lVar9 = 6;\n", "          __s1 = pcVar6;\n", "          __s = \"loose\";\n", "          break;\n", "        }\n", "        err(1,\"who are you?? getpwuid failed\");\n", "      }\n", "                    /* WARNING: Subroutine does not return */\n", "      errx(1,\n", "           \"usage: 9mount [ -insuvx ] [ -a spec ] [ -c cache ] [ -d debug ] [ -m msize ] dial mountpt\"\n", "          );\n", "    }\n", "    __s1 = dial;\n", "    if ((*pcVar2 == '-') && (cVar3 = pcVar2[1], cVar3 != '\\0')) {\n", "      do {\n", "        dial = pcVar2 + 1;\n", "        switch(cVar3) {\n", "        case 'a':\n", "          __s = getarg('a',dial,local_210);\n", "          *dial = '\\0';\n", "          goto LAB_00400d08;\n", "        case 'c':\n", "          pcVar6 = getarg('c',dial,local_210);\n", "          *dial = '\\0';\n", "          goto LAB_00400d08;\n", "        case 'd':\n", "          local_228 = getarg('d',dial,local_210);\n", "          *dial = '\\0';\n", "          goto LAB_00400d08;\n", "        case 'i':\n", "          cVar3 = pcVar2[2];\n", "          local_220 = 1;\n", "          break;\n", "        case 'm':\n", "          local_238 = getarg('m',dial,local_210);\n", "          *dial = '\\0';\n", "          goto LAB_00400d08;\n", "        case 'n':\n", "          cVar3 = pcVar2[2];\n", "          local_230 = 1;\n", "          break;\n", "        case 's':\n", "          cVar3 = pcVar2[2];\n", "          _Var5 = 0xffffffff;\n", "          break;\n", "        case 'u':\n", "          cVar3 = pcVar2[2];\n", "          local_22c = 1;\n", "          break;\n", "        case 'v':\n", "          cVar3 = pcVar2[2];\n", "          local_21c = 1;\n", "          break;\n", "        case 'x':\n", "          _Var5 = getuid();\n", "        default:\n", "          cVar3 = pcVar2[2];\n", "        }\n", "        pcVar2 = dial;\n", "      } while (cVar3 != '\\0');\n", "    }\n", "    else {\n", "      __s1 = pcVar2;\n", "      if ((dial != (char *)0x0) &&\n", "         (bVar11 = __filename != (char *)0x0, __filename = pcVar2, __s1 = dial, bVar11)) {\n", "                    /* WARNING: Subroutine does not return */\n", "        errx(1,\"%s: too many arguments\");\n", "      }\n", "    }\n", "  } while( true );\n", "  while( true ) {\n", "    lVar9 = lVar9 + -1;\n", "    bVar11 = *__s1 == *__s;\n", "    __s1 = __s1 + (ulong)bVar12 * -2 + 1;\n", "    __s = __s + (ulong)bVar12 * -2 + 1;\n", "    if (!bVar11) break;\n", "    if (lVar9 == 0) break;\n", "  }\n", "  if (!bVar11) {\n", "                    /* WARNING: Subroutine does not return */\n", "    errx(1,\"%s: unknown cache mode (expecting loose)\",pcVar6);\n", "  }\n", "  __snprintf_chk(buf,0x100,1,0x100,\"cache=%s\",pcVar6);\n", "  append(local_240,buf,local_248);\n", "LAB_00401018:\n", "  if (local_228 != (char *)0x0) {\n", "    uVar10 = 0;\n", "    __s1 = strtok(local_228,\",\");\n", "    while (__s1 != (char *)0x0) {\n", "      lVar9 = 0;\n", "      while( true ) {\n", "        __ecode = strcmp(__s1,debug_flags[lVar9].mnemonic);\n", "        if (__ecode == 0) break;\n", "        lVar9 = lVar9 + 1;\n", "        if (lVar9 == 9) {\n", "                    /* WARNING: Subroutine does not return */\n", "          errx(1,\"%s: unrecognised debug channel\",__s1);\n", "        }\n", "      }\n", "      uVar10 = uVar10 | debug_flags[(int)lVar9].mask;\n", "      __s1 = strtok((char *)0x0,\",\");\n", "    }\n", "    __snprintf_chk(buf,0x100,1,0x100,\"debug=0x%04x\",(ulong)uVar10);\n", "    append(local_240,buf,local_248);\n", "  }\n", "  __s1 = local_238;\n", "  if (local_238 != (char *)0x0) {\n", "    sVar7 = strspn(local_238,\"0123456789\");\n", "    sVar8 = strlen(__s1);\n", "    if (sVar7 < sVar8) {\n", "                    /* WARNING: Subroutine does not return */\n", "      errx(1,\"%s: msize must be an integer\",local_238);\n", "    }\n", "    __snprintf_chk(buf,0x100,1,0x100,\"msize=%s\",local_238);\n", "    append(local_240,buf,local_248);\n", "  }\n", "  __snprintf_chk(buf,0x100,1,0x100,0x401b6c,local_218->pw_name);\n", "  append(local_240,buf,local_248);\n", "  __s1 = getenv(\"USER\");\n", "  if (__s1 != (char *)0x0) {\n", "    getenv(\"USER\");\n", "  }\n", "  __snprintf_chk(buf,0x100,1,0x100);\n", "  __s1 = strchr(buf,0x2c);\n", "  if (__s1 != (char *)0x0) {\n", "                    /* WARNING: Subroutine does not return */\n", "    errx(1,\"%s: username can\\'t contain commas\",buf + 6);\n", "  }\n", "  dest = local_240;\n", "  append(local_240,buf,local_248);\n", "  if (_Var5 == 0xffffffff) {\n", "    dest = local_240;\n", "    append(local_240,\"access=any\",local_248);\n", "  }\n", "  else {\n", "    if (_Var5 != 0) {\n", "      __snprintf_chk(buf,0x100,1,0x100);\n", "      dest = local_240;\n", "      append(local_240,buf,local_248);\n", "    }\n", "  }\n", "  if (local_22c == 0) {\n", "    dest = local_240;\n", "    append(local_240,\"noextend\",local_248);\n", "  }\n", "  if (local_21c == 0) {\n", "    dest = local_240;\n", "    append(local_240,\"nodev\",local_248);\n", "  }\n", "  if (local_220 != 0) {\n", "    _Var4 = getgid();\n", "    uVar14 = 0;\n", "    _Var5 = getuid();\n", "    __snprintf_chk(buf,0x100,1,0x100,\"uid=%d,gid=%d\",(ulong)_Var5,(ulong)_Var4,dest);\n", "    dest = local_240;\n", "    destlen = local_248;\n", "    append(local_240,buf,local_248);\n", "    _Var4 = getgid();\n", "    _Var5 = getuid();\n", "    __snprintf_chk(buf,0x100,1,0x100,\"dfltuid=%d,dfltgid=%d\",(ulong)_Var5,CONCAT44(uVar14,_Var4));\n", "    append(dest,buf,destlen);\n", "  }\n", "  if (port != 0) {\n", "    __snprintf_chk(buf,0x100,1,0x100);\n", "    append(local_240,buf,local_248);\n", "  }\n", "  if ((((*proto == 't') && (proto[1] == 'c')) && (proto[2] == 'p')) && (proto[3] == '\\0')) {\n", "    __ecode = getaddrinfo(addr,(char *)0x0,(addrinfo *)0x0,(addrinfo **)&ai);\n", "    if (__ecode != 0) {\n", "      __filename = gai_strerror(__ecode);\n", "                    /* WARNING: Subroutine does not return */\n", "      errx(1,\"getaddrinfo: %s\",__filename);\n", "    }\n", "    __ecode = getnameinfo((sockaddr *)ai->ai_addr,ai->ai_addrlen,buf,0x100,(char *)0x0,0,1);\n", "    if (__ecode != 0) {\n", "      __filename = gai_strerror(__ecode);\n", "                    /* WARNING: Subroutine does not return */\n", "      errx(1,\"getnameinfo: %s\",__filename);\n", "    }\n", "  }\n", "  else {\n", "    snprintf(buf,0x100,\"%s\");\n", "  }\n", "  if (local_230 == 0) {\n", "    __ecode = mount(buf,__filename,\"9p\",0,opts);\n", "    if (__ecode != 0) {\n", "LAB_004015f5:\n", "      err(1,\"mount\");\n", "      goto LAB_00401606;\n", "    }\n", "  }\n", "  else {\n", "    __fprintf_chk(stderr,1,\"mount -t 9p -o %s %s %s\\n\",opts,buf,__filename);\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return 0;\n", "  }\n", "LAB_00401606:\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tchar buf[256], *opts, *dial = NULL, *mountpt = NULL;\n", "\tint optlen = 64, port = 0, i;\n", "\tstruct stat stbuf;\n", "\tstruct passwd *pw;\n", "\tint axess = 0, dotu = 0, uidgid = 0, dev = 0, debug = 0, dryrun = 0;\n", "\tchar *debugstr = NULL, *msize = NULL, *cache = NULL, *aname = NULL;\n", "\tchar *cp, *proto, *addr;\n", "\n", "\tif (!(opts=calloc(optlen, 1))) {\n", "\t\terr(1, \"calloc\");\n", "\t}\n", "\twhile (*++argv) {\n", "\t\tif (**argv == '-' && (*argv)[1] != '\\0') {\n", "\t\t\tfor (cp=*argv+1; *cp; ++cp) {\n", "\t\t\t\tswitch (*cp) {\n", "\t\t\t\t\tcase 'i': uidgid = 1; break;\n", "\t\t\t\t\tcase 'n': dryrun = 1; break;\n", "\t\t\t\t\tcase 's': axess = -1; break;\n", "\t\t\t\t\tcase 'u': dotu = 1; break;\n", "\t\t\t\t\tcase 'v': dev = 1; break;\n", "\t\t\t\t\tcase 'x': axess = getuid(); break;\n", "\t\t\t\t\tcase 'a':\n", "\t\t\t\t\t\taname = getarg('a', cp, &argv);\n", "\t\t\t\t\t\t*cp-- = '\\0'; /* breaks out of for loop */\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase 'c':\n", "\t\t\t\t\t\tcache = getarg('c', cp, &argv);\n", "\t\t\t\t\t\t*cp-- = '\\0';\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase 'd':\n", "\t\t\t\t\t\tdebugstr = getarg('d', cp, &argv);\n", "\t\t\t\t\t\t*cp-- = '\\0';\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase 'm':\n", "\t\t\t\t\t\tmsize = getarg('m', cp, &argv);\n", "\t\t\t\t\t\t*cp-- = '\\0';\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t} else if (!dial) {\n", "\t\t\tdial = *argv;\n", "\t\t} else if (!mountpt) {\n", "\t\t\tmountpt = *argv;\n", "\t\t} else {\n", "\t\t\terrx(1, \"%s: too many arguments\", *argv);\n", "\t\t}\n", "\t}\n", "\n", "\tif (!dial || !mountpt) {\n", "\t\terrx(1, \"usage: 9mount [ -insuvx ] [ -a spec ] [ -c cache ] [ -d debug ] [ -m msize ] dial mountpt\");\n", "\t}\n", "\n", "\tif(!(pw=getpwuid(getuid()))) {\n", "\t\terr(1, \"who are you?? getpwuid failed\");\n", "\t}\n", "\t/* Make sure mount exists, is writable, and not sticky */\n", "\tif (stat(mountpt, &stbuf) || access(mountpt, W_OK)) {\n", "\t\terr(1, \"%s\", mountpt);\n", "\t}\n", "\tif (stbuf.st_mode & S_ISVTX) {\n", "\t\terrx(1, \"%s: refusing to mount over sticky directory\", mountpt);\n", "\t}\n", "\n", "\tif (strcmp(dial, \"-\") == 0) {\n", "\t\tproto = \"fd\";\n", "\t\taddr = \"nodev\";\n", "\t\tappend(&opts, \"rfdno=0,wrfdno=1\", &optlen);\n", "\t} else {\n", "\t\tparsedial(dial, &proto, &addr, &port);\n", "\t}\n", "\n", "\t/* set up mount options */\n", "\tappend(&opts, proto, &optlen); /* < 2.6.24 */\n", "\tsnprintf(buf, sizeof(buf), \"trans=%s\", proto);\n", "\tappend(&opts, buf, &optlen); /* >= 2.6.24 */\n", "\n", "\tif (aname) {\n", "\t\tif (strchr(aname, ',')) {\n", "\t\t\terrx(1, \"%s: spec can't contain commas\", aname);\n", "\t\t}\n", "\t\tsnprintf(buf, sizeof(buf), \"aname=%s\", aname);\n", "\t\tappend(&opts, buf, &optlen);\n", "\t}\n", "\n", "\tif (cache) {\n", "\t\tif (strcmp(cache, \"loose\") != 0) {\n", "\t\t\terrx(1, \"%s: unknown cache mode (expecting loose)\", cache);\n", "\t\t}\n", "\t\tsnprintf(buf, sizeof(buf), \"cache=%s\", cache);\n", "\t\tappend(&opts, buf, &optlen);\n", "\t}\n", "\n", "\tif (debugstr) {\n", "\t\tfor (cp=strtok(debugstr, \",\"); cp; cp=strtok(NULL, \",\")) {\n", "\t\t\tfor (i=0; i<nelem(debug_flags); ++i) {\n", "\t\t\t\tif (strcmp(cp, debug_flags[i].mnemonic) == 0) {\n", "\t\t\t\t\tdebug |= debug_flags[i].mask;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif (i >= nelem(debug_flags)) {\n", "\t\t\t\terrx(1, \"%s: unrecognised debug channel\", cp);\n", "\t\t\t}\n", "\t\t}\n", "\t\tsnprintf(buf, sizeof(buf), \"debug=0x%04x\", debug);\n", "\t\tappend(&opts, buf, &optlen);\n", "\t}\n", "\n", "\tif (msize) {\n", "\t\tif (strspn(msize, \"0123456789\") < strlen(msize)) {\n", "\t\t\terrx(1, \"%s: msize must be an integer\", msize);\n", "\t\t}\n", "\t\tsnprintf(buf, sizeof(buf), \"msize=%s\", msize);\n", "\t\tappend(&opts, buf, &optlen);\n", "\t}\n", "\n", "\tsnprintf(buf, sizeof(buf), \"name=%s\", pw->pw_name);\n", "\tappend(&opts, buf, &optlen);\n", "\n", "\tif (getenv(\"USER\")) {\n", "\t\tsnprintf(buf, sizeof(buf), \"uname=%s\", getenv(\"USER\"));\n", "\t} else {\n", "\t\tsnprintf(buf, sizeof(buf), \"uname=%s\", pw->pw_name);\n", "\t}\n", "\tif (strchr(buf, ',')) {\n", "\t\terrx(1, \"%s: username can't contain commas\", buf+6);\n", "\t}\n", "\tappend(&opts, buf, &optlen);\n", "\n", "\tif (axess == -1) {\n", "\t\tappend(&opts, \"access=any\", &optlen);\n", "\t} else if (axess) {\n", "\t\tsnprintf(buf, sizeof(buf), \"access=%d\", axess);\n", "\t\tappend(&opts, buf, &optlen);\n", "\t}\n", "\tif (!dotu) {\n", "\t\tappend(&opts, \"noextend\", &optlen);\n", "\t}\n", "\tif (!dev) {\n", "\t\tappend(&opts, \"nodev\", &optlen);\n", "\t}\n", "\tif (uidgid) {\n", "\t\tsnprintf(buf, sizeof(buf), \"uid=%d,gid=%d\", getuid(), getgid());\n", "\t\tappend(&opts, buf, &optlen); /* < 2.6.24 */\n", "\t\tsnprintf(buf, sizeof(buf), \"dfltuid=%d,dfltgid=%d\", getuid(), getgid());\n", "\t\tappend(&opts, buf, &optlen); /* >= 2.6.24 */\n", "\t}\n", "\tif (port) {\n", "\t\tsnprintf(buf, sizeof(buf), \"port=%d\", port);\n", "\t\tappend(&opts, buf, &optlen);\n", "\t}\n", "\n", "\tif (strcmp(proto, \"tcp\") == 0) {\n", "\t\tstruct addrinfo *ai;\n", "\t\tint r;\n", "\t\tif ((r=getaddrinfo(addr, NULL, NULL, &ai))) {\n", "\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(r));\n", "\t\t}\n", "\t\tif ((r=getnameinfo(ai->ai_addr, ai->ai_addrlen, buf,\n", "\t\t\t\t\t\tsizeof(buf), NULL, 0, NI_NUMERICHOST))) {\n", "\t\t\terrx(1, \"getnameinfo: %s\", gai_strerror(r));\n", "\t\t}\n", "\t} else { /* unix socket, virtio device or fd transport */\n", "\t\tsnprintf(buf, sizeof(buf), \"%s\", addr);\n", "\t}\n", "\n", "\tif(dryrun) {\n", "\t\tfprintf(stderr, \"mount -t 9p -o %s %s %s\\n\", opts, buf, mountpt);\n", "\t} else if (mount(buf, mountpt, \"9p\", 0, (void*)opts)) {\n", "\t\terr(1, \"mount\");\n", "\t}\n", "\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "char * append(char **dest,char *src,int *destlen)\n", "\n", "{\n", "  char *__s;\n", "  size_t sVar1;\n", "  size_t sVar2;\n", "  uint *puVar3;\n", "  uint *__dest;\n", "  byte bVar4;\n", "  uint uVar5;\n", "  int iVar6;\n", "  bool bVar7;\n", "  \n", "  __s = *dest;\n", "  iVar6 = *destlen;\n", "  while( true ) {\n", "    sVar1 = strlen(__s);\n", "    sVar2 = strlen(src);\n", "    if (sVar1 + 1 + sVar2 <= (ulong)(long)iVar6) break;\n", "    iVar6 = iVar6 * 2;\n", "    *destlen = iVar6;\n", "  }\n", "  __dest = (uint *)realloc(__s,(long)iVar6);\n", "  *(uint **)dest = __dest;\n", "  if (__dest != (uint *)0x0) {\n", "    if (*(char *)__dest != '\\0') {\n", "      do {\n", "        puVar3 = __dest;\n", "        uVar5 = *puVar3 + 0xfefefeff & ~*puVar3;\n", "        _bVar4 = uVar5 & 0x80808080;\n", "        bVar4 = (byte)_bVar4;\n", "        __dest = puVar3 + 1;\n", "      } while (_bVar4 == 0);\n", "      bVar7 = (uVar5 & 0x8080) == 0;\n", "      if (bVar7) {\n", "        bVar4 = (byte)(_bVar4 >> 0x10);\n", "      }\n", "      if (bVar7) {\n", "        __dest = (uint *)((long)puVar3 + 6);\n", "      }\n", "      *(undefined2 *)((long)__dest + (-3 - (ulong)CARRY1(bVar4,bVar4))) = 0x2c;\n", "      __dest = (uint *)*dest;\n", "    }\n", "    strcat((char *)__dest,src);\n", "    return *dest;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  errx(1,\"out of memory\");\n", "}\n", "\n"], "c": ["char*\n", "append(char **dest, char *src, int *destlen)\n", "{\n", "\twhile (strlen(*dest) + 1 + strlen(src) > *destlen)\n", "\t\t*destlen *= 2;\n", "\tif (!(*dest=realloc(*dest, *destlen)))\n", "\t\terrx(1, \"out of memory\");\n", "\n", "\tif (**dest)\n", "\t\tstrcat(*dest, \",\");\n", "\tstrcat(*dest, src);\n", "\treturn *dest;\n", "}"]}, {"ghidra": ["\n", "void set_wm_hints(int wide,int high)\n", "\n", "{\n", "  long lVar1;\n", "  char *pcVar2;\n", "  int iVar3;\n", "  ulong *puVar4;\n", "  undefined8 *puVar5;\n", "  char **ppcVar6;\n", "  ulong uVar7;\n", "  long in_FS_OFFSET;\n", "  bool bVar8;\n", "  undefined8 uVar9;\n", "  undefined8 uVar10;\n", "  XTextProperty wname;\n", "  XTextProperty iname;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  puVar4 = (ulong *)XAllocSizeHints();\n", "  if (puVar4 != (ulong *)0x0) {\n", "    puVar5 = (undefined8 *)XAllocWMHints();\n", "    if (puVar5 != (undefined8 *)0x0) {\n", "      uVar9 = 0x4024c9;\n", "      ppcVar6 = (char **)XAllocClassHint();\n", "      if (ppcVar6 != (char **)0x0) {\n", "        *puVar4 = 0x3a;\n", "        *(int *)(puVar4 + 4) = wide;\n", "        *(int *)(puVar4 + 3) = wide;\n", "        *(int *)(puVar4 + 2) = wide;\n", "        *(int *)((long)puVar4 + 0x24) = high;\n", "        *(int *)((long)puVar4 + 0x1c) = high;\n", "        *(int *)((long)puVar4 + 0x14) = high;\n", "        uVar7 = XWMGeometry(dpy,(ulong)(uint)screen,geometry,0x40354e,1,puVar4,puVar4 + 1,\n", "                            (long)puVar4 + 0xc,puVar4 + 2,(long)puVar4 + 0x14,puVar4 + 9,uVar9);\n", "        if ((uVar7 & 3) != 0) {\n", "          *puVar4 = *puVar4 | 1;\n", "        }\n", "        *(int *)(puVar4 + 4) = wide;\n", "        *(int *)(puVar4 + 3) = wide;\n", "        *(int *)(puVar4 + 2) = wide;\n", "        *(int *)((long)puVar4 + 0x24) = high;\n", "        *(int *)((long)puVar4 + 0x1c) = high;\n", "        *(int *)((long)puVar4 + 0x14) = high;\n", "        iVar3 = XStringListToTextProperty(&labelname,1,&wname);\n", "        if (iVar3 == 0) {\n", "LAB_004026bc:\n", "          memory(\"window name structure\");\n", "          wm_protocols = XInternAtom(dpy,\"WM_PROTOCOLS\",0);\n", "          wm_delete_window = XInternAtom(dpy,\"WM_DELETE_WINDOW\",0);\n", "          iVar3 = XSetWMProtocols(dpy,menuwin,&wm_delete_window,1);\n", "          if (iVar3 != 1) {\n", "            __fprintf_chk(stderr,1,\"%s: could not ask for clean delete\\n\",progname);\n", "            return;\n", "          }\n", "          return;\n", "        }\n", "        uVar9 = 0x40258a;\n", "        iVar3 = XStringListToTextProperty(&labelname,1,&iname);\n", "        if (iVar3 == 0) {\n", "          memory(\"icon name structure\");\n", "          goto LAB_004026bc;\n", "        }\n", "        menuwin = XCreateSimpleWindow(dpy,root,(ulong)*(uint *)(puVar4 + 1),\n", "                                      (ulong)*(uint *)((long)puVar4 + 0xc),\n", "                                      (ulong)*(uint *)(puVar4 + 2),\n", "                                      (ulong)*(uint *)((long)puVar4 + 0x14),1,black,white,uVar9);\n", "        uVar10 = 0x4025ef;\n", "        uVar9 = XCreateBitmapFromData(dpy,menuwin,nine_menu_bits,0x28,0x28);\n", "        bVar8 = iconic == 0;\n", "        puVar5[2] = uVar9;\n", "        *puVar5 = 7;\n", "        pcVar2 = progname;\n", "        *(undefined4 *)(puVar5 + 1) = 0;\n", "        *(int *)((long)puVar5 + 0xc) = (-(uint)bVar8 & 0xfffffffe) + 3;\n", "        *ppcVar6 = pcVar2;\n", "        ppcVar6[1] = \"9menu\";\n", "        XSetWMProperties(dpy,menuwin,&wname,&iname,g_argv,(ulong)(uint)g_argc,puVar4,puVar5,ppcVar6,\n", "                         uVar10);\n", "        if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "          return;\n", "        }\n", "        goto LAB_004026ad;\n", "      }\n", "      memory(\"class hints\");\n", "    }\n", "    memory(\"window manager hints\");\n", "  }\n", "  memory(\"size hints\");\n", "LAB_004026ad:\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "set_wm_hints(wide, high)"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "void run_menu(void)\n", "\n", "{\n", "  long lVar1;\n", "  bool bVar2;\n", "  byte bVar3;\n", "  int iVar4;\n", "  size_t sVar5;\n", "  ulong uVar6;\n", "  long lVar7;\n", "  char *__s;\n", "  int iVar8;\n", "  uint uVar9;\n", "  uint uVar10;\n", "  ulong uVar11;\n", "  uint cur;\n", "  long lVar12;\n", "  char *com;\n", "  char *pcVar13;\n", "  uint high;\n", "  uint wide;\n", "  uint cur_00;\n", "  long in_FS_OFFSET;\n", "  bool bVar14;\n", "  byte bVar15;\n", "  undefined8 uVar16;\n", "  XEvent ev;\n", "  \n", "  bVar15 = 0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (numitems < 1) {\n", "    wide = 0;\n", "  }\n", "  else {\n", "    lVar12 = 0;\n", "    wide = 0;\n", "    iVar8 = 0;\n", "    do {\n", "      __s = *(char **)((long)labels + lVar12);\n", "      sVar5 = strlen(__s);\n", "      iVar4 = XTextWidth(font,__s,sVar5 & 0xffffffff);\n", "      if ((int)wide < (int)(iVar4 + 4U)) {\n", "        wide = iVar4 + 4U;\n", "      }\n", "      iVar8 = iVar8 + 1;\n", "      lVar12 = lVar12 + 8;\n", "    } while (iVar8 < numitems);\n", "  }\n", "  uVar11 = 0xffffffff;\n", "  bVar2 = true;\n", "  cur_00 = 0;\n", "  high = font->descent + font->ascent + 1;\n", "  _high = (ulong)high;\n", "  set_wm_hints(wide,numitems * high);\n", "  ask_wm_for_delete();\n", "  XSelectInput(dpy,menuwin,0x2a06d);\n", "  XMapWindow(dpy,menuwin);\n", "  cur = 0xffffffff;\n", "switchD_00402b6b_caseD_15:\n", "  uVar16 = 0x402b59;\n", "  XNextEvent();\n", "  bVar3 = (byte)((uint)ev._64_4_ >> 0x18);\n", "  switch(ev._0_4_) {\n", "  default:\n", "    __fprintf_chk(stderr,1,\"%s: unknown ev.type %d\\n\");\n", "    goto switchD_00402b6b_caseD_15;\n", "  case 2:\n", "    uVar16 = 0x402d73;\n", "    uVar6 = XKeycodeToKeysym(dpy,(ulong)ev[84],0);\n", "    if (((((uVar6 - 0xff52 & 0xfffffffffffffffd) != 0) && ((uVar6 & 0xffffffffffffff7f) != 0xff0d))\n", "        && ((uVar6 - 0xff97 & 0xfffffffffffffffd) != 0)) &&\n", "       ((((uVar6 - 0x6e & 0xfffffffffffffffd) != 0 && (uVar6 != 0xff1b)) && (1 < uVar6 - 0x6a))))\n", "    goto switchD_00402b6b_caseD_15;\n", "    if (((uVar6 == 0xff52) || (uVar6 == 0x70)) || ((uVar6 == 0x6b || (uVar6 == 0xff97)))) {\n", "      uVar9 = cur - 1;\n", "      uVar11 = (ulong)cur;\n", "    }\n", "    else {\n", "      if (((uVar6 == 0xff54) || ((uVar6 & 0xfffffffffffffffb) == 0x6a)) ||\n", "         (uVar9 = cur, uVar6 == 0xff99)) {\n", "        uVar9 = cur + 1;\n", "        uVar11 = (ulong)cur;\n", "      }\n", "    }\n", "    while ((int)uVar9 < 0) {\n", "      uVar9 = uVar9 + numitems;\n", "    }\n", "    uVar9 = (int)uVar9 % numitems;\n", "    if (((uVar6 == 0xff52) || (uVar6 == 0xff54)) ||\n", "       (((uVar6 == 0x70 || ((uVar6 == 0x6e || (uVar6 - 0x6a < 2)))) ||\n", "        ((uVar6 - 0xff97 & 0xfffffffffffffffd) == 0)))) {\n", "      uVar10 = (uint)uVar11;\n", "      cur = uVar10;\n", "      if (uVar9 != uVar10) {\n", "        cur = uVar9;\n", "        if (((int)uVar10 < numitems) && (-1 < (int)uVar10)) {\n", "          if (uVar9 == 0xffffffff) goto switchD_00402b6b_caseD_15;\n", "          XFillRectangle(dpy,menuwin,gc,0,(ulong)(high * uVar10),(ulong)wide,_high,uVar16);\n", "        }\n", "        if ((-1 < (int)uVar9) && ((int)uVar9 < numitems)) {\n", "          XFillRectangle(dpy,menuwin,gc,0,(ulong)(uVar9 * high),(ulong)wide,_high,uVar16);\n", "        }\n", "      }\n", "      goto switchD_00402b6b_caseD_15;\n", "    }\n", "    if (warp != 0) {\n", "      restoremouse();\n", "      if (uVar6 != 0xff1b) goto LAB_00402eb9;\n", "LAB_00403184:\n", "      com = commands[(int)uVar9];\n", "      if (com != labels[(int)uVar9]) goto LAB_004031f1;\n", "      goto LAB_00402b94;\n", "    }\n", "    if (uVar6 == 0xff1b) goto LAB_00403184;\n", "LAB_00402eb9:\n", "    bVar14 = (uVar6 & 0xffffffffffffff7f) == 0xff0d;\n", "    if (bVar14) {\n", "      lVar12 = (long)(int)uVar9;\n", "      lVar7 = 5;\n", "      __s = labels[lVar12];\n", "      com = __s;\n", "      pcVar13 = \"exit\";\n", "      do {\n", "        if (lVar7 == 0) break;\n", "        lVar7 = lVar7 + -1;\n", "        bVar14 = *com == *pcVar13;\n", "        com = com + (ulong)bVar15 * -2 + 1;\n", "        pcVar13 = pcVar13 + (ulong)bVar15 * -2 + 1;\n", "      } while (bVar14);\n", "      if (bVar14) goto LAB_004031dd;\n", "      spawn(commands[lVar12]);\n", "    }\n", "    if (popup != 0) goto LAB_00402b94;\n", "    break;\n", "  case 4:\n", "  case 6:\n", "    uVar6 = (long)ev._68_4_ / (long)(int)high & 0xffffffff;\n", "    if (((byte)((byte)(uVar6 >> 0x1f) | bVar3 >> 7) == 0) && (ev._64_4_ <= (int)wide)) {\n", "      uVar11 = 0xffffffff;\n", "      if ((int)uVar6 < numitems) {\n", "        uVar11 = uVar6;\n", "      }\n", "    }\n", "    else {\n", "      uVar11 = 0xffffffff;\n", "    }\n", "    uVar9 = (uint)uVar11;\n", "    if (cur != uVar9) {\n", "      if ((-1 < (int)cur) && ((int)cur < numitems)) {\n", "        XFillRectangle(dpy,menuwin,gc,0,(ulong)(cur * high),(ulong)wide,_high,uVar16);\n", "      }\n", "      if ((-1 < (int)uVar9) && ((int)uVar9 < numitems)) {\n", "        XFillRectangle(dpy,menuwin,gc,0,(ulong)(uVar9 * high),(ulong)wide,_high,uVar16);\n", "      }\n", "      uVar11 = (ulong)cur;\n", "      cur = uVar9;\n", "    }\n", "    goto switchD_00402b6b_caseD_15;\n", "  case 5:\n", "    if ((((ev._84_4_ == 2) || (cur_00 = ev._68_4_ / (int)high, (int)cur_00 < 0)) ||\n", "        ((byte)((int)wide < ev._64_4_ | bVar3 >> 7) != 0)) || (numitems <= (int)cur_00))\n", "    goto switchD_00402b6b_caseD_15;\n", "    bVar14 = warp == 0;\n", "    if (!bVar14) {\n", "      bVar14 = true;\n", "      restoremouse();\n", "    }\n", "    lVar12 = (long)(int)cur_00;\n", "    lVar7 = 5;\n", "    __s = labels[lVar12];\n", "    com = __s;\n", "    pcVar13 = \"exit\";\n", "    do {\n", "      if (lVar7 == 0) break;\n", "      lVar7 = lVar7 + -1;\n", "      bVar14 = *com == *pcVar13;\n", "      com = com + (ulong)bVar15 * -2 + 1;\n", "      pcVar13 = pcVar13 + (ulong)bVar15 * -2 + 1;\n", "    } while (bVar14);\n", "    if (bVar14) {\n", "LAB_004031dd:\n", "      com = commands[lVar12];\n", "      if (com != __s) {\n", "LAB_004031f1:\n", "        spawn(com);\n", "      }\n", "      goto LAB_00402b94;\n", "    }\n", "    uVar16 = 0x402c9e;\n", "    spawn(commands[lVar12]);\n", "    if (popup != 0) goto LAB_00402b94;\n", "    if ((-1 < (int)cur) && ((int)cur < numitems)) {\n", "      XFillRectangle(dpy,menuwin,gc,0,(ulong)(cur * high),(ulong)wide,_high,uVar16);\n", "    }\n", "    uVar9 = 0xffffffff;\n", "    break;\n", "  case 8:\n", "    uVar11 = 0xffffffff;\n", "    XClearWindow(dpy);\n", "    redraw(-1,high,wide);\n", "    cur = 0xffffffff;\n", "    goto switchD_00402b6b_caseD_15;\n", "  case 0xc:\n", "    XClearWindow();\n", "    redraw(cur,high,wide);\n", "    goto switchD_00402b6b_caseD_15;\n", "  case 0x12:\n", "    bVar2 = true;\n", "    XClearWindow(dpy,menuwin);\n", "    goto switchD_00402b6b_caseD_15;\n", "  case 0x13:\n", "    if (bVar2) {\n", "      if (teleport == 0) {\n", "        if (warp != 0) {\n", "          warpmouse(cur_00,wide,high);\n", "        }\n", "      }\n", "      else {\n", "        teleportmenu(cur_00,wide,high);\n", "      }\n", "    }\n", "    bVar2 = false;\n", "    XClearWindow();\n", "    redraw(cur_00,high,wide);\n", "    cur = cur_00;\n", "    goto switchD_00402b6b_caseD_15;\n", "  case 0x21:\n", "    goto switchD_00402b6b_caseD_21;\n", "  }\n", "  cur = uVar9;\n", "  if (popdown != 0) {\n", "    XIconifyWindow(dpy,menuwin,(ulong)(uint)screen);\n", "  }\n", "  goto switchD_00402b6b_caseD_15;\n", "switchD_00402b6b_caseD_21:\n", "  if ((ev._40_8_ == wm_protocols) && (ev._56_8_ == wm_delete_window)) {\n", "LAB_00402b94:\n", "    if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "      __stack_chk_fail();\n", "    }\n", "    return;\n", "  }\n", "  goto switchD_00402b6b_caseD_15;\n", "}\n", "\n"], "c": ["void\n", "run_menu()\n", "{\n", "\tXEvent ev;\n", "\tXClientMessageEvent *cmsg;\n", "\tKeySym key;\n", "\tint i, cur, old, wide, high, ico, dx, dy;\n", "\n", "\tdx = 0;\n", "\tfor (i = 0; i < numitems; i++) {\n", "\t\twide = XTextWidth(font, labels[i], strlen(labels[i])) + 4;\n", "\t\tif (wide > dx)\n", "\t\t\tdx = wide;\n", "\t}\n", "\twide = dx;\n", "\n", "\told = cur = -1;\n", "\n", "\thigh = font->ascent + font->descent + 1;\n", "\tdy = numitems * high;\n", "\n", "\tset_wm_hints(wide, dy);\n", "\n", "\task_wm_for_delete();\n", "\n", "#define\tMenuMask (ButtonPressMask|ButtonReleaseMask\\\n", "\t|LeaveWindowMask|PointerMotionMask|ButtonMotionMask\\\n", "\t|ExposureMask|StructureNotifyMask|KeyPressMask)\n", "\n", "\tXSelectInput(dpy, menuwin, MenuMask);\n", "\n", "\tXMapWindow(dpy, menuwin);\n", "\n", "\tico = 1;\t/* warp to first item */\n", "\ti = 0;\t\t/* save menu Item position */\n", "\n", "\tfor (;;) {\n", "\t\tXNextEvent(dpy, &ev);\n", "\t\tswitch (ev.type) {\n", "\t\tdefault:\n", "\t\t\tfprintf(stderr, \"%s: unknown ev.type %d\\n\",\n", "\t\t\t\tprogname, ev.type);\n", "\t\t\tbreak;\n", "\t\tcase ButtonRelease:\n", "\t\t\t/* allow button 1 or button 3 */\n", "\t\t\tif (ev.xbutton.button == Button2)\n", "\t\t\t\tbreak;\n", "\t\t\ti = ev.xbutton.y/high;\n", "\t\t\tif (ev.xbutton.x < 0 || ev.xbutton.x > wide)\n", "\t\t\t\tbreak;\n", "\t\t\telse if (i < 0 || i >= numitems)\n", "\t\t\t\tbreak;\n", "\t\t\tif (warp)\n", "\t\t\t\trestoremouse();\n", "\t\t\tif (strcmp(labels[i], \"exit\") == 0) {\n", "\t\t\t\tif (commands[i] != labels[i]) {\n", "\t\t\t\t\tspawn(commands[i]);\n", "\t\t\t\t}\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\t\tspawn(commands[i]);\n", "\t\t\tif (popup)\n", "\t\t\t\treturn;\n", "\t\t\tif (cur >= 0 && cur < numitems)\n", "\t\t\t\tXFillRectangle(dpy, menuwin, gc, 0, cur*high, wide, high);\n", "\t\t\tif (popdown)\n", "\t\t\t\tXIconifyWindow(dpy, menuwin, screen);\n", "\t\t\tcur = -1;\n", "\t\t\tbreak;\n", "\t\tcase ButtonPress:\n", "\t\tcase MotionNotify:\n", "\t\t\told = cur;\n", "\t\t\tcur = ev.xbutton.y/high;\n", "\t\t\tif (ev.xbutton.x < 0 || ev.xbutton.x > wide)\n", "\t\t\t\tcur = -1;\n", "\t\t\telse if (cur < 0 || cur >= numitems)\n", "\t\t\t\tcur = -1;\n", "\t\t\tif (cur == old)\n", "\t\t\t\tbreak;\n", "\t\t\tif (old >= 0 && old < numitems)\n", "\t\t\t\tXFillRectangle(dpy, menuwin, gc, 0, old*high, wide, high);\n", "\t\t\tif (cur >= 0 && cur < numitems)\n", "\t\t\t\tXFillRectangle(dpy, menuwin, gc, 0, cur*high, wide, high);\n", "\t\t\tbreak;\n", "\t\tcase KeyPress:\n", "\t\t\tkey = XKeycodeToKeysym(dpy, ev.xkey.keycode, 0);\t\n", "\t\t\tif (key != CONFIG_MENU_UP_KEY\n", "\t\t\t    && key != CONFIG_MENU_DOWN_KEY\n", "\t\t\t    && key != CONFIG_MENU_SELECT_KEY\n", "\t\t\t    && key != CONFIG_MENU_ALTERNATE_DOWN_KEY\n", "\t\t\t    && key != CONFIG_MENU_ALTERNATE_UP_KEY\n", "\t\t\t    && key != CONFIG_MENU_ALTERNATE_SELECT_KEY\n", "\t\t\t    && key != CONFIG_MENU_EMACS_DOWN_KEY\n", "\t\t\t    && key != CONFIG_MENU_EMACS_UP_KEY\n", "\t\t\t    && key != CONFIG_MENU_VI_DOWN_KEY\n", "\t\t\t    && key != CONFIG_MENU_VI_UP_KEY\n", "\t\t\t    && key != CONFIG_MENU_ABORT_KEY)\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tif (key == CONFIG_MENU_UP_KEY || key == CONFIG_MENU_EMACS_UP_KEY || key == CONFIG_MENU_VI_UP_KEY || key == CONFIG_MENU_ALTERNATE_UP_KEY) {\n", "\t\t\t\told = cur;\n", "\t\t\t\tcur--;\n", "\t\t\t} else if (key == CONFIG_MENU_DOWN_KEY || key == CONFIG_MENU_EMACS_DOWN_KEY || key == CONFIG_MENU_VI_DOWN_KEY || key == CONFIG_MENU_ALTERNATE_DOWN_KEY) {\n", "\t\t\t\told = cur;\n", "\t\t\t\tcur++;\n", "\t\t\t}\n", "\t\t\t\n", "\t\t\twhile (cur < 0)\n", "\t\t\t\tcur += numitems;\n", "\t\t\n", "\t\t\tcur %= numitems;\n", "\n", "\t\t\tif (key == CONFIG_MENU_UP_KEY || key == CONFIG_MENU_DOWN_KEY\n", "\t\t\t    || key == CONFIG_MENU_EMACS_UP_KEY || key == CONFIG_MENU_EMACS_DOWN_KEY\n", "\t\t\t    || key == CONFIG_MENU_VI_UP_KEY || key == CONFIG_MENU_VI_DOWN_KEY\n", "\t\t\t    || key == CONFIG_MENU_ALTERNATE_UP_KEY || key == CONFIG_MENU_ALTERNATE_DOWN_KEY) {\n", "\t\t\t\tif (cur == old)\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tif (old >= 0 && old < numitems && cur != -1)\n", "\t\t\t\t\tXFillRectangle(dpy, menuwin, gc, 0, old*high, wide, high);\n", "\t\t\t\tif (cur >= 0 && cur < numitems && cur != -1)\n", "\t\t\t\t\tXFillRectangle(dpy, menuwin, gc, 0, cur*high, wide, high);\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\n", "\t\t\tif (warp)\n", "\t\t\t\trestoremouse();\n", "\t\t\tif (key == CONFIG_MENU_ABORT_KEY) {\n", "\t\t\t\tif (commands[cur] != labels[cur]) {\n", "\t\t\t\t\tspawn(commands[cur]);\n", "\t\t\t\t}\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\t\tif (key == CONFIG_MENU_SELECT_KEY || key == CONFIG_MENU_ALTERNATE_SELECT_KEY) {\n", "\t\t\t\tif (strcmp(labels[cur], \"exit\") == 0) {\n", "\t\t\t\t\tif (commands[cur] != labels[cur]) {\n", "\t\t\t\t\t\tspawn(commands[cur]);\n", "\t\t\t\t\t}\n", "\t\t\t\t\treturn;\n", "\t\t\t\t}\n", "\t\t\t\tspawn(commands[cur]);\n", "\t\t\t}\n", "\n", "\t\t\tif (popup)\n", "\t\t\t\treturn;\n", "\t\t\tif (popdown)\n", "\t\t\t\tXIconifyWindow(dpy, menuwin, screen);\n", "\t\t\tbreak;\n", "\t\tcase LeaveNotify:\n", "\t\t\tcur = old = -1;\n", "\t\t\tXClearWindow(dpy, menuwin);\n", "\t\t\tredraw(cur, high, wide);\n", "\t\t\tbreak;\n", "\t\tcase ReparentNotify:\n", "\t\tcase ConfigureNotify:\n", "\t\t\t/*\n", "\t\t\t * ignore these, they come from XMoveWindow\n", "\t\t\t * and are enabled by Struct..\n", "\t\t\t */\n", "\t\t\tbreak;\n", "\t\tcase UnmapNotify:\n", "\t\t\tico = 1;\n", "\t\t\tXClearWindow(dpy, menuwin);\n", "\t\t\tbreak;\n", "\t\tcase MapNotify:\n", "\t\t\tif (ico) {\n", "\t\t\t\tif (teleport)\n", "\t\t\t\t\tteleportmenu(i, wide, high);\n", "\t\t\t\telse if (warp)\n", "\t\t\t\t\twarpmouse(i, wide, high);\n", "\t\t\t}\n", "\t\t\tXClearWindow(dpy, menuwin);\n", "\t\t\tredraw(cur = i, high, wide);\n", "\t\t\tico = 0;\n", "\t\t\tbreak;\n", "\t\tcase Expose:\n", "\t\t\tXClearWindow(dpy, menuwin);\n", "\t\t\tredraw(cur, high, wide);\n", "\t\t\tbreak;\n", "\t\tcase ClientMessage:\n", "\t\t\tcmsg = &ev.xclient;\n", "\t\t\tif (cmsg->message_type == wm_protocols\n", "\t\t\t    && cmsg->data.l[0] == wm_delete_window)\n", "\t\t\t\treturn;\n", "\t\tcase MappingNotify:\t/* why do we get this? */\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void spawn(char *com)\n", "\n", "{\n", "  char *sh_base;\n", "  __pid_t _Var1;\n", "  char *pcVar2;\n", "  long lVar3;\n", "  char *pcVar4;\n", "  bool bVar5;\n", "  byte bVar6;\n", "  \n", "  pcVar4 = shell;\n", "  bVar6 = 0;\n", "  if (sh_base == (char *)0x0) {\n", "    pcVar2 = strrchr(shell,0x2f);\n", "    if (pcVar2 == (char *)0x0) {\n", "      sh_base = pcVar4;\n", "    }\n", "    else {\n", "      sh_base = pcVar2 + 1;\n", "    }\n", "  }\n", "  bVar5 = popup == 0;\n", "  if (bVar5) {\n", "    lVar3 = 5;\n", "    pcVar4 = com;\n", "    pcVar2 = \"exec \";\n", "    do {\n", "      if (lVar3 == 0) break;\n", "      lVar3 = lVar3 + -1;\n", "      bVar5 = *pcVar4 == *pcVar2;\n", "      pcVar4 = pcVar4 + (ulong)bVar6 * -2 + 1;\n", "      pcVar2 = pcVar2 + (ulong)bVar6 * -2 + 1;\n", "    } while (bVar5);\n", "    if (bVar5) {\n", "      com = com + 5;\n", "    }\n", "    else {\n", "      _Var1 = fork();\n", "      if (_Var1 < 0) {\n", "        __fprintf_chk(stderr,1,\"%s: can\\'t fork\\n\",progname);\n", "        return;\n", "      }\n", "      if (_Var1 != 0) {\n", "        return;\n", "      }\n", "    }\n", "  }\n", "  close(*(int *)(dpy + 0x10));\n", "  execl(shell,sh_base,&DAT_00403406,com,0);\n", "  execl(\"/bin/sh\",\"sh\",&DAT_00403406,com,0);\n", "                    /* WARNING: Subroutine does not return */\n", "  _exit(1);\n", "}\n", "\n"], "c": ["void\n", "spawn(com)"]}, {"ghidra": ["\n", "void restoremouse(void)\n", "\n", "{\n", "  XWarpPointer(dpy,menuwin,root,0,0,0,0,(ulong)(uint)savex,(ulong)(uint)savey);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "restoremouse()\n", "{\n", "\tXWarpPointer(dpy, menuwin, root, 0, 0, 0, 0,\n", "\t\t\t\tsavex, savey);\n", "}"]}, {"ghidra": ["\n", "void memory(char *s)\n", "\n", "{\n", "  __fprintf_chk(stderr,1,\"%s: couldn\\'t allocate memory for %s\\n\",progname,s);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(1);\n", "}\n", "\n"], "c": ["void\n", "memory(s)"]}, {"ghidra": ["\n", "int args(int argc,char **argv)\n", "\n", "{\n", "  long lVar1;\n", "  long lVar2;\n", "  char *__s;\n", "  size_t sVar3;\n", "  long lVar4;\n", "  uint *puVar5;\n", "  uint *puVar6;\n", "  byte bVar7;\n", "  uint uVar8;\n", "  int iVar9;\n", "  char *__string;\n", "  char *pcVar10;\n", "  long in_FS_OFFSET;\n", "  bool bVar11;\n", "  byte bVar12;\n", "  char pathbuf [4096];\n", "  \n", "  bVar12 = 0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  lVar2 = 0;\n", "  if (((argc == 0) || (argv == (char **)0x0)) || (__s = *argv, __s == (char *)0x0)) {\n", "    iVar9 = -1;\n", "LAB_004021aa:\n", "    if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "      return iVar9;\n", "    }\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  iVar9 = 0;\n", "  bVar11 = argc == 0;\n", "  if (argc < 1) goto LAB_004021aa;\n", "LAB_00402168:\n", "  lVar4 = 9;\n", "  __string = __s;\n", "  pcVar10 = \"-display\";\n", "  do {\n", "    if (lVar4 == 0) break;\n", "    lVar4 = lVar4 + -1;\n", "    bVar11 = *__string == *pcVar10;\n", "    __string = __string + (ulong)bVar12 * -2 + 1;\n", "    pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "  } while (bVar11);\n", "  if (bVar11) {\n", "    iVar9 = iVar9 + 1;\n", "    displayname = argv[lVar2 + 1];\n", "  }\n", "  else {\n", "    lVar4 = 6;\n", "    __string = __s;\n", "    pcVar10 = \"-file\";\n", "    do {\n", "      if (lVar4 == 0) break;\n", "      lVar4 = lVar4 + -1;\n", "      bVar11 = *__string == *pcVar10;\n", "      __string = __string + (ulong)bVar12 * -2 + 1;\n", "      pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "    } while (bVar11);\n", "    if (bVar11) {\n", "      filename = argv[lVar2 + 1];\n", "      iVar9 = iVar9 + 2;\n", "      goto joined_r0x004021a1;\n", "    }\n", "    lVar4 = 6;\n", "    __string = __s;\n", "    pcVar10 = \"-font\";\n", "    do {\n", "      if (lVar4 == 0) break;\n", "      lVar4 = lVar4 + -1;\n", "      bVar11 = *__string == *pcVar10;\n", "      __string = __string + (ulong)bVar12 * -2 + 1;\n", "      pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "    } while (bVar11);\n", "    if (bVar11) {\n", "      iVar9 = iVar9 + 1;\n", "      fontname = argv[lVar2 + 1];\n", "    }\n", "    else {\n", "      lVar4 = 10;\n", "      __string = __s;\n", "      pcVar10 = \"-geometry\";\n", "      do {\n", "        if (lVar4 == 0) break;\n", "        lVar4 = lVar4 + -1;\n", "        bVar11 = *__string == *pcVar10;\n", "        __string = __string + (ulong)bVar12 * -2 + 1;\n", "        pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "      } while (bVar11);\n", "      if (bVar11) {\n", "        iVar9 = iVar9 + 1;\n", "        geometry = argv[lVar2 + 1];\n", "      }\n", "      else {\n", "        lVar4 = 7;\n", "        __string = __s;\n", "        pcVar10 = \"-label\";\n", "        do {\n", "          if (lVar4 == 0) break;\n", "          lVar4 = lVar4 + -1;\n", "          bVar11 = *__string == *pcVar10;\n", "          __string = __string + (ulong)bVar12 * -2 + 1;\n", "          pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "        } while (bVar11);\n", "        if (bVar11) {\n", "          iVar9 = iVar9 + 1;\n", "          labelname = argv[lVar2 + 1];\n", "        }\n", "        else {\n", "          lVar4 = 7;\n", "          __string = __s;\n", "          pcVar10 = \"-shell\";\n", "          do {\n", "            if (lVar4 == 0) break;\n", "            lVar4 = lVar4 + -1;\n", "            bVar11 = *__string == *pcVar10;\n", "            __string = __string + (ulong)bVar12 * -2 + 1;\n", "            pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "          } while (bVar11);\n", "          if (bVar11) {\n", "            iVar9 = iVar9 + 1;\n", "            shell = argv[lVar2 + 1];\n", "            goto LAB_00402153;\n", "          }\n", "          lVar2 = 7;\n", "          __string = __s;\n", "          pcVar10 = \"-popup\";\n", "          do {\n", "            if (lVar2 == 0) break;\n", "            lVar2 = lVar2 + -1;\n", "            bVar11 = *__string == *pcVar10;\n", "            __string = __string + (ulong)bVar12 * -2 + 1;\n", "            pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "          } while (bVar11);\n", "          if (bVar11) {\n", "            popup = popup + 1;\n", "          }\n", "          else {\n", "            lVar2 = 9;\n", "            __string = __s;\n", "            pcVar10 = \"-popdown\";\n", "            do {\n", "              if (lVar2 == 0) break;\n", "              lVar2 = lVar2 + -1;\n", "              bVar11 = *__string == *pcVar10;\n", "              __string = __string + (ulong)bVar12 * -2 + 1;\n", "              pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "            } while (bVar11);\n", "            if (bVar11) {\n", "              popdown = popdown + 1;\n", "            }\n", "            else {\n", "              bVar11 = *__s == '-';\n", "              if (bVar11) {\n", "                if (__s[1] == 'f') {\n", "                  bVar11 = __s[2] == 'g';\n", "                  if ((!bVar11) || (bVar11 = __s[3] == '\\0', !bVar11)) goto LAB_00402302;\n", "                  iVar9 = iVar9 + 1;\n", "                  fgcname = argv[iVar9];\n", "                }\n", "                else {\n", "                  bVar11 = __s[1] == 'b';\n", "                  if (((!bVar11) || (bVar11 = __s[2] == 'g', !bVar11)) ||\n", "                     (bVar11 = __s[3] == '\\0', !bVar11)) goto LAB_00402302;\n", "                  iVar9 = iVar9 + 1;\n", "                  bgcname = argv[iVar9];\n", "                }\n", "              }\n", "              else {\n", "LAB_00402302:\n", "                lVar2 = 8;\n", "                __string = __s;\n", "                pcVar10 = \"-iconic\";\n", "                do {\n", "                  if (lVar2 == 0) break;\n", "                  lVar2 = lVar2 + -1;\n", "                  bVar11 = *__string == *pcVar10;\n", "                  __string = __string + (ulong)bVar12 * -2 + 1;\n", "                  pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "                } while (bVar11);\n", "                if (bVar11) {\n", "                  iconic = iconic + 1;\n", "                }\n", "                else {\n", "                  lVar2 = 6;\n", "                  __string = __s;\n", "                  pcVar10 = \"-path\";\n", "                  do {\n", "                    if (lVar2 == 0) break;\n", "                    lVar2 = lVar2 + -1;\n", "                    bVar11 = *__string == *pcVar10;\n", "                    __string = __string + (ulong)bVar12 * -2 + 1;\n", "                    pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "                  } while (bVar11);\n", "                  if (bVar11) {\n", "                    __s = getenv(\"PATH\");\n", "                    if (__s != (char *)0x0) {\n", "                      getcwd(pathbuf,0x1000);\n", "                      sVar3 = strlen(__s);\n", "                      puVar6 = (uint *)pathbuf;\n", "                      do {\n", "                        puVar5 = puVar6;\n", "                        uVar8 = *puVar5 + 0xfefefeff & ~*puVar5;\n", "                        _bVar7 = uVar8 & 0x80808080;\n", "                        bVar7 = (byte)_bVar7;\n", "                        puVar6 = puVar5 + 1;\n", "                      } while (_bVar7 == 0);\n", "                      bVar11 = (uVar8 & 0x8080) == 0;\n", "                      if (bVar11) {\n", "                        bVar7 = (byte)(_bVar7 >> 0x10);\n", "                      }\n", "                      if (bVar11) {\n", "                        puVar6 = (uint *)((long)puVar5 + 6);\n", "                      }\n", "                      __string = (char *)malloc((long)puVar6 +\n", "                                                sVar3 + (-(long)pathbuf - (ulong)CARRY1(bVar7,bVar7)\n", "                                                        ) + 4);\n", "                      __sprintf_chk(__string,1,0xffffffffffffffff,\"PATH=%s:%s\",pathbuf,__s);\n", "                      putenv(__string);\n", "                    }\n", "                  }\n", "                  else {\n", "                    lVar2 = 10;\n", "                    __string = __s;\n", "                    pcVar10 = \"-teleport\";\n", "                    do {\n", "                      if (lVar2 == 0) break;\n", "                      lVar2 = lVar2 + -1;\n", "                      bVar11 = *__string == *pcVar10;\n", "                      __string = __string + (ulong)bVar12 * -2 + 1;\n", "                      pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "                    } while (bVar11);\n", "                    if (bVar11) {\n", "                      teleport = teleport + 1;\n", "                    }\n", "                    else {\n", "                      lVar2 = 6;\n", "                      __string = __s;\n", "                      pcVar10 = \"-warp\";\n", "                      do {\n", "                        if (lVar2 == 0) break;\n", "                        lVar2 = lVar2 + -1;\n", "                        bVar11 = *__string == *pcVar10;\n", "                        __string = __string + (ulong)bVar12 * -2 + 1;\n", "                        pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "                      } while (bVar11);\n", "                      if (!bVar11) {\n", "                        lVar2 = 9;\n", "                        __string = __s;\n", "                        pcVar10 = \"-version\";\n", "                        goto code_r0x00402454;\n", "                      }\n", "                      warp = warp + 1;\n", "                    }\n", "                  }\n", "                }\n", "              }\n", "            }\n", "          }\n", "        }\n", "      }\n", "    }\n", "  }\n", "LAB_00402153:\n", "  iVar9 = iVar9 + 1;\n", "joined_r0x004021a1:\n", "  if (argc <= iVar9) goto LAB_004021aa;\n", "  lVar2 = (long)iVar9;\n", "  __s = argv[lVar2];\n", "  bVar11 = __s == (char *)0x0;\n", "  if (bVar11) goto LAB_004021aa;\n", "  goto LAB_00402168;\n", "  while( true ) {\n", "    lVar2 = lVar2 + -1;\n", "    bVar11 = *__string == *pcVar10;\n", "    __string = __string + (ulong)bVar12 * -2 + 1;\n", "    pcVar10 = pcVar10 + (ulong)bVar12 * -2 + 1;\n", "    if (!bVar11) break;\n", "code_r0x00402454:\n", "    if (lVar2 == 0) break;\n", "  }\n", "  if (!bVar11) {\n", "    if (*__s != '-') goto LAB_004021aa;\n", "    usage();\n", "  }\n", "  puts(version);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(0);\n", "}\n", "\n"], "c": ["int\n", "args(argc, argv)"]}, {"ghidra": ["\n", "void ask_wm_for_delete(void)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  wm_protocols = XInternAtom(dpy,\"WM_PROTOCOLS\",0);\n", "  wm_delete_window = XInternAtom(dpy,\"WM_DELETE_WINDOW\",0);\n", "  iVar1 = XSetWMProtocols(dpy,menuwin,&wm_delete_window,1);\n", "  if (iVar1 != 1) {\n", "    __fprintf_chk(stderr,1,\"%s: could not ask for clean delete\\n\",progname);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "ask_wm_for_delete()\n", "{\n", "\tint status;\n", "\n", "\twm_protocols = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n", "\twm_delete_window = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n", "\tstatus = XSetWMProtocols(dpy, menuwin, & wm_delete_window, 1);\n", "\n", "\tif (status != True)\n", "\t\tfprintf(stderr, \"%s: could not ask for clean delete\\n\",\n", "\t\t\tprogname);\n", "}"]}, {"ghidra": ["\n", "void usage(void)\n", "\n", "{\n", "  __fprintf_chk(stderr,1,\"usage: %s [-display displayname] [-font fname] \",progname);\n", "  fwrite(\"[-file filename] [-path]\",1,0x18,stderr);\n", "  fwrite(\"[-geometry geom] [-shell shell]  [-label name] \",1,0x2f,stderr);\n", "  fwrite(\"[-popup] [-popdown] [-iconic]  [-teleport] \",1,0x2b,stderr);\n", "  fwrite(\"[-warp]  [-version] menitem:command ...\\n\",1,0x28,stderr);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(0);\n", "}\n", "\n"], "c": ["void\n", "usage()\n", "{\n", "\tfprintf(stderr, \"usage: %s [-display displayname] [-font fname] \", progname);\n", "\tfprintf(stderr, \"[-file filename] [-path]\");\n", "\tfprintf(stderr, \"[-geometry geom] [-shell shell]  [-label name] \");\n", "\tfprintf(stderr, \"[-popup] [-popdown] [-iconic]  [-teleport] \");\n", "\tfprintf(stderr, \"[-warp]  [-version] menitem:command ...\\n\");\n", "\texit(0);\n", "}"]}, {"ghidra": ["\n", "int cmpenv(void *a,void *b)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = strcmp(*(char **)a,*(char **)b);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "cmpenv(const void *a, const void *b)\n", "{\n", "\treturn strcmp(*(char**)a, *(char**)b);\n", "}"]}, {"ghidra": ["\n", "void pptr(io *f,void *v)\n", "\n", "{\n", "  byte bVar1;\n", "  uint uVar2;\n", "  ulong uVar3;\n", "  \n", "  if ((ulong)v >> 0x20 != 0) {\n", "    uVar3 = 0x3c;\n", "    do {\n", "      bVar1 = (byte)uVar3;\n", "      uVar2 = (int)uVar3 - 4;\n", "      uVar3 = (ulong)uVar2;\n", "      pchr(f,(int)\"0123456789ABCDEF\"[(uint)((ulong)v >> (bVar1 & 0x3f)) & 0xf]);\n", "    } while (uVar2 != 0x1c);\n", "  }\n", "  uVar3 = 0x1c;\n", "  do {\n", "    bVar1 = (byte)uVar3;\n", "    uVar2 = (int)uVar3 - 4;\n", "    uVar3 = (ulong)uVar2;\n", "    pchr(f,(int)\"0123456789ABCDEF\"[(uint)((ulong)v >> (bVar1 & 0x3f)) & 0xf]);\n", "  } while (uVar2 != 0xfffffffc);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pptr(io *f, void *v)\n", "{\n", "\tint n;\n", "\tuintptr p;\n", "\n", "\tp = (uintptr)v;\n", "\tif(sizeof(uintptr) == sizeof(uvlong) && p>>32)\n", "\t\tfor(n = 60;n>=32;n-=4) pchr(f, \"0123456789ABCDEF\"[(p>>n)&0xF]);\n", "\n", "\tfor(n = 28;n>=0;n-=4) pchr(f, \"0123456789ABCDEF\"[(p>>n)&0xF]);\n", "}"]}, {"ghidra": ["\n", "void Execute(word *args,word *path)\n", "\n", "{\n", "  char *__s;\n", "  char **p;\n", "  char **__envp;\n", "  size_t sVar1;\n", "  int iVar2;\n", "  long in_FS_OFFSET;\n", "  char file [1024];\n", "  long local_40;\n", "  \n", "  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n", "  p = mkargv(args);\n", "  __envp = mkenv();\n", "  if (path != (word *)0x0) {\n", "    do {\n", "      while( true ) {\n", "        __s = path->word;\n", "        sVar1 = strlen(__s);\n", "        iVar2 = (int)sVar1;\n", "        if (iVar2 < 0x400) break;\n", "LAB_0040d070:\n", "        path = path->next;\n", "        if (path == (word *)0x0) goto LAB_0040d110;\n", "      }\n", "      __memcpy_chk(file,__s,sVar1 + 1,0x400);\n", "      if (file[0] != '\\0') {\n", "        iVar2 = iVar2 + 1;\n", "        *(undefined2 *)(file + sVar1) = 0x2f;\n", "      }\n", "      __s = p[1];\n", "      sVar1 = strlen(__s);\n", "      if (0x3ff < (long)iVar2 + sVar1) {\n", "        werrstr(\"command name too long\");\n", "        goto LAB_0040d070;\n", "      }\n", "      __strcat_chk(file,__s,0x400);\n", "      execve(file,p + 1,__envp);\n", "      path = path->next;\n", "    } while (path != (word *)0x0);\n", "  }\n", "LAB_0040d110:\n", "  rerrstr(file,0x400);\n", "  pfmt(rc_err,\"%s: %s\\n\",p[1],file);\n", "  efree((char *)p);\n", "  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void Execute(word *args, word *path)\n", "{\n", "\tchar **argv=mkargv(args);\n", "\tchar **env=mkenv();\n", "\tchar file[1024];\n", "\tint nc;\n", "\tUpdenv();\n", "\tfor(;path;path=path->next){\n", "\t\tnc=strlen(path->word);\n", "\t\tif(nc<1024){\n", "\t\t\tstrcpy(file, path->word);\n", "\t\t\tif(file[0]){\n", "\t\t\t\tstrcat(file, \"/\");\n", "\t\t\t\tnc++;\n", "\t\t\t}\n", "\t\t\tif(nc+strlen(argv[1])<1024){\n", "\t\t\t\tstrcat(file, argv[1]);\n", "\t\t\t\texecve(file, argv+1, env);\n", "\t\t\t}\n", "\t\t\telse werrstr(\"command name too long\");\n", "\t\t}\n", "\t}\n", "\trerrstr(file, sizeof file);\n", "\tpfmt(err, \"%s: %s\\n\", argv[1], file);\n", "\tefree((char *)argv);\n", "}"]}, {"ghidra": ["\n", "void Xbackq(void)\n", "\n", "{\n", "  long lVar1;\n", "  list *plVar2;\n", "  thread *ptVar3;\n", "  int __c;\n", "  __pid_t pid;\n", "  var *pvVar4;\n", "  io *b;\n", "  char *pcVar5;\n", "  word *next;\n", "  word *pwVar6;\n", "  char *pcVar7;\n", "  char *__s;\n", "  word *pwVar8;\n", "  long in_FS_OFFSET;\n", "  int pfd [2];\n", "  char wd [8193];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  pvVar4 = vlook(\"ifs\");\n", "  if (pvVar4->val == (word *)0x0) {\n", "    __s = \"\";\n", "  }\n", "  else {\n", "    __s = pvVar4->val->word;\n", "  }\n", "  __c = pipe(pfd);\n", "  if (__c < 0) {\n", "    Xerror(\"can\\'t make pipe\");\n", "  }\n", "  else {\n", "    pid = fork();\n", "    if (pid == -1) {\n", "      Xerror(\"try again\");\n", "      close(pfd[0]);\n", "      close(pfd[1]);\n", "    }\n", "    else {\n", "      if (pid == 0) {\n", "        clearwaitpids();\n", "        close(pfd[0]);\n", "        start(runq->code,runq->pc + 1,runq->local);\n", "        pushredir(1,pfd[1],1);\n", "      }\n", "      else {\n", "        next = (word *)0x0;\n", "        addwaitpid(pid);\n", "        close(pfd[1]);\n", "        b = openfd(pfd[0]);\n", "        pcVar7 = wd;\n", "LAB_0040dbdf:\n", "        __c = rchr(b);\n", "        if (__c != -1) {\n", "          do {\n", "            pcVar5 = strchr(__s,__c);\n", "            if (pcVar5 == (char *)0x0) {\n", "              if (pcVar7 != wd + 0x2000) {\n", "                *pcVar7 = (char)__c;\n", "                pcVar7 = pcVar7 + 1;\n", "                goto LAB_0040dbdf;\n", "              }\n", "            }\n", "            else {\n", "              if (pcVar7 == wd) goto LAB_0040dbdf;\n", "            }\n", "            *pcVar7 = '\\0';\n", "            next = newword(wd,next);\n", "            __c = rchr(b);\n", "            pcVar7 = wd;\n", "            if (__c == -1) break;\n", "          } while( true );\n", "        }\n", "        if (pcVar7 != wd) {\n", "          *pcVar7 = '\\0';\n", "          next = newword(wd,next);\n", "        }\n", "        closeio(b);\n", "        Waitfor(pid,0);\n", "        ptVar3 = runq;\n", "        if (next != (word *)0x0) {\n", "          plVar2 = runq->argv;\n", "          pwVar6 = plVar2->words;\n", "          do {\n", "            pwVar8 = next;\n", "            next = pwVar8->next;\n", "            pwVar8->next = pwVar6;\n", "            pwVar6 = pwVar8;\n", "          } while (next != (word *)0x0);\n", "          plVar2->words = pwVar8;\n", "        }\n", "        ptVar3->pc = *(int *)(ptVar3->code + ptVar3->pc);\n", "      }\n", "    }\n", "  }\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "Xbackq(void)\n", "{\n", "\tchar wd[8193];\n", "\tint c;\n", "\tchar *s, *ewd=&wd[8192], *stop;\n", "\tstruct io *f;\n", "\tvar *ifs = vlook(\"ifs\");\n", "\tword *v, *nextv;\n", "\tint pfd[2];\n", "\tint pid;\n", "\tstop = ifs->val?ifs->val->word:\"\";\n", "\tif(pipe(pfd)<0){\n", "\t\tXerror(\"can't make pipe\");\n", "\t\treturn;\n", "\t}\n", "\tswitch(pid = fork()){\n", "\tcase -1:\n", "\t\tXerror(\"try again\");\n", "\t\tclose(pfd[PRD]);\n", "\t\tclose(pfd[PWR]);\n", "\t\treturn;\n", "\tcase 0:\n", "\t\tclearwaitpids();\n", "\t\tclose(pfd[PRD]);\n", "\t\tstart(runq->code, runq->pc+1, runq->local);\n", "\t\tpushredir(ROPEN, pfd[PWR], 1);\n", "\t\treturn;\n", "\tdefault:\n", "\t\taddwaitpid(pid);\n", "\t\tclose(pfd[PWR]);\n", "\t\tf = openfd(pfd[PRD]);\n", "\t\ts = wd;\n", "\t\tv = 0;\n", "\t\twhile((c = rchr(f))!=EOF){\n", "\t\t\tif(strchr(stop, c) || s==ewd){\n", "\t\t\t\tif(s!=wd){\n", "\t\t\t\t\t*s='\\0';\n", "\t\t\t\t\tv = newword(wd, v);\n", "\t\t\t\t\ts = wd;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\telse *s++=c;\n", "\t\t}\n", "\t\tif(s!=wd){\n", "\t\t\t*s='\\0';\n", "\t\t\tv = newword(wd, v);\n", "\t\t}\n", "\t\tcloseio(f);\n", "\t\tWaitfor(pid, 0);\n", "\t\t/* v points to reversed arglist -- reverse it onto argv */\n", "\t\twhile(v){\n", "\t\t\tnextv = v->next;\n", "\t\t\tv->next = runq->argv->words;\n", "\t\t\trunq->argv->words = v;\n", "\t\t\tv = nextv;\n", "\t\t}\n", "\t\trunq->pc = runq->code[runq->pc].i;\n", "\t\treturn;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void readhere(void)\n", "\n", "{\n", "  int iVar1;\n", "  long lVar2;\n", "  char *__s2;\n", "  here *phVar3;\n", "  int fd;\n", "  int iVar4;\n", "  io *f;\n", "  char *pcVar5;\n", "  here *p;\n", "  long in_FS_OFFSET;\n", "  bool bVar6;\n", "  char line [4097];\n", "  \n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  p = here;\n", "  if (here != (here *)0x0) {\n", "    do {\n", "      iVar1 = p->tag->quoted;\n", "      __s2 = p->tag->str;\n", "      fd = Creat(p->name);\n", "      if (fd < 0) {\n", "        yyerror(\"can\\'t create here document\");\n", "      }\n", "      pcVar5 = line;\n", "      f = openfd(fd);\n", "      pprompt();\n", "      while (fd = rchr(runq->cmdfd), fd != -1) {\n", "        bVar6 = fd == 10;\n", "        if ((bVar6) || (pcVar5 == line + 0x1000)) {\n", "          *pcVar5 = '\\0';\n", "          if ((__s2 != (char *)0x0) && (iVar4 = strcmp(line,__s2), iVar4 == 0)) break;\n", "          if (iVar1 == 0) {\n", "            psubst(f,line);\n", "            if (bVar6) goto LAB_00407b39;\n", "LAB_00407b24:\n", "            pcVar5 = line + 1;\n", "            line[0] = (char)fd;\n", "          }\n", "          else {\n", "            pstr(f,line);\n", "            if (!bVar6) goto LAB_00407b24;\n", "LAB_00407b39:\n", "            pprompt();\n", "            pcVar5 = line;\n", "            pchr(f,10);\n", "          }\n", "        }\n", "        else {\n", "          *pcVar5 = (char)fd;\n", "          pcVar5 = pcVar5 + 1;\n", "        }\n", "      }\n", "      flush(f);\n", "      closeio(f);\n", "      cleanhere(p->name);\n", "      phVar3 = p->next;\n", "      efree((char *)p);\n", "      p = phVar3;\n", "    } while (phVar3 != (here *)0x0);\n", "  }\n", "  here = (here *)0x0;\n", "  doprompt = 1;\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  doprompt = 1;\n", "  here = (here *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "readhere(void)\n", "{\n", "\tstruct here *h, *nexth;\n", "\tio *f;\n", "\tchar *s, *tag;\n", "\tint c, subst;\n", "\tchar line[NLINE+1];\n", "\tfor(h = here;h;h = nexth){\n", "\t\tsubst=!h->tag->quoted;\n", "\t\ttag = h->tag->str;\n", "\t\tc = Creat(h->name);\n", "\t\tif(c<0)\n", "\t\t\tyyerror(\"can't create here document\");\n", "\t\tf = openfd(c);\n", "\t\ts = line;\n", "\t\tpprompt();\n", "\t\twhile((c = rchr(runq->cmdfd))!=EOF){\n", "\t\t\tif(c=='\\n' || s==&line[NLINE]){\n", "\t\t\t\t*s='\\0';\n", "\t\t\t\tif(tag && strcmp(line, tag)==0) break;\n", "\t\t\t\tif(subst)\n", "\t\t\t\t\tpsubst(f, line);\n", "\t\t\t\telse pstr(f, line);\n", "\t\t\t\ts = line;\n", "\t\t\t\tif(c=='\\n'){\n", "\t\t\t\t\tpprompt();\n", "\t\t\t\t\tpchr(f, c);\n", "\t\t\t\t}\n", "\t\t\t\telse *s++=c;\n", "\t\t\t}\n", "\t\t\telse *s++=c;\n", "\t\t}\n", "\t\tflush(f);\n", "\t\tcloseio(f);\n", "\t\tcleanhere(h->name);\n", "\t\tnexth = h->next;\n", "\t\tefree((char *)h);\n", "\t}\n", "\there = 0;\n", "\tdoprompt = 1;\n", "}"]}, {"ghidra": ["\n", "void pdec(io *f,int n)\n", "\n", "{\n", "  if (n < 0) {\n", "    n = -n;\n", "    pchr(f,0x2d);\n", "  }\n", "  if (9 < n) {\n", "    pdec(f,n / 10);\n", "  }\n", "  pchr(f,n % 10 + 0x30);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pdec(io *f, int n)\n", "{\n", "\tif(n<0){\n", "\t\tn=-n;\n", "\t\tif(n>=0){\n", "\t\t\tpchr(f, '-');\n", "\t\t\tpdec(f, n);\n", "\t\t\treturn;\n", "\t\t}\n", "\t\t/* n is two's complement minimum integer */\n", "\t\tn = 1-n;\n", "\t\tpchr(f, '-');\n", "\t\tpdec(f, n/10);\n", "\t\tpchr(f, n%10+'1');\n", "\t\treturn;\n", "\t}\n", "\tif(n>9)\n", "\t\tpdec(f, n/10);\n", "\tpchr(f, n%10+'0');\n", "}"]}, {"ghidra": ["\n", "int p9dup(int old,int new)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  if (new != -1) {\n", "    iVar1 = dup2(old,new);\n", "    return iVar1;\n", "  }\n", "  iVar1 = dup(old);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "p9dup(int old, int new)\n", "{\n", "\tif(new == -1)\n", "\t\treturn dup(old);\n", "\treturn dup2(old, new);\n", "}"]}, {"ghidra": ["\n", "void p9free(void *v)\n", "\n", "{\n", "  if (v != (void *)0x0) {\n", "    lock(&malloclock);\n", "    free(v);\n", "    unlock(&malloclock);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "p9free(void *v)\n", "{\n", "\tif(v == nil)\n", "\t\treturn;\n", "\tlock(&malloclock);\n", "\tfree(v);\n", "\tunlock(&malloclock);\n", "}"]}, {"ghidra": ["\n", "int compile(tree *t)\n", "\n", "{\n", "  long lVar1;\n", "  bool bVar2;\n", "  \n", "  ncode = 100;\n", "  codebuf = (code *)emalloc(800);\n", "  lVar1 = 0;\n", "  codep = 0;\n", "  if (ncode == 0) {\n", "    morecode();\n", "    lVar1 = (long)codep << 3;\n", "  }\n", "  *(undefined4 *)((long)codebuf + lVar1) = 0;\n", "  codep = codep + 1;\n", "  outcode(t,(uint)(flag[101] != (char **)0x0));\n", "  if (nerror == 0) {\n", "    readhere();\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar1 = (long)codep;\n", "    codep = codep + 1;\n", "    bVar2 = codep == ncode;\n", "    codebuf[lVar1] = 0x404d80;\n", "    if (bVar2) {\n", "      morecode();\n", "    }\n", "    codebuf[codep] = 0;\n", "    codep = codep + 1;\n", "    return 1;\n", "  }\n", "  efree((char *)codebuf);\n", "  return 0;\n", "}\n", "\n"], "c": ["int\n", "compile(tree *t)\n", "{\n", "\tncode = 100;\n", "\tcodebuf = (code *)emalloc(ncode*sizeof codebuf[0]);\n", "\tcodep = 0;\n", "\temiti(0);\t\t\t/* reference count */\n", "\toutcode(t, flag['e']?1:0);\n", "\tif(nerror){\n", "\t\tefree((char *)codebuf);\n", "\t\treturn 0;\n", "\t}\n", "\treadhere();\n", "\temitf(Xreturn);\n", "\temitf(0);\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "var * gvlook(char *name)\n", "\n", "{\n", "  char cVar1;\n", "  var *pvVar2;\n", "  var *next;\n", "  int iVar3;\n", "  int iVar4;\n", "  char *name_00;\n", "  int iVar5;\n", "  \n", "  cVar1 = *name;\n", "  if (cVar1 == '\\0') {\n", "    iVar5 = 0;\n", "  }\n", "  else {\n", "    iVar3 = 1;\n", "    iVar5 = 0;\n", "    name_00 = name;\n", "    do {\n", "      iVar4 = cVar1 * iVar3;\n", "      name_00 = name_00 + 1;\n", "      iVar3 = iVar3 + 1;\n", "      iVar5 = iVar5 + iVar4;\n", "      cVar1 = *name_00;\n", "    } while (cVar1 != '\\0');\n", "    iVar5 = iVar5 % 0x209;\n", "    if (iVar5 < 0) {\n", "      iVar5 = iVar5 + 0x209;\n", "    }\n", "  }\n", "  next = gvar[iVar5];\n", "  pvVar2 = next;\n", "  while( true ) {\n", "    if (pvVar2 == (var *)0x0) {\n", "      name_00 = p9strdup(name);\n", "      next = newvar(name_00,next);\n", "      gvar[iVar5] = next;\n", "      return next;\n", "    }\n", "    iVar3 = strcmp(pvVar2->name,name);\n", "    if (iVar3 == 0) break;\n", "    pvVar2 = pvVar2->next;\n", "  }\n", "  return pvVar2;\n", "}\n", "\n"], "c": ["var*\n", "gvlook(char *name)\n", "{\n", "\tint h = hash(name, NVAR);\n", "\tvar *v;\n", "\tfor(v = gvar[h];v;v = v->next) if(strcmp(v->name, name)==0) return v;\n", "\treturn gvar[h] = newvar(strdup(name), gvar[h]);\n", "}"]}, {"ghidra": ["\n", "void skipwhite(void)\n", "\n", "{\n", "  do {\n", "    if (future == -1) {\n", "      future = getnext();\n", "    }\n", "    if (future == 0x23) {\n", "      incomm = 1;\n", "      while (future != -1) {\n", "        while( true ) {\n", "          if (future == 10) goto LAB_00408920;\n", "          advance();\n", "          if (future != -1) break;\n", "          future = getnext();\n", "          if (future == -1) goto LAB_00408920;\n", "        }\n", "      }\n", "LAB_00408920:\n", "      incomm = 0;\n", "    }\n", "    if ((future != 9) && (future != 0x20)) {\n", "      return;\n", "    }\n", "    advance();\n", "  } while( true );\n", "}\n", "\n"], "c": ["void\n", "skipwhite(void)\n", "{\n", "\tint c;\n", "\tfor(;;){\n", "\t\tc = nextc();\n", "\t\t/* Why did this used to be  if(!inquote && c=='#') ?? */\n", "\t\tif(c=='#'){\n", "\t\t\tincomm = 1;\n", "\t\t\tfor(;;){\n", "\t\t\t\tc = nextc();\n", "\t\t\t\tif(c=='\\n' || c==EOF) {\n", "\t\t\t\t\tincomm = 0;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t\tadvance();\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(c==' ' || c=='\\t')\n", "\t\t\tadvance();\n", "\t\telse return;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int awaitfor(int pid,char *str,int n)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = _await(pid,str,n,0);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "awaitfor(int pid, char *str, int n)\n", "{\n", "\treturn _await(pid, str, n, 0);\n", "}"]}, {"ghidra": ["\n", "void pdeglob(io *f,char *s)\n", "\n", "{\n", "  char cVar1;\n", "  char *pcVar2;\n", "  \n", "  cVar1 = *s;\n", "  while (cVar1 != '\\0') {\n", "    pcVar2 = s + (cVar1 == '\\x01');\n", "    s = pcVar2 + 1;\n", "    pchr(f,(int)*pcVar2);\n", "    cVar1 = pcVar2[1];\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pdeglob(io *f, char *s)\n", "{\n", "\twhile(*s){\n", "\t\tif(*s==GLOB)\n", "\t\t\ts++;\n", "\t\tpchr(f, *s++);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void execwhatis(void)\n", "\n", "{\n", "  long lVar1;\n", "  char *__s2;\n", "  bool bVar2;\n", "  int iVar3;\n", "  var *pvVar4;\n", "  word *pwVar5;\n", "  undefined2 *puVar6;\n", "  undefined8 uVar7;\n", "  builtin *pbVar8;\n", "  word *pwVar9;\n", "  char *__s1;\n", "  long in_FS_OFFSET;\n", "  io out [1];\n", "  char file [512];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  pwVar9 = runq->argv->words->next;\n", "  if (pwVar9 == (word *)0x0) {\n", "    Xerror1(\"Usage: whatis name ...\");\n", "  }\n", "  else {\n", "    setstatus(\"\");\n", "    out[0].fd = mapfd(1);\n", "    out[0].bufp = out[0].buf;\n", "    out[0].strp = (char *)0x0;\n", "    out[0].ebuf = file;\n", "    do {\n", "      bVar2 = false;\n", "      pvVar4 = vlook(pwVar9->word);\n", "      if (pvVar4->val != (word *)0x0) {\n", "        pfmt(out,\"%s=\",pwVar9->word);\n", "        pwVar5 = pvVar4->val;\n", "        uVar7 = 0x28;\n", "        if (pwVar5->next == (word *)0x0) {\n", "          bVar2 = true;\n", "          pfmt(out,\"%q\\n\",pwVar5->word);\n", "        }\n", "        else {\n", "          do {\n", "            if (pwVar5->word == (char *)0x0) break;\n", "            pfmt(out,\"%c%q\",uVar7);\n", "            pwVar5 = pwVar5->next;\n", "            uVar7 = 0x20;\n", "          } while (pwVar5 != (word *)0x0);\n", "          bVar2 = true;\n", "          pfmt(out,\")\\n\",uVar7);\n", "        }\n", "      }\n", "      pvVar4 = gvlook(pwVar9->word);\n", "      if (pvVar4->fn == (code *)0x0) {\n", "        __s1 = pwVar9->word;\n", "        pbVar8 = Builtin;\n", "        __s2 = Builtin[0].name;\n", "        while (__s2 != (char *)0x0) {\n", "          iVar3 = strcmp(__s1,__s2);\n", "          if (iVar3 == 0) {\n", "            pfmt(out,\"builtin %s\\n\",__s1);\n", "            if (pbVar8->name != (char *)0x0) goto LAB_0040a87f;\n", "            __s1 = pwVar9->word;\n", "            break;\n", "          }\n", "          pbVar8 = pbVar8 + 1;\n", "          __s2 = pbVar8->name;\n", "        }\n", "        pwVar5 = rcsearchpath(__s1);\n", "        while (pwVar5 != (word *)0x0) {\n", "          puVar6 = (undefined2 *)__stpcpy_chk(file,pwVar5->word,0x200);\n", "          if (file[0] != '\\0') {\n", "            *puVar6 = 0x2f;\n", "          }\n", "          __strcat_chk(file,pwVar9->word,0x200);\n", "          iVar3 = Executable(file);\n", "          if (iVar3 != 0) {\n", "            pfmt(out,\"%s\\n\",file);\n", "            goto LAB_0040a87f;\n", "          }\n", "          pwVar5 = pwVar5->next;\n", "        }\n", "        if (!bVar2) {\n", "          pfmt(rc_err,\"%s: not found\\n\",pwVar9->word);\n", "          setstatus(\"not found\");\n", "        }\n", "      }\n", "      else {\n", "        pfmt(out,\"fn %s %s\\n\",pvVar4->name,pvVar4->fn[(long)pvVar4->pc + -1]);\n", "      }\n", "LAB_0040a87f:\n", "      pwVar9 = pwVar9->next;\n", "    } while (pwVar9 != (word *)0x0);\n", "    poplist();\n", "    flush(rc_err);\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "execwhatis(void){\t/* mildly wrong -- should fork before writing */\n", "\tword *a, *b, *path;\n", "\tvar *v;\n", "\tstruct builtin *bp;\n", "\tchar file[512];\n", "\tstruct io out[1];\n", "\tint found, sep;\n", "\ta = runq->argv->words->next;\n", "\tif(a==0){\n", "\t\tXerror1(\"Usage: whatis name ...\");\n", "\t\treturn;\n", "\t}\n", "\tsetstatus(\"\");\n", "\tout->fd = mapfd(1);\n", "\tout->bufp = out->buf;\n", "\tout->ebuf = &out->buf[NBUF];\n", "\tout->strp = 0;\n", "\tfor(;a;a = a->next){\n", "\t\tv = vlook(a->word);\n", "\t\tif(v->val){\n", "\t\t\tpfmt(out, \"%s=\", a->word);\n", "\t\t\tif(v->val->next==0)\n", "\t\t\t\tpfmt(out, \"%q\\n\", v->val->word);\n", "\t\t\telse{\n", "\t\t\t\tsep='(';\n", "\t\t\t\tfor(b = v->val;b && b->word;b = b->next){\n", "\t\t\t\t\tpfmt(out, \"%c%q\", sep, b->word);\n", "\t\t\t\t\tsep=' ';\n", "\t\t\t\t}\n", "\t\t\t\tpfmt(out, \")\\n\");\n", "\t\t\t}\n", "\t\t\tfound = 1;\n", "\t\t}\n", "\t\telse\n", "\t\t\tfound = 0;\n", "\t\tv = gvlook(a->word);\n", "\t\tif(v->fn)\n", "\t\t\tpfmt(out, \"fn %s %s\\n\", v->name, v->fn[v->pc-1].s);\n", "\t\telse{\n", "\t\t\tfor(bp = Builtin;bp->name;bp++)\n", "\t\t\t\tif(strcmp(a->word, bp->name)==0){\n", "\t\t\t\t\tpfmt(out, \"builtin %s\\n\", a->word);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\tif(!bp->name){\n", "\t\t\t\tfor(path = searchpath(a->word);path;path = path->next){\n", "\t\t\t\t\tstrcpy(file, path->word);\n", "\t\t\t\t\tif(file[0])\n", "\t\t\t\t\t\tstrcat(file, \"/\");\n", "\t\t\t\t\tstrcat(file, a->word);\n", "\t\t\t\t\tif(Executable(file)){\n", "\t\t\t\t\t\tpfmt(out, \"%s\\n\", file);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t\tif(!path && !found){\n", "\t\t\t\t\tpfmt(err, \"%s: not found\\n\", a->word);\n", "\t\t\t\t\tsetstatus(\"not found\");\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\tpoplist();\n", "\tflush(err);\n", "}"]}, {"ghidra": ["\n", "int exitnext(void)\n", "\n", "{\n", "  code *pcVar1;\n", "  code **ppcVar2;\n", "  \n", "  ppcVar2 = (code **)(runq->code + runq->pc);\n", "  pcVar1 = *ppcVar2;\n", "  while (pcVar1 == Xpopredir) {\n", "    ppcVar2 = ppcVar2 + 1;\n", "    pcVar1 = *ppcVar2;\n", "  }\n", "  return (int)(uint)(pcVar1 == Xexit);\n", "}\n", "\n"], "c": ["int\n", "exitnext(void){\n", "\tunion code *c=&runq->code[runq->pc];\n", "\twhile(c->f==Xpopredir) c++;\n", "\treturn c->f==Xexit;\n", "}"]}, {"ghidra": ["\n", "void p9longjmp(long *buf,int val)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  __longjmp_chk();\n", "}\n", "\n"], "c": ["void\n", "p9longjmp(p9jmp_buf buf, int val)\n", "{\n", "\tsiglongjmp((void*)buf, val);\n", "}"]}, {"ghidra": ["\n", "void p9notejmp(void *x,long *buf,int val)\n", "\n", "{\n", "                    /* WARNING: Subroutine does not return */\n", "  __longjmp_chk(buf,(ulong)(uint)val);\n", "}\n", "\n"], "c": ["void\n", "p9notejmp(void *x, p9jmp_buf buf, int val)\n", "{\n", "\tUSED(x);\n", "\tsiglongjmp((void*)buf, val);\n", "}"]}, {"ghidra": ["\n", "void panic(char *s,int n)\n", "\n", "{\n", "  pfmt(rc_err,\"rc: \");\n", "  pfmt(rc_err,s,(ulong)(uint)n);\n", "  pchr(rc_err,10);\n", "  flush(rc_err);\n", "  Abort();\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "panic(char *s, int n)\n", "{\n", "\tpfmt(err, \"rc: \");\n", "\tpfmt(err, s, n);\n", "\tpchr(err, '\\n');\n", "\tflush(err);\n", "\tAbort();\n", "}"]}, {"ghidra": ["\n", "int Opendir(char *name)\n", "\n", "{\n", "  int fd;\n", "  int iVar1;\n", "  Dir *v;\n", "  \n", "  fd = p9open(name,0);\n", "  iVar1 = -1;\n", "  if (fd != -1) {\n", "    v = dirfstat(fd);\n", "    if ((v == (Dir *)0x0) || ((*(byte *)((long)&v->mode + 3) & 0x80) == 0)) {\n", "      p9free(v);\n", "      close(fd);\n", "      return -1;\n", "    }\n", "    if (fd < 0x32) {\n", "      dir[fd].i = 0;\n", "      dir[fd].n = 0;\n", "    }\n", "    p9free(v);\n", "    iVar1 = fd;\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int Opendir(char *name)\n", "{\n", "\tDir *db;\n", "\tint f;\n", "\tf=open(name, 0);\n", "\tif(f==-1)\n", "\t\treturn f;\n", "\tdb = dirfstat(f);\n", "\tif(db!=nil && (db->mode&DMDIR)){\n", "\t\tif(f<NFD){\n", "\t\t\tdir[f].i=0;\n", "\t\t\tdir[f].n=0;\n", "\t\t}\n", "\t\tfree(db);\n", "\t\treturn f;\n", "\t}\n", "\tfree(db);\n", "\tclose(f);\n", "\treturn -1;\n", "}"]}, {"ghidra": ["\n", "char * unsharp(char *old)\n", "\n", "{\n", "  char \"unsharp\" [8];\n", "  int iVar1;\n", "  size_t sVar2;\n", "  size_t sVar3;\n", "  int iVar4;\n", "  anon_struct_conflict11 *paVar5;\n", "  char *__s;\n", "  char *__s_00;\n", "  long lVar6;\n", "  \n", "  if (replace[0].new == (char *)0x0) {\n", "    replace[0].new = get9root();\n", "  }\n", "  lVar6 = 0;\n", "  paVar5 = replace;\n", "  __s = replace[0].new;\n", "  do {\n", "    if (__s != (char *)0x0) {\n", "      __s_00 = paVar5->old;\n", "      sVar2 = strlen(__s_00);\n", "      iVar4 = (int)sVar2;\n", "      iVar1 = strncmp(old,__s_00,(long)iVar4);\n", "      if (iVar1 == 0) {\n", "        __s_00 = old + (long)iVar4;\n", "        if ((*__s_00 == '/') || (*__s_00 == '\\0')) {\n", "          sVar2 = strlen(__s);\n", "          sVar3 = strlen(old);\n", "          iVar4 = ((int)sVar2 + (int)sVar3) - iVar4;\n", "          __s = (char *)p9malloc((long)(iVar4 + 1));\n", "          if (__s == (char *)0x0) {\n", "            sysfatal(\"out of memory translating %s to %s%s\",old,replace[lVar6].new,__s_00);\n", "          }\n", "          strcpy(__s,replace[lVar6].new);\n", "          strcpy(__s + (int)sVar2,__s_00);\n", "          sVar2 = strlen(__s);\n", "          if (sVar2 == (long)iVar4) {\n", "            return __s;\n", "          }\n", "                    /* WARNING: Subroutine does not return */\n", "          __assert_fail(\"strlen(new) == len\",\"unsharp.c\",0x28,\"unsharp\");\n", "        }\n", "      }\n", "    }\n", "    if ((int)lVar6 == 1) {\n", "      return old;\n", "    }\n", "    __s = paVar5[1].new;\n", "    lVar6 = 1;\n", "    paVar5 = paVar5 + 1;\n", "  } while( true );\n", "}\n", "\n"], "c": ["char*\n", "unsharp(char *old)\n", "{\n", "\tchar *new;\n", "\tint i, olen, nlen, len;\n", "\n", "\tif(replace[0].new == nil)\n", "\t\treplace[0].new = get9root();\n", "\n", "\tfor(i=0; i<nelem(replace); i++){\n", "\t\tif(!replace[i].new)\n", "\t\t\tcontinue;\n", "\t\tolen = strlen(replace[i].old);\n", "\t\tif(strncmp(old, replace[i].old, olen) != 0\n", "\t\t|| (old[olen] != '\\0' && old[olen] != '/'))\n", "\t\t\tcontinue;\n", "\t\tnlen = strlen(replace[i].new);\n", "\t\tlen = strlen(old)+nlen-olen;\n", "\t\tnew = malloc(len+1);\n", "\t\tif(new == nil)\n", "\t\t\t/* Most callers won't check the return value... */\n", "\t\t\tsysfatal(\"out of memory translating %s to %s%s\", old, replace[i].new, old+olen);\n", "\t\tstrcpy(new, replace[i].new);\n", "\t\tstrcpy(new+nlen, old+olen);\n", "\t\tassert(strlen(new) == len);\n", "\t\treturn new;\n", "\t}\n", "\treturn old;\n", "}"]}, {"ghidra": ["\n", "void execfunc(var *func)\n", "\n", "{\n", "  word *pwVar1;\n", "  thread *ptVar2;\n", "  char *name;\n", "  var *next;\n", "  \n", "  popword();\n", "  pwVar1 = runq->argv->words;\n", "  runq->argv->words = (word *)0x0;\n", "  poplist();\n", "  start(func->fn,func->pc,runq->local);\n", "  ptVar2 = runq;\n", "  next = runq->local;\n", "  name = p9strdup(\"*\");\n", "  next = newvar(name,next);\n", "  ptVar2->local = next;\n", "  next = runq->local;\n", "  next->val = pwVar1;\n", "  next->changed = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execfunc(var *func)\n", "{\n", "\tword *starval;\n", "\tpopword();\n", "\tstarval = runq->argv->words;\n", "\trunq->argv->words = 0;\n", "\tpoplist();\n", "\tstart(func->fn, func->pc, runq->local);\n", "\trunq->local = newvar(strdup(\"*\"), runq->local);\n", "\trunq->local->val = starval;\n", "\trunq->local->changed = 1;\n", "}"]}, {"ghidra": ["\n", "char * list2strcolon(word *words)\n", "\n", "{\n", "  char cVar1;\n", "  char *pcVar2;\n", "  size_t sVar3;\n", "  char *pcVar4;\n", "  char *pcVar5;\n", "  word *pwVar6;\n", "  char *pcVar7;\n", "  int iVar8;\n", "  \n", "  if (words == (word *)0x0) {\n", "    pcVar4 = emalloc(1);\n", "    pcVar7 = pcVar4;\n", "  }\n", "  else {\n", "    iVar8 = 0;\n", "    pwVar6 = words;\n", "    do {\n", "      sVar3 = strlen(pwVar6->word);\n", "      pwVar6 = pwVar6->next;\n", "      iVar8 = iVar8 + 1 + (int)sVar3;\n", "    } while (pwVar6 != (word *)0x0);\n", "    pcVar4 = emalloc((long)(iVar8 + 1));\n", "    pcVar7 = pcVar4;\n", "    do {\n", "      pcVar5 = words->word;\n", "      cVar1 = *pcVar5;\n", "      pcVar2 = pcVar7;\n", "      while (cVar1 != '\\0') {\n", "        pcVar5 = pcVar5 + 1;\n", "        *pcVar2 = cVar1;\n", "        cVar1 = *pcVar5;\n", "        pcVar2 = pcVar2 + 1;\n", "      }\n", "      *pcVar2 = ':';\n", "      words = words->next;\n", "      pcVar7 = pcVar2 + 1;\n", "    } while (words != (word *)0x0);\n", "    if (pcVar7 != pcVar4) {\n", "      *pcVar2 = '\\0';\n", "      return pcVar4;\n", "    }\n", "  }\n", "  *pcVar7 = '\\0';\n", "  return pcVar4;\n", "}\n", "\n"], "c": ["char*\n", "list2strcolon(word *words)\n", "{\n", "\tchar *value, *s, *t;\n", "\tint len = 0;\n", "\tword *ap;\n", "\tfor(ap = words;ap;ap = ap->next)\n", "\t\tlen+=1+strlen(ap->word);\n", "\tvalue = emalloc(len+1);\n", "\ts = value;\n", "\tfor(ap = words;ap;ap = ap->next){\n", "\t\tfor(t = ap->word;*t;) *s++=*t++;\n", "\t\t*s++=':';\n", "\t}\n", "\tif(s==value)\n", "\t\t*s='\\0';\n", "\telse s[-1]='\\0';\n", "\treturn value;\n", "}"]}, {"ghidra": ["\n", "void psubst(io *f,char *s)\n", "\n", "{\n", "  byte *name;\n", "  byte bVar1;\n", "  word *w;\n", "  byte *pbVar2;\n", "  int iVar3;\n", "  var *pvVar4;\n", "  byte *pbVar5;\n", "  byte bVar6;\n", "  int c;\n", "  int iVar7;\n", "  \n", "  bVar6 = *s;\n", "  do {\n", "    while( true ) {\n", "      if (bVar6 == 0) {\n", "        return;\n", "      }\n", "      if (bVar6 != 0x24) break;\n", "      bVar6 = ((byte *)s)[1];\n", "      name = (byte *)s + 1;\n", "      pbVar2 = name;\n", "      if (bVar6 == 0x24) {\n", "        pchr(f,0x24);\n", "        bVar6 = ((byte *)s)[2];\n", "        s = (char *)((byte *)s + 2);\n", "      }\n", "      else {\n", "        while (bVar6 != 0) {\n", "          c = idchr((int)(char)bVar6);\n", "          if (c == 0) {\n", "            bVar6 = *pbVar2;\n", "            break;\n", "          }\n", "          bVar6 = pbVar2[1];\n", "          pbVar2 = pbVar2 + 1;\n", "        }\n", "        *pbVar2 = 0;\n", "        bVar1 = ((byte *)s)[1];\n", "        if ((byte)(bVar1 - 0x30) < 10) {\n", "          c = 0;\n", "          pbVar5 = name;\n", "          do {\n", "            pbVar5 = pbVar5 + 1;\n", "            iVar7 = (int)(char)bVar1 + c * 10;\n", "            bVar1 = *pbVar5;\n", "            c = iVar7 + -0x30;\n", "          } while ((byte)(bVar1 - 0x30) < 10);\n", "          if ((c == 0) || (bVar1 != 0)) goto LAB_00407937;\n", "          pvVar4 = vlook(\"*\");\n", "          w = pvVar4->val;\n", "          if ((w != (word *)0x0) && (iVar3 = count(w), c <= iVar3)) {\n", "            iVar7 = iVar7 + -0x31;\n", "            while (iVar7 != 0) {\n", "              iVar7 = iVar7 + -1;\n", "              w = w->next;\n", "            }\n", "            pstr(f,w->word);\n", "          }\n", "        }\n", "        else {\n", "LAB_00407937:\n", "          pvVar4 = vlook((char *)name);\n", "          pstrs(f,pvVar4->val);\n", "        }\n", "        *pbVar2 = bVar6;\n", "        s = (char *)pbVar2;\n", "        if (bVar6 == 0x5e) {\n", "          bVar6 = pbVar2[1];\n", "          s = (char *)(pbVar2 + 1);\n", "        }\n", "      }\n", "    }\n", "    c = (int)(char)bVar6;\n", "    if ((uint)bVar6 - 0xa0 < 0x56) {\n", "      pchr(f,c);\n", "      bVar6 = ((byte *)s)[1];\n", "      s = (char *)((byte *)s + 1);\n", "      if (bVar6 == 0) {\n", "        return;\n", "      }\n", "LAB_00407988:\n", "      c = (int)(char)bVar6;\n", "    }\n", "    else {\n", "      if ((uint)bVar6 - 0xf6 < 2) {\n", "        pchr(f,c);\n", "        if (((byte *)s)[1] == 0) {\n", "          return;\n", "        }\n", "        pchr(f,(int)(char)((byte *)s)[1]);\n", "        bVar6 = ((byte *)s)[2];\n", "        s = (char *)((byte *)s + 2);\n", "        if (bVar6 == 0) {\n", "          return;\n", "        }\n", "        goto LAB_00407988;\n", "      }\n", "    }\n", "    pchr(f,c);\n", "    bVar6 = ((byte *)s)[1];\n", "    s = (char *)((byte *)s + 1);\n", "  } while( true );\n", "}\n", "\n"], "c": ["void\n", "psubst(io *f, char *s)\n", "{\n", "\tchar *t, *u;\n", "\tint savec, n;\n", "\tword *star;\n", "\twhile(*s){\n", "\t\tif(*s!='$'){\n", "\t\t\tif(0xa0<=(*s&0xff) && (*s&0xff)<=0xf5){\n", "\t\t\t\tpchr(f, *s++);\n", "\t\t\t\tif(*s=='\\0')\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\telse if(0xf6<=(*s&0xff) && (*s&0xff)<=0xf7){\n", "\t\t\t\tpchr(f, *s++);\n", "\t\t\t\tif(*s=='\\0')\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tpchr(f, *s++);\n", "\t\t\t\tif(*s=='\\0')\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tpchr(f, *s++);\n", "\t\t}\n", "\t\telse{\n", "\t\t\tt=++s;\n", "\t\t\tif(*t=='$')\n", "\t\t\t\tpchr(f, *t++);\n", "\t\t\telse{\n", "\t\t\t\twhile(*t && idchr(*t)) t++;\n", "\t\t\t\tsavec=*t;\n", "\t\t\t\t*t='\\0';\n", "\t\t\t\tn = 0;\n", "\t\t\t\tfor(u = s;*u && '0'<=*u && *u<='9';u++) n = n*10+*u-'0';\n", "\t\t\t\tif(n && *u=='\\0'){\n", "\t\t\t\t\tstar = vlook(\"*\")->val;\n", "\t\t\t\t\tif(star && 1<=n && n<=count(star)){\n", "\t\t\t\t\t\twhile(--n) star = star->next;\n", "\t\t\t\t\t\tpstr(f, star->word);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t\telse\n", "\t\t\t\t\tpstrs(f, vlook(s)->val);\n", "\t\t\t\t*t = savec;\n", "\t\t\t\tif(savec=='^')\n", "\t\t\t\t\tt++;\n", "\t\t\t}\n", "\t\t\ts = t;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "char * nextutf(char *p)\n", "\n", "{\n", "  if (((int)*p & 0xe0U) == 0xc0) {\n", "    if (p[1] != '\\0') goto LAB_0040706e;\n", "  }\n", "  else {\n", "    if ((((int)*p & 0xf0U) == 0xe0) && (p[1] != '\\0')) {\n", "      if (p[2] != '\\0') {\n", "        return p + 3;\n", "      }\n", "LAB_0040706e:\n", "      return p + 2;\n", "    }\n", "  }\n", "  return p + 1;\n", "}\n", "\n"], "c": ["char*\n", "nextutf(char *p)\n", "{\n", "\tif(twobyte(*p)) return p[1]=='\\0'?p+1:p+2;\n", "\tif(threebyte(*p)) return p[1]=='\\0'?p+1:p[2]=='\\0'?p+2:p+3;\n", "\treturn p+1;\n", "}"]}, {"ghidra": ["\n", "void globdir(char *p,char *namep)\n", "\n", "{\n", "  char cVar1;\n", "  int f;\n", "  int iVar2;\n", "  char *p_00;\n", "  char *name;\n", "  char *p_01;\n", "  bool bVar3;\n", "  \n", "  cVar1 = *p;\n", "  p_00 = namep;\n", "  p_01 = p;\n", "  if (cVar1 != '\\0') {\n", "    do {\n", "      if (cVar1 == '\\x01') {\n", "        *p_00 = '\\0';\n", "        name = globname;\n", "        if (*globname == '\\0') {\n", "          name = \".\";\n", "        }\n", "        f = Opendir(name);\n", "        if (f < 0) {\n", "          return;\n", "        }\n", "        while ((cVar1 = *p, cVar1 != '\\0' && (cVar1 != '/'))) {\n", "          p = p + 1;\n", "        }\n", "        while (iVar2 = Readdir(f,p_00,(uint)(cVar1 == '/')), iVar2 != 0) {\n", "          iVar2 = matchfn(p_00,p_01);\n", "          if (iVar2 != 0) {\n", "            cVar1 = *p_00;\n", "            name = p_00;\n", "            while (cVar1 != '\\0') {\n", "              name = name + 1;\n", "              cVar1 = *name;\n", "            }\n", "            globdir(p,name);\n", "          }\n", "          cVar1 = *p;\n", "        }\n", "        Closedir(f);\n", "        return;\n", "      }\n", "      p = p + 1;\n", "      *namep = cVar1;\n", "      namep = namep + 1;\n", "      bVar3 = cVar1 == '/';\n", "      cVar1 = *p;\n", "      if (bVar3) {\n", "        p_01 = p;\n", "        p_00 = namep;\n", "      }\n", "    } while (cVar1 != '\\0');\n", "    *namep = '\\0';\n", "    f = access(globname,0);\n", "    if (f != 0) {\n", "      return;\n", "    }\n", "  }\n", "  globv = newword(globname,globv);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "globdir(char *p, char *namep)\n", "{\n", "\tchar *t, *newp;\n", "\tint f;\n", "\t/* scan the pattern looking for a component with a metacharacter in it */\n", "\tif(*p=='\\0'){\n", "\t\tglobv = newword(globname, globv);\n", "\t\treturn;\n", "\t}\n", "\tt = namep;\n", "\tnewp = p;\n", "\twhile(*newp){\n", "\t\tif(*newp==GLOB)\n", "\t\t\tbreak;\n", "\t\t*t=*newp++;\n", "\t\tif(*t++=='/'){\n", "\t\t\tnamep = t;\n", "\t\t\tp = newp;\n", "\t\t}\n", "\t}\n", "\t/* If we ran out of pattern, append the name if accessible */\n", "\tif(*newp=='\\0'){\n", "\t\t*t='\\0';\n", "\t\tif(access(globname, 0)==0)\n", "\t\t\tglobv = newword(globname, globv);\n", "\t\treturn;\n", "\t}\n", "\t/* read the directory and recur for any entry that matches */\n", "\t*namep='\\0';\n", "\tif((f = Opendir(globname[0]?globname:\".\"))<0) return;\n", "\twhile(*newp!='/' && *newp!='\\0') newp++;\n", "\twhile(Readdir(f, namep, *newp=='/')){\n", "\t\tif(matchfn(namep, p)){\n", "\t\t\tfor(t = namep;*t;t++);\n", "\t\t\tglobdir(newp, t);\n", "\t\t}\n", "\t}\n", "\tClosedir(f);\n", "}"]}, {"ghidra": ["\n", "void execdot(void)\n", "\n", "{\n", "  long lVar1;\n", "  list *p;\n", "  thread *ptVar2;\n", "  thread *ptVar3;\n", "  int first;\n", "  int from;\n", "  byte *s;\n", "  char *w;\n", "  word *pwVar4;\n", "  undefined2 *puVar5;\n", "  io *piVar6;\n", "  long lVar7;\n", "  byte *pbVar8;\n", "  char *pcVar9;\n", "  byte *pbVar10;\n", "  char *pcVar11;\n", "  int iVar12;\n", "  long in_FS_OFFSET;\n", "  bool bVar13;\n", "  bool bVar14;\n", "  byte bVar15;\n", "  char file [512];\n", "  \n", "  ptVar2 = runq;\n", "  bVar15 = 0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (first == 0) {\n", "    eflagok = 1;\n", "  }\n", "  else {\n", "    dotcmds[0]._0_4_ = 1;\n", "    dotcmds[1] = Xmark;\n", "    dotcmds[2] = Xword;\n", "    dotcmds[3] = &DAT_00415ddc;\n", "    dotcmds[4] = Xlocal;\n", "    dotcmds[5] = Xmark;\n", "    dotcmds[6] = Xword;\n", "    dotcmds[7] = &DAT_0041568e;\n", "    dotcmds[8] = Xlocal;\n", "    dotcmds[9] = Xrdcmds;\n", "    dotcmds[10] = Xunlocal;\n", "    dotcmds[11] = Xunlocal;\n", "    dotcmds[12] = Xreturn;\n", "    first = 0;\n", "  }\n", "  popword();\n", "  pwVar4 = ptVar2->argv->words;\n", "  bVar13 = false;\n", "  bVar14 = pwVar4 == (word *)0x0;\n", "  if (bVar14) {\n", "LAB_0040a650:\n", "    Xerror1(\"Usage: . [-i] file [arg ...]\");\n", "  }\n", "  else {\n", "    s = (byte *)pwVar4->word;\n", "    lVar7 = 3;\n", "    pbVar8 = s;\n", "    pbVar10 = &DAT_00415dfb;\n", "    do {\n", "      if (lVar7 == 0) break;\n", "      lVar7 = lVar7 + -1;\n", "      bVar13 = *pbVar8 < *pbVar10;\n", "      bVar14 = *pbVar8 == *pbVar10;\n", "      pbVar8 = pbVar8 + (ulong)bVar15 * -2 + 1;\n", "      pbVar10 = pbVar10 + (ulong)bVar15 * -2 + 1;\n", "    } while (bVar14);\n", "    iVar12 = 0;\n", "    if ((!bVar13 && !bVar14) == bVar13) {\n", "      popword();\n", "      pwVar4 = ptVar2->argv->words;\n", "      if (pwVar4 == (word *)0x0) goto LAB_0040a650;\n", "      s = (byte *)pwVar4->word;\n", "      iVar12 = 1;\n", "    }\n", "    w = p9strdup((char *)s);\n", "    popword();\n", "    pwVar4 = rcsearchpath(w);\n", "    if (pwVar4 != (word *)0x0) {\n", "      do {\n", "        puVar5 = (undefined2 *)__stpcpy_chk(file,pwVar4->word,0x200);\n", "        if (file[0] != '\\0') {\n", "          *puVar5 = 0x2f;\n", "        }\n", "        __strcat_chk(file,w,0x200);\n", "        from = p9open(file,0);\n", "        bVar13 = from == 0;\n", "        if (-1 < from) {\n", "LAB_0040a52b:\n", "          start(dotcmds,1,(var *)0x0);\n", "          pushredir(3,from,0);\n", "          ptVar3 = runq;\n", "          runq->cmdfile = w;\n", "          piVar6 = openfd(from);\n", "          ptVar3->cmdfd = piVar6;\n", "          ptVar3 = runq;\n", "          runq->iflag = iVar12;\n", "          ptVar3->iflast = 0;\n", "          pushlist();\n", "          p = ptVar2->argv;\n", "          runq->argv->words = p->words;\n", "          ptVar2->argv = p->next;\n", "          efree((char *)p);\n", "          pushlist();\n", "          pushword(w);\n", "          ndot = ndot + 1;\n", "          goto LAB_0040a5b9;\n", "        }\n", "        lVar7 = 0xb;\n", "        pcVar9 = file;\n", "        pcVar11 = \"/dev/stdin\";\n", "        do {\n", "          if (lVar7 == 0) break;\n", "          lVar7 = lVar7 + -1;\n", "          bVar13 = *pcVar9 == *pcVar11;\n", "          pcVar9 = pcVar9 + (ulong)bVar15 * -2 + 1;\n", "          pcVar11 = pcVar11 + (ulong)bVar15 * -2 + 1;\n", "        } while (bVar13);\n", "        if (bVar13) {\n", "          from = Dup1(0);\n", "          if (-1 < from) goto LAB_0040a52b;\n", "        }\n", "        pwVar4 = pwVar4->next;\n", "      } while (pwVar4 != (word *)0x0);\n", "    }\n", "    pfmt(rc_err,\"%s: \",w);\n", "    setstatus(\"can\\'t open\");\n", "    Xerror(\".: can\\'t open\");\n", "  }\n", "LAB_0040a5b9:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "execdot(void)\n", "{\n", "\tint iflag = 0;\n", "\tint fd;\n", "\tlist *av;\n", "\tthread *p = runq;\n", "\tchar *zero;\n", "\tstatic int first = 1;\n", "\tchar file[512];\n", "\tword *path;\n", "\tif(first){\n", "\t\tdotcmds[0].i = 1;\n", "\t\tdotcmds[1].f = Xmark;\n", "\t\tdotcmds[2].f = Xword;\n", "\t\tdotcmds[3].s=\"0\";\n", "\t\tdotcmds[4].f = Xlocal;\n", "\t\tdotcmds[5].f = Xmark;\n", "\t\tdotcmds[6].f = Xword;\n", "\t\tdotcmds[7].s=\"*\";\n", "\t\tdotcmds[8].f = Xlocal;\n", "\t\tdotcmds[9].f = Xrdcmds;\n", "\t\tdotcmds[10].f = Xunlocal;\n", "\t\tdotcmds[11].f = Xunlocal;\n", "\t\tdotcmds[12].f = Xreturn;\n", "\t\tfirst = 0;\n", "\t}\n", "\telse\n", "\t\teflagok = 1;\n", "\tpopword();\n", "\tif(p->argv->words && strcmp(p->argv->words->word, \"-i\")==0){\n", "\t\tiflag = 1;\n", "\t\tpopword();\n", "\t}\n", "\t/* get input file */\n", "\tif(p->argv->words==0){\n", "\t\tXerror1(\"Usage: . [-i] file [arg ...]\");\n", "\t\treturn;\n", "\t}\n", "\tzero = strdup(p->argv->words->word);\n", "\tpopword();\n", "\tfd=-1;\n", "\tfor(path = searchpath(zero);path;path = path->next){\n", "\t\tstrcpy(file, path->word);\n", "\t\tif(file[0])\n", "\t\t\tstrcat(file, \"/\");\n", "\t\tstrcat(file, zero);\n", "\t\tif((fd = open(file, 0))>=0) break;\n", "\t\tif(strcmp(file, \"/dev/stdin\")==0){\t/* for sun & ucb */\n", "\t\t\tfd = Dup1(0);\n", "\t\t\tif(fd>=0)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\tif(fd<0){\n", "\t\tpfmt(err, \"%s: \", zero);\n", "\t\tsetstatus(\"can't open\");\n", "\t\tXerror(\".: can't open\");\n", "\t\treturn;\n", "\t}\n", "\t/* set up for a new command loop */\n", "\tstart(dotcmds, 1, (struct var *)0);\n", "\tpushredir(RCLOSE, fd, 0);\n", "\trunq->cmdfile = zero;\n", "\trunq->cmdfd = openfd(fd);\n", "\trunq->iflag = iflag;\n", "\trunq->iflast = 0;\n", "\t/* push $* value */\n", "\tpushlist();\n", "\trunq->argv->words = p->argv->words;\n", "\t/* free caller's copy of $* */\n", "\tav = p->argv;\n", "\tp->argv = av->next;\n", "\tefree((char *)av);\n", "\t/* push $0 value */\n", "\tpushlist();\n", "\tpushword(zero);\n", "\tndot++;\n", "}"]}, {"ghidra": ["\n", "int nextc(void)\n", "\n", "{\n", "  if (future != -1) {\n", "    return future;\n", "  }\n", "  future = getnext();\n", "  return future;\n", "}\n", "\n"], "c": ["int\n", "nextc(void)\n", "{\n", "\tif(future==EOF)\n", "\t\tfuture = getnext();\n", "\treturn future;\n", "}"]}, {"ghidra": ["\n", "void glob(char *p)\n", "\n", "{\n", "  word *right;\n", "  int iVar1;\n", "  char *pcVar2;\n", "  char cVar3;\n", "  char *pcVar4;\n", "  char *pcVar5;\n", "  \n", "  right = globv;\n", "  iVar1 = Globsize(p);\n", "  pcVar4 = p;\n", "  pcVar5 = p;\n", "  if (iVar1 == 0) {\n", "    do {\n", "      while (*pcVar4 != '\\x01') {\n", "        *pcVar5 = *pcVar4;\n", "        cVar3 = *pcVar4;\n", "        pcVar4 = pcVar4 + 1;\n", "        pcVar5 = pcVar5 + 1;\n", "        if (cVar3 == '\\0') goto LAB_004074eb;\n", "      }\n", "      pcVar2 = pcVar4 + 1;\n", "      *pcVar5 = pcVar4[1];\n", "      pcVar4 = pcVar4 + 2;\n", "      pcVar5 = pcVar5 + 1;\n", "    } while (*pcVar2 != '\\0');\n", "  }\n", "  else {\n", "    globname = emalloc((long)iVar1);\n", "    *globname = '\\0';\n", "    globdir(p,globname);\n", "    efree(globname);\n", "    if (right != globv) {\n", "      globsort(globv,right);\n", "      return;\n", "    }\n", "    do {\n", "      cVar3 = *pcVar4;\n", "      pcVar2 = pcVar4;\n", "      if (cVar3 == '\\x01') {\n", "        pcVar2 = pcVar4 + 1;\n", "        cVar3 = pcVar4[1];\n", "      }\n", "      *pcVar5 = cVar3;\n", "      pcVar4 = pcVar2 + 1;\n", "      pcVar5 = pcVar5 + 1;\n", "    } while (*pcVar2 != '\\0');\n", "  }\n", "LAB_004074eb:\n", "  globv = newword(p,globv);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "glob(char *p)\n", "{\n", "\tword *svglobv = globv;\n", "\tint globlen = Globsize(p);\n", "\tif(!globlen){\n", "\t\tdeglob(p);\n", "\t\tglobv = newword(p, globv);\n", "\t\treturn;\n", "\t}\n", "\tglobname = emalloc(globlen);\n", "\tglobname[0]='\\0';\n", "\tglobdir(p, globname);\n", "\tefree(globname);\n", "\tif(svglobv==globv){\n", "\t\tdeglob(p);\n", "\t\tglobv = newword(p, globv);\n", "\t}\n", "\telse\n", "\t\tglobsort(globv, svglobv);\n", "}"]}, {"ghidra": ["\n", "void Xsubshell(void)\n", "\n", "{\n", "  __pid_t pid;\n", "  \n", "  pid = fork();\n", "  if (pid == -1) {\n", "    Xerror(\"try again\");\n", "    return;\n", "  }\n", "  if (pid != 0) {\n", "    addwaitpid(pid);\n", "    Waitfor(pid,1);\n", "    runq->pc = *(int *)(runq->code + runq->pc);\n", "    return;\n", "  }\n", "  clearwaitpids();\n", "  start(runq->code,runq->pc + 1,runq->local);\n", "  runq->ret = (thread *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "Xsubshell(void)\n", "{\n", "\tint pid;\n", "\tswitch(pid = fork()){\n", "\tcase -1:\n", "\t\tXerror(\"try again\");\n", "\t\tbreak;\n", "\tcase 0:\n", "\t\tclearwaitpids();\n", "\t\tstart(runq->code, runq->pc+1, runq->local);\n", "\t\trunq->ret = 0;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\taddwaitpid(pid);\n", "\t\tWaitfor(pid, 1);\n", "\t\trunq->pc = runq->code[runq->pc].i;\n", "\t\tbreak;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void pwrd(io *f,char *s)\n", "\n", "{\n", "  char cVar1;\n", "  int iVar2;\n", "  char *pcVar3;\n", "  \n", "  cVar1 = *s;\n", "  pcVar3 = s;\n", "  if (cVar1 != '\\0') {\n", "    do {\n", "      iVar2 = wordchr((int)cVar1);\n", "      if (iVar2 == 0) {\n", "        if ((s == pcVar3) || (*pcVar3 != '\\0')) goto LAB_004083a8;\n", "        goto LAB_00408391;\n", "      }\n", "      pcVar3 = pcVar3 + 1;\n", "      cVar1 = *pcVar3;\n", "    } while (cVar1 != '\\0');\n", "    if (s != pcVar3) {\n", "LAB_00408391:\n", "      pstr(f,s);\n", "      return;\n", "    }\n", "  }\n", "LAB_004083a8:\n", "  pquo(f,s);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pwrd(io *f, char *s)\n", "{\n", "\tchar *t;\n", "\tfor(t = s;*t;t++) if(!wordchr(*t)) break;\n", "\tif(t==s || *t)\n", "\t\tpquo(f, s);\n", "\telse pstr(f, s);\n", "}"]}, {"ghidra": ["\n", "int iscase(tree *t)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  if (t->type != 0xe011) {\n", "    return 0;\n", "  }\n", "  iVar1 = iscase(t);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "iscase(tree *t)\n", "{\n", "\tif(t->type!=SIMPLE)\n", "\t\treturn 0;\n", "\tdo t = c0; while(t->type==ARGLIST);\n", "\treturn t->type==WORD && !t->quoted && strcmp(t->str, \"case\")==0;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Unknown calling convention yet parameter storage is locked */\n", "\n", "__off64_t Seek(int __fd,__off64_t __offset,int __whence)\n", "\n", "{\n", "  __off64_t _Var1;\n", "  \n", "  _Var1 = lseek64(__fd,__offset,__whence);\n", "  return _Var1;\n", "}\n", "\n"], "c": ["vlong\n", "seek(int fd, vlong offset, int whence)\n", "{\n", "\treturn lseek(fd, offset, whence);\n", "}"]}, {"ghidra": ["\n", "void Xrdfn(void)\n", "\n", "{\n", "  char *__s;\n", "  char *pcVar1;\n", "  size_t sVar2;\n", "  io *f;\n", "  long lVar3;\n", "  char **ppcVar4;\n", "  char *pcVar5;\n", "  bool bVar6;\n", "  byte bVar7;\n", "  \n", "  bVar7 = 0;\n", "  __s = *envp;\n", "  do {\n", "    bVar6 = __s == (char *)0x0;\n", "    if (bVar6) {\n", "      Xreturn();\n", "      return;\n", "    }\n", "    ppcVar4 = envp + 1;\n", "    lVar3 = 3;\n", "    pcVar1 = __s;\n", "    pcVar5 = \"fn#\";\n", "    do {\n", "      if (lVar3 == 0) break;\n", "      lVar3 = lVar3 + -1;\n", "      bVar6 = *pcVar1 == *pcVar5;\n", "      pcVar1 = pcVar1 + (ulong)bVar7 * -2 + 1;\n", "      pcVar5 = pcVar5 + (ulong)bVar7 * -2 + 1;\n", "    } while (bVar6);\n", "    if ((bVar6) && (pcVar1 = strchr(__s,0x3d), pcVar1 != (char *)0x0)) {\n", "      *pcVar1 = ' ';\n", "      __s[2] = ' ';\n", "      sVar2 = strlen(__s);\n", "      f = opencore(__s,(int)sVar2);\n", "      execcmds(f);\n", "      __s[(int)sVar2] = '\\0';\n", "      return;\n", "    }\n", "    __s = *ppcVar4;\n", "    envp = ppcVar4;\n", "  } while( true );\n", "}\n", "\n"], "c": ["void Xrdfn(void){\n", "\tchar *p;\n", "\tregister char *s;\n", "\tregister int len;\n", "\tfor(;*envp;envp++){\n", "\t\ts = *envp;\n", "\t\tif(strncmp(s, \"fn#\", 3) == 0){\n", "\t\t\tp = strchr(s, '=');\n", "\t\t\tif(p == nil)\n", "\t\t\t\tcontinue;\n", "\t\t\t*p = ' ';\n", "\t\t\ts[2] = ' ';\n", "\t\t\tlen = strlen(s);\n", "\t\t\texeccmds(opencore(s, len));\n", "\t\t\ts[len] = '\\0';\n", "\t\t\treturn;\n", "\t\t}\n", "#if 0\n", "\t\tfor(s=*envp;*s && *s!='(' && *s!='=';s++);\n", "\t\tswitch(*s){\n", "\t\tcase '\\0':\n", "\t\t\tpfmt(err, \"environment %q?\\n\", *envp);\n", "\t\t\tbreak;\n", "\t\tcase '=':\t/* ignore variables */\n", "\t\t\tbreak;\n", "\t\tcase '(':\t\t/* Bourne again */\n", "\t\t\ts=*envp+3;\n", "\t\t\tenvp++;\n", "\t\t\tlen=strlen(s);\n", "\t\t\ts[len]='\\n';\n", "\t\t\texeccmds(opencore(s, len+1));\n", "\t\t\ts[len]='\\0';\n", "\t\t\treturn;\n", "\t\t}\n", "#endif\n", "\t}\n", "\tXreturn();\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "void execulimit(void)\n", "\n", "{\n", "  char *pcVar1;\n", "  long lVar2;\n", "  int iVar3;\n", "  int fd;\n", "  char **v;\n", "  byte *__nptr;\n", "  char *pcVar4;\n", "  ulong uVar5;\n", "  rlim_t rVar6;\n", "  long lVar7;\n", "  byte bVar8;\n", "  int fd_00;\n", "  undefined8 *puVar9;\n", "  byte *pbVar10;\n", "  byte **ppbVar11;\n", "  byte *str;\n", "  long in_FS_OFFSET;\n", "  bool bVar12;\n", "  bool bVar13;\n", "  bool bVar14;\n", "  bool bVar15;\n", "  byte bVar16;\n", "  char *p;\n", "  rlimit rl;\n", "  int flag [256];\n", "  long local_40;\n", "  \n", "  bVar16 = 0;\n", "  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n", "  setstatus(\"\");\n", "  v = mkargv(runq->argv->words);\n", "  if (v[1] != (char *)0x0) {\n", "    lVar7 = 0;\n", "    do {\n", "      fd_00 = (int)lVar7;\n", "      lVar2 = lVar7 + 2;\n", "      lVar7 = lVar7 + 1;\n", "    } while (v[lVar2] != (char *)0x0);\n", "    lVar7 = 0x80;\n", "    ppbVar11 = (byte **)(v + 2);\n", "    puVar9 = (undefined8 *)flag;\n", "    while (lVar7 != 0) {\n", "      lVar7 = lVar7 + -1;\n", "      *puVar9 = 0;\n", "      puVar9 = puVar9 + (ulong)bVar16 * 0x1ffffffffffffffe + 1;\n", "    }\n", "    __fixargv0();\n", "    __nptr = (byte *)v[2];\n", "    goto joined_r0x0040b238;\n", "  }\n", "  lVar7 = 0x80;\n", "  ppbVar11 = (byte **)(v + 2);\n", "  puVar9 = (undefined8 *)flag;\n", "  while (lVar7 != 0) {\n", "    lVar7 = lVar7 + -1;\n", "    *puVar9 = 0;\n", "    puVar9 = puVar9 + (ulong)bVar16 * 0x1ffffffffffffffe + 1;\n", "  }\n", "  __fixargv0();\n", "  __nptr = (byte *)v[2];\n", "  if (__nptr == (byte *)0x0) {\n", "    flag[72] = 0;\n", "    iVar3 = -1;\n", "    fd_00 = mapfd(1);\n", "LAB_0040b4c3:\n", "    bVar15 = flag[72] == 0;\n", "    bVar13 = true;\n", "LAB_0040b3dc:\n", "    bVar12 = iVar3 == 0;\n", "    bVar14 = iVar3 == 1;\n", "    if (bVar14) {\n", "      __nptr = *ppbVar11;\n", "      lVar7 = 10;\n", "      str = __nptr;\n", "      pbVar10 = (byte *)\"unlimited\";\n", "      do {\n", "        if (lVar7 == 0) break;\n", "        lVar7 = lVar7 + -1;\n", "        bVar12 = *str < *pbVar10;\n", "        bVar14 = *str == *pbVar10;\n", "        str = str + (ulong)bVar16 * -2 + 1;\n", "        pbVar10 = pbVar10 + (ulong)bVar16 * -2 + 1;\n", "      } while (bVar14);\n", "      if (bVar14) {\n", "        iVar3 = -3;\n", "      }\n", "      else {\n", "        lVar7 = 5;\n", "        str = __nptr;\n", "        pbVar10 = &DAT_00415f22;\n", "        do {\n", "          if (lVar7 == 0) break;\n", "          lVar7 = lVar7 + -1;\n", "          bVar12 = *str < *pbVar10;\n", "          bVar14 = *str == *pbVar10;\n", "          str = str + (ulong)bVar16 * -2 + 1;\n", "          pbVar10 = pbVar10 + (ulong)bVar16 * -2 + 1;\n", "        } while (bVar14);\n", "        if (bVar14) {\n", "          iVar3 = -2;\n", "        }\n", "        else {\n", "          lVar7 = 5;\n", "          str = __nptr;\n", "          pbVar10 = &DAT_00415f27;\n", "          do {\n", "            if (lVar7 == 0) break;\n", "            lVar7 = lVar7 + -1;\n", "            bVar12 = *str < *pbVar10;\n", "            bVar14 = *str == *pbVar10;\n", "            str = str + (ulong)bVar16 * -2 + 1;\n", "            pbVar10 = pbVar10 + (ulong)bVar16 * -2 + 1;\n", "          } while (bVar14);\n", "          iVar3 = -1;\n", "          if ((!bVar12 && !bVar14) != bVar12) {\n", "            lVar7 = strtol((char *)__nptr,&p,0);\n", "            iVar3 = (int)lVar7;\n", "            if ((iVar3 < 0) || (*p != '\\0')) goto LAB_0040b2fd;\n", "          }\n", "        }\n", "      }\n", "    }\n", "    else {\n", "      iVar3 = -4;\n", "    }\n", "    if (flag[97] == 0) {\n", "      p = \"cdflmnstuv\";\n", "      uVar5 = 99;\n", "      do {\n", "        if (flag[uVar5] != 0) {\n", "          getrlimit64(rlx[(long)(p + -0x415f0d)],(rlimit64 *)&rl);\n", "          if (iVar3 == -3) {\n", "            rVar6 = 0xffffffffffffffff;\n", "          }\n", "          else {\n", "            if (iVar3 < -2) {\n", "              if (iVar3 == -4) {\n", "                if (flag[72] != 0) {\n", "                  rl.rlim_cur._0_4_ = (int)rl.rlim_max;\n", "                }\n", "                if ((int)rl.rlim_cur == -1) {\n", "                  fprint(fd_00,\"ulimit -%c unlimited\\n\",(ulong)(uint)(int)*p);\n", "                }\n", "                else {\n", "                  fprint(fd_00,\"ulimit -%c %d\\n\",(ulong)(uint)(int)*p);\n", "                }\n", "                goto LAB_0040b518;\n", "              }\n", "LAB_0040b614:\n", "              rVar6 = SEXT48(iVar3);\n", "            }\n", "            else {\n", "              if (iVar3 == -2) {\n", "                rVar6 = SEXT48((int)rl.rlim_max);\n", "              }\n", "              else {\n", "                if (iVar3 != -1) goto LAB_0040b614;\n", "                rVar6 = SEXT48((int)rl.rlim_cur);\n", "              }\n", "            }\n", "          }\n", "          if (bVar15) {\n", "            rl.rlim_cur = SEXT48((int)rVar6);\n", "          }\n", "          if (bVar13) {\n", "            rl.rlim_max = rVar6;\n", "          }\n", "          fd = setrlimit64(rlx[(long)(p + -0x415f0d)],(rlimit64 *)&rl);\n", "          if (fd < 0) {\n", "            fd = mapfd(2);\n", "            fprint(fd,\"setrlimit: %r\\n\");\n", "          }\n", "        }\n", "LAB_0040b518:\n", "        pcVar4 = p + 1;\n", "        __nptr = (byte *)(p + 1);\n", "        uVar5 = (ulong)*__nptr;\n", "        p = pcVar4;\n", "      } while (*__nptr != 0);\n", "    }\n", "    else {\n", "      p = \"cdflmnstuv\";\n", "      do {\n", "        getrlimit64(rlx[(long)(p + -0x415f0d)],(rlimit64 *)&rl);\n", "        if (flag[72] == 0) {\n", "        }\n", "        else {\n", "          rl.rlim_cur._0_4_ = (int)rl.rlim_max;\n", "        }\n", "        if ((int)rl.rlim_cur == -1) {\n", "          fprint(fd_00,\"ulimit -%c unlimited\\n\",(ulong)(uint)(int)*p);\n", "        }\n", "        else {\n", "          fprint(fd_00,\"ulimit -%c %d\\n\",(ulong)(uint)(int)*p);\n", "        }\n", "        pcVar4 = p + 1;\n", "        pcVar1 = p + 1;\n", "        p = pcVar4;\n", "      } while (*pcVar1 != '\\0');\n", "    }\n", "  }\n", "  else {\n", "    iVar3 = -1;\n", "    fd_00 = -1;\n", "    if ((*__nptr != 0x2d) || (bVar8 = __nptr[1], bVar8 == 0)) {\n", "LAB_0040b3a4:\n", "      fd_00 = mapfd(1);\n", "      if (flag[83] == 0) goto LAB_0040b4c3;\n", "      bVar13 = flag[72] != 0;\n", "      bVar15 = true;\n", "      goto LAB_0040b3dc;\n", "    }\n", "    while ((str = __nptr + 1, bVar8 != 0x2d || (__nptr[2] != 0))) {\n", "      rl.rlim_cur = rl.rlim_cur & 0xffffffffffff0000;\n", "      bVar8 = __nptr[1];\n", "      while (bVar8 != 0) {\n", "        iVar3 = chartorune((Rune *)&rl,(char *)str);\n", "        str = str + iVar3;\n", "        if (str == (byte *)0x0) break;\n", "        if (((0x19 < (ushort)((uint)(ushort)rl.rlim_cur - 0x48)) ||\n", "            ((1 << ((byte)((uint)(ushort)rl.rlim_cur - 0x48) & 0x3f) & 0x2000801U) == 0)) &&\n", "           (pcVar4 = strchr(\"cdflmnstuv\",(uint)(ushort)rl.rlim_cur), pcVar4 == (char *)0x0)) {\n", "          eusage();\n", "          goto LAB_0040b33d;\n", "        }\n", "        bVar8 = *str;\n", "        flag[(int)(uint)(ushort)rl.rlim_cur] = 1;\n", "      }\n", "      ppbVar11 = ppbVar11 + 1;\n", "      __nptr = *ppbVar11;\n", "      fd_00 = fd_00 + -1;\n", "joined_r0x0040b238:\n", "      iVar3 = fd_00;\n", "      if (((__nptr == (byte *)0x0) || (*__nptr != 0x2d)) || (bVar8 = __nptr[1], bVar8 == 0))\n", "      goto LAB_0040b2f4;\n", "    }\n", "    iVar3 = fd_00 + -1;\n", "    ppbVar11 = ppbVar11 + 1;\n", "LAB_0040b2f4:\n", "    if (iVar3 < 2) goto LAB_0040b3a4;\n", "LAB_0040b2fd:\n", "    eusage();\n", "  }\n", "  p9free(v);\n", "  poplist();\n", "  flush(rc_err);\n", "LAB_0040b33d:\n", "  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execulimit(void)\n", "{\n", "\tint fd, n, argc, sethard, setsoft, limit;\n", "\tint flag[256];\n", "\tchar **argv, **oargv, *p;\n", "\tchar *argv0;\n", "\tstruct rlimit rl;\n", "\n", "\targv0 = nil;\n", "\tsetstatus(\"\");\n", "\toargv = mkargv(runq->argv->words);\n", "\targv = oargv+1;\n", "\tfor(argc=0; argv[argc]; argc++)\n", "\t\t;\n", "\n", "\tmemset(flag, 0, sizeof flag);\n", "\tARGBEGIN{\n", "\tdefault:\n", "\t\tif(strchr(eargs, ARGC()) == nil){\n", "\t\t\teusage();\n", "\t\t\treturn;\n", "\t\t}\n", "\tcase 'S':\n", "\tcase 'H':\n", "\tcase 'a':\n", "\t\tflag[ARGC()] = 1;\n", "\t\tbreak;\n", "\t}ARGEND\n", "\n", "\tif(argc > 1){\n", "\t\teusage();\n", "\t\tgoto out;\n", "\t}\n", "\n", "\tfd = mapfd(1);\n", "\n", "\tsethard = 1;\n", "\tsetsoft = 1;\n", "\tif(flag['S'] && flag['H'])\n", "\t\t;\n", "\telse if(flag['S'])\n", "\t\tsethard = 0;\n", "\telse if(flag['H'])\n", "\t\tsetsoft = 0;\n", "\n", "\tlimit = Notset;\n", "\tif(argc>0){\n", "\t\tif(strcmp(argv[0], \"unlimited\") == 0)\n", "\t\t\tlimit = Unlimited;\n", "\t\telse if(strcmp(argv[0], \"hard\") == 0)\n", "\t\t\tlimit = Hard;\n", "\t\telse if(strcmp(argv[0], \"soft\") == 0)\n", "\t\t\tlimit = Soft;\n", "\t\telse if((limit = strtol(argv[0], &p, 0)) < 0 || *p != 0){\n", "\t\t\teusage();\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t}\n", "\tif(flag['a']){\n", "\t\tfor(p=eargs; *p; p++){\n", "\t\t\tgetrlimit(rlx[p-eargs], &rl);\n", "\t\t\tn = flag['H'] ? rl.rlim_max : rl.rlim_cur;\n", "\t\t\tif(n == -1)\n", "\t\t\t\tfprint(fd, \"ulimit -%c unlimited\\n\", *p);\n", "\t\t\telse\n", "\t\t\t\tfprint(fd, \"ulimit -%c %d\\n\", *p, n);\n", "\t\t}\n", "\t\tgoto out;\n", "\t}\n", "\tfor(p=eargs; *p; p++){\n", "\t\tif(flag[(uchar)*p]){\n", "\t\t\tn = 0;\n", "\t\t\tgetrlimit(rlx[p-eargs], &rl);\n", "\t\t\tswitch(limit){\n", "\t\t\tcase Notset:\n", "\t\t\t\tn = flag['H'] ? rl.rlim_max : rl.rlim_cur;\n", "\t\t\t\tif(n == -1)\n", "\t\t\t\t\tfprint(fd, \"ulimit -%c unlimited\\n\", *p);\n", "\t\t\t\telse\n", "\t\t\t\t\tfprint(fd, \"ulimit -%c %d\\n\", *p, n);\n", "\t\t\t\tbreak;\n", "\t\t\tcase Hard:\n", "\t\t\t\tn = rl.rlim_max;\n", "\t\t\t\tgoto set;\n", "\t\t\tcase Soft:\n", "\t\t\t\tn = rl.rlim_cur;\n", "\t\t\t\tgoto set;\n", "\t\t\tcase Unlimited:\n", "\t\t\t\tn = -1;\n", "\t\t\t\tgoto set;\n", "\t\t\tdefault:\n", "\t\t\t\tn = limit;\n", "\t\t\tset:\n", "\t\t\t\tif(setsoft)\n", "\t\t\t\t\trl.rlim_cur = n;\n", "\t\t\t\tif(sethard)\n", "\t\t\t\t\trl.rlim_max = n;\n", "\t\t\t\tif(setrlimit(rlx[p-eargs], &rl) < 0)\n", "\t\t\t\t\tfprint(mapfd(2), \"setrlimit: %r\\n\");\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\n", "out:\n", "\tfree(oargv);\n", "\tpoplist();\n", "\tflush(err);\n", "}"]}, {"ghidra": ["\n", "int noted(int v)\n", "\n", "{\n", "  Jmp *buf;\n", "  \n", "  buf = (*_notejmpbuf)();\n", "  p9longjmp((long *)buf,~-(uint)(v == 0) + 2);\n", "                    /* WARNING: Subroutine does not return */\n", "  abort();\n", "}\n", "\n"], "c": ["int\n", "noted(int v)\n", "{\n", "\tp9longjmp((*_notejmpbuf)()->b, v==NCONT ? 2 : 1);\n", "\tabort();\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int p9open(char *name,int mode)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  uVar2 = mode & 0xffffdf9c;\n", "  if ((mode & 0x10U) != 0) {\n", "    uVar2 = uVar2 ^ 0x10;\n", "  }\n", "  if ((uVar2 & 0x80) != 0) {\n", "    uVar2 = uVar2 ^ 0x80;\n", "  }\n", "  if ((uVar2 & 0x100) != 0) {\n", "    uVar2 = uVar2 ^ 0x100;\n", "  }\n", "  if ((uVar2 & 0x4000) != 0) {\n", "    uVar2 = uVar2 ^ 0x4000;\n", "  }\n", "  if (uVar2 == 0) {\n", "    __fd = __open64_2();\n", "    iVar4 = __fd;\n", "    if (-1 < __fd) {\n", "      if ((mode & 0x2000U) != 0) {\n", "        fl.l_type = ZEXT12((mode & 3U) != 0);\n", "        fl.l_start = 0;\n", "        fl.l_whence = 0;\n", "        fl.l_len = 0;\n", "        iVar3 = fcntl(__fd,6,&fl);\n", "        if (iVar3 < 0) {\n", "          iVar4 = -1;\n", "          close(__fd);\n", "          werrstr(\"lock: %r\");\n", "          goto LAB_0040f6fd;\n", "        }\n", "      }\n", "      if ((mode & 0x20U) != 0) {\n", "        fcntl(__fd,2,1);\n", "      }\n", "      if ((mode & 0x40U) != 0) {\n", "        remove(name);\n", "      }\n", "    }\n", "  }\n", "  else {\n", "    werrstr(\"mode 0x%x not supported\",(ulong)uVar2);\n", "    iVar4 = -1;\n", "  }\n", "LAB_0040f6fd:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9open(char *name, int mode)\n", "{\n", "\tint cexec, rclose;\n", "\tint fd, umode, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tumode = rdwr;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tlock = mode&OLOCK;\n", "\tmode &= ~(3|OCEXEC|ORCLOSE|OLOCK);\n", "\tif(mode&OTRUNC){\n", "\t\tumode |= O_TRUNC;\n", "\t\tmode ^= OTRUNC;\n", "\t}\n", "\tif(mode&ODIRECT){\n", "\t\tumode |= O_DIRECT;\n", "\t\tmode ^= ODIRECT;\n", "\t}\n", "\tif(mode&ONONBLOCK){\n", "\t\tumode |= O_NONBLOCK;\n", "\t\tmode ^= ONONBLOCK;\n", "\t}\n", "\tif(mode&OAPPEND){\n", "\t\tumode |= O_APPEND;\n", "\t\tmode ^= OAPPEND;\n", "\t}\n", "\tif(mode){\n", "\t\twerrstr(\"mode 0x%x not supported\", mode);\n", "\t\treturn -1;\n", "\t}\n", "\tfd = open(name, umode);\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(name);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "void rlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\t(*_rlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers++;\n", "}"]}, {"ghidra": ["\n", "int p9pipe(int *fd)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = socketpair(1,1,0,fd);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "p9pipe(int fd[2])\n", "{\n", "\treturn socketpair(AF_UNIX, SOCK_STREAM, 0, fd);\n", "}"]}, {"ghidra": ["\n", "long p9write(int f,void *av,long n)\n", "\n", "{\n", "  ssize_t sVar1;\n", "  long lVar2;\n", "  \n", "  if (n < 1) {\n", "    lVar2 = 0;\n", "  }\n", "  else {\n", "    lVar2 = 0;\n", "    do {\n", "      sVar1 = write(f,(void *)((long)av + lVar2),n - lVar2);\n", "      if (sVar1 < 1) {\n", "        if (lVar2 != 0) {\n", "          return lVar2;\n", "        }\n", "        return sVar1;\n", "      }\n", "      lVar2 = lVar2 + sVar1;\n", "    } while (lVar2 < n);\n", "  }\n", "  return lVar2;\n", "}\n", "\n"], "c": ["long\n", "p9write(int f, void *av, long n)\n", "{\n", "\tchar *a;\n", "\tlong m, t;\n", "\n", "\ta = av;\n", "\tt = 0;\n", "\twhile(t < n){\n", "\t\tm = write(f, a+t, n-t);\n", "\t\tif(m <= 0){\n", "\t\t\tif(t == 0)\n", "\t\t\t\treturn m;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tt += m;\n", "\t}\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "void execwait(void)\n", "\n", "{\n", "  int pid;\n", "  \n", "  pid = count(runq->argv->words);\n", "  if (pid == 1) {\n", "    Waitfor(-1,0);\n", "    poplist();\n", "    return;\n", "  }\n", "  if (pid == 2) {\n", "    pid = p9atoi(runq->argv->words->next->word);\n", "    Waitfor(pid,0);\n", "    poplist();\n", "    return;\n", "  }\n", "  Xerror1(\"Usage: wait [pid]\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execwait(void)\n", "{\n", "\tswitch(count(runq->argv->words)){\n", "\tdefault:\n", "\t\tXerror1(\"Usage: wait [pid]\");\n", "\t\treturn;\n", "\tcase 2:\n", "\t\tWaitfor(atoi(runq->argv->words->next->word), 0);\n", "\t\tbreak;\n", "\tcase 1:\n", "\t\tWaitfor(-1, 0);\n", "\t\tbreak;\n", "\t}\n", "\tpoplist();\n", "}"]}, {"ghidra": ["\n", "void delwaitpid(int pid)\n", "\n", "{\n", "  int *piVar1;\n", "  int iVar2;\n", "  int *piVar3;\n", "  int iVar4;\n", "  long lVar5;\n", "  \n", "  piVar1 = waitpids;\n", "  if (nwaitpids < 1) {\n", "    iVar4 = 0;\n", "  }\n", "  else {\n", "    iVar4 = 0;\n", "    iVar2 = 0;\n", "    piVar3 = waitpids;\n", "    do {\n", "      if (*piVar3 != pid) {\n", "        lVar5 = (long)iVar4;\n", "        iVar4 = iVar4 + 1;\n", "        piVar1[lVar5] = *piVar3;\n", "      }\n", "      iVar2 = iVar2 + 1;\n", "      piVar3 = piVar3 + 1;\n", "    } while (iVar2 < nwaitpids);\n", "  }\n", "  nwaitpids = iVar4;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "delwaitpid(int pid)\n", "{\n", "\tint r, w;\n", "\t\n", "\tfor(r=w=0; r<nwaitpids; r++)\n", "\t\tif(waitpids[r] != pid)\n", "\t\t\twaitpids[w++] = waitpids[r];\n", "\tnwaitpids = w;\n", "}"]}, {"ghidra": ["\n", "char * Rcmain(void)\n", "\n", "{\n", "  char *pcVar1;\n", "  \n", "  pcVar1 = unsharp(\"/usr/lib/plan9/etc/rcmain\");\n", "  return pcVar1;\n", "}\n", "\n"], "c": ["char*\n", "Rcmain(void)\n", "{\n", "\treturn unsharp(\"/usr/lib/plan9/etc/rcmain\");\n", "}"]}, {"ghidra": ["\n", "void pprompt(void)\n", "\n", "{\n", "  word *pwVar1;\n", "  var *pvVar2;\n", "  \n", "  if (runq->iflag == 0) {\n", "    runq->lineno = runq->lineno + 1;\n", "    doprompt = 0;\n", "    return;\n", "  }\n", "  pstr(rc_err,promptstr);\n", "  flush(rc_err);\n", "  pvVar2 = vlook(\"prompt\");\n", "  if ((pvVar2->val == (word *)0x0) || (pwVar1 = pvVar2->val->next, pwVar1 == (word *)0x0)) {\n", "    promptstr = \"\\t\";\n", "  }\n", "  else {\n", "    promptstr = pwVar1->word;\n", "  }\n", "  runq->lineno = runq->lineno + 1;\n", "  doprompt = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pprompt(void)\n", "{\n", "\tvar *prompt;\n", "\tif(runq->iflag){\n", "\t\tpstr(err, promptstr);\n", "\t\tflush(err);\n", "\t\tprompt = vlook(\"prompt\");\n", "\t\tif(prompt->val && prompt->val->next)\n", "\t\t\tpromptstr = prompt->val->next->word;\n", "\t\telse\n", "\t\t\tpromptstr=\"\\t\";\n", "\t}\n", "\trunq->lineno++;\n", "\tdoprompt = 0;\n", "}"]}, {"ghidra": ["\n", "void outcode(tree *t,int eflag)\n", "\n", "{\n", "  char **ppcVar1;\n", "  tree **pptVar2;\n", "  int a;\n", "  int a_00;\n", "  tree *t_00;\n", "  char *pcVar3;\n", "  long lVar4;\n", "  tree *t_01;\n", "  bool bVar5;\n", "  \n", "  if (t == (tree *)0x0) {\n", "    return;\n", "  }\n", "  a_00 = t->type;\n", "  if ((a_00 != 0x3b) && (a_00 != 0xe006)) {\n", "    runq->iflast = 0;\n", "  }\n", "  a = codep;\n", "  if (a_00 == 0xe00b) {\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x404830;\n", "    outcode(t->child[0],eflag);\n", "    if (t->child[1] == (tree *)0x0) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x405490;\n", "      a_00 = t->type;\n", "      goto LAB_004026c0;\n", "    }\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    bVar5 = codep == ncode;\n", "    codebuf[lVar4] = 0x405400;\n", "    if (bVar5) {\n", "      morecode();\n", "    }\n", "    *(undefined4 *)(codebuf + codep) = 0;\n", "    a_00 = codep;\n", "    codep = codep + 1;\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    ppcVar1 = (char **)(codebuf + codep);\n", "    pcVar3 = fnstr(t->child[1]);\n", "    *ppcVar1 = pcVar3;\n", "    codep = codep + 1;\n", "    outcode(t->child[1],eflag);\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    bVar5 = codep == ncode;\n", "    codebuf[lVar4] = 0x4053a0;\n", "    if (bVar5) {\n", "      morecode();\n", "    }\n", "    codebuf[codep] = 0x404d80;\n", "LAB_00402b50:\n", "    codep = codep + 1;\n", "    stuffdot(a_00);\n", "    a_00 = t->type;\n", "    goto LAB_004026c0;\n", "  }\n", "  if (a_00 < 0xe00c) {\n", "    if (a_00 == 0xe002) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x404830;\n", "      if (t->child[1] == (tree *)0x0) {\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        lVar4 = (long)codep;\n", "        codep = codep + 1;\n", "        codebuf[lVar4] = 0x404830;\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        lVar4 = (long)codep;\n", "        codep = codep + 1;\n", "        codebuf[lVar4] = 0x404720;\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        ppcVar1 = (char **)(codebuf + codep);\n", "        pcVar3 = p9strdup(\"*\");\n", "        *ppcVar1 = pcVar3;\n", "        codep = codep + 1;\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        codebuf[codep] = 0x405bf0;\n", "      }\n", "      else {\n", "        outcode(t->child[1],eflag);\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        codebuf[codep] = 0x4065f0;\n", "      }\n", "      codep = codep + 1;\n", "      if (ncode == codep) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x404830;\n", "      if (bVar5) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x404830;\n", "      outcode(t->child[0],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x406030;\n", "      a_00 = codep;\n", "      if (bVar5) {\n", "        morecode();\n", "        a_00 = codep;\n", "      }\n", "      codebuf[a_00] = 0x406570;\n", "      codep = a_00 + 1;\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      *(undefined4 *)(codebuf + codep) = 0;\n", "      a = codep;\n", "      codep = codep + 1;\n", "      outcode(t->child[2],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x404cb0;\n", "      if (bVar5) {\n", "        morecode();\n", "      }\n", "      *(int *)(codebuf + codep) = a_00;\n", "      codep = codep + 1;\n", "      stuffdot(a);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x4053a0;\n", "      a_00 = t->type;\n", "      goto LAB_004026c0;\n", "    }\n", "    if (a_00 < 0xe003) {\n", "      if (a_00 == 0x3b) {\n", "        outcode(t->child[0],eflag);\n", "        t_00 = t->child[1];\n", "LAB_004029fc:\n", "        outcode(t_00,eflag);\n", "        a_00 = t->type;\n", "        goto LAB_004026c0;\n", "      }\n", "      if (a_00 < 0x3c) {\n", "        if (a_00 == 0x24) {\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x404830;\n", "          outcode(t->child[0],eflag);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x405bf0;\n", "          a_00 = t->type;\n", "          goto LAB_004026c0;\n", "        }\n", "        if (a_00 == 0x26) {\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          a_00 = ncode;\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x40d870;\n", "          if (havefork != 0) {\n", "            if (codep == a_00) goto LAB_0040323f;\n", "            goto LAB_00402aff;\n", "          }\n", "LAB_00403830:\n", "          if (codep == a_00) goto LAB_00403b9c;\n", "          goto LAB_00403838;\n", "        }\n", "        if (a_00 == 0x22) {\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x404830;\n", "          outcode(t->child[0],eflag);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x405d20;\n", "          a_00 = t->type;\n", "          goto LAB_004026c0;\n", "        }\n", "      }\n", "      else {\n", "        if (a_00 == 0x5e) {\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x404830;\n", "          outcode(t->child[1],eflag);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x404830;\n", "          outcode(t->child[0],eflag);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x405a50;\n", "          a_00 = t->type;\n", "          goto LAB_004026c0;\n", "        }\n", "        if (a_00 == 0x60) {\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          a_00 = ncode;\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x40db40;\n", "          if (havefork != 0) {\n", "            if (codep == a_00) {\n", "              morecode();\n", "            }\n", "            *(undefined4 *)(codebuf + codep) = 0;\n", "            a_00 = codep;\n", "            codep = codep + 1;\n", "            outcode(t->child[0],0);\n", "            if (codep == ncode) {\n", "              morecode();\n", "            }\n", "            lVar4 = (long)codep;\n", "            codep = codep + 1;\n", "            codebuf[lVar4] = 0x405090;\n", "            stuffdot(a_00);\n", "            a_00 = t->type;\n", "            goto LAB_004026c0;\n", "          }\n", "          goto LAB_00403830;\n", "        }\n", "        t_00 = t;\n", "        if (a_00 == 0x3d) {\n", "          do {\n", "            t_00 = t_00->child[2];\n", "            t_01 = t;\n", "            if (t_00 == (tree *)0x0) goto LAB_0040376b;\n", "          } while (t_00->type == 0x3d);\n", "          do {\n", "            if (ncode == codep) {\n", "              morecode();\n", "            }\n", "            lVar4 = (long)codep;\n", "            codep = codep + 1;\n", "            codebuf[lVar4] = 0x404830;\n", "            outcode(t_01->child[1],eflag);\n", "            if (codep == ncode) {\n", "              morecode();\n", "            }\n", "            lVar4 = (long)codep;\n", "            codep = codep + 1;\n", "            codebuf[lVar4] = 0x404830;\n", "            outcode(t_01->child[0],eflag);\n", "            if (codep == ncode) {\n", "              morecode();\n", "            }\n", "            lVar4 = (long)codep;\n", "            codep = codep + 1;\n", "            codebuf[lVar4] = 0x406030;\n", "            t_01 = t_01->child[2];\n", "          } while (t_01->type == 0x3d);\n", "          outcode(t_01,eflag);\n", "          a_00 = t->type;\n", "          t_00 = t;\n", "          if (a_00 != 0x3d) goto LAB_004026c0;\n", "          do {\n", "            if (ncode == codep) {\n", "              morecode();\n", "            }\n", "            lVar4 = (long)codep;\n", "            codep = codep + 1;\n", "            codebuf[lVar4] = 0x4053a0;\n", "            pptVar2 = t_00->child;\n", "            t_00 = pptVar2[2];\n", "          } while (pptVar2[2]->type == 0x3d);\n", "          goto LAB_00402d05;\n", "        }\n", "      }\n", "LAB_004029db:\n", "      pfmt(rc_err,\"bad type %d in outcode\\n\");\n", "      a_00 = t->type;\n", "      goto LAB_004026c0;\n", "    }\n", "    if (a_00 == 0xe007) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x404830;\n", "      outcode(t->child[1],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x404830;\n", "      outcode(t->child[0],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x405580;\n", "      if (eflag != 0) {\n", "LAB_00402db5:\n", "        if (codep == ncode) {\n", "LAB_00403311:\n", "          morecode();\n", "        }\n", "LAB_00402dc1:\n", "        lVar4 = (long)codep;\n", "        codep = codep + 1;\n", "        codebuf[lVar4] = 0x4062d0;\n", "        a_00 = t->type;\n", "        goto LAB_004026c0;\n", "      }\n", "    }\n", "    else {\n", "      if (a_00 < 0xe008) {\n", "        if (a_00 == 0xe005) {\n", "          outcode(t->child[0],0);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          bVar5 = codep == ncode;\n", "          codebuf[lVar4] = 0x406390;\n", "          if (bVar5) {\n", "            morecode();\n", "          }\n", "          *(undefined4 *)(codebuf + codep) = 0;\n", "          a_00 = codep;\n", "          codep = codep + 1;\n", "          outcode(t->child[1],eflag);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          codebuf[codep] = 0x404e20;\n", "          goto LAB_00402b50;\n", "        }\n", "        if (a_00 < 0xe006) {\n", "          if (a_00 == 0xe004) {\n", "            outcode(t->child[0],0);\n", "            if (a == codep) {\n", "              a_00 = a;\n", "              if (a == ncode) {\n", "                morecode();\n", "                a_00 = codep;\n", "              }\n", "              codep = a_00 + 1;\n", "              codebuf[a_00] = 0x405570;\n", "            }\n", "            if (ncode == codep) {\n", "              morecode();\n", "            }\n", "            lVar4 = (long)codep;\n", "            codep = codep + 1;\n", "            bVar5 = codep == ncode;\n", "            codebuf[lVar4] = 0x406350;\n", "            if (bVar5) {\n", "              morecode();\n", "            }\n", "            *(undefined4 *)(codebuf + codep) = 0;\n", "            a_00 = codep;\n", "            codep = codep + 1;\n", "            outcode(t->child[1],eflag);\n", "            if (codep == ncode) {\n", "              morecode();\n", "            }\n", "            lVar4 = (long)codep;\n", "            codep = codep + 1;\n", "            bVar5 = codep == ncode;\n", "            codebuf[lVar4] = 0x404cb0;\n", "            if (bVar5) {\n", "              morecode();\n", "            }\n", "            *(int *)(codebuf + codep) = a;\n", "            codep = codep + 1;\n", "            stuffdot(a_00);\n", "            a_00 = t->type;\n", "            goto LAB_004026c0;\n", "          }\n", "          goto LAB_004029db;\n", "        }\n", "        if (runq->iflast == 0) {\n", "          yyerror(\"`if not\\' does not follow `if(...)\\'\");\n", "        }\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        lVar4 = (long)codep;\n", "        codep = codep + 1;\n", "        bVar5 = codep == ncode;\n", "        codebuf[lVar4] = 0x404c80;\n", "        if (bVar5) {\n", "          morecode();\n", "        }\n", "        *(undefined4 *)(codebuf + codep) = 0;\n", "        t_00 = t->child[0];\n", "        a_00 = codep;\n", "        goto LAB_00402e60;\n", "      }\n", "      if (a_00 != 0xe009) {\n", "        if (a_00 < 0xe00a) {\n", "          outcode(t->child[0],eflag);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x4062a0;\n", "          a_00 = t->type;\n", "        }\n", "        else {\n", "          codeswitch(t,eflag);\n", "          a_00 = t->type;\n", "        }\n", "        goto LAB_004026c0;\n", "      }\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      a_00 = ncode;\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x40dee0;\n", "      if (havefork == 0) {\n", "        if (codep == a_00) {\n", "          morecode();\n", "        }\n", "        ppcVar1 = (char **)(codebuf + codep);\n", "        pcVar3 = fnstr(t->child[0]);\n", "        *ppcVar1 = pcVar3;\n", "        codep = codep + 1;\n", "      }\n", "      else {\n", "        if (codep == a_00) {\n", "          morecode();\n", "        }\n", "        *(undefined4 *)(codebuf + codep) = 0;\n", "        a_00 = codep;\n", "        codep = codep + 1;\n", "        outcode(t->child[0],eflag);\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        lVar4 = (long)codep;\n", "        codep = codep + 1;\n", "        codebuf[lVar4] = 0x405090;\n", "        stuffdot(a_00);\n", "      }\n", "      if (eflag != 0) {\n", "        if (codep == ncode) goto LAB_00403311;\n", "        goto LAB_00402dc1;\n", "      }\n", "    }\n", "LAB_00402d05:\n", "    a_00 = t->type;\n", "    goto LAB_004026c0;\n", "  }\n", "  if (a_00 == 0xe013) {\n", "LAB_004026a2:\n", "    outcode(t->child[1],eflag);\n", "    outcode(t->child[0],eflag);\n", "    a_00 = t->type;\n", "    goto LAB_004026c0;\n", "  }\n", "  if (0xe013 < a_00) {\n", "    if (a_00 == 0xe017) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x40dd60;\n", "      if (bVar5) {\n", "        morecode();\n", "      }\n", "      *(int *)(codebuf + codep) = t->rtype;\n", "      codep = codep + 1;\n", "      if (havefork != 0) {\n", "        if (codep == ncode) {\n", "LAB_0040323f:\n", "          morecode();\n", "        }\n", "LAB_00402aff:\n", "        *(undefined4 *)(codebuf + codep) = 0;\n", "        a_00 = codep;\n", "        codep = codep + 1;\n", "        outcode(t->child[0],eflag);\n", "        if (codep == ncode) {\n", "          morecode();\n", "        }\n", "        codebuf[codep] = 0x405090;\n", "        goto LAB_00402b50;\n", "      }\n", "      if (codep == ncode) {\n", "LAB_00403b9c:\n", "        morecode();\n", "      }\n", "LAB_00403838:\n", "      ppcVar1 = (char **)(codebuf + codep);\n", "      pcVar3 = fnstr(t->child[0]);\n", "      *ppcVar1 = pcVar3;\n", "      codep = codep + 1;\n", "      a_00 = t->type;\n", "      goto LAB_004026c0;\n", "    }\n", "    if (a_00 < 0xe018) {\n", "      t_00 = t->child[0];\n", "      goto LAB_004029fc;\n", "    }\n", "    if (a_00 == 0xe019) {\n", "      outcode(t->child[0],0);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x406310;\n", "      if (bVar5) {\n", "LAB_004031ba:\n", "        morecode();\n", "      }\n", "    }\n", "    else {\n", "      if (0xe018 < a_00) {\n", "        if (a_00 == 0xe01a) {\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x404830;\n", "          outcode(t->child[0],eflag);\n", "          if (codep == ncode) {\n", "            morecode();\n", "          }\n", "          lVar4 = (long)codep;\n", "          codep = codep + 1;\n", "          codebuf[lVar4] = 0x405f00;\n", "          a_00 = t->type;\n", "          goto LAB_004026c0;\n", "        }\n", "        goto LAB_004029db;\n", "      }\n", "      outcode(t->child[0],0);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x406350;\n", "      if (bVar5) goto LAB_004031ba;\n", "    }\n", "    *(undefined4 *)(codebuf + codep) = 0;\n", "    t_00 = t->child[1];\n", "    a_00 = codep;\n", "LAB_00402e60:\n", "    codep = a_00 + 1;\n", "    outcode(t_00,eflag);\n", "    stuffdot(a_00);\n", "    a_00 = t->type;\n", "    goto LAB_004026c0;\n", "  }\n", "  if (a_00 == 0xe00f) {\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    bVar5 = codep == ncode;\n", "    codebuf[lVar4] = 0x40d9f0;\n", "    if (bVar5) {\n", "      morecode();\n", "    }\n", "    *(int *)(codebuf + codep) = t->fd0;\n", "    codep = codep + 1;\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    *(int *)(codebuf + codep) = t->fd1;\n", "    codep = codep + 1;\n", "    if (havefork == 0) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      ppcVar1 = (char **)(codebuf + codep);\n", "      pcVar3 = fnstr(t->child[0]);\n", "      *ppcVar1 = pcVar3;\n", "      codep = codep + 1;\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      *(undefined4 *)(codebuf + codep) = 0;\n", "      a_00 = codep;\n", "      codep = codep + 1;\n", "    }\n", "    else {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      *(undefined4 *)(codebuf + codep) = 0;\n", "      a = codep;\n", "      codep = codep + 1;\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      *(undefined4 *)(codebuf + codep) = 0;\n", "      a_00 = codep;\n", "      codep = codep + 1;\n", "      outcode(t->child[0],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x405090;\n", "      stuffdot(a);\n", "    }\n", "    outcode(t->child[1],eflag);\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x404d80;\n", "    stuffdot(a_00);\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x4060f0;\n", "    goto LAB_00402d05;\n", "  }\n", "  if (0xe00f < a_00) {\n", "    if (a_00 == 0xe011) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x404830;\n", "      outcode(t->child[0],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x409ba0;\n", "      if (eflag == 0) {\n", "        a_00 = t->type;\n", "        goto LAB_004026c0;\n", "      }\n", "      goto LAB_00402db5;\n", "    }\n", "    if (a_00 < 0xe012) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x404830;\n", "      outcode(t->child[0],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x404830;\n", "      outcode(t->child[1],eflag);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x405e30;\n", "      a_00 = t->type;\n", "      goto LAB_004026c0;\n", "    }\n", "    goto LAB_004026a2;\n", "  }\n", "  if (a_00 == 0xe00d) {\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x404830;\n", "    outcode(t->child[0],eflag);\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x4065f0;\n", "    switch(t->rtype) {\n", "    case 1:\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x405760;\n", "      break;\n", "    case 2:\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x4059a0;\n", "      break;\n", "    case 3:\n", "    case 4:\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x405840;\n", "      break;\n", "    case 7:\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      codebuf[lVar4] = 0x4058f0;\n", "    }\n", "    if (ncode == codep) {\n", "LAB_00403908:\n", "      morecode();\n", "    }\n", "LAB_00402ec1:\n", "    *(int *)(codebuf + codep) = t->fd0;\n", "  }\n", "  else {\n", "    if (a_00 < 0xe00e) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x404720;\n", "      if (bVar5) {\n", "        morecode();\n", "      }\n", "      ppcVar1 = (char **)(codebuf + codep);\n", "      pcVar3 = p9strdup(t->str);\n", "      *ppcVar1 = pcVar3;\n", "      codep = codep + 1;\n", "      a_00 = t->type;\n", "      goto LAB_004026c0;\n", "    }\n", "    if (t->rtype != 5) {\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      lVar4 = (long)codep;\n", "      codep = codep + 1;\n", "      bVar5 = codep == ncode;\n", "      codebuf[lVar4] = 0x404c00;\n", "      if (bVar5) goto LAB_00403908;\n", "      goto LAB_00402ec1;\n", "    }\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    bVar5 = codep == ncode;\n", "    codebuf[lVar4] = 0x404c40;\n", "    if (bVar5) {\n", "      morecode();\n", "    }\n", "    *(int *)(codebuf + codep) = t->fd0;\n", "    codep = codep + 1;\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    *(int *)(codebuf + codep) = t->fd1;\n", "  }\n", "  codep = codep + 1;\n", "  outcode(t->child[1],eflag);\n", "  if (codep == ncode) {\n", "    morecode();\n", "  }\n", "  lVar4 = (long)codep;\n", "  codep = codep + 1;\n", "  codebuf[lVar4] = 0x404ce0;\n", "  a_00 = t->type;\n", "LAB_004026c0:\n", "  if ((a_00 == 0x3b) || (a_00 == 0xe006)) {\n", "    if (t->child[0] != (tree *)0x0) {\n", "      runq->iflast = (uint)(t->child[0]->type == 0xe005);\n", "    }\n", "  }\n", "  else {\n", "    runq->iflast = (uint)(a_00 == 0xe005);\n", "  }\n", "  return;\n", "LAB_0040376b:\n", "  do {\n", "    if (ncode == codep) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x404830;\n", "    outcode(t_01->child[1],eflag);\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x404830;\n", "    outcode(t_01->child[0],eflag);\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar4 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar4] = 0x405b30;\n", "    pptVar2 = t_01->child;\n", "    t_01 = pptVar2[2];\n", "  } while (pptVar2[2] != (tree *)0x0);\n", "  goto LAB_00402d05;\n", "}\n", "\n"], "c": ["void\n", "outcode(tree *t, int eflag)\n", "{\n", "\tint p, q;\n", "\ttree *tt;\n", "\tif(t==0)\n", "\t\treturn;\n", "\tif(t->type!=NOT && t->type!=';')\n", "\t\trunq->iflast = 0;\n", "\tswitch(t->type){\n", "\tdefault:\n", "\t\tpfmt(err, \"bad type %d in outcode\\n\", t->type);\n", "\t\tbreak;\n", "\tcase '$':\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xdol);\n", "\t\tbreak;\n", "\tcase '\"':\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xqdol);\n", "\t\tbreak;\n", "\tcase SUB:\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xmark);\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xsub);\n", "\t\tbreak;\n", "\tcase '&':\n", "\t\temitf(Xasync);\n", "\t\tif(havefork){\n", "\t\t\tp = emiti(0);\n", "\t\t\toutcode(c0, eflag);\n", "\t\t\temitf(Xexit);\n", "\t\t\tstuffdot(p);\n", "\t\t} else\n", "\t\t\temits(fnstr(c0));\n", "\t\tbreak;\n", "\tcase ';':\n", "\t\toutcode(c0, eflag);\n", "\t\toutcode(c1, eflag);\n", "\t\tbreak;\n", "\tcase '^':\n", "\t\temitf(Xmark);\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xconc);\n", "\t\tbreak;\n", "\tcase '`':\n", "\t\temitf(Xbackq);\n", "\t\tif(havefork){\n", "\t\t\tp = emiti(0);\n", "\t\t\toutcode(c0, 0);\n", "\t\t\temitf(Xexit);\n", "\t\t\tstuffdot(p);\n", "\t\t} else\n", "\t\t\temits(fnstr(c0));\n", "\t\tbreak;\n", "\tcase ANDAND:\n", "\t\toutcode(c0, 0);\n", "\t\temitf(Xtrue);\n", "\t\tp = emiti(0);\n", "\t\toutcode(c1, eflag);\n", "\t\tstuffdot(p);\n", "\t\tbreak;\n", "\tcase ARGLIST:\n", "\t\toutcode(c1, eflag);\n", "\t\toutcode(c0, eflag);\n", "\t\tbreak;\n", "\tcase BANG:\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xbang);\n", "\t\tbreak;\n", "\tcase PCMD:\n", "\tcase BRACE:\n", "\t\toutcode(c0, eflag);\n", "\t\tbreak;\n", "\tcase COUNT:\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xcount);\n", "\t\tbreak;\n", "\tcase FN:\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\tif(c1){\n", "\t\t\temitf(Xfn);\n", "\t\t\tp = emiti(0);\n", "\t\t\temits(fnstr(c1));\n", "\t\t\toutcode(c1, eflag);\n", "\t\t\temitf(Xunlocal);\t/* get rid of $* */\n", "\t\t\temitf(Xreturn);\n", "\t\t\tstuffdot(p);\n", "\t\t}\n", "\t\telse\n", "\t\t\temitf(Xdelfn);\n", "\t\tbreak;\n", "\tcase IF:\n", "\t\toutcode(c0, 0);\n", "\t\temitf(Xif);\n", "\t\tp = emiti(0);\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xwastrue);\n", "\t\tstuffdot(p);\n", "\t\tbreak;\n", "\tcase NOT:\n", "\t\tif(!runq->iflast)\n", "\t\t\tyyerror(\"`if not' does not follow `if(...)'\");\n", "\t\temitf(Xifnot);\n", "\t\tp = emiti(0);\n", "\t\toutcode(c0, eflag);\n", "\t\tstuffdot(p);\n", "\t\tbreak;\n", "\tcase OROR:\n", "\t\toutcode(c0, 0);\n", "\t\temitf(Xfalse);\n", "\t\tp = emiti(0);\n", "\t\toutcode(c1, eflag);\n", "\t\tstuffdot(p);\n", "\t\tbreak;\n", "\tcase PAREN:\n", "\t\toutcode(c0, eflag);\n", "\t\tbreak;\n", "\tcase SIMPLE:\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xsimple);\n", "\t\tif(eflag)\n", "\t\t\temitf(Xeflag);\n", "\t\tbreak;\n", "\tcase SUBSHELL:\n", "\t\temitf(Xsubshell);\n", "\t\tif(havefork){\n", "\t\t\tp = emiti(0);\n", "\t\t\toutcode(c0, eflag);\n", "\t\t\temitf(Xexit);\n", "\t\t\tstuffdot(p);\n", "\t\t} else\n", "\t\t\temits(fnstr(c0));\n", "\t\tif(eflag)\n", "\t\t\temitf(Xeflag);\n", "\t\tbreak;\n", "\tcase SWITCH:\n", "\t\tcodeswitch(t, eflag);\n", "\t\tbreak;\n", "\tcase TWIDDLE:\n", "\t\temitf(Xmark);\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xmatch);\n", "\t\tif(eflag)\n", "\t\t\temitf(Xeflag);\n", "\t\tbreak;\n", "\tcase WHILE:\n", "\t\tq = codep;\n", "\t\toutcode(c0, 0);\n", "\t\tif(q==codep)\n", "\t\t\temitf(Xsettrue);\t/* empty condition == while(true) */\n", "\t\temitf(Xtrue);\n", "\t\tp = emiti(0);\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xjump);\n", "\t\temiti(q);\n", "\t\tstuffdot(p);\n", "\t\tbreak;\n", "\tcase WORDS:\n", "\t\toutcode(c1, eflag);\n", "\t\toutcode(c0, eflag);\n", "\t\tbreak;\n", "\tcase FOR:\n", "\t\temitf(Xmark);\n", "\t\tif(c1){\n", "\t\t\toutcode(c1, eflag);\n", "\t\t\temitf(Xglob);\n", "\t\t}\n", "\t\telse{\n", "\t\t\temitf(Xmark);\n", "\t\t\temitf(Xword);\n", "\t\t\temits(strdup(\"*\"));\n", "\t\t\temitf(Xdol);\n", "\t\t}\n", "\t\temitf(Xmark);\t\t/* dummy value for Xlocal */\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xlocal);\n", "\t\tp = emitf(Xfor);\n", "\t\tq = emiti(0);\n", "\t\toutcode(c2, eflag);\n", "\t\temitf(Xjump);\n", "\t\temiti(p);\n", "\t\tstuffdot(q);\n", "\t\temitf(Xunlocal);\n", "\t\tbreak;\n", "\tcase WORD:\n", "\t\temitf(Xword);\n", "\t\temits(strdup(t->str));\n", "\t\tbreak;\n", "\tcase DUP:\n", "\t\tif(t->rtype==DUPFD){\n", "\t\t\temitf(Xdup);\n", "\t\t\temiti(t->fd0);\n", "\t\t\temiti(t->fd1);\n", "\t\t}\n", "\t\telse{\n", "\t\t\temitf(Xclose);\n", "\t\t\temiti(t->fd0);\n", "\t\t}\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xpopredir);\n", "\t\tbreak;\n", "\tcase PIPEFD:\n", "\t\temitf(Xpipefd);\n", "\t\temiti(t->rtype);\n", "\t\tif(havefork){\n", "\t\t\tp = emiti(0);\n", "\t\t\toutcode(c0, eflag);\n", "\t\t\temitf(Xexit);\n", "\t\t\tstuffdot(p);\n", "\t\t} else {\n", "\t\t\temits(fnstr(c0));\n", "\t\t}\n", "\t\tbreak;\n", "\tcase REDIR:\n", "\t\temitf(Xmark);\n", "\t\toutcode(c0, eflag);\n", "\t\temitf(Xglob);\n", "\t\tswitch(t->rtype){\n", "\t\tcase APPEND:\n", "\t\t\temitf(Xappend);\n", "\t\t\tbreak;\n", "\t\tcase WRITE:\n", "\t\t\temitf(Xwrite);\n", "\t\t\tbreak;\n", "\t\tcase READ:\n", "\t\tcase HERE:\n", "\t\t\temitf(Xread);\n", "\t\t\tbreak;\n", "\t\tcase RDWR:\n", "\t\t\temitf(Xrdwr);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\temiti(t->fd0);\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xpopredir);\n", "\t\tbreak;\n", "\tcase '=':\n", "\t\ttt = t;\n", "\t\tfor(;t && t->type=='=';t = c2);\n", "\t\tif(t){\n", "\t\t\tfor(t = tt;t->type=='=';t = c2){\n", "\t\t\t\temitf(Xmark);\n", "\t\t\t\toutcode(c1, eflag);\n", "\t\t\t\temitf(Xmark);\n", "\t\t\t\toutcode(c0, eflag);\n", "\t\t\t\temitf(Xlocal);\n", "\t\t\t}\n", "\t\t\toutcode(t, eflag);\n", "\t\t\tfor(t = tt; t->type=='='; t = c2)\n", "\t\t\t\temitf(Xunlocal);\n", "\t\t}\n", "\t\telse{\n", "\t\t\tfor(t = tt;t;t = c2){\n", "\t\t\t\temitf(Xmark);\n", "\t\t\t\toutcode(c1, eflag);\n", "\t\t\t\temitf(Xmark);\n", "\t\t\t\toutcode(c0, eflag);\n", "\t\t\t\temitf(Xassign);\n", "\t\t\t}\n", "\t\t}\n", "\t\tt = tt;\t/* so tests below will work */\n", "\t\tbreak;\n", "\tcase PIPE:\n", "\t\temitf(Xpipe);\n", "\t\temiti(t->fd0);\n", "\t\temiti(t->fd1);\n", "\t\tif(havefork){\n", "\t\t\tp = emiti(0);\n", "\t\t\tq = emiti(0);\n", "\t\t\toutcode(c0, eflag);\n", "\t\t\temitf(Xexit);\n", "\t\t\tstuffdot(p);\n", "\t\t} else {\n", "\t\t\temits(fnstr(c0));\n", "\t\t\tq = emiti(0);\n", "\t\t}\n", "\t\toutcode(c1, eflag);\n", "\t\temitf(Xreturn);\n", "\t\tstuffdot(q);\n", "\t\temitf(Xpipewait);\n", "\t\tbreak;\n", "\t}\n", "\tif(t->type!=NOT && t->type!=';')\n", "\t\trunq->iflast = t->type==IF;\n", "\telse if(c0) runq->iflast = c0->type==IF;\n", "}"]}, {"ghidra": ["\n", "tree * simplemung(tree *t)\n", "\n", "{\n", "  int iVar1;\n", "  tree *ptVar2;\n", "  io *f;\n", "  char *pcVar3;\n", "  tree *ptVar4;\n", "  \n", "  ptVar2 = newtree();\n", "  ptVar2->child[0] = t;\n", "  ptVar2->type = 0xe011;\n", "  ptVar2->child[1] = (tree *)0x0;\n", "  ptVar2->child[2] = (tree *)0x0;\n", "  f = openstr();\n", "  pfmt(f,\"%t\",ptVar2);\n", "  pcVar3 = p9strdup(f->strp);\n", "  ptVar2->str = pcVar3;\n", "  closeio(f);\n", "  ptVar4 = ptVar2->child[0];\n", "  iVar1 = ptVar4->type;\n", "  do {\n", "    if (iVar1 != 0xe012) {\n", "      return ptVar2;\n", "    }\n", "    while (1 < ptVar4->child[1]->type - 0xe00dU) {\n", "      ptVar4 = ptVar4->child[0];\n", "      if (ptVar4->type != 0xe012) {\n", "        return ptVar2;\n", "      }\n", "    }\n", "    ptVar4->child[1]->child[1] = ptVar2;\n", "    ptVar2 = ptVar4->child[1];\n", "    ptVar4->child[1] = (tree *)0x0;\n", "    ptVar4 = ptVar4->child[0];\n", "    iVar1 = ptVar4->type;\n", "  } while( true );\n", "}\n", "\n"], "c": ["tree*\n", "simplemung(tree *t)\n", "{\n", "\ttree *u;\n", "\tstruct io *s;\n", "\tt = tree1(SIMPLE, t);\n", "\ts = openstr();\n", "\tpfmt(s, \"%t\", t);\n", "\tt->str = strdup(s->strp);\n", "\tcloseio(s);\n", "\tfor(u = t->child[0];u->type==ARGLIST;u = u->child[0]){\n", "\t\tif(u->child[1]->type==DUP\n", "\t\t|| u->child[1]->type==REDIR){\n", "\t\t\tu->child[1]->child[1] = t;\n", "\t\t\tt = u->child[1];\n", "\t\t\tu->child[1] = 0;\n", "\t\t}\n", "\t}\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "void globsort(word *left,word *right)\n", "\n", "{\n", "  char *pcVar1;\n", "  word *pwVar2;\n", "  char **ppcVar3;\n", "  int iVar4;\n", "  char **__base;\n", "  \n", "  if (left == right) {\n", "    __base = (char **)emalloc(0);\n", "    qsort(__base,0,8,globcmp);\n", "  }\n", "  else {\n", "    iVar4 = 0;\n", "    pwVar2 = left;\n", "    do {\n", "      pwVar2 = pwVar2->next;\n", "      iVar4 = iVar4 + 1;\n", "    } while (right != pwVar2);\n", "    __base = (char **)emalloc((long)iVar4 << 3);\n", "    iVar4 = 0;\n", "    ppcVar3 = __base;\n", "    pwVar2 = left;\n", "    do {\n", "      iVar4 = iVar4 + 1;\n", "      *ppcVar3 = pwVar2->word;\n", "      pwVar2 = pwVar2->next;\n", "      ppcVar3 = ppcVar3 + 1;\n", "    } while (right != pwVar2);\n", "    qsort(__base,(long)iVar4,8,globcmp);\n", "    ppcVar3 = __base;\n", "    do {\n", "      pcVar1 = *ppcVar3;\n", "      ppcVar3 = ppcVar3 + 1;\n", "      left->word = pcVar1;\n", "      left = left->next;\n", "    } while (right != left);\n", "  }\n", "  efree((char *)__base);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "globsort(word *left, word *right)\n", "{\n", "\tchar **list;\n", "\tword *a;\n", "\tint n = 0;\n", "\tfor(a = left;a!=right;a = a->next) n++;\n", "\tlist = (char **)emalloc(n*sizeof(char *));\n", "\tfor(a = left,n = 0;a!=right;a = a->next,n++) list[n] = a->word;\n", "\tqsort((void *)list, n, sizeof(void *), globcmp);\n", "\tfor(a = left,n = 0;a!=right;a = a->next,n++) a->word = list[n];\n", "\tefree((char *)list);\n", "}"]}, {"ghidra": ["\n", "void addwaitpid(int pid)\n", "\n", "{\n", "  long lVar1;\n", "  \n", "  waitpids = (int *)p9realloc(waitpids,(long)(nwaitpids + 1) << 2);\n", "  if (waitpids != (int *)0x0) {\n", "    lVar1 = (long)nwaitpids;\n", "    nwaitpids = nwaitpids + 1;\n", "    waitpids[lVar1] = pid;\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  panic(\"Can\\'t realloc %d waitpids\",nwaitpids + 1);\n", "}\n", "\n"], "c": ["void\n", "addwaitpid(int pid)\n", "{\n", "\twaitpids = realloc(waitpids, (nwaitpids+1)*sizeof waitpids[0]);\n", "\tif(waitpids == 0)\n", "\t\tpanic(\"Can't realloc %d waitpids\", nwaitpids+1);\n", "\twaitpids[nwaitpids++] = pid;\n", "}"]}, {"ghidra": ["\n", "void execrfork(void)\n", "\n", "{\n", "  char cVar1;\n", "  word *pwVar2;\n", "  char *pcVar3;\n", "  int iVar4;\n", "  uint flags;\n", "  \n", "  iVar4 = count(runq->argv->words);\n", "  if (iVar4 == 1) {\n", "    iVar4 = p9rfork(0xb);\n", "  }\n", "  else {\n", "    pwVar2 = runq->argv->words;\n", "    if (iVar4 != 2) {\n", "Usage:\n", "      pfmt(rc_err,\"Usage: %s [nNeEsfF]\\n\",pwVar2->word);\n", "      setstatus(\"rfork usage\");\n", "      poplist();\n", "      return;\n", "    }\n", "    flags = 0;\n", "    pcVar3 = pwVar2->next->word;\n", "    cVar1 = *pcVar3;\n", "    while (cVar1 != '\\0') {\n", "      switch(cVar1) {\n", "      case 'E':\n", "        cVar1 = pcVar3[1];\n", "        flags = flags | 0x800;\n", "        break;\n", "      case 'F':\n", "        flags = flags | 0x1000;\n", "      case 'e':\n", "        cVar1 = pcVar3[1];\n", "        break;\n", "      default:\n", "        goto Usage;\n", "      case 'N':\n", "        cVar1 = pcVar3[1];\n", "        flags = flags | 0x400;\n", "        break;\n", "      case 'f':\n", "        cVar1 = pcVar3[1];\n", "        flags = flags | 4;\n", "        break;\n", "      case 'n':\n", "        cVar1 = pcVar3[1];\n", "        flags = flags | 1;\n", "        break;\n", "      case 's':\n", "        cVar1 = pcVar3[1];\n", "        flags = flags | 8;\n", "      }\n", "      pcVar3 = pcVar3 + 1;\n", "    }\n", "    iVar4 = p9rfork(flags);\n", "  }\n", "  if (iVar4 != -1) {\n", "    setstatus(\"\");\n", "    poplist();\n", "    return;\n", "  }\n", "  pfmt(rc_err,\"rc: %s failed\\n\",runq->argv->words->word);\n", "  setstatus(\"rfork failed\");\n", "  poplist();\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execrfork(void)\n", "{\n", "\tint arg;\n", "\tchar *s;\n", "\n", "\tswitch(count(runq->argv->words)){\n", "\tcase 1:\n", "\t\targ = RFENVG|RFNOTEG|RFNAMEG;\n", "\t\tbreak;\n", "\tcase 2:\n", "\t\targ = 0;\n", "\t\tfor(s = runq->argv->words->next->word;*s;s++) switch(*s){\n", "\t\tdefault:\n", "\t\t\tgoto Usage;\n", "\t\tcase 'n':\n", "\t\t\targ|=RFNAMEG;  break;\n", "\t\tcase 'N':\n", "\t\t\targ|=RFCNAMEG;\n", "\t\t\tbreak;\n", "\t\tcase 'e':\n", "\t\t\t/* arg|=RFENVG; */  break;\n", "\t\tcase 'E':\n", "\t\t\targ|=RFCENVG;  break;\n", "\t\tcase 's':\n", "\t\t\targ|=RFNOTEG;  break;\n", "\t\tcase 'f':\n", "\t\t\targ|=RFFDG;    break;\n", "\t\tcase 'F':\n", "\t\t\targ|=RFCFDG;   break;\n", "\t\t}\n", "\t\tbreak;\n", "\tdefault:\n", "\tUsage:\n", "\t\tpfmt(err, \"Usage: %s [nNeEsfF]\\n\", runq->argv->words->word);\n", "\t\tsetstatus(\"rfork usage\");\n", "\t\tpoplist();\n", "\t\treturn;\n", "\t}\n", "\tif(rfork(arg)==-1){\n", "\t\tpfmt(err, \"rc: %s failed\\n\", runq->argv->words->word);\n", "\t\tsetstatus(\"rfork failed\");\n", "\t}\n", "\telse\n", "\t\tsetstatus(\"\");\n", "\tpoplist();\n", "}"]}, {"ghidra": ["\n", "int hash(char *s,int n)\n", "\n", "{\n", "  char cVar1;\n", "  int iVar2;\n", "  int iVar3;\n", "  int iVar4;\n", "  \n", "  cVar1 = *s;\n", "  if (cVar1 != '\\0') {\n", "    iVar4 = 1;\n", "    iVar2 = 0;\n", "    do {\n", "      iVar3 = cVar1 * iVar4;\n", "      s = s + 1;\n", "      iVar4 = iVar4 + 1;\n", "      iVar2 = iVar2 + iVar3;\n", "      cVar1 = *s;\n", "    } while (cVar1 != '\\0');\n", "    iVar2 = iVar2 % n;\n", "    if (iVar2 < 0) {\n", "      iVar2 = n + iVar2;\n", "    }\n", "    return iVar2;\n", "  }\n", "  return 0;\n", "}\n", "\n"], "c": ["int\n", "hash(char *s, int n)\n", "{\n", "\tint h = 0, i = 1;\n", "\twhile(*s) h+=*s++*i++;\n", "\th%=n;\n", "\treturn h<0?h+n:h;\n", "}"]}, {"ghidra": ["\n", "void * mallocz(ulong n,int clr)\n", "\n", "{\n", "  void *__s;\n", "  \n", "  __s = p9malloc(n);\n", "  if ((__s != (void *)0x0) && (clr != 0)) {\n", "    memset(__s,0,n);\n", "  }\n", "  return __s;\n", "}\n", "\n"], "c": ["void*\n", "mallocz(unsigned long n, int clr)\n", "{\n", "\tvoid *v;\n", "\n", "\tv = malloc(n);\n", "\tif(clr && v)\n", "\t\tmemset(v, 0, n);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void pstr(io *f,char *s)\n", "\n", "{\n", "  char cVar1;\n", "  \n", "  if (s == (char *)0x0) {\n", "    s = \"(null)\";\n", "  }\n", "  cVar1 = *s;\n", "  while (cVar1 != '\\0') {\n", "    s = s + 1;\n", "    pchr(f,(int)cVar1);\n", "    cVar1 = *s;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pstr(io *f, char *s)\n", "{\n", "\tif(s==0)\n", "\t\ts=\"(null)\";\n", "\twhile(*s) pchr(f, *s++);\n", "}"]}, {"ghidra": ["\n", "int rwakeup(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeup(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 0, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int wordchr(int c)\n", "\n", "{\n", "  char *pcVar1;\n", "  \n", "  pcVar1 = strchr(\"\\n \\t#;&|^$=`\\'{}()<>\",c);\n", "  return (int)(uint)(pcVar1 == (char *)0x0 && c != -1);\n", "}\n", "\n"], "c": ["int\n", "wordchr(int c)\n", "{\n", "\treturn !strchr(\"\\n \\t#;&|^$=`'{}()<>\", c) && c!=EOF;\n", "}"]}, {"ghidra": ["\n", "int morecode(void)\n", "\n", "{\n", "  ulong uVar1;\n", "  undefined8 *puVar2;\n", "  byte bVar3;\n", "  \n", "  bVar3 = 0;\n", "  ncode = ncode + 100;\n", "  codebuf = (code *)p9realloc(codebuf,(long)ncode << 3);\n", "  if (codebuf != (code *)0x0) {\n", "    puVar2 = codebuf + (long)ncode + -100;\n", "    *puVar2 = 0;\n", "    puVar2[99] = 0;\n", "    uVar1 = (ulong)(((int)puVar2 - (int)(undefined8 *)((ulong)(puVar2 + 1) & 0xfffffffffffffff8)) +\n", "                    800U >> 3);\n", "    puVar2 = (undefined8 *)((ulong)(puVar2 + 1) & 0xfffffffffffffff8);\n", "    while (uVar1 != 0) {\n", "      uVar1 = uVar1 - 1;\n", "      *puVar2 = 0;\n", "      puVar2 = puVar2 + (ulong)bVar3 * 0x1ffffffffffffffe + 1;\n", "    }\n", "    return 0;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  panic(\"Can\\'t realloc %d bytes in morecode!\",ncode * 8);\n", "}\n", "\n"], "c": ["int\n", "morecode(void)\n", "{\n", "\tncode+=100;\n", "\tcodebuf = (code *)realloc((char *)codebuf, ncode*sizeof codebuf[0]);\n", "\tif(codebuf==0)\n", "\t\tpanic(\"Can't realloc %d bytes in morecode!\",\n", "\t\t\t\tncode*sizeof codebuf[0]);\n", "\tmemset(codebuf+ncode-100, 0, 100*sizeof codebuf[0]);\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int rchr(io *b)\n", "\n", "{\n", "  byte *pbVar1;\n", "  int iVar2;\n", "  \n", "  pbVar1 = (byte *)b->bufp;\n", "  if (pbVar1 != (byte *)b->ebuf) {\n", "    *(byte **)&b->bufp = pbVar1 + 1;\n", "    return (int)(uint)*pbVar1;\n", "  }\n", "  iVar2 = emptybuf(b);\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rchr(io *b)\n", "{\n", "\tif(b->bufp==b->ebuf)\n", "\t\treturn emptybuf(b);\n", "\treturn *b->bufp++ & 0xFF;\n", "}"]}, {"ghidra": ["\n", "void kenter(int type,char *name)\n", "\n", "{\n", "  char cVar1;\n", "  kw *pkVar2;\n", "  int iVar3;\n", "  int iVar4;\n", "  char *pcVar5;\n", "  int iVar6;\n", "  \n", "  cVar1 = *name;\n", "  if (cVar1 == '\\0') {\n", "    iVar3 = 0;\n", "  }\n", "  else {\n", "    iVar6 = 0;\n", "    iVar3 = 1;\n", "    pcVar5 = name;\n", "    do {\n", "      iVar4 = cVar1 * iVar3;\n", "      pcVar5 = pcVar5 + 1;\n", "      iVar3 = iVar3 + 1;\n", "      iVar6 = iVar6 + iVar4;\n", "      cVar1 = *pcVar5;\n", "    } while (cVar1 != '\\0');\n", "    iVar6 = iVar6 % 0x1e;\n", "    iVar3 = iVar6 + 0x1e;\n", "    if (-1 < iVar6) {\n", "      iVar3 = iVar6;\n", "    }\n", "  }\n", "  pkVar2 = (kw *)emalloc(0x18);\n", "  pkVar2->name = name;\n", "  pkVar2->type = type;\n", "  pkVar2->next = kw[iVar3];\n", "  kw[iVar3] = pkVar2;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "kenter(int type, char *name)\n", "{\n", "\tint h = hash(name, NKW);\n", "\tstruct kw *p = new(struct kw);\n", "\tp->type = type;\n", "\tp->name = name;\n", "\tp->next = kw[h];\n", "\tkw[h] = p;\n", "}"]}, {"ghidra": ["\n", "int canwlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->writer == (_Thread *)0x0) && (l->readers == 0)) {\n", "      l->writer = (_Thread *)0x1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canwlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\treturn (*_wlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer || l->readers)\n", "\t\t\treturn 0;\n", "\t\tl->writer = (void*)1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "ulong octal(char *param_1)\n", "\n", "{\n", "  char cVar1;\n", "  ulong uVar2;\n", "  \n", "  while ((cVar1 = *param_1, (byte)(cVar1 - 9U) < 2 || (cVar1 == ' '))) {\n", "    param_1 = param_1 + 1;\n", "  }\n", "  uVar2 = 0;\n", "  if (7 < (byte)(cVar1 - 0x30U)) {\n", "    return uVar2;\n", "  }\n", "  do {\n", "    param_1 = param_1 + 1;\n", "    uVar2 = (ulong)(uint)((int)cVar1 + -0x30 + (int)uVar2 * 8);\n", "    cVar1 = *param_1;\n", "  } while ((byte)(cVar1 - 0x30U) < 8);\n", "  return uVar2;\n", "}\n", "\n"], "c": ["int\n", "octal(char *s)\n", "{\n", "\tint n = 0;\n", "\twhile(*s==' ' || *s=='\\t' || *s=='\\n') s++;\n", "\twhile('0'<=*s && *s<='7') n = n*8+*s++-'0';\n", "\treturn n;\n", "}"]}, {"ghidra": ["\n", "int postnote(int who,int pid,char *msg)\n", "\n", "{\n", "  int __sig;\n", "  __pid_t __pgrp;\n", "  \n", "  __sig = _p9strsig(msg);\n", "  if (__sig == 0) {\n", "    werrstr(\"unknown note\");\n", "  }\n", "  else {\n", "    if (who == 1) {\n", "      __sig = kill(pid,__sig);\n", "      return __sig;\n", "    }\n", "    if (who == 2) {\n", "      __pgrp = getpgid(pid);\n", "      if (-1 < __pgrp) {\n", "        __sig = killpg(__pgrp,__sig);\n", "        return __sig;\n", "      }\n", "    }\n", "    else {\n", "      werrstr(\"bad who in postnote\");\n", "    }\n", "  }\n", "  return -1;\n", "}\n", "\n"], "c": ["int\n", "postnote(int who, int pid, char *msg)\n", "{\n", "\tint sig;\n", "\n", "\tsig = _p9strsig(msg);\n", "\tif(sig == 0){\n", "\t\twerrstr(\"unknown note\");\n", "\t\treturn -1;\n", "\t}\n", "\n", "\tswitch(who){\n", "\tdefault:\n", "\t\twerrstr(\"bad who in postnote\");\n", "\t\treturn -1;\n", "\tcase PNPROC:\n", "\t\treturn kill(pid, sig);\n", "\tcase PNGROUP:\n", "\t\tif((pid = getpgid(pid)) < 0)\n", "\t\t\treturn -1;\n", "\t\treturn killpg(pid, sig);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "Dir * dirfstat(int fd)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  Dir *d;\n", "  long in_FS_OFFSET;\n", "  char *str;\n", "  stat st;\n", "  char tmp [100];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar2 = __fxstat64(1,fd,(stat64 *)&st);\n", "  if (-1 < iVar2) {\n", "    snprint(tmp,100,\"/dev/fd/%d\");\n", "    iVar2 = _p9dir(&st,&st,tmp,(Dir *)0x0,(char **)0x0,(char *)0x0);\n", "    d = (Dir *)mallocz((long)iVar2 + 0x78,1);\n", "    if (d != (Dir *)0x0) {\n", "      str = (char *)(d + 1);\n", "      _p9dir(&st,&st,tmp,d,&str,(char *)((long)&((Dir *)str)->type + (long)iVar2));\n", "      goto LAB_0040e755;\n", "    }\n", "  }\n", "  d = (Dir *)0x0;\n", "LAB_0040e755:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return d;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["Dir*\n", "dirfstat(int fd)\n", "{\n", "\tstruct stat st;\n", "\tint nstr;\n", "\tDir *d;\n", "\tchar *str, tmp[100];\n", "\n", "\tif(fstat(fd, &st) < 0)\n", "\t\treturn nil;\n", "\n", "\tsnprint(tmp, sizeof tmp, \"/dev/fd/%d\", fd);\n", "\tnstr = _p9dir(&st, &st, tmp, nil, nil, nil);\n", "\td = mallocz(sizeof(Dir)+nstr, 1);\n", "\tif(d == nil)\n", "\t\treturn nil;\n", "\tstr = (char*)&d[1];\n", "\t_p9dir(&st, &st, tmp, d, &str, str+nstr);\n", "\treturn d;\n", "}"]}, {"ghidra": ["\n", "int p9rfork(int flags)\n", "\n", "{\n", "  uint uVar1;\n", "  __pid_t __pid;\n", "  int iVar2;\n", "  long lVar3;\n", "  ulong uVar4;\n", "  long in_FS_OFFSET;\n", "  bool bVar5;\n", "  int status;\n", "  int p [2];\n", "  char *q;\n", "  char buf [128];\n", "  long local_20;\n", "  \n", "  uVar4 = (ulong)(uint)flags;\n", "  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if ((flags & 0x34U) == 0x14) {\n", "    uVar4 = (ulong)(flags & 0xfffff7a0U);\n", "    if ((flags & 0xfffff7a0U) != 0) goto LAB_0040ff52;\n", "    if ((flags & 0x40U) == 0) {\n", "      uVar1 = fork();\n", "      if (uVar1 != 0xffffffff) {\n", "        uVar4 = (ulong)(flags & 0xffffffe9);\n", "LAB_0040fd95:\n", "        if (uVar1 != 0) goto LAB_0040fd48;\n", "LAB_0040fd99:\n", "        if (((uVar4 & 0x800) != 0) && (environ != (undefined8 *)0x0)) {\n", "          *environ = 0;\n", "        }\n", "        goto LAB_0040fd18;\n", "      }\n", "    }\n", "    else {\n", "      signal(0x11,nop);\n", "      iVar2 = p9pipe(p);\n", "      if ((-1 < iVar2) && (__pid = fork(), __pid != -1)) {\n", "        uVar4 = (ulong)(flags & 0xffffffa9);\n", "        if (__pid != 0) {\n", "          close(p[1]);\n", "          status = 0;\n", "          __pid = wait4(__pid,&status,0,(rusage *)0x0);\n", "          if (__pid < 0) {\n", "            werrstr(\"pipe dance - wait4 - %r\");\n", "            close(p[0]);\n", "            uVar1 = 0xffffffff;\n", "            goto LAB_0040fd48;\n", "          }\n", "          lVar3 = readn(p[0],buf,0x7f);\n", "          close(p[0]);\n", "          if ((status & 0x7fU) != 0) {\n", "            werrstr(\"pipe dance - !exited 0x%ux\",(ulong)(uint)status);\n", "            uVar1 = 0xffffffff;\n", "            goto LAB_0040fd48;\n", "          }\n", "          bVar5 = (char)((ulong)(uint)status >> 8) == '\\0';\n", "          iVar2 = (int)lVar3;\n", "          if (iVar2 < 1) {\n", "            if (bVar5) {\n", "              if (iVar2 < 0) {\n", "                werrstr(\"pipe dance - pipe read error - %r\");\n", "                uVar1 = 0xffffffff;\n", "              }\n", "              else {\n", "                if (iVar2 == 0) {\n", "                  werrstr(\"pipe dance - pipe read eof\");\n", "                  uVar1 = 0xffffffff;\n", "                }\n", "                else {\n", "                  werrstr(\"pipe dance - unknown failure\");\n", "                  uVar1 = 0xffffffff;\n", "                }\n", "              }\n", "              goto LAB_0040fd48;\n", "            }\n", "          }\n", "          else {\n", "            if (bVar5) {\n", "              buf[iVar2] = '\\0';\n", "              if (buf[0] == 'x') {\n", "                werrstr(\"%s\",buf + 2);\n", "                uVar1 = 0xffffffff;\n", "                goto LAB_0040fd48;\n", "              }\n", "              lVar3 = strtol(buf,&q,0);\n", "              uVar1 = (uint)lVar3;\n", "              goto LAB_0040fd95;\n", "            }\n", "          }\n", "          werrstr(\"pipe dance - non-zero status 0x%ux\",(ulong)(uint)status);\n", "          uVar1 = 0xffffffff;\n", "          goto LAB_0040fd48;\n", "        }\n", "        signal(0x11,(__sighandler_t)0x1);\n", "        close(p[0]);\n", "        uVar1 = fork();\n", "        if (uVar1 != 0) {\n", "          if ((int)uVar1 < 1) {\n", "            fprint(p[1],\"x %r\");\n", "          }\n", "          else {\n", "            fprint(p[1],\"%d\",(ulong)uVar1);\n", "          }\n", "          close(p[1]);\n", "                    /* WARNING: Subroutine does not return */\n", "          _exit(0);\n", "        }\n", "        close(p[1]);\n", "        goto LAB_0040fd99;\n", "      }\n", "    }\n", "  }\n", "  else {\n", "LAB_0040fd18:\n", "    if ((uVar4 & 0x10) != 0) {\n", "      werrstr(\"cannot use rfork for shared memory -- use libthread\");\n", "      uVar1 = 0xffffffff;\n", "      goto LAB_0040fd48;\n", "    }\n", "    if ((uVar4 & 1) != 0) {\n", "      uVar4 = (ulong)((uint)uVar4 & 0xfffffffe);\n", "    }\n", "    if ((uVar4 & 8) != 0) {\n", "      __pid = getpid();\n", "      uVar4 = (ulong)((uint)uVar4 & 0xfffffff7);\n", "      setpgid(0,__pid);\n", "    }\n", "    uVar1 = (uint)uVar4 & 0x40;\n", "    if ((uVar4 & 0x40) != 0) {\n", "      werrstr(\"cannot use RFNOWAIT without RFPROC\");\n", "      uVar1 = 0xffffffff;\n", "      goto LAB_0040fd48;\n", "    }\n", "    if ((uint)uVar4 == 0) goto LAB_0040fd48;\n", "LAB_0040ff52:\n", "    werrstr(\"unknown flags %08ux in rfork\",uVar4);\n", "  }\n", "  uVar1 = 0xffffffff;\n", "LAB_0040fd48:\n", "  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return (int)uVar1;\n", "}\n", "\n"], "c": ["int\n", "p9rfork(int flags)\n", "{\n", "\tint pid, status;\n", "\tint p[2];\n", "\tint n;\n", "\tchar buf[128], *q;\n", "\textern char **environ;\n", "\n", "\tif((flags&(RFPROC|RFFDG|RFMEM)) == (RFPROC|RFFDG)){\n", "\t\t/* check other flags before we commit */\n", "\t\tflags &= ~(RFPROC|RFFDG|RFENVG);\n", "\t\tn = (flags & ~(RFNOTEG|RFNAMEG|RFNOWAIT|RFCENVG));\n", "\t\tif(n){\n", "\t\t\twerrstr(\"unknown flags %08ux in rfork\", n);\n", "\t\t\treturn -1;\n", "\t\t}\n", "\t\tif(flags&RFNOWAIT){\n", "\t\t\t/*\n", "\t\t\t * BUG - should put the signal handler back after we\n", "\t\t\t * finish, but I just don't care.  If a program calls with\n", "\t\t\t * NOWAIT once, they're not likely to want child notes\n", "\t\t\t * after that.\n", "\t\t\t */\n", "\t\t\tsignal(SIGCHLD, nop);\n", "\t\t\tif(pipe(p) < 0)\n", "\t\t\t\treturn -1;\n", "\t\t}\n", "\t\tpid = fork();\n", "\t\tif(pid == -1)\n", "\t\t\treturn -1;\n", "\t\tif(flags&RFNOWAIT){\n", "\t\t\tflags &= ~RFNOWAIT;\n", "\t\t\tif(pid){\n", "\t\t\t\t/*\n", "\t\t\t\t * Parent - wait for child to fork wait-free child.\n", "\t\t\t\t * Then read pid from pipe.  Assume pipe buffer can absorb the write.\n", "\t\t\t\t */\n", "\t\t\t\tclose(p[1]);\n", "\t\t\t\tstatus = 0;\n", "\t\t\t\tif(wait4(pid, &status, 0, 0) < 0){\n", "\t\t\t\t\twerrstr(\"pipe dance - wait4 - %r\");\n", "\t\t\t\t\tclose(p[0]);\n", "\t\t\t\t\treturn -1;\n", "\t\t\t\t}\n", "\t\t\t\tn = readn(p[0], buf, sizeof buf-1);\n", "\t\t\t\tclose(p[0]);\n", "\t\t\t\tif(!WIFEXITED(status) || WEXITSTATUS(status)!=0 || n <= 0){\n", "\t\t\t\t\tif(!WIFEXITED(status))\n", "\t\t\t\t\t\twerrstr(\"pipe dance - !exited 0x%ux\", status);\n", "\t\t\t\t\telse if(WEXITSTATUS(status) != 0)\n", "\t\t\t\t\t\twerrstr(\"pipe dance - non-zero status 0x%ux\", status);\n", "\t\t\t\t\telse if(n < 0)\n", "\t\t\t\t\t\twerrstr(\"pipe dance - pipe read error - %r\");\n", "\t\t\t\t\telse if(n == 0)\n", "\t\t\t\t\t\twerrstr(\"pipe dance - pipe read eof\");\n", "\t\t\t\t\telse\n", "\t\t\t\t\t\twerrstr(\"pipe dance - unknown failure\");\n", "\t\t\t\t\treturn -1;\n", "\t\t\t\t}\n", "\t\t\t\tbuf[n] = 0;\n", "\t\t\t\tif(buf[0] == 'x'){\n", "\t\t\t\t\twerrstr(\"%s\", buf+2);\n", "\t\t\t\t\treturn -1;\n", "\t\t\t\t}\n", "\t\t\t\tpid = strtol(buf, &q, 0);\n", "\t\t\t}else{\n", "\t\t\t\t/*\n", "\t\t\t\t * Child - fork a new child whose wait message can't \n", "\t\t\t\t * get back to the parent because we're going to exit!\n", "\t\t\t\t */\n", "\t\t\t\tsignal(SIGCHLD, SIG_IGN);\n", "\t\t\t\tclose(p[0]);\n", "\t\t\t\tpid = fork();\n", "\t\t\t\tif(pid){\n", "\t\t\t\t\t/* Child parent - send status over pipe and exit. */\n", "\t\t\t\t\tif(pid > 0)\n", "\t\t\t\t\t\tfprint(p[1], \"%d\", pid);\n", "\t\t\t\t\telse\n", "\t\t\t\t\t\tfprint(p[1], \"x %r\");\n", "\t\t\t\t\tclose(p[1]);\n", "\t\t\t\t\t_exit(0);\n", "\t\t\t\t}else{\n", "\t\t\t\t\t/* Child child - close pipe. */\n", "\t\t\t\t\tclose(p[1]);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(pid != 0)\n", "\t\t\treturn pid;\n", "\t\tif(flags&RFCENVG)\n", "\t\t\tif(environ)\n", "\t\t\t\t*environ = nil;\n", "\t}\n", "\tif(flags&RFPROC){\n", "\t\twerrstr(\"cannot use rfork for shared memory -- use libthread\");\n", "\t\treturn -1;\n", "\t}\n", "\tif(flags&RFNAMEG){\n", "\t\t/* XXX set $NAMESPACE to a new directory */\n", "\t\tflags &= ~RFNAMEG;\n", "\t}\n", "\tif(flags&RFNOTEG){\n", "\t\tsetpgid(0, getpid());\n", "\t\tflags &= ~RFNOTEG;\n", "\t}\n", "\tif(flags&RFNOWAIT){\n", "\t\twerrstr(\"cannot use RFNOWAIT without RFPROC\");\n", "\t\treturn -1;\n", "\t}\n", "\tif(flags){\n", "\t\twerrstr(\"unknown flags %08ux in rfork\", flags);\n", "\t\treturn -1;\n", "\t}\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void * p9calloc(ulong a,ulong b)\n", "\n", "{\n", "  void *pvVar1;\n", "  size_t __nmemb;\n", "  \n", "  __nmemb = a * b;\n", "  if (__nmemb == 0) {\n", "    __nmemb = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = calloc(__nmemb,1);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9calloc(ulong a, ulong b)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(a*b == 0)\n", "\t\ta = b = 1;\n", "\n", "\tlock(&malloclock);\n", "\tv = calloc(a*b, 1);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void werrstr(char *fmt,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list arg;\n", "  char buf [128];\n", "  char local_c8 [8];\n", "  long local_c0;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n", "  arg[0].overflow_arg_area = &stack0x00000008;\n", "  arg[0].reg_save_area = local_b8;\n", "  arg[0].gp_offset = 8;\n", "  arg[0].fp_offset = 0x30;\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  vseprint(buf,local_c8,fmt,arg);\n", "  errstr(buf,0x80);\n", "  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "werrstr(char *fmt, ...)\n", "{\n", "\tva_list arg;\n", "\tchar buf[ERRMAX];\n", "\n", "\tva_start(arg, fmt);\n", "\tvseprint(buf, buf+ERRMAX, fmt, arg);\n", "\tva_end(arg);\n", "\terrstr(buf, ERRMAX);\n", "}"]}, {"ghidra": ["\n", "void dotrap(void)\n", "\n", "{\n", "  int iVar1;\n", "  word *a;\n", "  thread *ptVar2;\n", "  __pid_t _Var3;\n", "  var *next;\n", "  word *pwVar4;\n", "  char *stat;\n", "  int iVar5;\n", "  long lVar6;\n", "  \n", "  next = vlook(\"*\");\n", "  a = next->val;\n", "  iVar5 = ntrap;\n", "  while (iVar5 != 0) {\n", "    lVar6 = 0;\n", "    do {\n", "      while (trap[lVar6] != 0) {\n", "        ntrap = iVar5 + -1;\n", "        trap[lVar6] = trap[lVar6] + -1;\n", "        _Var3 = getpid();\n", "        if (_Var3 != mypid) {\n", "          stat = getstatus();\n", "          Exit(stat);\n", "        }\n", "        next = vlook(Signame[lVar6]);\n", "        if (next->fn == (code *)0x0) {\n", "          if ((int)lVar6 - 2U < 2) {\n", "            iVar1 = runq->iflag;\n", "            while (iVar5 = ntrap, iVar1 == 0) {\n", "              Xreturn();\n", "              iVar1 = runq->iflag;\n", "            }\n", "          }\n", "          else {\n", "            stat = getstatus();\n", "            Exit(stat);\n", "            iVar5 = ntrap;\n", "          }\n", "        }\n", "        else {\n", "          start(next->fn,next->pc,(var *)0x0);\n", "          ptVar2 = runq;\n", "          next = runq->local;\n", "          stat = p9strdup(\"*\");\n", "          next = newvar(stat,next);\n", "          ptVar2->local = next;\n", "          next = runq->local;\n", "          pwVar4 = copywords(a,(word *)0x0);\n", "          next->val = pwVar4;\n", "          ptVar2 = runq;\n", "          runq->local->changed = 1;\n", "          ptVar2->startredir = (redir *)0x0;\n", "          ptVar2->redir = (redir *)0x0;\n", "          iVar5 = ntrap;\n", "        }\n", "      }\n", "      lVar6 = lVar6 + 1;\n", "    } while (lVar6 != 0x20);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "dotrap(void)\n", "{\n", "\tint i;\n", "\tstruct var *trapreq;\n", "\tstruct word *starval;\n", "\tstarval = vlook(\"*\")->val;\n", "\twhile(ntrap) for(i = 0;i!=NSIG;i++) while(trap[i]){\n", "\t\t--trap[i];\n", "\t\t--ntrap;\n", "\t\tif(getpid()!=mypid) Exit(getstatus());\n", "\t\ttrapreq = vlook(Signame[i]);\n", "\t\tif(trapreq->fn){\n", "\t\t\tstart(trapreq->fn, trapreq->pc, (struct var *)0);\n", "\t\t\trunq->local = newvar(strdup(\"*\"), runq->local);\n", "\t\t\trunq->local->val = copywords(starval, (struct word *)0);\n", "\t\t\trunq->local->changed = 1;\n", "\t\t\trunq->redir = runq->startredir = 0;\n", "\t\t}\n", "\t\telse if(i==SIGINT || i==SIGQUIT){\n", "\t\t\t/*\n", "\t\t\t * run the stack down until we uncover the\n", "\t\t\t * command reading loop.  Xreturn will exit\n", "\t\t\t * if there is none (i.e. if this is not\n", "\t\t\t * an interactive rc.)\n", "\t\t\t */\n", "\t\t\twhile(!runq->iflag) Xreturn();\n", "\t\t}\n", "\t\telse Exit(getstatus());\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void exits(char *s)\n", "\n", "{\n", "  anon_subr_void_for_f *paVar1;\n", "  __pid_t _Var2;\n", "  int __status;\n", "  anon_struct_conflict1 *paVar3;\n", "  \n", "  paVar3 = onex + 0x20;\n", "  _Var2 = getpid();\n", "  do {\n", "    while ((paVar1 = paVar3->f, paVar1 != (anon_subr_void_for_f *)0x0 && (paVar3->pid == _Var2))) {\n", "      paVar3->f = (anon_subr_void_for_f *)0x0;\n", "      paVar3 = paVar3 + -1;\n", "      (*paVar1)();\n", "      if (paVar3 == (anon_struct_conflict1 *)&DAT_0061de70) goto LAB_0040e4a0;\n", "    }\n", "    paVar3 = paVar3 + -1;\n", "  } while (paVar3 != (anon_struct_conflict1 *)&DAT_0061de70);\n", "LAB_0040e4a0:\n", "  if ((s != (char *)0x0) && (*s != '\\0')) {\n", "    __status = exitcode(s);\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(__status);\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(0);\n", "}\n", "\n"], "c": ["void\n", "exits(char *s)\n", "{\n", "\tint i, pid;\n", "\tvoid (*f)(void);\n", "\n", "\tpid = getpid();\n", "\tfor(i = NEXIT-1; i >= 0; i--)\n", "\t\tif((f = onex[i].f) && pid == onex[i].pid) {\n", "\t\t\tonex[i].f = 0;\n", "\t\t\t(*f)();\n", "\t\t}\n", "\tif(s == 0 || *s == 0)\n", "\t\texit(0);\n", "\texit(exitcode(s));\n", "}"]}, {"ghidra": ["\n", "void runlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _runlock;\n", "  if (_runlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->readers = l->readers + -1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "runlock(RWLock *l)\n", "{\n", "\tif(_runlock)\n", "\t\t(*_runlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->readers--;\n", "}"]}, {"ghidra": ["\n", "int p9create(char *path,int mode,ulong perm)\n", "\n", "{\n", "  long lVar1;\n", "  uint uVar2;\n", "  int __fd;\n", "  int iVar3;\n", "  int iVar4;\n", "  uint __oflag;\n", "  uint uVar5;\n", "  long in_FS_OFFSET;\n", "  flock fl;\n", "  \n", "  uVar5 = mode & 3;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if ((perm & 0x80000000) == 0) {\n", "    if ((mode & 0x80U) == 0) {\n", "      __oflag = uVar5 | 0x240;\n", "      uVar2 = mode & 0xffffdf8c;\n", "    }\n", "    else {\n", "      __oflag = uVar5 | 0x4240;\n", "      uVar2 = mode & 0xffffdf0c;\n", "    }\n", "    if ((uVar2 & 0x1000) != 0) {\n", "      __oflag = __oflag | 0x80;\n", "      uVar2 = uVar2 & 0xffffefff;\n", "    }\n", "    if ((uVar2 & 0x4000) != 0) {\n", "      __oflag = __oflag | 0x400;\n", "      uVar2 = uVar2 & 0xffffbfff;\n", "    }\n", "    if (uVar2 == 0) {\n", "      __fd = open64(path,__oflag);\n", "out:\n", "      iVar4 = __fd;\n", "      if (-1 < __fd) {\n", "        if ((mode & 0x2000U) != 0) {\n", "          fl.l_type = ZEXT12(uVar5 != 0);\n", "          fl.l_start = 0;\n", "          fl.l_whence = 0;\n", "          fl.l_len = 0;\n", "          iVar3 = fcntl(__fd,6,&fl);\n", "          if (iVar3 < 0) {\n", "            iVar4 = -1;\n", "            close(__fd);\n", "            werrstr(\"lock: %r\");\n", "            goto LAB_0040e539;\n", "          }\n", "        }\n", "        if ((mode & 0x20U) != 0) {\n", "          fcntl(__fd,2,1);\n", "        }\n", "        if ((mode & 0x40U) != 0) {\n", "          remove(path);\n", "        }\n", "      }\n", "      goto LAB_0040e539;\n", "    }\n", "    werrstr(\"unsupported mode in create\");\n", "  }\n", "  else {\n", "    if ((mode & 0xffffdf9fU) == 0) {\n", "      __fd = mkdir(path,(uint)perm & 0x1ff);\n", "      if (-1 < __fd) {\n", "        __fd = open64(path,0);\n", "        goto out;\n", "      }\n", "    }\n", "    else {\n", "      werrstr(\"bad mode in directory create\");\n", "    }\n", "  }\n", "  iVar4 = -1;\n", "LAB_0040e539:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return iVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "p9create(char *path, int mode, ulong perm)\n", "{\n", "\tint fd, cexec, umode, rclose, lock, rdwr;\n", "\tstruct flock fl;\n", "\n", "\trdwr = mode&3;\n", "\tlock = mode&OLOCK;\n", "\tcexec = mode&OCEXEC;\n", "\trclose = mode&ORCLOSE;\n", "\tmode &= ~(ORCLOSE|OCEXEC|OLOCK);\n", "\n", "\t/* XXX should get mode mask right? */\n", "\tfd = -1;\n", "\tif(perm&DMDIR){\n", "\t\tif(mode != OREAD){\n", "\t\t\twerrstr(\"bad mode in directory create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tif(mkdir(path, perm&0777) < 0)\n", "\t\t\tgoto out;\n", "\t\tfd = open(path, O_RDONLY);\n", "\t}else{\n", "\t\tumode = (mode&3)|O_CREAT|O_TRUNC;\n", "\t\tmode &= ~(3|OTRUNC);\n", "\t\tif(mode&ODIRECT){\n", "\t\t\tumode |= O_DIRECT;\n", "\t\t\tmode &= ~ODIRECT;\n", "\t\t}\n", "\t\tif(mode&OEXCL){\n", "\t\t\tumode |= O_EXCL;\n", "\t\t\tmode &= ~OEXCL;\n", "\t\t}\n", "\t\tif(mode&OAPPEND){\n", "\t\t\tumode |= O_APPEND;\n", "\t\t\tmode &= ~OAPPEND;\n", "\t\t}\n", "\t\tif(mode){\n", "\t\t\twerrstr(\"unsupported mode in create\");\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t\tfd = open(path, umode, perm);\n", "\t}\n", "out:\n", "\tif(fd >= 0){\n", "\t\tif(lock){\n", "\t\t\tfl.l_type = (rdwr==OREAD) ? F_RDLCK : F_WRLCK;\n", "\t\t\tfl.l_whence = SEEK_SET;\n", "\t\t\tfl.l_start = 0;\n", "\t\t\tfl.l_len = 0;\n", "\t\t\tif(fcntl(fd, F_SETLK, &fl) < 0){\n", "\t\t\t\tclose(fd);\n", "\t\t\t\twerrstr(\"lock: %r\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cexec)\n", "\t\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n", "\t\tif(rclose)\n", "\t\t\tremove(path);\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "int Readdir(int f,char *p,int onlydirs)\n", "\n", "{\n", "  int iVar1;\n", "  uint uVar2;\n", "  long lVar3;\n", "  long lVar4;\n", "  \n", "  if (0x31 < (uint)f) {\n", "    return 0;\n", "  }\n", "  lVar4 = (long)f;\n", "  uVar2 = dir[lVar4].i;\n", "  if (uVar2 == dir[lVar4].n) {\n", "    p9free(dir[lVar4].dbuf);\n", "    dir[lVar4].dbuf = (Dir *)0x0;\n", "    lVar3 = dirread(f,(Dir **)(dir + lVar4));\n", "    iVar1 = (int)lVar3;\n", "    if (iVar1 < 0) {\n", "      dir[lVar4].n = 0;\n", "      dir[lVar4].i = 0;\n", "      return 0;\n", "    }\n", "    dir[lVar4].n = iVar1;\n", "    dir[lVar4].i = 0;\n", "    if (iVar1 == 0) {\n", "      return 0;\n", "    }\n", "    uVar2 = 0;\n", "  }\n", "  strcpy(p,dir[lVar4].dbuf[uVar2].name);\n", "  dir[lVar4].i = dir[lVar4].i + 1;\n", "  return 1;\n", "}\n", "\n"], "c": ["int Readdir(int f, char *p, int onlydirs)\n", "{\n", "\tint n;\n", "\tUSED(onlydirs);\t/* only advisory */\n", "\n", "\tif(f<0 || f>=NFD)\n", "\t\treturn 0;\n", "\tif(dir[f].i==dir[f].n){\t/* read */\n", "\t\tfree(dir[f].dbuf);\n", "\t\tdir[f].dbuf=0;\n", "\t\tn=dirread(f, &dir[f].dbuf);\n", "\t\tif(n>=0)\n", "\t\t\tdir[f].n=n;\n", "\t\telse\n", "\t\t\tdir[f].n=0;\n", "\t\tdir[f].i=0;\n", "\t}\n", "\tif(dir[f].i==dir[f].n)\n", "\t\treturn 0;\n", "\tstrcpy(p, dir[f].dbuf[dir[f].i].name);\n", "\tdir[f].i++;\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "void Closedir(int f)\n", "\n", "{\n", "  long lVar1;\n", "  \n", "  if ((uint)f < 0x32) {\n", "    lVar1 = (long)f;\n", "    p9free(dir[lVar1].dbuf);\n", "    dir[lVar1].i = 0;\n", "    dir[lVar1].n = 0;\n", "    dir[lVar1].dbuf = (Dir *)0x0;\n", "  }\n", "  close(f);\n", "  return;\n", "}\n", "\n"], "c": ["void Closedir(int f){\n", "\tif(f>=0 && f<NFD){\n", "\t\tfree(dir[f].dbuf);\n", "\t\tdir[f].i=0;\n", "\t\tdir[f].n=0;\n", "\t\tdir[f].dbuf=0;\n", "\t}\n", "\tclose(f);\n", "}"]}, {"ghidra": ["\n", "int havewaitpid(int pid)\n", "\n", "{\n", "  int *piVar1;\n", "  \n", "  if (nwaitpids < 1) {\n", "    return 0;\n", "  }\n", "  if (*waitpids != pid) {\n", "    piVar1 = waitpids;\n", "    do {\n", "      piVar1 = piVar1 + 1;\n", "      if (piVar1 == waitpids + (ulong)(nwaitpids - 1) + 1) {\n", "        return 0;\n", "      }\n", "    } while (*piVar1 != pid);\n", "  }\n", "  return 1;\n", "}\n", "\n"], "c": ["int\n", "havewaitpid(int pid)\n", "{\n", "\tint i;\n", "\t\n", "\tfor(i=0; i<nwaitpids; i++)\n", "\t\tif(waitpids[i] == pid)\n", "\t\t\treturn 1;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void codeswitch(tree *t,int eflag)\n", "\n", "{\n", "  tree *t_00;\n", "  tree *t_01;\n", "  int a;\n", "  int a_00;\n", "  int a_01;\n", "  long lVar1;\n", "  int iVar2;\n", "  bool bVar3;\n", "  \n", "  t_00 = t->child[1]->child[0];\n", "  if (((t_00 == (tree *)0x0) || (t_00->type != 0x3b)) || (t_00->child[0]->type != 0xe011)) {\n", "    yyerror(\"case missing in switch\");\n", "    return;\n", "  }\n", "  a_01 = iscase(t_00->child[0]);\n", "  if (a_01 == 0) {\n", "    yyerror(\"case missing in switch\");\n", "    return;\n", "  }\n", "  if (codep == ncode) {\n", "    morecode();\n", "  }\n", "  lVar1 = (long)codep;\n", "  codep = codep + 1;\n", "  codebuf[lVar1] = 0x404830;\n", "  outcode(t->child[0],eflag);\n", "  if (codep == ncode) {\n", "    morecode();\n", "  }\n", "  lVar1 = (long)codep;\n", "  codep = codep + 1;\n", "  bVar3 = codep == ncode;\n", "  codebuf[lVar1] = 0x404cb0;\n", "  if (bVar3) {\n", "    morecode();\n", "  }\n", "  *(undefined4 *)(codebuf + codep) = 0;\n", "  a_01 = codep;\n", "  codep = codep + 1;\n", "  iVar2 = codep;\n", "  if (codep == ncode) {\n", "    morecode();\n", "    iVar2 = codep;\n", "  }\n", "  a = ncode;\n", "  codebuf[iVar2] = 0x404cb0;\n", "  codep = iVar2 + 1;\n", "  if (codep == a) {\n", "    morecode();\n", "  }\n", "  *(undefined4 *)(codebuf + codep) = 0;\n", "  a = codep;\n", "  codep = codep + 1;\n", "  stuffdot(a_01);\n", "  t_00 = t->child[1]->child[0];\n", "  a_01 = t_00->type;\n", "  do {\n", "    if (a_01 != 0x3b) {\n", "      stuffdot(a);\n", "      if (codep == ncode) {\n", "        morecode();\n", "      }\n", "      codebuf[codep] = 0x404cd0;\n", "      codep = codep + 1;\n", "      return;\n", "    }\n", "    t_01 = t_00->child[1];\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar1 = (long)codep;\n", "    codep = codep + 1;\n", "    codebuf[lVar1] = 0x404830;\n", "    t_00 = t_00->child[0]->child[0];\n", "    a_01 = t_00->type;\n", "    while (a_01 == 0xe012) {\n", "      outcode(t_00->child[1],eflag);\n", "      t_00 = t_00->child[0];\n", "      a_01 = t_00->type;\n", "    }\n", "    if (ncode == codep) {\n", "      morecode();\n", "    }\n", "    lVar1 = (long)codep;\n", "    codep = codep + 1;\n", "    bVar3 = codep == ncode;\n", "    codebuf[lVar1] = 0x404ed0;\n", "    if (bVar3) {\n", "      morecode();\n", "    }\n", "    *(undefined4 *)(codebuf + codep) = 0;\n", "    a_00 = codep;\n", "    codep = codep + 1;\n", "    a_01 = t_01->type;\n", "    t_00 = t_01;\n", "    while (a_01 == 0x3b) {\n", "      t_01 = t_00->child[0];\n", "      if ((t_01->type == 0xe011) && (a_01 = iscase(t_01), a_01 != 0)) goto LAB_004023c3;\n", "      outcode(t_01,eflag);\n", "      t_00 = t_00->child[1];\n", "      a_01 = t_00->type;\n", "    }\n", "    if ((a_01 != 0xe011) || (a_01 = iscase(t_00), a_01 == 0)) {\n", "      outcode(t_00,eflag);\n", "    }\n", "LAB_004023c3:\n", "    if (codep == ncode) {\n", "      morecode();\n", "    }\n", "    lVar1 = (long)codep;\n", "    codep = codep + 1;\n", "    bVar3 = codep == ncode;\n", "    codebuf[lVar1] = 0x404cb0;\n", "    if (bVar3) {\n", "      morecode();\n", "    }\n", "    *(int *)(codebuf + codep) = iVar2;\n", "    codep = codep + 1;\n", "    stuffdot(a_00);\n", "    a_01 = t_00->type;\n", "  } while( true );\n", "}\n", "\n"], "c": ["void\n", "codeswitch(tree *t, int eflag)\n", "{\n", "\tint leave;\t\t/* patch jump address to leave switch */\n", "\tint out;\t\t/* jump here to leave switch */\n", "\tint nextcase;\t/* patch jump address to next case */\n", "\ttree *tt;\n", "\tif(c1->child[0]==nil\n", "\t|| c1->child[0]->type!=';'\n", "\t|| !iscase(c1->child[0]->child[0])){\n", "\t\tyyerror(\"case missing in switch\");\n", "\t\treturn;\n", "\t}\n", "\temitf(Xmark);\n", "\toutcode(c0, eflag);\n", "\temitf(Xjump);\n", "\tnextcase = emiti(0);\n", "\tout = emitf(Xjump);\n", "\tleave = emiti(0);\n", "\tstuffdot(nextcase);\n", "\tt = c1->child[0];\n", "\twhile(t->type==';'){\n", "\t\ttt = c1;\n", "\t\temitf(Xmark);\n", "\t\tfor(t = c0->child[0];t->type==ARGLIST;t = c0) outcode(c1, eflag);\n", "\t\temitf(Xcase);\n", "\t\tnextcase = emiti(0);\n", "\t\tt = tt;\n", "\t\tfor(;;){\n", "\t\t\tif(t->type==';'){\n", "\t\t\t\tif(iscase(c0)) break;\n", "\t\t\t\toutcode(c0, eflag);\n", "\t\t\t\tt = c1;\n", "\t\t\t}\n", "\t\t\telse{\n", "\t\t\t\tif(!iscase(t)) outcode(t, eflag);\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t\temitf(Xjump);\n", "\t\temiti(out);\n", "\t\tstuffdot(nextcase);\n", "\t}\n", "\tstuffdot(leave);\n", "\temitf(Xpopm);\n", "}"]}, {"ghidra": ["\n", "int await(char *str,int n)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = _await(-1,str,n,0);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "await(char *str, int n)\n", "{\n", "\treturn _await(-1, str, n, 0);\n", "}"]}, {"ghidra": ["\n", "void deglob(char *s)\n", "\n", "{\n", "  char *pcVar1;\n", "  char cVar2;\n", "  char *pcVar3;\n", "  char *pcVar4;\n", "  \n", "  pcVar4 = s;\n", "  do {\n", "    while (*s == '\\x01') {\n", "      pcVar1 = s + 1;\n", "      pcVar3 = s + 1;\n", "      s = s + 2;\n", "      *pcVar4 = *pcVar1;\n", "      pcVar4 = pcVar4 + 1;\n", "      if (*pcVar3 == '\\0') {\n", "        return;\n", "      }\n", "    }\n", "    *pcVar4 = *s;\n", "    cVar2 = *s;\n", "    s = s + 1;\n", "    pcVar4 = pcVar4 + 1;\n", "  } while (cVar2 != '\\0');\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "deglob(char *s)\n", "{\n", "\tchar *t = s;\n", "\tdo{\n", "\t\tif(*t==GLOB)\n", "\t\t\tt++;\n", "\t\t*s++=*t;\n", "\t}while(*t++);\n", "}"]}, {"ghidra": ["\n", "void freetree(tree *p)\n", "\n", "{\n", "  if (p != (tree *)0x0) {\n", "    freetree(p->child[0]);\n", "    freetree(p->child[1]);\n", "    freetree(p->child[2]);\n", "    if (p->str != (char *)0x0) {\n", "      efree(p->str);\n", "    }\n", "    efree((char *)p);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "freetree(tree *p)\n", "{\n", "\tif(p==0)\n", "\t\treturn;\t\n", "\tfreetree(p->child[0]);\n", "\tfreetree(p->child[1]);\n", "\tfreetree(p->child[2]);\n", "\tif(p->str)\n", "\t\tefree(p->str);\n", "\tefree((char *)p);\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "int _p9dir(stat *lst,stat *st,char *name,Dir *d,char **str,char *estr)\n", "\n", "{\n", "  long lVar1;\n", "  __dev_t _Var2;\n", "  ulong uVar3;\n", "  ulong uVar4;\n", "  vlong vVar5;\n", "  int gid;\n", "  group *g;\n", "  int uid;\n", "  passwd *p;\n", "  char cVar6;\n", "  int iVar7;\n", "  uint uVar8;\n", "  int __fd;\n", "  int iVar9;\n", "  char *__s;\n", "  size_t sVar10;\n", "  size_t sVar11;\n", "  u64int uVar12;\n", "  char *pcVar13;\n", "  size_t sVar14;\n", "  uint uVar15;\n", "  ulong uVar16;\n", "  uint uVar17;\n", "  char *__s_00;\n", "  __gid_t __gid;\n", "  __uid_t __uid;\n", "  undefined8 *puVar18;\n", "  long in_FS_OFFSET;\n", "  u64int u64;\n", "  long l;\n", "  hd_geometry geo;\n", "  char tmp [20];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (d != (Dir *)0x0) {\n", "    *(undefined8 *)d = 0;\n", "    d->ext = (char *)0x0;\n", "    puVar18 = (undefined8 *)((ulong)&d->qid & 0xfffffffffffffff8);\n", "    uVar16 = (ulong)(((int)d - (int)puVar18) + 0x78U >> 3);\n", "    while (uVar16 != 0) {\n", "      uVar16 = uVar16 - 1;\n", "      *puVar18 = 0;\n", "      puVar18 = puVar18 + 1;\n", "    }\n", "  }\n", "  __s = strrchr(name,0x2f);\n", "  if (((__s == (char *)0x0) || (__s_00 = __s + 1, __s_00 == (char *)0x0)) || (__s[1] == '\\0')) {\n", "    cVar6 = *name;\n", "    pcVar13 = name;\n", "    __s_00 = name;\n", "    if (cVar6 == '/') goto LAB_00412d33;\n", "LAB_004129b1:\n", "    if (cVar6 != '\\0') goto LAB_00412c88;\n", "    sVar10 = 1;\n", "    __s_00 = \"/\";\n", "  }\n", "  else {\n", "    pcVar13 = __s_00;\n", "    if (__s[1] == '/') {\n", "LAB_00412d33:\n", "      __s_00 = pcVar13 + 1;\n", "      cVar6 = pcVar13[1];\n", "      goto LAB_004129b1;\n", "    }\n", "LAB_00412c88:\n", "    sVar10 = strlen(__s_00);\n", "  }\n", "  iVar7 = (int)sVar10;\n", "  if (d != (Dir *)0x0) {\n", "    if (estr < *str + sVar10 + 1) {\n", "      d->name = \"oops\";\n", "      sVar10 = strlen(__s_00);\n", "      iVar7 = (int)sVar10;\n", "    }\n", "    else {\n", "      memcpy(*str,__s_00,sVar10 + 1);\n", "      d->name = *str;\n", "      __s = *str;\n", "      sVar10 = strlen(__s);\n", "      *str = __s + sVar10 + 1;\n", "      sVar10 = strlen(__s_00);\n", "      iVar7 = (int)sVar10;\n", "    }\n", "  }\n", "  if (p == (passwd *)0x0) {\n", "    if (_p9usepwlibrary != 0) {\n", "      __uid = st->st_uid;\n", "      goto LAB_00412cf8;\n", "    }\n", "LAB_00412a22:\n", "    snprint(tmp,0x14,\"%d\");\n", "    __s = tmp;\n", "  }\n", "  else {\n", "    __uid = st->st_uid;\n", "    if (__uid == uid) {\n", "      if ((__uid != p->pw_uid) && (_p9usepwlibrary != 0)) goto LAB_00412cf8;\n", "    }\n", "    else {\n", "      if (_p9usepwlibrary == 0) goto LAB_00412a22;\n", "LAB_00412cf8:\n", "      p = (passwd *)getpwuid(__uid);\n", "      uid = st->st_uid;\n", "      __uid = uid;\n", "      if (p == (passwd *)0x0) goto LAB_00412a22;\n", "    }\n", "    if (p->pw_uid != __uid) goto LAB_00412a22;\n", "    __s = p->pw_name;\n", "  }\n", "  sVar10 = strlen(__s);\n", "  if (d == (Dir *)0x0) {\n", "LAB_00412a7f:\n", "    if (g != (group *)0x0) goto LAB_00412a8f;\n", "LAB_00412dec:\n", "    if (_p9usepwlibrary != 0) {\n", "      __gid = st->st_gid;\n", "      goto LAB_00412cb8;\n", "    }\n", "  }\n", "  else {\n", "    if (estr < *str + sVar10 + 1) {\n", "      d->uid = \"oops\";\n", "      goto LAB_00412a7f;\n", "    }\n", "    memcpy(*str,__s,sVar10 + 1);\n", "    d->uid = *str;\n", "    __s = *str;\n", "    sVar11 = strlen(__s);\n", "    *str = __s + sVar11 + 1;\n", "    if (g == (group *)0x0) goto LAB_00412dec;\n", "LAB_00412a8f:\n", "    __gid = st->st_gid;\n", "    if (__gid == gid) {\n", "      if ((__gid != g->gr_gid) && (_p9usepwlibrary != 0)) goto LAB_00412cb8;\n", "LAB_00412cd8:\n", "      if (__gid == g->gr_gid) {\n", "        __s = g->gr_name;\n", "        goto LAB_00412ac9;\n", "      }\n", "    }\n", "    else {\n", "      if (_p9usepwlibrary != 0) {\n", "LAB_00412cb8:\n", "        g = (group *)getgrgid(__gid);\n", "        __gid = st->st_gid;\n", "        gid = __gid;\n", "        if (g != (group *)0x0) goto LAB_00412cd8;\n", "      }\n", "    }\n", "  }\n", "  snprint(tmp,0x14,\"%d\");\n", "  __s = tmp;\n", "LAB_00412ac9:\n", "  sVar11 = strlen(__s);\n", "  if (d != (Dir *)0x0) {\n", "    if (estr < *str + sVar11 + 1) {\n", "      d->gid = \"oops\";\n", "    }\n", "    else {\n", "      memcpy(*str,__s,sVar11 + 1);\n", "      d->gid = *str;\n", "      __s = *str;\n", "      sVar14 = strlen(__s);\n", "      *str = __s + sVar14 + 1;\n", "    }\n", "    _Var2 = st->st_dev;\n", "    d->muid = \"\";\n", "    d->type = 0x4d;\n", "    uVar3 = (st->st_mtim).tv_sec;\n", "    (d->qid).path = _Var2 << 0x20 | st->st_ino;\n", "    if ((d->qid).vers == 0) {\n", "      (d->qid).vers = uVar3 + (st->st_ctim).tv_sec;\n", "    }\n", "    uVar8 = st->st_mode;\n", "    uVar15 = uVar8 & 0x1ff;\n", "    d->mode = (ulong)uVar15;\n", "    uVar4 = (st->st_atim).tv_sec;\n", "    d->mtime = uVar3;\n", "    vVar5 = st->st_size;\n", "    d->atime = uVar4;\n", "    d->length = vVar5;\n", "    uVar17 = lst->st_mode;\n", "    if ((uVar17 & 0xf000) == 0xa000) {\n", "      d->mode = (ulong)(uVar15 | 0x2000000);\n", "      d->length = lst->st_size;\n", "    }\n", "    else {\n", "      uVar8 = uVar8 & 0xf000;\n", "      if (uVar8 == 0x4000) {\n", "        (d->qid).type = -0x80;\n", "        d->length = 0;\n", "        d->mode = (ulong)(uVar15 | 0x80000000);\n", "        uVar17 = lst->st_mode;\n", "      }\n", "      else {\n", "        if (uVar8 == 0x1000) {\n", "          d->mode = (ulong)(uVar15 | 0x200000);\n", "        }\n", "        else {\n", "          if (uVar8 == 0xc000) {\n", "            d->mode = (ulong)(uVar15 | 0x100000);\n", "          }\n", "          else {\n", "            if (uVar8 == 0x6000) {\n", "              d->mode = (ulong)(uVar15 | 0x800000);\n", "              (d->qid).path = st->st_rdev | 0x620000;\n", "            }\n", "            else {\n", "              if (uVar8 == 0x2000) {\n", "                d->mode = (ulong)(uVar15 | 0x800000);\n", "                (d->qid).path = st->st_rdev | 0x630000;\n", "              }\n", "            }\n", "          }\n", "        }\n", "      }\n", "    }\n", "    if (((uVar17 & 0xb000) == 0x2000) && (__fd = open64(name,0), -1 < __fd)) {\n", "      geo._0_8_ = 0;\n", "      geo.start = 0;\n", "      l = 0;\n", "      u64 = 0;\n", "      iVar9 = ioctl(__fd,0x80081272,&u64);\n", "      uVar12 = u64;\n", "      if (iVar9 < 0) {\n", "        iVar9 = ioctl(__fd,0x1260,&l);\n", "        if (iVar9 < 0) {\n", "          iVar9 = ioctl(__fd,0x301,&geo);\n", "          if (iVar9 < 0) {\n", "            uVar12 = 0;\n", "          }\n", "          else {\n", "            uVar12 = (geo._0_8_ >> 0x10 & 0xffff) * (geo._0_8_ & 0xff) * (geo._0_8_ >> 8 & 0xff) *\n", "                     0x200;\n", "          }\n", "        }\n", "        else {\n", "          uVar12 = l << 9;\n", "        }\n", "      }\n", "      d->length = uVar12;\n", "      close(__fd);\n", "    }\n", "  }\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return (int)sVar10 + iVar7 + 3 + (int)sVar11;\n", "}\n", "\n"], "c": ["int\n", "_p9dir(struct stat *lst, struct stat *st, char *name, Dir *d, char **str, char *estr)\n", "{\n", "\tchar *s;\n", "\tchar tmp[20];\n", "\tstatic struct group *g;\n", "\tstatic struct passwd *p;\n", "\tstatic int gid, uid;\n", "\tint sz, fd;\n", "\n", "\tfd = -1;\n", "\tUSED(fd);\n", "\tsz = 0;\n", "\tif(d)\n", "\t\tmemset(d, 0, sizeof *d);\n", "\n", "\t/* name */\n", "\ts = strrchr(name, '/');\n", "\tif(s)\n", "\t\ts++;\n", "\tif(!s || !*s)\n", "\t\ts = name;\n", "\tif(*s == '/')\n", "\t\ts++;\n", "\tif(*s == 0)\n", "\t\ts = \"/\";\n", "\tif(d){\n", "\t\tif(*str + strlen(s)+1 > estr)\n", "\t\t\td->name = \"oops\";\n", "\t\telse{\n", "\t\t\tstrcpy(*str, s);\n", "\t\t\td->name = *str;\n", "\t\t\t*str += strlen(*str)+1;\n", "\t\t}\n", "\t}\n", "\tsz += strlen(s)+1;\n", "\n", "\t/* user */\n", "\tif(p && st->st_uid == uid && p->pw_uid == uid)\n", "\t\t;\n", "\telse if(_p9usepwlibrary){\n", "\t\tp = getpwuid(st->st_uid);\n", "\t\tuid = st->st_uid;\n", "\t}\n", "\tif(p == nil || st->st_uid != uid || p->pw_uid != uid){\n", "\t\tsnprint(tmp, sizeof tmp, \"%d\", (int)st->st_uid);\n", "\t\ts = tmp;\n", "\t}else\n", "\t\ts = p->pw_name;\n", "\tsz += strlen(s)+1;\n", "\tif(d){\n", "\t\tif(*str+strlen(s)+1 > estr)\n", "\t\t\td->uid = \"oops\";\t\n", "\t\telse{\n", "\t\t\tstrcpy(*str, s);\n", "\t\t\td->uid = *str;\n", "\t\t\t*str += strlen(*str)+1;\n", "\t\t}\n", "\t}\n", "\n", "\t/* group */\n", "\tif(g && st->st_gid == gid && g->gr_gid == gid)\n", "\t\t;\n", "\telse if(_p9usepwlibrary){\n", "\t\tg = getgrgid(st->st_gid);\n", "\t\tgid = st->st_gid;\n", "\t}\n", "\tif(g == nil || st->st_gid != gid || g->gr_gid != gid){\n", "\t\tsnprint(tmp, sizeof tmp, \"%d\", (int)st->st_gid);\n", "\t\ts = tmp;\n", "\t}else\n", "\t\ts = g->gr_name;\n", "\tsz += strlen(s)+1;\n", "\tif(d){\n", "\t\tif(*str + strlen(s)+1 > estr)\n", "\t\t\td->gid = \"oops\";\t\n", "\t\telse{\n", "\t\t\tstrcpy(*str, s);\n", "\t\t\td->gid = *str;\n", "\t\t\t*str += strlen(*str)+1;\n", "\t\t}\n", "\t}\n", "\n", "\tif(d){\n", "\t\td->type = 'M';\n", "\n", "\t\td->muid = \"\";\n", "\t\td->qid.path = ((uvlong)st->st_dev<<32) | st->st_ino;\n", "#ifdef _HAVESTGEN\n", "\t\td->qid.vers = st->st_gen;\n", "#endif\n", "\t\tif(d->qid.vers == 0)\n", "\t\t\td->qid.vers = st->st_mtime + st->st_ctime;\n", "\t\td->mode = st->st_mode&0777;\n", "\t\td->atime = st->st_atime;\n", "\t\td->mtime = st->st_mtime;\n", "\t\td->length = st->st_size;\n", "\n", "\t\tif(S_ISLNK(lst->st_mode)){\t/* yes, lst not st */\n", "\t\t\td->mode |= DMSYMLINK;\n", "\t\t\td->length = lst->st_size;\n", "\t\t}\n", "\t\telse if(S_ISDIR(st->st_mode)){\n", "\t\t\td->length = 0;\n", "\t\t\td->mode |= DMDIR;\n", "\t\t\td->qid.type = QTDIR;\n", "\t\t}\n", "\t\telse if(S_ISFIFO(st->st_mode))\n", "\t\t\td->mode |= DMNAMEDPIPE;\n", "\t\telse if(S_ISSOCK(st->st_mode))\n", "\t\t\td->mode |= DMSOCKET;\n", "\t\telse if(S_ISBLK(st->st_mode)){\n", "\t\t\td->mode |= DMDEVICE;\n", "\t\t\td->qid.path = ('b'<<16)|st->st_rdev;\n", "\t\t}\n", "\t\telse if(S_ISCHR(st->st_mode)){\n", "\t\t\td->mode |= DMDEVICE;\n", "\t\t\td->qid.path = ('c'<<16)|st->st_rdev;\n", "\t\t}\n", "\t\t/* fetch real size for disks */\n", "\t\tif(S_ISBLK(lst->st_mode) || S_ISCHR(lst->st_mode)){\n", "\t\t\tif((fd = open(name, O_RDONLY)) >= 0){\n", "\t\t\t\td->length = disksize(fd, st);\n", "\t\t\t\tclose(fd);\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\n", "\treturn sz;\n", "}"]}, {"ghidra": ["\n", "tree * token(char *str,int type)\n", "\n", "{\n", "  tree *ptVar1;\n", "  char *pcVar2;\n", "  \n", "  ptVar1 = newtree();\n", "  ptVar1->type = type;\n", "  pcVar2 = p9strdup(str);\n", "  ptVar1->str = pcVar2;\n", "  return ptVar1;\n", "}\n", "\n"], "c": ["tree*\n", "token(char *str, int type)\n", "{\n", "\ttree *t = newtree();\n", "\tt->type = type;\n", "\tt->str = strdup(str);\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "long readnb(int fd,char *buf,long cnt)\n", "\n", "{\n", "  bool bVar1;\n", "  uint uVar2;\n", "  int iVar3;\n", "  ssize_t sVar4;\n", "  int *piVar5;\n", "  \n", "  bVar1 = false;\n", "LAB_0040b8b8:\n", "  sVar4 = read(fd,buf,cnt);\n", "  if ((int)sVar4 != -1) {\n", "    return (long)(int)sVar4;\n", "  }\n", "  if (!bVar1) goto code_r0x0040b8ce;\n", "  goto LAB_0040b908;\n", "code_r0x0040b8ce:\n", "  piVar5 = __errno_location();\n", "  if (*piVar5 == 0xb) {\n", "    uVar2 = fcntl(fd,3,0);\n", "    if (uVar2 != 0xffffffff) {\n", "      iVar3 = fcntl(fd,4,(ulong)(uVar2 & 0xffff0000 |\n", "                                (uint)CONCAT11((char)((ulong)uVar2 >> 8),(char)uVar2) & 0xfffff7ff))\n", "      ;\n", "      if (iVar3 != -1) {\n", "LAB_0040b908:\n", "        bVar1 = true;\n", "        goto LAB_0040b8b8;\n", "      }\n", "    }\n", "    return -1;\n", "  }\n", "  goto LAB_0040b8b8;\n", "}\n", "\n"], "c": ["long\n", "readnb(int fd, char *buf, long cnt)\n", "{\n", "\tint n, didreset;\n", "\tint flgs;\n", "\n", "\tdidreset = 0;\n", "\twhile((n = read(fd, buf, cnt)) == -1)\n", "\t\tif(!didreset && errno == EAGAIN){\n", "\t\t\tif((flgs = fcntl(fd, F_GETFL, 0)) == -1)\n", "\t\t\t\treturn -1;\n", "\t\t\tflgs &= ~O_NONBLOCK;\n", "\t\t\tif(fcntl(fd, F_SETFL, flgs) == -1)\n", "\t\t\t\treturn -1;\n", "\t\t\tdidreset = 1;\n", "\t\t}\n", "\n", "\treturn n;\n", "}"]}, {"ghidra": ["\n", "int Waitfor(int pid,int unused0)\n", "\n", "{\n", "  long lVar1;\n", "  int fd;\n", "  int *piVar2;\n", "  Waitmsg *v;\n", "  long lVar3;\n", "  thread *ptVar4;\n", "  char *s;\n", "  char *pcVar5;\n", "  char *pcVar6;\n", "  long in_FS_OFFSET;\n", "  bool bVar7;\n", "  byte bVar8;\n", "  char errbuf [128];\n", "  \n", "  bVar8 = 0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (-1 < pid) {\n", "    if (nwaitpids < 1) {\n", "LAB_0040d67f:\n", "      fd = 0;\n", "      goto LAB_0040d681;\n", "    }\n", "    if (pid != *waitpids) {\n", "      piVar2 = waitpids;\n", "      do {\n", "        piVar2 = piVar2 + 1;\n", "        if (piVar2 == waitpids + (ulong)(nwaitpids - 1) + 1) goto LAB_0040d67f;\n", "      } while (pid != *piVar2);\n", "    }\n", "  }\n", "  v = p9wait();\n", "  while (bVar7 = v == (Waitmsg *)0x0, !bVar7) {\n", "    delwaitpid(v->pid);\n", "    bVar7 = v->pid == pid;\n", "    if (bVar7) {\n", "      s = v->msg;\n", "      lVar3 = 8;\n", "      pcVar5 = s;\n", "      pcVar6 = \"signal: \";\n", "      goto code_r0x0040d7c9;\n", "    }\n", "    bVar7 = runq->iflag == 0;\n", "    if (!bVar7) {\n", "      lVar3 = 8;\n", "      s = v->msg;\n", "      pcVar5 = \"signal: \";\n", "      do {\n", "        if (lVar3 == 0) break;\n", "        lVar3 = lVar3 + -1;\n", "        bVar7 = *s == *pcVar5;\n", "        s = s + (ulong)bVar8 * -2 + 1;\n", "        pcVar5 = pcVar5 + (ulong)bVar8 * -2 + 1;\n", "      } while (bVar7);\n", "      if (bVar7) {\n", "        fprint(2,\"%d: %s\\n\");\n", "      }\n", "    }\n", "    ptVar4 = runq->ret;\n", "    while (ptVar4 != (thread *)0x0) {\n", "      while (ptVar4->pid == v->pid) {\n", "        s = v->msg;\n", "        ptVar4->pid = -1;\n", "        __strcpy_chk(ptVar4->status,s,0x80);\n", "        ptVar4 = ptVar4->ret;\n", "        if (ptVar4 == (thread *)0x0) goto LAB_0040d750;\n", "      }\n", "      ptVar4 = ptVar4->ret;\n", "    }\n", "LAB_0040d750:\n", "    p9free(v);\n", "    v = p9wait();\n", "  }\n", "  rerrstr(errbuf,0x80);\n", "  lVar3 = 0xc;\n", "  s = errbuf;\n", "  pcVar5 = \"interrupted\";\n", "  do {\n", "    if (lVar3 == 0) break;\n", "    lVar3 = lVar3 + -1;\n", "    bVar7 = *s == *pcVar5;\n", "    s = s + (ulong)bVar8 * -2 + 1;\n", "    pcVar5 = pcVar5 + (ulong)bVar8 * -2 + 1;\n", "  } while (bVar7);\n", "  fd = -(uint)bVar7;\n", "  goto LAB_0040d681;\n", "  while( true ) {\n", "    lVar3 = lVar3 + -1;\n", "    bVar7 = *pcVar5 == *pcVar6;\n", "    pcVar5 = pcVar5 + (ulong)bVar8 * -2 + 1;\n", "    pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n", "    if (!bVar7) break;\n", "code_r0x0040d7c9:\n", "    if (lVar3 == 0) break;\n", "  }\n", "  if (bVar7) {\n", "    fd = mapfd(2);\n", "    fprint(fd,\"%d: %s\\n\",(ulong)(uint)pid,s);\n", "    s = v->msg;\n", "  }\n", "  setstatus(s);\n", "  p9free(v);\n", "  fd = 0;\n", "LAB_0040d681:\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return fd;\n", "}\n", "\n"], "c": ["Waitmsg*\n", "waitfor(int pid)\n", "{\n", "\tchar buf[256];\n", "\n", "\treturn _wait(awaitfor(pid, buf, sizeof buf-1), buf);\n", "}"]}, {"ghidra": ["\n", "io * openstr(void)\n", "\n", "{\n", "  io *piVar1;\n", "  char *pcVar2;\n", "  \n", "  piVar1 = (io *)emalloc(0x220);\n", "  piVar1->fd = -1;\n", "  pcVar2 = emalloc(0x65);\n", "  piVar1->strp = pcVar2;\n", "  piVar1->bufp = pcVar2;\n", "  piVar1->ebuf = pcVar2 + 100;\n", "  do {\n", "    *pcVar2 = '\\0';\n", "    pcVar2 = pcVar2 + 1;\n", "  } while (pcVar2 <= piVar1->ebuf);\n", "  return piVar1;\n", "}\n", "\n"], "c": ["io*\n", "openstr(void)\n", "{\n", "\tio *f = new(struct io);\n", "\tchar *s;\n", "\tf->fd=-1;\n", "\tf->bufp = f->strp = emalloc(101);\n", "\tf->ebuf = f->bufp+100;\n", "\tfor(s = f->bufp;s<=f->ebuf;s++) *s='\\0';\n", "\treturn f;\n", "}"]}, {"ghidra": ["\n", "void __fmtunlock(void)\n", "\n", "{\n", "  unlock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtunlock(void)\n", "{\n", "\tunlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "io * opencore(char *s,int len)\n", "\n", "{\n", "  io *piVar1;\n", "  char *__dest;\n", "  size_t __n;\n", "  \n", "  __n = SEXT48(len);\n", "  piVar1 = (io *)emalloc(0x220);\n", "  __dest = emalloc(__n);\n", "  piVar1->strp = __dest;\n", "  piVar1->bufp = __dest;\n", "  piVar1->fd = -1;\n", "  piVar1->ebuf = __dest + __n;\n", "  Memcpy(__dest,s,__n);\n", "  return piVar1;\n", "}\n", "\n"], "c": ["io*\n", "opencore(char *s, int len)\n", "{\n", "\tio *f = new(struct io);\n", "\tchar *buf = emalloc(len);\n", "\tf->fd= -1 /*open(\"/dev/null\", 0)*/;\n", "\tf->bufp = f->strp = buf;\n", "\tf->ebuf = buf+len;\n", "\tMemcpy(buf, s, len);\n", "\treturn f;\n", "}"]}, {"ghidra": ["\n", "char * strecpy(char *to,char *e,char *from)\n", "\n", "{\n", "  void *pvVar1;\n", "  char *pcVar2;\n", "  \n", "  if (e <= to) {\n", "    return to;\n", "  }\n", "  pvVar1 = memccpy(to,from,0,(size_t)(e + -(long)to));\n", "  pcVar2 = (char *)((long)pvVar1 + -1);\n", "  if (pvVar1 == (void *)0x0) {\n", "    e[-1] = '\\0';\n", "    pcVar2 = e + -1;\n", "  }\n", "  return pcVar2;\n", "}\n", "\n"], "c": ["char*\n", "strecpy(char *to, char *e, char *from)\n", "{\n", "\tif(to >= e)\n", "\t\treturn to;\n", "\tto = memccpy(to, from, '\\0', e - to);\n", "\tif(to == nil){\n", "\t\tto = e - 1;\n", "\t\t*to = '\\0';\n", "\t}else{\n", "\t\tto--;\n", "\t}\n", "\treturn to;\n", "}"]}, {"ghidra": ["\n", "int unicode(char *p)\n", "\n", "{\n", "  uint uVar1;\n", "  \n", "  uVar1 = SEXT14(*p);\n", "  if ((uVar1 & 0xe0) == 0xc0) {\n", "    return (int)((uint)(byte)p[1] & 0x3f | (uVar1 & 0x1f) << 6);\n", "  }\n", "  if ((uVar1 & 0xf0) != 0xe0) {\n", "    return uVar1 & 0xff;\n", "  }\n", "  return (int)((uVar1 & 0xff) << 0xc | ((uint)(byte)p[1] & 0x3f) << 6 | (uint)(byte)p[2] & 0x3f);\n", "}\n", "\n"], "c": ["int\n", "unicode(char *p)\n", "{\n", "\tint u=*p&0xff;\n", "\tif(twobyte(u)) return ((u&0x1f)<<6)|(p[1]&0x3f);\n", "\tif(threebyte(u)) return (u<<12)|((p[1]&0x3f)<<6)|(p[2]&0x3f);\n", "\treturn u;\n", "}"]}, {"ghidra": ["\n", "void execexec(void)\n", "\n", "{\n", "  word *path;\n", "  \n", "  popword();\n", "  if (runq->argv->words != (word *)0x0) {\n", "    doredir(runq->redir);\n", "    path = rcsearchpath(runq->argv->words->word);\n", "    Execute(runq->argv->words,path);\n", "    poplist();\n", "    return;\n", "  }\n", "  Xerror1(\"empty argument list\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execexec(void)\n", "{\n", "\tpopword();\t/* \"exec\" */\n", "\tif(runq->argv->words==0){\n", "\t\tXerror1(\"empty argument list\");\n", "\t\treturn;\n", "\t}\n", "\tdoredir(runq->redir);\n", "\tExecute(runq->argv->words, searchpath(runq->argv->words->word));\n", "\tpoplist();\n", "}"]}, {"ghidra": ["\n", "void pfnc(io *fd,thread *t)\n", "\n", "{\n", "  code *pcVar1;\n", "  anon_subr_void_for_f *paVar2;\n", "  list *plVar3;\n", "  uint uVar4;\n", "  anon_struct *paVar5;\n", "  int iVar6;\n", "  \n", "  pcVar1 = t->code;\n", "  paVar2 = (anon_subr_void_for_f *)pcVar1[t->pc];\n", "  uVar4 = getpid();\n", "  pfmt(fd,\"pid %d cycle %p %d \",(ulong)uVar4,pcVar1);\n", "  if (fname[0].f != (anon_subr_void_for_f *)0x0) {\n", "    if (paVar2 == fname[0].f) {\n", "      iVar6 = 0;\n", "    }\n", "    else {\n", "      paVar5 = fname;\n", "      iVar6 = 0;\n", "      do {\n", "        paVar5 = paVar5 + 1;\n", "        iVar6 = iVar6 + 1;\n", "        if (paVar5->f == (anon_subr_void_for_f *)0x0) goto LAB_0040990d;\n", "      } while (paVar2 != paVar5->f);\n", "    }\n", "    pstr(fd,fname[iVar6].name);\n", "    if (fname[iVar6].f != (anon_subr_void_for_f *)0x0) goto LAB_0040991f;\n", "  }\n", "LAB_0040990d:\n", "  pfmt(fd,\"%p\",paVar2);\n", "LAB_0040991f:\n", "  plVar3 = t->argv;\n", "  while (plVar3 != (list *)0x0) {\n", "    pfmt(fd,\" (%v)\",plVar3->words);\n", "    plVar3 = plVar3->next;\n", "  }\n", "  pchr(fd,10);\n", "  flush(fd);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pfnc(io *fd, thread *t)\n", "{\n", "\tint i;\n", "\tvoid (*fn)(void) = t->code[t->pc].f;\n", "\tlist *a;\n", "\tpfmt(fd, \"pid %d cycle %p %d \", getpid(), t->code, t->pc);\n", "\tfor(i = 0;fname[i].f;i++) if(fname[i].f==fn){\n", "\t\tpstr(fd, fname[i].name);\n", "\t\tbreak;\n", "\t}\n", "\tif(!fname[i].f)\n", "\t\tpfmt(fd, \"%p\", fn);\n", "\tfor(a = t->argv;a;a = a->next) pfmt(fd, \" (%v)\", a->words);\n", "\tpchr(fd, '\\n');\n", "\tflush(fd);\n", "}"]}, {"ghidra": ["\n", "char * fnstr(tree *t)\n", "\n", "{\n", "  char *pcVar1;\n", "  char cVar2;\n", "  io *f;\n", "  \n", "  f = openstr();\n", "  cVar2 = nl;\n", "  nl = ';';\n", "  pfmt(f,\"%t\",t);\n", "  pcVar1 = f->strp;\n", "  nl = cVar2;\n", "  f->strp = (char *)0x0;\n", "  closeio(f);\n", "  return pcVar1;\n", "}\n", "\n"], "c": ["char*\n", "fnstr(tree *t)\n", "{\n", "\tio *f = openstr();\n", "\tchar *v;\n", "\textern char nl;\n", "\tchar svnl = nl;\n", "\tnl=';';\n", "\tpfmt(f, \"%t\", t);\n", "\tnl = svnl;\n", "\tv = f->strp;\n", "\tf->strp = 0;\n", "\tcloseio(f);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "int errstr(char *err,uint n)\n", "\n", "{\n", "  char *to;\n", "  int *piVar1;\n", "  long in_FS_OFFSET;\n", "  char tmp [128];\n", "  char local_28 [8];\n", "  long local_20;\n", "  \n", "  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n", "  strecpy(tmp,local_28,err);\n", "  rerrstr(err,n);\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    to = (*_syserrstr)();\n", "    if (to != (char *)0x0) goto LAB_0040ef54;\n", "  }\n", "  to = xsyserr;\n", "LAB_0040ef54:\n", "  strecpy(to,to + 0x80,tmp);\n", "  piVar1 = __errno_location();\n", "  *piVar1 = 0x19283745;\n", "  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return 0;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "errstr(char *err, uint n)\n", "{\n", "\tchar tmp[ERRMAX];\n", "\tchar *syserr;\n", "\n", "\tstrecpy(tmp, tmp+ERRMAX, err);\n", "\trerrstr(err, n);\n", "\tsyserr = getsyserr();\n", "\tstrecpy(syserr, syserr+ERRMAX, tmp);\n", "\terrno = EPLAN9;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int notedisable(char *msg)\n", "\n", "{\n", "  int sig;\n", "  \n", "  sig = _p9strsig(msg);\n", "  sig = notesetenable(sig,0);\n", "  return sig;\n", "}\n", "\n"], "c": ["int\n", "notedisable(char *msg)\n", "{\n", "\treturn notesetenable(_p9strsig(msg), 0);\n", "}"]}, {"ghidra": ["\n", "int gettokens(char *s,char **args,int maxargs,char *sep)\n", "\n", "{\n", "  bool bVar1;\n", "  char *pcVar2;\n", "  long c;\n", "  int iVar3;\n", "  \n", "  if (maxargs < 1) {\n", "    iVar3 = 0;\n", "  }\n", "  else {\n", "    iVar3 = 0;\n", "    while (*s != '\\0') {\n", "      pcVar2 = utfrune(sep,(long)*s);\n", "      if (pcVar2 == (char *)0x0) {\n", "        if (*s == '\\0') {\n", "          return iVar3;\n", "        }\n", "        *args = s;\n", "        c = (long)*s;\n", "        bVar1 = false;\n", "LAB_00413550:\n", "        if ((char)c != '\\0') {\n", "          do {\n", "            if (bVar1) {\n", "              if ((char)c == '\\'') goto LAB_004135a8;\n", "            }\n", "            else {\n", "              pcVar2 = utfrune(sep,c);\n", "              if (pcVar2 != (char *)0x0) break;\n", "              if (*s == '\\'') {\n", "                c = (long)s[1];\n", "                bVar1 = true;\n", "                s = s + 1;\n", "                goto LAB_00413550;\n", "              }\n", "            }\n", "            pcVar2 = s + 1;\n", "            c = (long)*pcVar2;\n", "            s = s + 1;\n", "            if (*pcVar2 == '\\0') break;\n", "          } while( true );\n", "        }\n", "        iVar3 = iVar3 + 1;\n", "        args = args + 1;\n", "        if (iVar3 == maxargs) {\n", "          return iVar3;\n", "        }\n", "      }\n", "      else {\n", "        *s = '\\0';\n", "        s = s + 1;\n", "      }\n", "    }\n", "  }\n", "  return iVar3;\n", "LAB_004135a8:\n", "  c = (long)s[1];\n", "  if (s[1] == '\\'') {\n", "    c = (long)s[2];\n", "    bVar1 = true;\n", "    s = s + 2;\n", "  }\n", "  else {\n", "    s = s + 1;\n", "    bVar1 = false;\n", "  }\n", "  goto LAB_00413550;\n", "}\n", "\n"], "c": ["int\n", "gettokens(char *s, char **args, int maxargs, char *sep)\n", "{\n", "\tint nargs;\n", "\n", "\tfor(nargs=0; nargs<maxargs; nargs++){\n", "\t\twhile(*s!='\\0' && utfrune(sep, *s)!=nil)\n", "\t\t\t*s++ = '\\0';\n", "\t\tif(*s == '\\0')\n", "\t\t\tbreak;\n", "\t\targs[nargs] = s;\n", "\t\ts = etoken(s, sep);\n", "\t}\n", "\n", "\treturn nargs;\n", "}"]}, {"ghidra": ["\n", "tree * newtree(void)\n", "\n", "{\n", "  tree *ptVar1;\n", "  \n", "  ptVar1 = (tree *)emalloc(0x40);\n", "  ptVar1->iskw = 0;\n", "  ptVar1->str = (char *)0x0;\n", "  ptVar1->child[2] = (tree *)0x0;\n", "  ptVar1->child[1] = (tree *)0x0;\n", "  ptVar1->child[0] = (tree *)0x0;\n", "  ptVar1->next = treenodes;\n", "  treenodes = ptVar1;\n", "  return ptVar1;\n", "}\n", "\n"], "c": ["tree*\n", "newtree(void)\n", "{\n", "\ttree *t = new(tree);\n", "\tt->iskw = 0;\n", "\tt->str = 0;\n", "\tt->child[0] = t->child[1] = t->child[2] = 0;\n", "\tt->next = treenodes;\n", "\ttreenodes = t;\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "void qlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock != (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\t(*_qlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 1;\n", "}"]}, {"ghidra": ["\n", "void bigpath(var *v)\n", "\n", "{\n", "  char *pcVar1;\n", "  word *val;\n", "  char *__s;\n", "  word **ppwVar2;\n", "  long in_FS_OFFSET;\n", "  word *w;\n", "  long local_20;\n", "  \n", "  ppwVar2 = &w;\n", "  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n", "  if (v->val == (word *)0x0) {\n", "    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_0040be06;\n", "    val = (word *)0x0;\n", "  }\n", "  else {\n", "    __s = v->val->word;\n", "    w = (word *)0x0;\n", "    if (*__s != '\\0') {\n", "      do {\n", "        while( true ) {\n", "          pcVar1 = strchr(__s,0x3a);\n", "          if (pcVar1 == (char *)0x0) {\n", "            if (*__s == '\\0') {\n", "              val = newword(\".\",(word *)0x0);\n", "              *ppwVar2 = val;\n", "            }\n", "            else {\n", "              val = newword(__s,(word *)0x0);\n", "              *ppwVar2 = val;\n", "            }\n", "            goto LAB_0040bd88;\n", "          }\n", "          *pcVar1 = '\\0';\n", "          if (*__s == '\\0') break;\n", "          val = newword(__s,(word *)0x0);\n", "          *ppwVar2 = val;\n", "          *pcVar1 = ':';\n", "          __s = pcVar1 + 1;\n", "          ppwVar2 = &val->next;\n", "          if (__s == (char *)0x0) goto LAB_0040bd88;\n", "        }\n", "        val = newword(\".\",(word *)0x0);\n", "        *ppwVar2 = val;\n", "        *pcVar1 = ':';\n", "        __s = pcVar1 + 1;\n", "        ppwVar2 = &val->next;\n", "      } while (__s != (char *)0x0);\n", "    }\n", "LAB_0040bd88:\n", "    val = w;\n", "    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "LAB_0040be06:\n", "                    /* WARNING: Subroutine does not return */\n", "      __stack_chk_fail();\n", "    }\n", "  }\n", "  _setvar(\"path\",val,0);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "bigpath(var *v)\n", "{\n", "\t/* convert $PATH to $path */\n", "\tchar *p, *q;\n", "\tword **l, *w;\n", "\n", "\tif(v->val == nil){\n", "\t\t_setvar(\"path\", nil, 0);\n", "\t\treturn;\n", "\t}\n", "\tp = v->val->word;\n", "\tw = nil;\n", "\tl = &w;\n", "\t/*\n", "\t * Doesn't handle escaped colon nonsense.\n", "\t */\n", "\tif(p[0] == 0)\n", "\t\tp = nil;\n", "\twhile(p){\n", "\t\tq = strchr(p, ':');\n", "\t\tif(q)\n", "\t\t\t*q = 0;\n", "\t\t*l = newword(p[0] ? p : \".\", nil);\n", "\t\tl = &(*l)->next;\n", "\t\tif(q){\n", "\t\t\t*q = ':';\n", "\t\t\tp = q+1;\n", "\t\t}else\n", "\t\t\tp = nil;\n", "\t}\n", "\t_setvar(\"path\", w, 0);\n", "}"]}, {"ghidra": ["\n", "int advance(void)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = future;\n", "  if (future == -1) {\n", "    iVar1 = getnext();\n", "  }\n", "  future = -1;\n", "  lastc = iVar1;\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "advance(void)\n", "{\n", "\tint c = nextc();\n", "\tlastc = future;\n", "\tfuture = EOF;\n", "\treturn c;\n", "}"]}, {"ghidra": ["\n", "void lock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock != (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->held = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "lock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\t(*_lock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 1;\n", "}"]}, {"ghidra": ["\n", "long readn(int f,void *av,long n)\n", "\n", "{\n", "  ssize_t sVar1;\n", "  long lVar2;\n", "  \n", "  if (n < 1) {\n", "    lVar2 = 0;\n", "  }\n", "  else {\n", "    lVar2 = 0;\n", "    do {\n", "      sVar1 = read(f,(void *)((long)av + lVar2),n - lVar2);\n", "      if (sVar1 < 1) {\n", "        if (lVar2 != 0) {\n", "          return lVar2;\n", "        }\n", "        return sVar1;\n", "      }\n", "      lVar2 = lVar2 + sVar1;\n", "    } while (lVar2 < n);\n", "  }\n", "  return lVar2;\n", "}\n", "\n"], "c": ["long\n", "readn(int f, void *av, long n)\n", "{\n", "\tchar *a;\n", "\tlong m, t;\n", "\n", "\ta = av;\n", "\tt = 0;\n", "\twhile(t < n){\n", "\t\tm = read(f, a+t, n-t);\n", "\t\tif(m <= 0){\n", "\t\t\tif(t == 0)\n", "\t\t\t\treturn m;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tt += m;\n", "\t}\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "void execexit(void)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = count(runq->argv->words);\n", "  if (iVar1 != 1) {\n", "    if (iVar1 != 2) {\n", "      pfmt(rc_err,\"Usage: exit [status]\\nExiting anyway\\n\");\n", "    }\n", "    setstatus(runq->argv->words->next->word);\n", "  }\n", "  Xexit();\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execexit(void)\n", "{\n", "\tswitch(count(runq->argv->words)){\n", "\tdefault:\n", "\t\tpfmt(err, \"Usage: exit [status]\\nExiting anyway\\n\");\n", "\tcase 2:\n", "\t\tsetstatus(runq->argv->words->next->word);\n", "\tcase 1:\tXexit();\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int Creat(char *file)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = p9create(file,1,0x1b6);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int Creat(char *file)\n", "{\n", "\treturn create(file, 1, 0666L);\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Exceeded maximum restarts with more pending */\n", "\n", "void Xsimple(void)\n", "\n", "{\n", "  thread *ptVar1;\n", "  int pid;\n", "  int iVar2;\n", "  var *func;\n", "  code **ppcVar3;\n", "  long lVar4;\n", "  code *pcVar5;\n", "  word *w;\n", "  builtin *pbVar6;\n", "  char *__s1;\n", "  char *__s2;\n", "  bool bVar7;\n", "  byte bVar8;\n", "  \n", "  ptVar1 = runq;\n", "  bVar8 = 0;\n", "  globlist();\n", "  w = runq->argv->words;\n", "  if (w == (word *)0x0) {\n", "    Xerror1(\"empty argument list\");\n", "    return;\n", "  }\n", "  if (flag[120] != (char **)0x0) {\n", "    pfmt(rc_err,\"%v\\n\",ptVar1->argv->words);\n", "  }\n", "  func = gvlook(w->word);\n", "  bVar7 = func->fn == (code *)0x0;\n", "  if (!bVar7) {\n", "    execfunc(func);\n", "    return;\n", "  }\n", "  lVar4 = 8;\n", "  __s1 = w->word;\n", "  __s2 = \"builtin\";\n", "  do {\n", "    if (lVar4 == 0) break;\n", "    lVar4 = lVar4 + -1;\n", "    bVar7 = *__s1 == *__s2;\n", "    __s1 = __s1 + (ulong)bVar8 * -2 + 1;\n", "    __s2 = __s2 + (ulong)bVar8 * -2 + 1;\n", "  } while (bVar7);\n", "  if (bVar7) {\n", "    pid = count(w);\n", "    if (pid == 1) {\n", "      pfmt(rc_err,\"builtin: empty argument list\\n\");\n", "      setstatus(\"empty arg list\");\n", "      poplist();\n", "      return;\n", "    }\n", "    w = w->next;\n", "    popword();\n", "  }\n", "  if (Builtin[0].name != (char *)0x0) {\n", "    __s1 = w->word;\n", "    pbVar6 = Builtin;\n", "    __s2 = Builtin[0].name;\n", "    do {\n", "      pid = strcmp(__s1,__s2);\n", "      if (pid == 0) {\n", "                    /* WARNING: Could not recover jumptable at 0x00409c62. Too many branches */\n", "                    /* WARNING: Treating indirect jump as call */\n", "        (*pbVar6->fnc)();\n", "        return;\n", "      }\n", "      pbVar6 = pbVar6 + 1;\n", "      __s2 = pbVar6->name;\n", "    } while (__s2 != (char *)0x0);\n", "  }\n", "  ppcVar3 = (code **)(runq->code + runq->pc);\n", "  pcVar5 = *ppcVar3;\n", "  if (pcVar5 == Xpopredir) {\n", "    do {\n", "      ppcVar3 = ppcVar3 + 1;\n", "      pcVar5 = *ppcVar3;\n", "    } while (pcVar5 == Xpopredir);\n", "  }\n", "  if (pcVar5 == Xexit) {\n", "    pushword(\"exec\");\n", "    execexec();\n", "    Xexit();\n", "    return;\n", "  }\n", "  flush(rc_err);\n", "  Updenv();\n", "  pid = execforkexec();\n", "  if (pid < 0) {\n", "    Xerror(\"try again\");\n", "    return;\n", "  }\n", "  poplist();\n", "  do {\n", "    iVar2 = Waitfor(pid,1);\n", "  } while (iVar2 < 0);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "Xsimple(void)\n", "{\n", "\tword *a;\n", "\tthread *p = runq;\n", "\tvar *v;\n", "\tstruct builtin *bp;\n", "\tint pid;\n", "\tgloblist();\n", "\ta = runq->argv->words;\n", "\tif(a==0){\n", "\t\tXerror1(\"empty argument list\");\n", "\t\treturn;\n", "\t}\n", "\tif(flag['x'])\n", "\t\tpfmt(err, \"%v\\n\", p->argv->words); /* wrong, should do redirs */\n", "\tv = gvlook(a->word);\n", "\tif(v->fn)\n", "\t\texecfunc(v);\n", "\telse{\n", "\t\tif(strcmp(a->word, \"builtin\")==0){\n", "\t\t\tif(count(a)==1){\n", "\t\t\t\tpfmt(err, \"builtin: empty argument list\\n\");\n", "\t\t\t\tsetstatus(\"empty arg list\");\n", "\t\t\t\tpoplist();\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\t\ta = a->next;\n", "\t\t\tpopword();\n", "\t\t}\n", "\t\tfor(bp = Builtin;bp->name;bp++)\n", "\t\t\tif(strcmp(a->word, bp->name)==0){\n", "\t\t\t\t(*bp->fnc)();\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\tif(exitnext()){\n", "\t\t\t/* fork and wait is redundant */\n", "\t\t\tpushword(\"exec\");\n", "\t\t\texecexec();\n", "\t\t\tXexit();\n", "\t\t}\n", "\t\telse{\n", "\t\t\tflush(err);\n", "\t\t\tUpdenv();\t/* necessary so changes don't go out again */\n", "\t\t\tif((pid = execforkexec()) < 0){\n", "\t\t\t\tXerror(\"try again\");\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\n", "\t\t\t/* interrupts don't get us out */\n", "\t\t\tpoplist();\n", "\t\t\twhile(Waitfor(pid, 1) < 0)\n", "\t\t\t\t;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "char * get9root(void)\n", "\n", "{\n", "  char *s;\n", "  char *pcVar1;\n", "  \n", "  if (s == (char *)0x0) {\n", "    pcVar1 = p9getenv(\"PLAN9\");\n", "    if (pcVar1 == (char *)0x0) {\n", "      pcVar1 = \"/usr/lib/plan9\";\n", "    }\n", "    return pcVar1;\n", "  }\n", "  return s;\n", "}\n", "\n"], "c": ["char*\n", "get9root(void)\n", "{\n", "\tstatic char *s;\n", "\n", "\tif(s)\n", "\t\treturn s;\n", "\n", "\tif((s = getenv(\"PLAN9\")) != 0)\n", "\t\treturn s;\n", "\t/* could do better - search $PATH */\n", "\ts = PREFIX;\n", "\treturn s;\n", "}"]}, {"ghidra": ["\n", "void pchr(io *b,int c)\n", "\n", "{\n", "  char *pcVar1;\n", "  \n", "  pcVar1 = b->bufp;\n", "  if (pcVar1 == b->ebuf) {\n", "    flush(b);\n", "    pcVar1 = b->bufp;\n", "    b->bufp = pcVar1 + 1;\n", "    *pcVar1 = (char)c;\n", "  }\n", "  else {\n", "    b->bufp = pcVar1 + 1;\n", "    *pcVar1 = (char)c;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pchr(io *b, int c)\n", "{\n", "\tif(b->bufp==b->ebuf)\n", "\t\tfullbuf(b, c);\n", "\telse *b->bufp++=c;\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  p9main(argc,argv);\n", "  exits(\"main\");\n", "  return 99;\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char **argv)\n", "{\n", "\tp9main(argc, argv);\n", "\texits(\"main\");\n", "\treturn 99;\n", "}"]}, {"ghidra": ["\n", "int noteenable(char *msg)\n", "\n", "{\n", "  int sig;\n", "  \n", "  sig = _p9strsig(msg);\n", "  sig = notesetenable(sig,1);\n", "  return sig;\n", "}\n", "\n"], "c": ["int\n", "noteenable(char *msg)\n", "{\n", "\treturn notesetenable(_p9strsig(msg), 1);\n", "}"]}, {"ghidra": ["\n", "void freenodes(void)\n", "\n", "{\n", "  tree *ptVar1;\n", "  tree *p;\n", "  \n", "  p = treenodes;\n", "  if (treenodes != (tree *)0x0) {\n", "    do {\n", "      ptVar1 = p->next;\n", "      if (p->str != (char *)0x0) {\n", "        efree(p->str);\n", "      }\n", "      efree((char *)p);\n", "      p = ptVar1;\n", "    } while (ptVar1 != (tree *)0x0);\n", "  }\n", "  treenodes = (tree *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "freenodes(void)\n", "{\n", "\ttree *t, *u;\n", "\tfor(t = treenodes;t;t = u){\n", "\t\tu = t->next;\n", "\t\tif(t->str)\n", "\t\t\tefree(t->str);\n", "\t\tefree((char *)t);\n", "\t}\n", "\ttreenodes = 0;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Unknown calling convention yet parameter storage is locked */\n", "\n", "int Unlink(char *__filename)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = remove(__filename);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["void Unlink(char *name)\n", "{\n", "\tremove(name);\n", "}"]}, {"ghidra": ["\n", "void sysfatal(char *fmt,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  char *pcVar1;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list arg;\n", "  char buf [256];\n", "  char local_d8 [8];\n", "  long local_d0;\n", "  undefined local_c8 [8];\n", "  undefined8 local_c0;\n", "  undefined8 local_b8;\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined4 local_98;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_98 = in_XMM0_Da;\n", "    local_88 = in_XMM1_Da;\n", "    local_78 = in_XMM2_Da;\n", "    local_68 = in_XMM3_Da;\n", "    local_58 = in_XMM4_Da;\n", "    local_48 = in_XMM5_Da;\n", "    local_38 = in_XMM6_Da;\n", "    local_28 = in_XMM7_Da;\n", "  }\n", "  local_d0 = *(long *)(in_FS_OFFSET + 0x28);\n", "  arg[0].overflow_arg_area = &stack0x00000008;\n", "  arg[0].reg_save_area = local_c8;\n", "  arg[0].gp_offset = 8;\n", "  arg[0].fp_offset = 0x30;\n", "  local_c0 = in_RSI;\n", "  local_b8 = in_RDX;\n", "  local_b0 = in_RCX;\n", "  local_a8 = in_R8;\n", "  local_a0 = in_R9;\n", "  if (_sysfatal != (anon_subr_void_char_ptr *)0x0) {\n", "    (*_sysfatal)(fmt,arg);\n", "  }\n", "  vseprint(buf,local_d8,fmt,arg);\n", "  __fixargv0();\n", "  pcVar1 = argv0;\n", "  if (argv0 == (char *)0x0) {\n", "    pcVar1 = \"<prog>\";\n", "  }\n", "  fprint(2,\"%s: %s\\n\",pcVar1,buf);\n", "  exits(\"fatal\");\n", "  if (local_d0 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "sysfatal(char *fmt, ...)\n", "{\n", "\tchar buf[256];\n", "\tva_list arg;\n", "\n", "\tva_start(arg, fmt);\n", "\tif(_sysfatal)\n", "\t\t(*_sysfatal)(fmt, arg);\n", "\tvseprint(buf, buf+sizeof buf, fmt, arg);\n", "\tva_end(arg);\n", "\n", "\t__fixargv0();\n", "\tfprint(2, \"%s: %s\\n\", argv0 ? argv0 : \"<prog>\", buf);\n", "\texits(\"fatal\");\n", "}"]}, {"ghidra": ["\n", "void stuffdot(int a)\n", "\n", "{\n", "  if ((-1 < a) && (a < codep)) {\n", "    *(int *)(codebuf + a) = codep;\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  panic(\"Bad address %d in stuffdot\",a);\n", "}\n", "\n"], "c": ["void\n", "stuffdot(int a)\n", "{\n", "\tif(a<0 || codep<=a)\n", "\t\tpanic(\"Bad address %d in stuffdot\", a);\n", "\tcodebuf[a].i = codep;\n", "}"]}, {"ghidra": ["\n", "tree * epimung(tree *comp,tree *epi)\n", "\n", "{\n", "  tree *ptVar1;\n", "  tree *ptVar2;\n", "  \n", "  ptVar1 = epi;\n", "  if (epi == (tree *)0x0) {\n", "    return comp;\n", "  }\n", "  do {\n", "    ptVar2 = ptVar1;\n", "    ptVar1 = ptVar2->child[1];\n", "  } while (ptVar1 != (tree *)0x0);\n", "  ptVar2->child[1] = comp;\n", "  return epi;\n", "}\n", "\n"], "c": ["tree*\n", "epimung(tree *comp, tree *epi)\n", "{\n", "\ttree *p;\n", "\tif(epi==0)\n", "\t\treturn comp;\n", "\tfor(p = epi;p->child[1];p = p->child[1]);\n", "\tp->child[1] = comp;\n", "\treturn epi;\n", "}"]}, {"ghidra": ["\n", "tree * heredoc(tree *tag)\n", "\n", "{\n", "  here *phVar1;\n", "  uint uVar2;\n", "  here *phVar3;\n", "  char *pcVar4;\n", "  tree *ptVar5;\n", "  bool bVar6;\n", "  \n", "  phVar3 = (here *)emalloc(0x18);\n", "  if (tag->type != 0xe00c) {\n", "    yyerror(\"Bad here tag\");\n", "  }\n", "  bVar6 = here != (here *)0x0;\n", "  phVar3->next = (here *)0x0;\n", "  phVar1 = phVar3;\n", "  if (bVar6) {\n", "    *ehere = phVar3;\n", "    phVar1 = here;\n", "  }\n", "  here = phVar1;\n", "  ehere = &phVar3->next;\n", "  phVar3->tag = tag;\n", "  uVar2 = getpid();\n", "  tmp[9] = hex[(int)uVar2 >> 0xc & 0xf];\n", "  tmp[10] = hex[(int)uVar2 >> 8 & 0xf];\n", "  tmp[11] = hex[(int)uVar2 >> 4 & 0xf];\n", "  tmp[12] = hex[uVar2 & 0xf];\n", "  tmp[14] = hex[ser >> 0xc & 0xf];\n", "  tmp[15] = hex[ser >> 8 & 0xf];\n", "  tmp[16] = hex[ser >> 4 & 0xf];\n", "  tmp[17] = hex[ser & 0xf];\n", "  ser = ser + 1;\n", "  pcVar4 = p9strdup(tmp);\n", "  phVar3->name = pcVar4;\n", "  ptVar5 = token(tmp,0xe00c);\n", "  return ptVar5;\n", "}\n", "\n"], "c": ["tree*\n", "heredoc(tree *tag)\n", "{\n", "\tstruct here *h = new(struct here);\n", "\tif(tag->type!=WORD)\n", "\t\tyyerror(\"Bad here tag\");\n", "\th->next = 0;\n", "\tif(here)\n", "\t\t*ehere = h;\n", "\telse\n", "\t\there = h;\n", "\tehere=&h->next;\n", "\th->tag = tag;\n", "\thexnum(&tmp[9], getpid());\n", "\thexnum(&tmp[14], ser++);\n", "\th->name = strdup(tmp);\n", "\treturn token(tmp, WORD);\n", "}"]}, {"ghidra": ["\n", "int emptybuf(io *f)\n", "\n", "{\n", "  long lVar1;\n", "  \n", "  if (f->fd != -1) {\n", "    lVar1 = Read(f->fd,f->buf,0x200);\n", "    if (0 < (int)lVar1) {\n", "      f->ebuf = f->buf + (int)lVar1;\n", "      f->bufp = f->buf + 1;\n", "      return (int)(uint)(byte)f->buf[0];\n", "    }\n", "  }\n", "  return -1;\n", "}\n", "\n"], "c": ["int\n", "emptybuf(io *f)\n", "{\n", "\tint n;\n", "\tif(f->fd==-1 || (n = Read(f->fd, f->buf, NBUF))<=0) return EOF;\n", "\tf->bufp = f->buf;\n", "\tf->ebuf = f->buf+n;\n", "\treturn *f->bufp++&0xff;\n", "}"]}, {"ghidra": ["\n", "ulong getcallerpc(void *x)\n", "\n", "{\n", "  return *(ulong *)((long)x + -8);\n", "}\n", "\n"], "c": ["ulong\n", "getcallerpc(void *x)\n", "{\n", "\treturn (((ulong*)(x))[-1]);\n", "}"]}, {"ghidra": ["\n", "void unlock(Lock *l)\n", "\n", "{\n", "  anon_subr_void_Lock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _unlock;\n", "  if (_unlock != (anon_subr_void_Lock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "unlock(Lock *l)\n", "{\n", "\tif(_unlock)\n", "\t\t(*_unlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->held = 0;\n", "}"]}, {"ghidra": ["\n", "void Trapinit(void)\n", "\n", "{\n", "  notify(notifyf);\n", "  return;\n", "}\n", "\n"], "c": ["void Trapinit(void){\n", "\tnotify(notifyf);\n", "}"]}, {"ghidra": ["\n", "void Xpipe(void)\n", "\n", "{\n", "  int iVar1;\n", "  int to;\n", "  int to_00;\n", "  long lVar2;\n", "  thread *ptVar3;\n", "  int iVar4;\n", "  __pid_t pid;\n", "  long lVar5;\n", "  long in_FS_OFFSET;\n", "  int pfd [2];\n", "  \n", "  ptVar3 = runq;\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar1 = runq->pc;\n", "  lVar5 = (long)iVar1;\n", "  to = *(int *)(runq->code + lVar5);\n", "  to_00 = *(int *)(runq->code + lVar5 + 1);\n", "  iVar4 = pipe(pfd);\n", "  if (iVar4 < 0) {\n", "    Xerror(\"can\\'t get pipe\");\n", "  }\n", "  else {\n", "    pid = fork();\n", "    if (pid == -1) {\n", "      Xerror(\"try again\");\n", "    }\n", "    else {\n", "      if (pid == 0) {\n", "        clearwaitpids();\n", "        start(ptVar3->code,iVar1 + 4,runq->local);\n", "        runq->ret = (thread *)0x0;\n", "        close(pfd[0]);\n", "        pushredir(1,pfd[1],to);\n", "      }\n", "      else {\n", "        addwaitpid(pid);\n", "        start(ptVar3->code,*(int *)(ptVar3->code + lVar5 + 2),runq->local);\n", "        close(pfd[1]);\n", "        pushredir(1,pfd[0],to_00);\n", "        iVar1 = *(int *)(ptVar3->code + lVar5 + 3);\n", "        ptVar3->pid = pid;\n", "        ptVar3->pc = iVar1;\n", "      }\n", "    }\n", "  }\n", "  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "Xpipe(void)\n", "{\n", "\tstruct thread *p = runq;\n", "\tint pc = p->pc, forkid;\n", "\tint lfd = p->code[pc++].i;\n", "\tint rfd = p->code[pc++].i;\n", "\tint pfd[2];\n", "\tif(pipe(pfd)<0){\n", "\t\tXerror(\"can't get pipe\");\n", "\t\treturn;\n", "\t}\n", "\tswitch(forkid = fork()){\n", "\tcase -1:\n", "\t\tXerror(\"try again\");\n", "\t\tbreak;\n", "\tcase 0:\n", "\t\tclearwaitpids();\n", "\t\tstart(p->code, pc+2, runq->local);\n", "\t\trunq->ret = 0;\n", "\t\tclose(pfd[PRD]);\n", "\t\tpushredir(ROPEN, pfd[PWR], lfd);\n", "\t\tbreak;\n", "\tdefault:\n", "\t\taddwaitpid(forkid);\n", "\t\tstart(p->code, p->code[pc].i, runq->local);\n", "\t\tclose(pfd[PWR]);\n", "\t\tpushredir(ROPEN, pfd[PRD], rfd);\n", "\t\tp->pc = p->code[pc+1].i;\n", "\t\tp->pid = forkid;\n", "\t\tbreak;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void * p9malloc(ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  if (n == 0) {\n", "    n = 1;\n", "  }\n", "  lock(&malloclock);\n", "  pvVar1 = malloc(n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9malloc(ulong n)\n", "{\n", "\tvoid *v;\n", "\t\n", "\tif(n == 0)\n", "\t\tn++;\n", "\tlock(&malloclock);\n", "\tv = malloc(n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void globlist(void)\n", "\n", "{\n", "  word *pwVar1;\n", "  list *plVar2;\n", "  word *pwVar3;\n", "  word *pwVar4;\n", "  \n", "  globv = (word *)0x0;\n", "  globlist1(runq->argv->words);\n", "  poplist();\n", "  pushlist();\n", "  pwVar3 = globv;\n", "  pwVar1 = globv;\n", "  if (globv != (word *)0x0) {\n", "    do {\n", "      pwVar4 = pwVar1;\n", "      pwVar1 = pwVar4->next;\n", "    } while (pwVar1 != (word *)0x0);\n", "    plVar2 = runq->argv;\n", "    pwVar4->next = plVar2->words;\n", "    plVar2->words = pwVar3;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "globlist(void)\n", "{\n", "\tword *a;\n", "\tglobv = 0;\n", "\tgloblist1(runq->argv->words);\n", "\tpoplist();\n", "\tpushlist();\n", "\tif(globv){\n", "\t\tfor(a = globv;a->next;a = a->next);\n", "\t\ta->next = runq->argv->words;\n", "\t\trunq->argv->words = globv;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void execfinit(void)\n", "\n", "{\n", "  int first;\n", "  \n", "  if (first != 0) {\n", "    rdfns[0]._0_4_ = 1;\n", "    rdfns[1] = Xrdfn;\n", "    rdfns[2] = Xjump;\n", "    rdfns[3]._0_4_ = 1;\n", "    first = 0;\n", "  }\n", "  Xpopm();\n", "  envp = environp;\n", "  start(rdfns,1,runq->local);\n", "  return;\n", "}\n", "\n"], "c": ["void execfinit(void){\n", "\tstatic int first=1;\n", "\tif(first){\n", "\t\trdfns[0].i=1;\n", "\t\trdfns[1].f=Xrdfn;\n", "\t\trdfns[2].f=Xjump;\n", "\t\trdfns[3].i=1;\n", "\t\tfirst=0;\n", "\t}\n", "\tXpopm();\n", "\tenvp=environp;\n", "\tstart(rdfns, 1, runq->local);\n", "}"]}, {"ghidra": ["\n", "void __fmtlock(void)\n", "\n", "{\n", "  lock(&fmtlock);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "__fmtlock(void)\n", "{\n", "\tlock(&fmtlock);\n", "}"]}, {"ghidra": ["\n", "int p9putenv(char *s,char *v)\n", "\n", "{\n", "  int iVar1;\n", "  char *__string;\n", "  \n", "  __string = smprint(\"%s=%s\",s,v);\n", "  if (__string == (char *)0x0) {\n", "    iVar1 = -1;\n", "  }\n", "  else {\n", "    putenv(__string);\n", "    iVar1 = 0;\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "p9putenv(char *s, char *v)\n", "{\n", "\tchar *t;\n", "\n", "\tt = smprint(\"%s=%s\", s, v);\n", "\tif(t == nil)\n", "\t\treturn -1;\n", "\tputenv(t);\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int notifyoff(char *msg)\n", "\n", "{\n", "  int s;\n", "  \n", "  s = _p9strsig(msg);\n", "  s = notifyseton(s,0);\n", "  return s;\n", "}\n", "\n"], "c": ["int\n", "notifyoff(char *msg)\n", "{\n", "\treturn notifyseton(_p9strsig(msg), 0);\n", "}"]}, {"ghidra": ["\n", "void inttoascii(char *s,long n)\n", "\n", "{\n", "  bp = s;\n", "  iacvt((int)n);\n", "  *bp = '\\0';\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "inttoascii(char *s, long n)\n", "{\n", "\tbp = s;\n", "\tiacvt(n);\n", "\t*bp='\\0';\n", "}"]}, {"ghidra": ["\n", "void pfmt(io *f,char *fmt,...)\n", "\n", "{\n", "  char *pcVar1;\n", "  char cVar2;\n", "  long lVar3;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  ulong uVar4;\n", "  tree **pptVar5;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  long in_FS_OFFSET;\n", "  va_list ap;\n", "  char rc_err [128];\n", "  tree *local_48 [2];\n", "  undefined8 local_38;\n", "  undefined8 local_30;\n", "  undefined8 local_28;\n", "  undefined8 local_20;\n", "  \n", "  lVar3 = *(long *)(in_FS_OFFSET + 0x28);\n", "  ap[0].overflow_arg_area = &stack0x00000008;\n", "  ap[0].gp_offset = 0x10;\n", "  pfmtnest = pfmtnest + 1;\n", "  cVar2 = *fmt;\n", "  local_38 = in_RDX;\n", "  local_30 = in_RCX;\n", "  local_28 = in_R8;\n", "  local_20 = in_R9;\n", "  while (cVar2 != '\\0') {\n", "    if (cVar2 == '%') {\n", "      cVar2 = fmt[1];\n", "      pcVar1 = fmt + 1;\n", "      if (cVar2 == 'p') {\n", "        if (ap[0].gp_offset < 0x30) {\n", "          uVar4 = (ulong)ap[0].gp_offset;\n", "          ap[0].gp_offset = ap[0].gp_offset + 8;\n", "          pptVar5 = (tree **)((long)local_48 + uVar4);\n", "        }\n", "        else {\n", "          pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "          ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "        }\n", "        pptr(f,*pptVar5);\n", "        fmt = pcVar1;\n", "        goto LAB_00407f46;\n", "      }\n", "      if ('p' < cVar2) {\n", "        if (cVar2 == 's') {\n", "          if (ap[0].gp_offset < 0x30) {\n", "            uVar4 = (ulong)ap[0].gp_offset;\n", "            ap[0].gp_offset = ap[0].gp_offset + 8;\n", "            pptVar5 = (tree **)((long)local_48 + uVar4);\n", "          }\n", "          else {\n", "            pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "            ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "          }\n", "          pstr(f,(char *)*pptVar5);\n", "          fmt = pcVar1;\n", "        }\n", "        else {\n", "          if (cVar2 < 't') {\n", "            if (cVar2 == 'q') {\n", "              if (ap[0].gp_offset < 0x30) {\n", "                uVar4 = (ulong)ap[0].gp_offset;\n", "                ap[0].gp_offset = ap[0].gp_offset + 8;\n", "                pptVar5 = (tree **)((long)local_48 + uVar4);\n", "              }\n", "              else {\n", "                pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "                ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "              }\n", "              pwrd(f,(char *)*pptVar5);\n", "              fmt = pcVar1;\n", "            }\n", "            else {\n", "              if (cVar2 != 'r') goto LAB_004080c0;\n", "              rerrstr(rc_err,0x80);\n", "              pstr(f,rc_err);\n", "              fmt = pcVar1;\n", "            }\n", "          }\n", "          else {\n", "            if (cVar2 == 't') {\n", "              if (ap[0].gp_offset < 0x30) {\n", "                uVar4 = (ulong)ap[0].gp_offset;\n", "                ap[0].gp_offset = ap[0].gp_offset + 8;\n", "                pptVar5 = (tree **)((long)local_48 + uVar4);\n", "              }\n", "              else {\n", "                pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "                ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "              }\n", "              pcmd(f,*pptVar5);\n", "              fmt = pcVar1;\n", "            }\n", "            else {\n", "              if (cVar2 != 'v') goto LAB_004080c0;\n", "              if (ap[0].gp_offset < 0x30) {\n", "                uVar4 = (ulong)ap[0].gp_offset;\n", "                ap[0].gp_offset = ap[0].gp_offset + 8;\n", "                pptVar5 = (tree **)((long)local_48 + uVar4);\n", "              }\n", "              else {\n", "                pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "                ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "              }\n", "              pval(f,(word *)*pptVar5);\n", "              fmt = pcVar1;\n", "            }\n", "          }\n", "        }\n", "        goto LAB_00407f46;\n", "      }\n", "      if (cVar2 == 'c') {\n", "        if (ap[0].gp_offset < 0x30) {\n", "          uVar4 = (ulong)ap[0].gp_offset;\n", "          ap[0].gp_offset = ap[0].gp_offset + 8;\n", "          pptVar5 = (tree **)((long)local_48 + uVar4);\n", "        }\n", "        else {\n", "          pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "          ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "        }\n", "        pchr(f,*(uint *)pptVar5);\n", "        fmt = pcVar1;\n", "        goto LAB_00407f46;\n", "      }\n", "      if ('c' < cVar2) {\n", "        if (cVar2 == 'd') {\n", "          if (ap[0].gp_offset < 0x30) {\n", "            uVar4 = (ulong)ap[0].gp_offset;\n", "            ap[0].gp_offset = ap[0].gp_offset + 8;\n", "            pptVar5 = (tree **)((long)local_48 + uVar4);\n", "          }\n", "          else {\n", "            pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "            ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "          }\n", "          pdec(f,*(uint *)pptVar5);\n", "          fmt = pcVar1;\n", "        }\n", "        else {\n", "          if (cVar2 != 'o') goto LAB_004080c0;\n", "          if (ap[0].gp_offset < 0x30) {\n", "            uVar4 = (ulong)ap[0].gp_offset;\n", "            ap[0].gp_offset = ap[0].gp_offset + 8;\n", "            pptVar5 = (tree **)((long)local_48 + uVar4);\n", "          }\n", "          else {\n", "            pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "            ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "          }\n", "          poct(f,*(uint *)pptVar5);\n", "          fmt = pcVar1;\n", "        }\n", "        goto LAB_00407f46;\n", "      }\n", "      if (cVar2 == '\\0') goto LAB_00407fd7;\n", "      if (cVar2 != 'Q') {\n", "LAB_004080c0:\n", "        pchr(f,(int)cVar2);\n", "        fmt = pcVar1;\n", "        goto LAB_00407f46;\n", "      }\n", "      if (ap[0].gp_offset < 0x30) {\n", "        uVar4 = (ulong)ap[0].gp_offset;\n", "        ap[0].gp_offset = ap[0].gp_offset + 8;\n", "        pptVar5 = (tree **)((long)local_48 + uVar4);\n", "      }\n", "      else {\n", "        pptVar5 = (tree **)ap[0].overflow_arg_area;\n", "        ap[0].overflow_arg_area = (tree **)ap[0].overflow_arg_area + 1;\n", "      }\n", "      pquo(f,(char *)*pptVar5);\n", "      cVar2 = fmt[2];\n", "      fmt = fmt + 2;\n", "    }\n", "    else {\n", "      pchr(f,(int)cVar2);\n", "LAB_00407f46:\n", "      cVar2 = fmt[1];\n", "      fmt = fmt + 1;\n", "    }\n", "  }\n", "  pfmtnest = pfmtnest + -1;\n", "  if (pfmtnest == 0) {\n", "    flush(f);\n", "  }\n", "LAB_00407fd7:\n", "  if (lVar3 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "pfmt(io *f, char *fmt, ...)\n", "{\n", "\tva_list ap;\n", "\tchar err[ERRMAX];\n", "\tva_start(ap, fmt);\n", "\tpfmtnest++;\n", "\tfor(;*fmt;fmt++)\n", "\t\tif(*fmt!='%')\n", "\t\t\tpchr(f, *fmt);\n", "\t\telse switch(*++fmt){\n", "\t\tcase '\\0':\n", "\t\t\tva_end(ap);\n", "\t\t\treturn;\n", "\t\tcase 'c':\n", "\t\t\tpchr(f, va_arg(ap, int));\n", "\t\t\tbreak;\n", "\t\tcase 'd':\n", "\t\t\tpdec(f, va_arg(ap, int));\n", "\t\t\tbreak;\n", "\t\tcase 'o':\n", "\t\t\tpoct(f, va_arg(ap, unsigned));\n", "\t\t\tbreak;\n", "\t\tcase 'p':\n", "\t\t\tpptr(f, va_arg(ap, void*));\n", "\t\t\tbreak;\n", "\t\tcase 'Q':\n", "\t\t\tpquo(f, va_arg(ap, char *));\n", "\t\t\tbreak;\n", "\t\tcase 'q':\n", "\t\t\tpwrd(f, va_arg(ap, char *));\n", "\t\t\tbreak;\n", "\t\tcase 'r':\n", "\t\t\trerrstr(err, sizeof err); pstr(f, err);\n", "\t\t\tbreak;\n", "\t\tcase 's':\n", "\t\t\tpstr(f, va_arg(ap, char *));\n", "\t\t\tbreak;\n", "\t\tcase 't':\n", "\t\t\tpcmd(f, va_arg(ap, struct tree *));\n", "\t\t\tbreak;\n", "\t\tcase 'v':\n", "\t\t\tpval(f, va_arg(ap, struct word *));\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tpchr(f, *fmt);\n", "\t\t\tbreak;\n", "\t\t}\n", "\tva_end(ap);\n", "\tif(--pfmtnest==0)\n", "\t\tflush(f);\n", "}"]}, {"ghidra": ["\n", "void globlist1(word *gl)\n", "\n", "{\n", "  if (gl != (word *)0x0) {\n", "    globlist1(gl->next);\n", "    glob(gl->word);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "globlist1(word *gl)\n", "{\n", "\tif(gl){\n", "\t\tgloblist1(gl->next);\n", "\t\tglob(gl->word);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "char * addtok(char *p,int val)\n", "\n", "{\n", "  if (p == (char *)0x0) {\n", "    return (char *)0x0;\n", "  }\n", "  if (p != tok + 0x1fff) {\n", "    *p = (char)val;\n", "    return p + 1;\n", "  }\n", "  tok[8191] = '\\0';\n", "  yyerror(\"token buffer too short\");\n", "  return (char *)0x0;\n", "}\n", "\n"], "c": ["char*\n", "addtok(char *p, int val)\n", "{\n", "\tif(p==0)\n", "\t\treturn 0;\n", "\tif(p==&tok[NTOK-1]){\n", "\t\t*p = 0;\n", "\t\tyyerror(\"token buffer too short\");\n", "\t\treturn 0;\n", "\t}\n", "\t*p++=val;\n", "\treturn p;\n", "}"]}, {"ghidra": ["\n", "int __errfmt(Fmt *f)\n", "\n", "{\n", "  int iVar1;\n", "  int *piVar2;\n", "  char *s;\n", "  \n", "  piVar2 = __errno_location();\n", "  if (*piVar2 != 0x19283745) {\n", "    s = strerror(*piVar2);\n", "LAB_0040efbb:\n", "    iVar1 = fmtstrcpy(f,s);\n", "    return iVar1;\n", "  }\n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    s = (*_syserrstr)();\n", "    if (s != (char *)0x0) goto LAB_0040efbb;\n", "  }\n", "  iVar1 = fmtstrcpy(f,xsyserr);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "__errfmt(Fmt *f)\n", "{\n", "\tif(errno == EPLAN9)\n", "\t\treturn fmtstrcpy(f, getsyserr());\n", "\treturn fmtstrcpy(f, strerror(errno));\n", "}"]}, {"ghidra": ["\n", "int mapfd(int fd)\n", "\n", "{\n", "  char cVar1;\n", "  redir *prVar2;\n", "  \n", "  prVar2 = runq->redir;\n", "  do {\n", "    while( true ) {\n", "      if (prVar2 == (redir *)0x0) {\n", "        return fd;\n", "      }\n", "      cVar1 = prVar2->type;\n", "      if ('\\0' < cVar1) break;\n", "LAB_0040a1be:\n", "      prVar2 = prVar2->next;\n", "    }\n", "    if ('\\x02' < cVar1) {\n", "      if ((cVar1 == '\\x03') && ((int)prVar2->from == fd)) {\n", "        fd = -1;\n", "      }\n", "      goto LAB_0040a1be;\n", "    }\n", "    if ((int)prVar2->to != fd) goto LAB_0040a1be;\n", "    fd = (int)prVar2->from;\n", "    prVar2 = prVar2->next;\n", "  } while( true );\n", "}\n", "\n"], "c": ["int\n", "mapfd(int fd)\n", "{\n", "\tredir *rp;\n", "\tfor(rp = runq->redir;rp;rp = rp->next){\n", "\t\tswitch(rp->type){\n", "\t\tcase RCLOSE:\n", "\t\t\tif(rp->from==fd)\n", "\t\t\t\tfd=-1;\n", "\t\t\tbreak;\n", "\t\tcase RDUP:\n", "\t\tcase ROPEN:\n", "\t\t\tif(rp->to==fd)\n", "\t\t\t\tfd = rp->from;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\treturn fd;\n", "}"]}, {"ghidra": ["\n", "void qunlock(QLock *l)\n", "\n", "{\n", "  anon_subr_void_QLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qunlock;\n", "  if (_qunlock != (anon_subr_void_QLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  (l->l).held = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "qunlock(QLock *l)\n", "{\n", "\tif(_qunlock)\n", "\t\t(*_qunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->l.held = 0;\n", "}"]}, {"ghidra": ["\n", "void Xpipefd(void)\n", "\n", "{\n", "  int iVar1;\n", "  long lVar2;\n", "  thread *ptVar3;\n", "  int from;\n", "  __pid_t pid;\n", "  char *s;\n", "  long lVar4;\n", "  long in_FS_OFFSET;\n", "  int pfd [2];\n", "  char name [40];\n", "  \n", "  ptVar3 = runq;\n", "  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar1 = runq->pc;\n", "  from = pipe(pfd);\n", "  if (from < 0) {\n", "    Xerror(\"can\\'t get pipe\");\n", "  }\n", "  else {\n", "    lVar4 = (long)iVar1;\n", "    from = pfd[1];\n", "    if (*(int *)(ptVar3->code + lVar4) != 3) {\n", "      from = pfd[0];\n", "      pfd[0] = pfd[1];\n", "    }\n", "    pid = fork();\n", "    if (pid == -1) {\n", "      Xerror(\"try again\");\n", "    }\n", "    else {\n", "      if (pid == 0) {\n", "        clearwaitpids();\n", "        start(ptVar3->code,iVar1 + 2,runq->local);\n", "        close(pfd[0]);\n", "        pushredir(1,from,(uint)(*(int *)(ptVar3->code + lVar4) == 3));\n", "        runq->ret = (thread *)0x0;\n", "      }\n", "      else {\n", "        addwaitpid(pid);\n", "        close(from);\n", "        pushredir(1,pfd[0],pfd[0]);\n", "        s = (char *)__stpcpy_chk(name,Fdprefix,0x28);\n", "        inttoascii(s,(long)pfd[0]);\n", "        pushword(name);\n", "        ptVar3->pc = *(int *)(ptVar3->code + lVar4 + 1);\n", "      }\n", "    }\n", "  }\n", "  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "Xpipefd(void)\n", "{\n", "\tstruct thread *p = runq;\n", "\tint pc = p->pc, pid;\n", "\tchar name[40];\n", "\tint pfd[2];\n", "\tint sidefd, mainfd;\n", "\tif(pipe(pfd)<0){\n", "\t\tXerror(\"can't get pipe\");\n", "\t\treturn;\n", "\t}\n", "\tif(p->code[pc].i==READ){\n", "\t\tsidefd = pfd[PWR];\n", "\t\tmainfd = pfd[PRD];\n", "\t}\n", "\telse{\n", "\t\tsidefd = pfd[PRD];\n", "\t\tmainfd = pfd[PWR];\n", "\t}\n", "\tswitch(pid = fork()){\n", "\tcase -1:\n", "\t\tXerror(\"try again\");\n", "\t\tbreak;\n", "\tcase 0:\n", "\t\tclearwaitpids();\n", "\t\tstart(p->code, pc+2, runq->local);\n", "\t\tclose(mainfd);\n", "\t\tpushredir(ROPEN, sidefd, p->code[pc].i==READ?1:0);\n", "\t\trunq->ret = 0;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\taddwaitpid(pid);\n", "\t\tclose(sidefd);\n", "\t\tpushredir(ROPEN, mainfd, mainfd);\t/* isn't this a noop? */\n", "\t\tstrcpy(name, Fdprefix);\n", "\t\tinttoascii(name+strlen(name), mainfd);\n", "\t\tpushword(name);\n", "\t\tp->pc = p->code[pc+1].i;\n", "\t\tbreak;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void execshift(void)\n", "\n", "{\n", "  word *pwVar1;\n", "  char **ppcVar2;\n", "  int iVar3;\n", "  var *pvVar4;\n", "  \n", "  iVar3 = count(runq->argv->words);\n", "  if (iVar3 == 1) {\n", "    iVar3 = 1;\n", "    pvVar4 = vlook(\"*\");\n", "  }\n", "  else {\n", "    if (iVar3 != 2) {\n", "      pfmt(rc_err,\"Usage: shift [n]\\n\");\n", "      setstatus(\"shift usage\");\n", "      poplist();\n", "      return;\n", "    }\n", "    iVar3 = p9atoi(runq->argv->words->next->word);\n", "    pvVar4 = vlook(\"*\");\n", "    if (iVar3 == 0) goto LAB_0040a0dd;\n", "  }\n", "  pwVar1 = pvVar4->val;\n", "  do {\n", "    if (pwVar1 == (word *)0x0) break;\n", "    ppcVar2 = &pwVar1->word;\n", "    pwVar1 = pwVar1->next;\n", "    efree(*ppcVar2);\n", "    efree((char *)pvVar4->val);\n", "    iVar3 = iVar3 + -1;\n", "    pvVar4->val = pwVar1;\n", "    pvVar4->changed = 1;\n", "  } while (iVar3 != 0);\n", "LAB_0040a0dd:\n", "  setstatus(\"\");\n", "  poplist();\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execshift(void)\n", "{\n", "\tint n;\n", "\tword *a;\n", "\tvar *star;\n", "\tswitch(count(runq->argv->words)){\n", "\tdefault:\n", "\t\tpfmt(err, \"Usage: shift [n]\\n\");\n", "\t\tsetstatus(\"shift usage\");\n", "\t\tpoplist();\n", "\t\treturn;\n", "\tcase 2:\n", "\t\tn = atoi(runq->argv->words->next->word);\n", "\t\tbreak;\n", "\tcase 1:\n", "\t\tn = 1;\n", "\t\tbreak;\n", "\t}\n", "\tstar = vlook(\"*\");\n", "\tfor(;n && star->val;--n){\n", "\t\ta = star->val->next;\n", "\t\tefree(star->val->word);\n", "\t\tefree((char *)star->val);\n", "\t\tstar->val = a;\n", "\t\tstar->changed = 1;\n", "\t}\n", "\tsetstatus(\"\");\n", "\tpoplist();\n", "}"]}, {"ghidra": ["\n", "void * p9realloc(void *v,ulong n)\n", "\n", "{\n", "  void *pvVar1;\n", "  \n", "  lock(&malloclock);\n", "  pvVar1 = realloc(v,n);\n", "  unlock(&malloclock);\n", "  return pvVar1;\n", "}\n", "\n"], "c": ["void*\n", "p9realloc(void *v, ulong n)\n", "{\n", "\tlock(&malloclock);\n", "\tv = realloc(v, n);\n", "\tunlock(&malloclock);\n", "\treturn v;\n", "}"]}, {"ghidra": ["\n", "void efree(char *p)\n", "\n", "{\n", "  if (p != (char *)0x0) {\n", "    p9free(p);\n", "    return;\n", "  }\n", "  pfmt(rc_err,\"free 0\\n\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "efree(char *p)\n", "{\n", "/*\tpfmt(err, \"free %p\\n\", p); flush(err); /**/\n", "\tif(p)\n", "\t\tfree(p);\n", "\telse pfmt(err, \"free 0\\n\");\n", "}"]}, {"ghidra": ["\n", "char * emalloc(long n)\n", "\n", "{\n", "  char *__s;\n", "  \n", "  __s = (char *)Malloc(n);\n", "  if (__s != (char *)0x0) {\n", "    memset(__s,0,n);\n", "    return __s;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  panic(\"Can\\'t malloc %d bytes\",(int)n);\n", "}\n", "\n"], "c": ["char*\n", "emalloc(long n)\n", "{\n", "\tchar *p = (char *)Malloc(n);\n", "\tif(p==0)\n", "\t\tpanic(\"Can't malloc %d bytes\", n);\n", "/*\tif(err){ pfmt(err, \"malloc %d->%p\\n\", n, p); flush(err); } /**/\n", "\tmemset(p, 0, n);\n", "\treturn p;\n", "}"]}, {"ghidra": ["\n", "tree * tree3(int type,tree *c0,tree *c1,tree *c2)\n", "\n", "{\n", "  tree *ptVar1;\n", "  \n", "  if ((type != 0x3b) || ((ptVar1 = c1, c0 != (tree *)0x0 && (ptVar1 = c0, c1 != (tree *)0x0)))) {\n", "    ptVar1 = newtree();\n", "    ptVar1->type = type;\n", "    ptVar1->child[0] = c0;\n", "    ptVar1->child[1] = c1;\n", "    ptVar1->child[2] = c2;\n", "  }\n", "  return ptVar1;\n", "}\n", "\n"], "c": ["tree*\n", "tree3(int type, tree *c0, tree *c1, tree *c2)\n", "{\n", "\ttree *t;\n", "\tif(type==';'){\n", "\t\tif(c0==0)\n", "\t\t\treturn c1;\n", "\t\tif(c1==0)\n", "\t\t\treturn c0;\n", "\t}\n", "\tt = newtree();\n", "\tt->type = type;\n", "\tt->child[0] = c0;\n", "\tt->child[1] = c1;\n", "\tt->child[2] = c2;\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "Waitmsg * waitnohang(void)\n", "\n", "{\n", "  long lVar1;\n", "  int n;\n", "  Waitmsg *pWVar2;\n", "  long in_FS_OFFSET;\n", "  char buf [256];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  n = awaitnohang(buf,0xff);\n", "  pWVar2 = _wait(n,buf);\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return pWVar2;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["Waitmsg*\n", "waitnohang(void)\n", "{\n", "\tchar buf[256];\n", "\n", "\treturn _wait(awaitnohang(buf, sizeof buf-1), buf);\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Control flow encountered bad instruction data */\n", "/* WARNING: Unknown calling convention yet parameter storage is locked */\n", "\n", "int dup(int __fd)\n", "\n", "{\n", "                    /* WARNING: Bad instruction - Truncating control flow here */\n", "                    /* dup@@GLIBC_2.2.5 */\n", "  halt_baddata();\n", "}\n", "\n"], "c": ["int Dup(int a, int b){\n", "\treturn dup(a, b);\n", "}"]}, {"ghidra": ["\n", "int canrlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _rlock;\n", "  if (_rlock == (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->writer == (_Thread *)0x0) {\n", "      l->readers = l->readers + 1;\n", "      iVar2 = 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canrlock(RWLock *l)\n", "{\n", "\tif(_rlock)\n", "\t\treturn (*_rlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->writer)\n", "\t\t\treturn 0;\n", "\t\tl->readers++;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "tree * tree2(int type,tree *c0,tree *c1)\n", "\n", "{\n", "  tree *ptVar1;\n", "  \n", "  ptVar1 = tree3(type,c0,c1,(tree *)0x0);\n", "  return ptVar1;\n", "}\n", "\n"], "c": ["tree*\n", "tree2(int type, tree *c0, tree *c1)\n", "{\n", "\treturn tree3(type, c0, c1, (tree *)0);\n", "}"]}, {"ghidra": ["\n", "long dirread(int fd,Dir **dp)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  char *__buf;\n", "  __ssize_t _Var3;\n", "  long lVar4;\n", "  long in_FS_OFFSET;\n", "  off_t off;\n", "  stat st;\n", "  \n", "  *dp = (Dir *)0x0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar2 = __fxstat64(1,fd,(stat64 *)&st);\n", "  if (-1 < iVar2) {\n", "    iVar2 = (int)st.st_blksize;\n", "    if (st.st_blksize < 0x2000) {\n", "      st.st_blksize = 0x2000;\n", "      iVar2 = 0x2000;\n", "    }\n", "    __buf = (char *)malloc(st.st_blksize);\n", "    if (__buf != (char *)0x0) {\n", "      off = p9seek(fd,0,1);\n", "      _Var3 = getdirentries64(fd,__buf,(long)iVar2,&off);\n", "      if (-1 < (int)_Var3) {\n", "        iVar2 = dirpackage(fd,__buf,(int)_Var3,dp);\n", "        free(__buf);\n", "        lVar4 = (long)iVar2;\n", "        goto LAB_0040eb8c;\n", "      }\n", "      free(__buf);\n", "    }\n", "  }\n", "  lVar4 = -1;\n", "LAB_0040eb8c:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return lVar4;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["long\n", "dirread(int fd, Dir **dp)\n", "{\n", "\tchar *buf;\n", "\tstruct stat st;\n", "\tint n;\n", "\n", "\t*dp = 0;\n", "\n", "\tif(fstat(fd, &st) < 0)\n", "\t\treturn -1;\n", "\n", "\tif(st.st_blksize < 8192)\n", "\t\tst.st_blksize = 8192;\n", "\n", "\tbuf = malloc(st.st_blksize);\n", "\tif(buf == nil)\n", "\t\treturn -1;\n", "\n", "\tn = mygetdents(fd, (void*)buf, st.st_blksize);\n", "\tif(n < 0){\n", "\t\tfree(buf);\n", "\t\treturn -1;\n", "\t}\n", "\tn = dirpackage(fd, buf, n, dp);\n", "\tfree(buf);\n", "\treturn n;\n", "}"]}, {"ghidra": ["\n", "void setvar(char *name,word *val)\n", "\n", "{\n", "  _setvar(name,val,1);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "setvar(char *name, word *val)\n", "{\n", "\t_setvar(name, val, 1);\n", "}"]}, {"ghidra": ["\n", "int tokenize(char *s,char **args,int maxargs)\n", "\n", "{\n", "  bool bVar1;\n", "  char *pcVar2;\n", "  char *pcVar3;\n", "  char cVar4;\n", "  long c;\n", "  int iVar5;\n", "  \n", "  if (maxargs < 1) {\n", "    iVar5 = 0;\n", "  }\n", "  else {\n", "    iVar5 = 0;\n", "    while (*s != '\\0') {\n", "      pcVar2 = utfrune(qsep,(long)*s);\n", "      if (pcVar2 == (char *)0x0) {\n", "        if (*s == '\\0') {\n", "          return iVar5;\n", "        }\n", "        *args = s;\n", "        c = (long)*s;\n", "        bVar1 = false;\n", "        pcVar2 = s;\n", "LAB_00413658:\n", "        if ((char)c != '\\0') {\n", "          do {\n", "            cVar4 = (char)c;\n", "            if (bVar1) {\n", "              if (cVar4 == '\\'') goto LAB_004136e0;\n", "            }\n", "            else {\n", "              pcVar3 = utfrune(qsep,c);\n", "              if (pcVar3 != (char *)0x0) break;\n", "              cVar4 = *s;\n", "              if (cVar4 == '\\'') {\n", "                c = (long)s[1];\n", "                bVar1 = true;\n", "                s = s + 1;\n", "                goto LAB_00413658;\n", "              }\n", "            }\n", "            *pcVar2 = cVar4;\n", "            pcVar3 = s + 1;\n", "            c = (long)*pcVar3;\n", "            pcVar2 = pcVar2 + 1;\n", "            s = s + 1;\n", "            if (*pcVar3 == '\\0') break;\n", "          } while( true );\n", "        }\n", "        if (*pcVar2 != '\\0') {\n", "          *pcVar2 = '\\0';\n", "          s = s + (s == pcVar2);\n", "        }\n", "        iVar5 = iVar5 + 1;\n", "        args = args + 1;\n", "        if (iVar5 == maxargs) {\n", "          return iVar5;\n", "        }\n", "      }\n", "      else {\n", "        s = s + 1;\n", "      }\n", "    }\n", "  }\n", "  return iVar5;\n", "LAB_004136e0:\n", "  c = (long)s[1];\n", "  if (s[1] == '\\'') {\n", "    *pcVar2 = '\\'';\n", "    s = s + 2;\n", "    c = (long)*s;\n", "    pcVar2 = pcVar2 + 1;\n", "    bVar1 = true;\n", "  }\n", "  else {\n", "    s = s + 1;\n", "    bVar1 = false;\n", "  }\n", "  goto LAB_00413658;\n", "}\n", "\n"], "c": ["int\n", "tokenize(char *s, char **args, int maxargs)\n", "{\n", "\tint nargs;\n", "\n", "\tfor(nargs=0; nargs<maxargs; nargs++){\n", "\t\twhile(*s!='\\0' && utfrune(qsep, *s)!=nil)\n", "\t\t\ts++;\n", "\t\tif(*s == '\\0')\n", "\t\t\tbreak;\n", "\t\targs[nargs] = s;\n", "\t\ts = qtoken(s, qsep);\n", "\t}\n", "\n", "\treturn nargs;\n", "}"]}, {"ghidra": ["\n", "void wunlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_void_RWLock_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wunlock;\n", "  if (_wunlock != (anon_subr_void_RWLock_ptr_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wunlock(RWLock *l)\n", "{\n", "\tif(_wunlock)\n", "\t\t(*_wunlock)(l, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = nil;\n", "}"]}, {"ghidra": ["\n", "int idchr(int c)\n", "\n", "{\n", "  uint uVar1;\n", "  char *pcVar2;\n", "  \n", "  uVar1 = 0;\n", "  if (0x20 < c) {\n", "    pcVar2 = strchr(\"!\\\"#$%&\\'()+,-./:;<=>?@[\\\\]^`{|}~\",c);\n", "    uVar1 = (uint)(pcVar2 == (char *)0x0);\n", "  }\n", "  return (int)uVar1;\n", "}\n", "\n"], "c": ["int\n", "idchr(int c)\n", "{\n", "\t/*\n", "\t * Formerly:\n", "\t * return 'a'<=c && c<='z' || 'A'<=c && c<='Z' || '0'<=c && c<='9'\n", "\t *\t|| c=='_' || c=='*';\n", "\t */\n", "\treturn c>' ' && !strchr(\"!\\\"#$%&'()+,-./:;<=>?@[\\\\]^`{|}~\", c);\n", "}"]}, {"ghidra": ["\n", "void rerrstr(char *err,uint n)\n", "\n", "{\n", "  int __errnum;\n", "  char *__dest;\n", "  int *piVar1;\n", "  char *__src;\n", "  \n", "  if (_syserrstr != (anon_subr_char_ptr *)0x0) {\n", "    __dest = (*_syserrstr)();\n", "    if ((undefined8 *)__dest != (undefined8 *)0x0) goto LAB_0040ee8f;\n", "  }\n", "  __dest = xsyserr;\n", "LAB_0040ee8f:\n", "  piVar1 = __errno_location();\n", "  __errnum = *piVar1;\n", "  if (__errnum == 4) {\n", "    *(undefined4 *)((undefined8 *)__dest + 1) = 0x646574;\n", "    *(undefined8 *)__dest = 0x7075727265746e69;\n", "  }\n", "  else {\n", "    if (__errnum != 0x19283745) {\n", "      __src = strerror(__errnum);\n", "      strcpy(__dest,__src);\n", "    }\n", "  }\n", "  strecpy(err,err + n,__dest);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rerrstr(char *err, uint n)\n", "{\n", "\tchar *syserr;\n", "\n", "\tsyserr = getsyserr();\n", "\tif(errno == EINTR)\n", "\t\tstrcpy(syserr, \"interrupted\");\n", "\telse if(errno != EPLAN9)\n", "\t\tstrcpy(syserr, strerror(errno));\n", "\tstrecpy(err, err+n, syserr);\n", "}"]}, {"ghidra": ["\n", "int Executable(char *file)\n", "\n", "{\n", "  Dir *v;\n", "  uint uVar1;\n", "  \n", "  v = dirstat(file);\n", "  if (v != (Dir *)0x0) {\n", "    uVar1 = 0;\n", "    if ((v->mode & 0x49) != 0) {\n", "      uVar1 = ((uint)(v->mode >> 0x1f) ^ 1) & 1;\n", "    }\n", "    p9free(v);\n", "    return (int)uVar1;\n", "  }\n", "  return 0;\n", "}\n", "\n"], "c": ["int Executable(char *file)\n", "{\n", "\tDir *statbuf;\n", "\tint ret;\n", "\n", "\tstatbuf = dirstat(file);\n", "\tif(statbuf == nil) return 0;\n", "\tret = ((statbuf->mode&0111)!=0 && (statbuf->mode&DMDIR)==0);\n", "\tfree(statbuf);\n", "\treturn ret;\n", "}"]}, {"ghidra": ["\n", "void rsleep(Rendez *r)\n", "\n", "{\n", "  anon_subr_void_Rendez_ptr_ulong *paVar1;\n", "  ulong uVar2;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rsleep;\n", "  if (_rsleep != (anon_subr_void_Rendez_ptr_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,uVar2);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "rsleep(Rendez *r)\n", "{\n", "\tif(_rsleep)\n", "\t\t(*_rsleep)(r, getcallerpc(&r));\n", "}"]}, {"ghidra": ["\n", "void doredir(redir *rp)\n", "\n", "{\n", "  char cVar1;\n", "  \n", "  if (rp != (redir *)0x0) {\n", "    doredir(rp->next);\n", "    cVar1 = rp->type;\n", "    if (cVar1 == '\\x02') {\n", "      Dup((int)rp->from,(int)rp->to);\n", "      return;\n", "    }\n", "    if (cVar1 == '\\x03') {\n", "      close((int)rp->from);\n", "      return;\n", "    }\n", "    if (cVar1 == '\\x01') {\n", "      if (rp->from != rp->to) {\n", "        Dup((int)rp->from,(int)rp->to);\n", "        close((int)rp->from);\n", "        return;\n", "      }\n", "    }\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "doredir(redir *rp)\n", "{\n", "\tif(rp){\n", "\t\tdoredir(rp->next);\n", "\t\tswitch(rp->type){\n", "\t\tcase ROPEN:\n", "\t\t\tif(rp->from!=rp->to){\n", "\t\t\t\tDup(rp->from, rp->to);\n", "\t\t\t\tclose(rp->from);\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase RDUP:\n", "\t\t\tDup(rp->from, rp->to);\n", "\t\t\tbreak;\n", "\t\tcase RCLOSE:\n", "\t\t\tclose(rp->from);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int rwakeupall(Rendez *r)\n", "\n", "{\n", "  anon_subr_int_Rendez_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Rendez *local_10;\n", "  \n", "  paVar1 = _rwakeup;\n", "  iVar2 = 0;\n", "  if (_rwakeup != (anon_subr_int_Rendez_ptr_int_ulong *)0x0) {\n", "    local_10 = r;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,1,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "rwakeupall(Rendez *r)\n", "{\n", "\tif(_rwakeup)\n", "\t\treturn (*_rwakeup)(r, 1, getcallerpc(&r));\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "tree * tree1(int type,tree *c0)\n", "\n", "{\n", "  tree *ptVar1;\n", "  \n", "  ptVar1 = tree3(type,c0,(tree *)0x0,(tree *)0x0);\n", "  return ptVar1;\n", "}\n", "\n"], "c": ["tree*\n", "tree1(int type, tree *c0)\n", "{\n", "\treturn tree3(type, c0, (tree *)0, (tree *)0);\n", "}"]}, {"ghidra": ["\n", "void pquo(io *f,char *s)\n", "\n", "{\n", "  char cVar1;\n", "  \n", "  pchr(f,0x27);\n", "  cVar1 = *s;\n", "  while (cVar1 != '\\0') {\n", "    while (cVar1 != '\\'') {\n", "      s = s + 1;\n", "      pchr(f,(int)cVar1);\n", "      cVar1 = *s;\n", "      if (cVar1 == '\\0') goto LAB_00408334;\n", "    }\n", "    s = s + 1;\n", "    pfmt(f,\"\\'\\'\");\n", "    cVar1 = *s;\n", "  }\n", "LAB_00408334:\n", "  pchr(f,0x27);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pquo(io *f, char *s)\n", "{\n", "\tpchr(f, '\\'');\n", "\tfor(;*s;s++)\n", "\t\tif(*s=='\\'')\n", "\t\t\tpfmt(f, \"''\");\n", "\t\telse pchr(f, *s);\n", "\tpchr(f, '\\'');\n", "}"]}, {"ghidra": ["\n", "void _setvar(char *name,word *val,int callfn)\n", "\n", "{\n", "  var *pvVar1;\n", "  \n", "  pvVar1 = vlook(name);\n", "  freewords(pvVar1->val);\n", "  pvVar1->val = val;\n", "  pvVar1->changed = 1;\n", "  if ((callfn != 0) && (pvVar1->changefn != (anon_subr_void_var_ptr_for_changefn *)0x0)) {\n", "                    /* WARNING: Could not recover jumptable at 0x0040bcd9. Too many branches */\n", "                    /* WARNING: Treating indirect jump as call */\n", "    (*pvVar1->changefn)(pvVar1);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "_setvar(char *name, word *val, int callfn)\n", "{\n", "\tstruct var *v = vlook(name);\n", "\tfreewords(v->val);\n", "\tv->val=val;\n", "\tv->changed=1;\n", "\tif(callfn && v->changefn)\n", "\t\tv->changefn(v);\n", "}"]}, {"ghidra": ["\n", "int nextis(int c)\n", "\n", "{\n", "  if (future == -1) {\n", "    future = getnext();\n", "  }\n", "  if (c != future) {\n", "    return 0;\n", "  }\n", "  advance();\n", "  return 1;\n", "}\n", "\n"], "c": ["int\n", "nextis(int c)\n", "{\n", "\tif(nextc()==c){\n", "\t\tadvance();\n", "\t\treturn 1;\n", "\t}\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void iorewind(io *io)\n", "\n", "{\n", "  if (io->fd != -1) {\n", "    io->ebuf = io->buf;\n", "    io->bufp = io->buf;\n", "    Seek(io->fd,0,0);\n", "    return;\n", "  }\n", "  io->bufp = io->strp;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "iorewind(io *io)\n", "{\n", "\tif(io->fd==-1)\n", "\t\tio->bufp = io->strp;\n", "\telse{\n", "\t\tio->bufp = io->ebuf = io->buf;\n", "\t\tSeek(io->fd, 0L, 0);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void wlock(RWLock *l)\n", "\n", "{\n", "  anon_subr_int_RWLock_ptr_int_ulong *paVar1;\n", "  ulong uVar2;\n", "  RWLock *local_10;\n", "  \n", "  paVar1 = _wlock;\n", "  if (_wlock != (anon_subr_int_RWLock_ptr_int_ulong *)0x0) {\n", "    local_10 = l;\n", "    uVar2 = getcallerpc(&local_10);\n", "    (*paVar1)(local_10,1,uVar2);\n", "    return;\n", "  }\n", "  l->writer = (_Thread *)0x1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "wlock(RWLock *l)\n", "{\n", "\tif(_wlock)\n", "\t\t(*_wlock)(l, 1, getcallerpc(&l));\n", "\telse\n", "\t\tl->writer = (void*)1;\n", "}"]}, {"ghidra": ["\n", "tree * mung2(tree *t,tree *c0,tree *c1)\n", "\n", "{\n", "  t->child[0] = c0;\n", "  t->child[1] = c1;\n", "  return t;\n", "}\n", "\n"], "c": ["tree*\n", "mung2(tree *t, tree *c0, tree *c1)\n", "{\n", "\tt->child[0] = c0;\n", "\tt->child[1] = c1;\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "int awaitnohang(char *str,int n)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = _await(-1,str,n,1);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "awaitnohang(char *str, int n)\n", "{\n", "\treturn _await(-1, str, n, WNOHANG);\n", "}"]}, {"ghidra": ["\n", "void execumask(void)\n", "\n", "{\n", "  long lVar1;\n", "  __mode_t __mask;\n", "  int fd;\n", "  char **v;\n", "  long lVar2;\n", "  char cVar3;\n", "  ulong uVar4;\n", "  char **ppcVar5;\n", "  char *pcVar6;\n", "  uint uVar7;\n", "  ulong uVar8;\n", "  long in_FS_OFFSET;\n", "  Rune _argc;\n", "  char *p;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  setstatus(\"\");\n", "  v = mkargv(runq->argv->words);\n", "  if (v[1] == (char *)0x0) {\n", "    __fixargv0();\n", "    pcVar6 = v[2];\n", "    ppcVar5 = v + 2;\n", "    if ((pcVar6 != (char *)0x0) && (*pcVar6 == '-')) {\n", "      cVar3 = pcVar6[1];\n", "      uVar7 = 0xffffffff;\n", "      if (cVar3 != '\\0') goto LAB_0040b72a;\n", "    }\n", "LAB_0040b7d0:\n", "    __mask = umask(0);\n", "    umask(__mask);\n", "    if ((int)__mask < 0) {\n", "      fd = mapfd(2);\n", "      fprint(fd,\"umask: %r\\n\");\n", "    }\n", "    else {\n", "      fd = mapfd(1);\n", "      fprint(fd,\"umask %03o\\n\",(ulong)__mask);\n", "    }\n", "  }\n", "  else {\n", "    uVar4 = 0;\n", "    do {\n", "      uVar8 = uVar4 & 0xffffffff;\n", "      uVar7 = (uint)uVar8;\n", "      lVar2 = uVar4 + 2;\n", "      uVar4 = uVar4 + 1;\n", "    } while (v[lVar2] != (char *)0x0);\n", "    __fixargv0();\n", "    pcVar6 = v[2];\n", "    ppcVar5 = v + 2;\n", "    while( true ) {\n", "      if (((pcVar6 == (char *)0x0) || (uVar7 = (uint)uVar8, *pcVar6 != '-')) ||\n", "         (cVar3 = pcVar6[1], cVar3 == '\\0')) goto LAB_0040b7c8;\n", "LAB_0040b72a:\n", "      if ((cVar3 == '-') && (pcVar6[2] == '\\0')) break;\n", "      _argc = 0;\n", "      if ((pcVar6[1] != '\\0') &&\n", "         (fd = chartorune(&_argc,pcVar6 + 1), pcVar6 + 1 + fd != (char *)0x0)) goto usage;\n", "      ppcVar5 = ppcVar5 + 1;\n", "      pcVar6 = *ppcVar5;\n", "      uVar7 = uVar7 - 1;\n", "      uVar8 = (ulong)uVar7;\n", "    }\n", "    uVar7 = uVar7 - 1;\n", "    ppcVar5 = ppcVar5 + 1;\n", "LAB_0040b7c8:\n", "    if ((int)uVar7 < 2) {\n", "      if (uVar7 != 1) goto LAB_0040b7d0;\n", "      lVar2 = strtol(*ppcVar5,&p,8);\n", "      if ((*p == '\\0') && (p != *ppcVar5)) {\n", "        umask((__mode_t)lVar2);\n", "        goto out;\n", "      }\n", "    }\n", "usage:\n", "    fd = mapfd(2);\n", "    fprint(fd,\"usage: umask [mode]\\n\");\n", "  }\n", "out:\n", "  p9free(v);\n", "  poplist();\n", "  flush(rc_err);\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "execumask(void)\n", "{\n", "\tint n, argc;\n", "\tchar **argv, **oargv, *p;\n", "\tchar *argv0;\n", "\n", "\targv0 = nil;\n", "\tsetstatus(\"\");\n", "\toargv = mkargv(runq->argv->words);\n", "\targv = oargv+1;\n", "\tfor(argc=0; argv[argc]; argc++)\n", "\t\t;\n", "\n", "\tARGBEGIN{\n", "\tdefault:\n", "\tusage:\n", "\t\tfprint(mapfd(2), \"usage: umask [mode]\\n\");\n", "\t\tgoto out;\n", "\t}ARGEND\n", "\n", "\tif(argc > 1)\n", "\t\tgoto usage;\n", "\n", "\tif(argc == 1){\n", "\t\tn = strtol(argv[0], &p, 8);\n", "\t\tif(*p != 0 || p == argv[0])\n", "\t\t\tgoto usage;\n", "\t\tumask(n);\n", "\t\tgoto out;\n", "\t}\n", "\n", "\tn = umask(0);\n", "\tumask(n);\n", "\tif(n < 0){\n", "\t\tfprint(mapfd(2), \"umask: %r\\n\");\n", "\t\tgoto out;\n", "\t}\n", "\n", "\tfprint(mapfd(1), \"umask %03o\\n\", n);\n", "\n", "out:\n", "\tfree(oargv);\n", "\tpoplist();\n", "\tflush(err);\n", "}"]}, {"ghidra": ["\n", "tree * klook(char *name)\n", "\n", "{\n", "  char cVar1;\n", "  kw *pkVar2;\n", "  tree *ptVar3;\n", "  int iVar4;\n", "  int iVar5;\n", "  char *pcVar6;\n", "  int iVar7;\n", "  \n", "  ptVar3 = token(name,0xe00c);\n", "  cVar1 = *name;\n", "  if (cVar1 == '\\0') {\n", "    iVar7 = 0;\n", "  }\n", "  else {\n", "    iVar7 = 0;\n", "    iVar4 = 1;\n", "    pcVar6 = name;\n", "    do {\n", "      iVar5 = cVar1 * iVar4;\n", "      pcVar6 = pcVar6 + 1;\n", "      iVar4 = iVar4 + 1;\n", "      iVar7 = iVar7 + iVar5;\n", "      cVar1 = *pcVar6;\n", "    } while (cVar1 != '\\0');\n", "    iVar7 = iVar7 % 0x1e;\n", "    if (iVar7 < 0) {\n", "      iVar7 = iVar7 + 0x1e;\n", "    }\n", "  }\n", "  pkVar2 = kw[iVar7];\n", "  while( true ) {\n", "    if (pkVar2 == (kw *)0x0) {\n", "      return ptVar3;\n", "    }\n", "    iVar7 = strcmp(pkVar2->name,name);\n", "    if (iVar7 == 0) break;\n", "    pkVar2 = pkVar2->next;\n", "  }\n", "  iVar7 = pkVar2->type;\n", "  ptVar3->iskw = 1;\n", "  ptVar3->type = iVar7;\n", "  return ptVar3;\n", "}\n", "\n"], "c": ["tree*\n", "klook(char *name)\n", "{\n", "\tstruct kw *p;\n", "\ttree *t = token(name, WORD);\n", "\tfor(p = kw[hash(name, NKW)];p;p = p->next)\n", "\t\tif(strcmp(p->name, name)==0){\n", "\t\t\tt->type = p->type;\n", "\t\t\tt->iskw = 1;\n", "\t\t\tbreak;\n", "\t\t}\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "void codefree(code *cp)\n", "\n", "{\n", "  code *pcVar1;\n", "  code *pcVar2;\n", "  code *pcVar3;\n", "  \n", "  *(int *)cp = *(int *)cp + -1;\n", "  if (*(int *)cp == 0) {\n", "    pcVar1 = cp + 1;\n", "    pcVar2 = (code *)cp[1];\n", "    while (pcVar2 != (code *)0x0) {\n", "      if ((((((((((((pcVar2 == Xclose || pcVar2 == Xappend) || pcVar2 == Xread) || pcVar2 == Xwrite)\n", "                 || pcVar2 == Xrdwr) || pcVar2 == Xasync) || pcVar2 == Xbackq) || pcVar2 == Xcase)\n", "             || pcVar2 == Xfalse) || pcVar2 == Xfor) || pcVar2 == Xjump) || pcVar2 == Xsubshell) ||\n", "         (pcVar2 == Xtrue)) {\n", "        pcVar2 = (code *)pcVar1[2];\n", "        pcVar1 = pcVar1 + 2;\n", "      }\n", "      else {\n", "        if ((pcVar2 == Xdup) || (pcVar2 == Xpipefd)) {\n", "          pcVar2 = (code *)pcVar1[3];\n", "          pcVar1 = pcVar1 + 3;\n", "        }\n", "        else {\n", "          pcVar3 = pcVar1 + 4;\n", "          if (pcVar2 != Xpipe) {\n", "            if ((pcVar2 == Xword) || (pcVar2 == Xdelhere)) {\n", "              pcVar3 = pcVar1 + 1;\n", "              efree((char *)pcVar1[1]);\n", "            }\n", "            else {\n", "              pcVar3 = pcVar1;\n", "              if (pcVar2 == Xfn) {\n", "                pcVar3 = pcVar1 + 2;\n", "                efree((char *)pcVar1[2]);\n", "              }\n", "            }\n", "          }\n", "          pcVar2 = (code *)pcVar3[1];\n", "          pcVar1 = pcVar3 + 1;\n", "        }\n", "      }\n", "    }\n", "    efree((char *)cp);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "codefree(code *cp)\n", "{\n", "\tcode *p;\n", "\tif(--cp[0].i!=0)\n", "\t\treturn;\n", "\tfor(p = cp+1;p->f;p++){\n", "\t\tif(p->f==Xappend || p->f==Xclose || p->f==Xread || p->f==Xwrite\n", "\t\t|| p->f==Xrdwr\n", "\t\t|| p->f==Xasync || p->f==Xbackq || p->f==Xcase || p->f==Xfalse\n", "\t\t|| p->f==Xfor || p->f==Xjump\n", "\t\t|| p->f==Xsubshell || p->f==Xtrue) p++;\n", "\t\telse if(p->f==Xdup || p->f==Xpipefd) p+=2;\n", "\t\telse if(p->f==Xpipe) p+=4;\n", "\t\telse if(p->f==Xword || p->f==Xdelhere) efree((++p)->s);\n", "\t\telse if(p->f==Xfn){\n", "\t\t\tefree(p[2].s);\n", "\t\t\tp+=2;\n", "\t\t}\n", "\t}\n", "\tefree((char *)cp);\n", "}"]}, {"ghidra": ["\n", "code * codecopy(code *cp)\n", "\n", "{\n", "  *(int *)cp = *(int *)cp + 1;\n", "  return cp;\n", "}\n", "\n"], "c": ["code*\n", "codecopy(code *cp)\n", "{\n", "\tcp[0].i++;\n", "\treturn cp;\n", "}"]}, {"ghidra": ["\n", "void Xasync(void)\n", "\n", "{\n", "  long lVar1;\n", "  int __fd;\n", "  int __fd_00;\n", "  word *val;\n", "  long in_FS_OFFSET;\n", "  char npid [10];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  __fd = p9open(\"/dev/null\",0);\n", "  if (__fd < 0) {\n", "    Xerror(\"Can\\'t open /dev/null\\n\");\n", "  }\n", "  else {\n", "    __fd_00 = p9rfork(0x1c);\n", "    if (__fd_00 == -1) {\n", "      close(__fd);\n", "      Xerror(\"try again\");\n", "    }\n", "    else {\n", "      if (__fd_00 == 0) {\n", "        clearwaitpids();\n", "        __fd_00 = p9open(\"/dev/tty\",0);\n", "        if (-1 < __fd_00) {\n", "          signal(0x15,(__sighandler_t)0x1);\n", "          signal(0x16,(__sighandler_t)0x1);\n", "          ioctl(__fd_00,0x5422);\n", "          close(__fd_00);\n", "        }\n", "        __fd_00 = isatty(0);\n", "        if (__fd_00 == 0) {\n", "          close(__fd);\n", "        }\n", "        else {\n", "          pushredir(1,__fd,0);\n", "        }\n", "        start(runq->code,runq->pc + 1,runq->local);\n", "        runq->ret = (thread *)0x0;\n", "      }\n", "      else {\n", "        addwaitpid(__fd_00);\n", "        close(__fd);\n", "        runq->pc = *(int *)(runq->code + runq->pc);\n", "        inttoascii(npid,(long)__fd_00);\n", "        val = newword(npid,(word *)0x0);\n", "        setvar(\"apid\",val);\n", "      }\n", "    }\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["void\n", "Xasync(void)\n", "{\n", "\tint null = open(\"/dev/null\", 0);\n", "\tint tty;\n", "\tint pid;\n", "\tchar npid[10];\n", "\tif(null<0){\n", "\t\tXerror(\"Can't open /dev/null\\n\");\n", "\t\treturn;\n", "\t}\n", "\tswitch(pid = rfork(RFFDG|RFPROC|RFNOTEG)){\n", "\tcase -1:\n", "\t\tclose(null);\n", "\t\tXerror(\"try again\");\n", "\t\tbreak;\n", "\tcase 0:\n", "\t\tclearwaitpids();\n", "\t\t/*\n", "\t\t * I don't know what the right thing to do here is,\n", "\t\t * so this is all experimentally determined.\n", "\t\t * If we just dup /dev/null onto 0, then running\n", "\t\t * ssh foo & will reopen /dev/tty, try to read a password,\n", "\t\t * get a signal, and repeat, in a tight loop, forever.\n", "\t\t * Arguably this is a bug in ssh (it behaves the same\n", "\t\t * way under bash as under rc) but I'm fixing it here \n", "\t\t * anyway.  If we dissociate the process from the tty,\n", "\t\t * then it won't be able to open /dev/tty ever again.\n", "\t\t * The SIG_IGN on SIGTTOU makes writing the tty\n", "\t\t * (via fd 1 or 2, for example) succeed even though \n", "\t\t * our pgrp is not the terminal's controlling pgrp.\n", "\t\t */\n", "\t\tif((tty = open(\"/dev/tty\", OREAD)) >= 0){\n", "\t\t\t/*\n", "\t\t\t * Should make reads of tty fail, writes succeed.\n", "\t\t\t */\n", "\t\t\tsignal(SIGTTIN, SIG_IGN);\n", "\t\t\tsignal(SIGTTOU, SIG_IGN);\n", "\t\t\tioctl(tty, TIOCNOTTY);\n", "\t\t\tclose(tty);\n", "\t\t}\n", "\t\tif(isatty(0))\n", "\t\t\tpushredir(ROPEN, null, 0);\n", "\t\telse\n", "\t\t\tclose(null);\n", "\t\tstart(runq->code, runq->pc+1, runq->local);\n", "\t\trunq->ret = 0;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\taddwaitpid(pid);\n", "\t\tclose(null);\n", "\t\trunq->pc = runq->code[runq->pc].i;\n", "\t\tinttoascii(npid, pid);\n", "\t\tsetvar(\"apid\", newword(npid, (word *)0));\n", "\t\tbreak;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "Dir * dirstat(char *file)\n", "\n", "{\n", "  int iVar1;\n", "  Dir *d;\n", "  long lVar2;\n", "  stat *psVar3;\n", "  stat *psVar4;\n", "  long in_FS_OFFSET;\n", "  byte bVar5;\n", "  char *str;\n", "  stat lst;\n", "  stat st;\n", "  long local_30;\n", "  \n", "  bVar5 = 0;\n", "  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar1 = __lxstat64(1,file,(stat64 *)&lst);\n", "  if (-1 < iVar1) {\n", "    lVar2 = 0x12;\n", "    psVar3 = &lst;\n", "    psVar4 = &st;\n", "    while (lVar2 != 0) {\n", "      lVar2 = lVar2 + -1;\n", "      psVar4->st_dev = psVar3->st_dev;\n", "      psVar3 = (stat *)((long)psVar3 + (ulong)bVar5 * -0x10 + 8);\n", "      psVar4 = (stat *)((long)psVar4 + (ulong)bVar5 * -0x10 + 8);\n", "    }\n", "    if ((lst.st_mode & 0xf000) == 0xa000) {\n", "      __xstat64(1,file,(stat64 *)&st);\n", "    }\n", "    iVar1 = _p9dir(&lst,&st,file,(Dir *)0x0,(char **)0x0,(char *)0x0);\n", "    d = (Dir *)mallocz((long)iVar1 + 0x78,1);\n", "    if (d != (Dir *)0x0) {\n", "      str = (char *)(d + 1);\n", "      _p9dir(&lst,&st,file,d,&str,(char *)((long)&((Dir *)str)->type + (long)iVar1));\n", "      goto LAB_0040edfd;\n", "    }\n", "  }\n", "  d = (Dir *)0x0;\n", "LAB_0040edfd:\n", "  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return d;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["Dir*\n", "dirstat(char *file)\n", "{\n", "\tstruct stat lst;\n", "\tstruct stat st;\n", "\tint nstr;\n", "\tDir *d;\n", "\tchar *str;\n", "\n", "\tif(lstat(file, &lst) < 0)\n", "\t\treturn nil;\n", "\tst = lst;\n", "\tif((lst.st_mode&S_IFMT) == S_IFLNK)\n", "\t\tstat(file, &st);\n", "\n", "\tnstr = _p9dir(&lst, &st, file, nil, nil, nil);\n", "\td = mallocz(sizeof(Dir)+nstr, 1);\n", "\tif(d == nil)\n", "\t\treturn nil;\n", "\tstr = (char*)&d[1];\n", "\t_p9dir(&lst, &st, file, d, &str, str+nstr);\n", "\treturn d;\n", "}"]}, {"ghidra": ["\n", "void littlepath(var *v)\n", "\n", "{\n", "  char *pcVar1;\n", "  word *val;\n", "  \n", "  pcVar1 = list2strcolon(v->val);\n", "  val = (word *)emalloc(0x10);\n", "  val->word = pcVar1;\n", "  val->next = (word *)0x0;\n", "  _setvar(\"PATH\",val,1);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "littlepath(var *v)\n", "{\n", "\t/* convert $path to $PATH */\n", "\tchar *p;\n", "\tword *w;\n", "\n", "\tp = list2strcolon(v->val);\n", "\tw = new(word);\n", "\tw->word = p;\n", "\tw->next = nil;\n", "\t_setvar(\"PATH\", w, 1);\t/* 1: recompute $path to expose colon problems */\n", "}"]}, {"ghidra": ["\n", "int exitcode(char *msg)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = p9atoi(msg);\n", "  if (iVar1 == 0) {\n", "    iVar1 = 1;\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "exitcode(char *msg)\n", "{\n", "\tint n;\n", "\t\n", "\tn = atoi(msg);\n", "\tif(n == 0)\n", "\t\tn = 1;\n", "\treturn n;\n", "}"]}, {"ghidra": ["\n", "void pathinit(void)\n", "\n", "{\n", "  var *v;\n", "  \n", "  v = gvlook(\"path\");\n", "  v->changefn = littlepath;\n", "  v = gvlook(\"PATH\");\n", "  v->changefn = bigpath;\n", "  bigpath(v);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pathinit(void)\n", "{\n", "\tvar *v;\n", "\n", "\tv = gvlook(\"path\");\n", "\tv->changefn = littlepath;\n", "\tv = gvlook(\"PATH\");\n", "\tv->changefn = bigpath;\n", "\tbigpath(v);\n", "}"]}, {"ghidra": ["\n", "int equtf(char *p,char *q)\n", "\n", "{\n", "  char cVar1;\n", "  int iVar2;\n", "  \n", "  cVar1 = *p;\n", "  iVar2 = 0;\n", "  if (cVar1 == *q) {\n", "    if (((int)cVar1 & 0xe0U) == 0xc0) {\n", "      return (int)(uint)(p[1] == q[1]);\n", "    }\n", "    iVar2 = 1;\n", "    if (((int)cVar1 & 0xf0U) == 0xe0) {\n", "      iVar2 = 0;\n", "      if ((p[1] == q[1]) && (iVar2 = 1, p[1] != '\\0')) {\n", "        return (int)(uint)(p[2] == q[2]);\n", "      }\n", "    }\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "equtf(char *p, char *q)\n", "{\n", "\tif(*p!=*q)\n", "\t\treturn 0;\n", "\tif(twobyte(*p)) return p[1]==q[1];\n", "\tif(threebyte(*p)){\n", "\t\tif(p[1]!=q[1])\n", "\t\t\treturn 0;\n", "\t\tif(p[1]=='\\0')\n", "\t\t\treturn 1;\t/* broken code at end of string! */\n", "\t\treturn p[2]==q[2];\n", "\t}\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "int Globsize(char *p)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  char cVar3;\n", "  long lVar4;\n", "  \n", "  cVar3 = *p;\n", "  if (cVar3 == '\\0') {\n", "    return 0;\n", "  }\n", "  iVar1 = 0x101;\n", "  lVar4 = 0;\n", "  do {\n", "    while (cVar3 == '\\x01') {\n", "      iVar2 = 1;\n", "      if ((p[1] != '\\x01') && (lVar4 = lVar4 + 1, p[1] == '*')) {\n", "        iVar2 = 0x100;\n", "      }\n", "      cVar3 = p[2];\n", "      iVar1 = iVar1 + iVar2;\n", "      p = p + 2;\n", "      if (cVar3 == '\\0') goto LAB_0040d206;\n", "    }\n", "    iVar1 = iVar1 + 1;\n", "    cVar3 = p[1];\n", "    p = p + 1;\n", "  } while (cVar3 != '\\0');\n", "LAB_0040d206:\n", "  if (lVar4 == 0) {\n", "    iVar1 = 0;\n", "  }\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int Globsize(char *p)\n", "{\n", "\tulong isglob=0, globlen=NDIR+1;\n", "\tfor(;*p;p++){\n", "\t\tif(*p==GLOB){\n", "\t\t\tp++;\n", "\t\t\tif(*p!=GLOB) isglob++;\n", "\t\t\tgloblen+=*p=='*'?NDIR:1;\n", "\t\t}\n", "\t\telse\n", "\t\t\tgloblen++;\n", "\t}\n", "\treturn isglob?globlen:0;\n", "}"]}, {"ghidra": ["\n", "void cleanhere(char *f)\n", "\n", "{\n", "  char **ppcVar1;\n", "  char *pcVar2;\n", "  long lVar3;\n", "  bool bVar4;\n", "  \n", "  if (codep == ncode) {\n", "    morecode();\n", "  }\n", "  lVar3 = (long)codep;\n", "  codep = codep + 1;\n", "  bVar4 = codep == ncode;\n", "  codebuf[lVar3] = 0x406550;\n", "  if (bVar4) {\n", "    morecode();\n", "  }\n", "  ppcVar1 = (char **)(codebuf + codep);\n", "  pcVar2 = p9strdup(f);\n", "  *ppcVar1 = pcVar2;\n", "  codep = codep + 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "cleanhere(char *f)\n", "{\n", "\temitf(Xdelhere);\n", "\temits(strdup(f));\n", "}"]}, {"ghidra": ["\n", "tree * mung3(tree *t,tree *c0,tree *c1,tree *c2)\n", "\n", "{\n", "  t->child[0] = c0;\n", "  t->child[1] = c1;\n", "  t->child[2] = c2;\n", "  return t;\n", "}\n", "\n"], "c": ["tree*\n", "mung3(tree *t, tree *c0, tree *c1, tree *c2)\n", "{\n", "\tt->child[0] = c0;\n", "\tt->child[1] = c1;\n", "\tt->child[2] = c2;\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "void notifyf(void *unused0,char *s)\n", "\n", "{\n", "  int iVar1;\n", "  size_t __n;\n", "  long lVar2;\n", "  char *__s;\n", "  long lVar3;\n", "  char *pcVar4;\n", "  bool bVar5;\n", "  byte bVar6;\n", "  \n", "  bVar6 = 0;\n", "  bVar5 = syssigname[0] == (char *)0x0;\n", "  if (!bVar5) {\n", "    lVar3 = 0;\n", "    __s = syssigname[0];\n", "    do {\n", "      __n = strlen(__s);\n", "      iVar1 = strncmp(s,__s,__n);\n", "      bVar5 = iVar1 == 0;\n", "      if (bVar5) {\n", "        lVar2 = 5;\n", "        __s = s;\n", "        pcVar4 = \"sys: \";\n", "        goto code_r0x0040cb17;\n", "      }\n", "      lVar3 = lVar3 + 1;\n", "      __s = syssigname[lVar3];\n", "      bVar5 = __s == (char *)0x0;\n", "    } while (!bVar5);\n", "  }\n", "  lVar3 = 0x18;\n", "  __s = s;\n", "  pcVar4 = \"sys: window size change\";\n", "  do {\n", "    if (lVar3 == 0) break;\n", "    lVar3 = lVar3 + -1;\n", "    bVar5 = *__s == *pcVar4;\n", "    __s = __s + (ulong)bVar6 * -2 + 1;\n", "    pcVar4 = pcVar4 + (ulong)bVar6 * -2 + 1;\n", "  } while (bVar5);\n", "  if (!bVar5) {\n", "    lVar3 = 0x1a;\n", "    __s = s;\n", "    pcVar4 = \"sys: write on closed pipe\";\n", "    do {\n", "      if (lVar3 == 0) break;\n", "      lVar3 = lVar3 + -1;\n", "      bVar5 = *__s == *pcVar4;\n", "      __s = __s + (ulong)bVar6 * -2 + 1;\n", "      pcVar4 = pcVar4 + (ulong)bVar6 * -2 + 1;\n", "    } while (bVar5);\n", "    if (!bVar5) {\n", "      lVar3 = 0xb;\n", "      __s = s;\n", "      pcVar4 = \"sys: child\";\n", "      do {\n", "        if (lVar3 == 0) break;\n", "        lVar3 = lVar3 + -1;\n", "        bVar5 = *__s == *pcVar4;\n", "        __s = __s + (ulong)bVar6 * -2 + 1;\n", "        pcVar4 = pcVar4 + (ulong)bVar6 * -2 + 1;\n", "      } while (bVar5);\n", "      if (!bVar5) {\n", "        pfmt(rc_err,\"rc: note: %s\\n\",s);\n", "      }\n", "    }\n", "  }\n", "  noted(1);\n", "  return;\n", "  while( true ) {\n", "    lVar2 = lVar2 + -1;\n", "    bVar5 = *__s == *pcVar4;\n", "    __s = __s + (ulong)bVar6 * -2 + 1;\n", "    pcVar4 = pcVar4 + (ulong)bVar6 * -2 + 1;\n", "    if (!bVar5) break;\n", "code_r0x0040cb17:\n", "    if (lVar2 == 0) break;\n", "  }\n", "  if (!bVar5) {\n", "    bVar5 = kidpid == 0;\n", "    if ((!bVar5) && (bVar5 = interrupted == 0, bVar5)) {\n", "      interrupted = 1;\n", "      postnote(2,kidpid,s);\n", "    }\n", "    interrupted = 1;\n", "  }\n", "  lVar2 = 10;\n", "  __s = s;\n", "  pcVar4 = \"interrupt\";\n", "  do {\n", "    if (lVar2 == 0) break;\n", "    lVar2 = lVar2 + -1;\n", "    bVar5 = *__s == *pcVar4;\n", "    __s = __s + (ulong)bVar6 * -2 + 1;\n", "    pcVar4 = pcVar4 + (ulong)bVar6 * -2 + 1;\n", "  } while (bVar5);\n", "  if ((!bVar5) || (trap[(int)lVar3] == 0)) {\n", "    trap[(int)lVar3] = trap[(int)lVar3] + 1;\n", "    ntrap = ntrap + 1;\n", "  }\n", "  if (0x1f < ntrap) {\n", "    pfmt(rc_err,\"rc: Too many traps (trap %s), aborting\\n\",s);\n", "                    /* WARNING: Subroutine does not return */\n", "    abort();\n", "  }\n", "  noted(0);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "notifyf(void *unused0, char *s)\n", "{\n", "\tint i;\n", "\tfor(i=0;syssigname[i];i++)\n", "\t\tif(strncmp(s, syssigname[i], strlen(syssigname[i]))==0){\n", "\t\t\tif(strncmp(s, \"sys: \", 5)!=0){\n", "\t\t\t\tif(kidpid && !interrupted){\n", "\t\t\t\t\tinterrupted=1;\n", "\t\t\t\t\tpostnote(PNGROUP, kidpid, s);\n", "\t\t\t\t}\n", "\t\t\t\tinterrupted = 1;\n", "\t\t\t}\n", "\t\t\tgoto Out;\n", "\t\t}\n", "\tif(strcmp(s, \"sys: window size change\") != 0)\n", "\tif(strcmp(s, \"sys: write on closed pipe\") != 0)\n", "\tif(strcmp(s, \"sys: child\") != 0)\n", "\t\tpfmt(err, \"rc: note: %s\\n\", s);\n", "\tnoted(NDFLT);\n", "\treturn;\n", "Out:\n", "\tif(strcmp(s, \"interrupt\")!=0 || trap[i]==0){\n", "\t\ttrap[i]++;\n", "\t\tntrap++;\n", "\t}\n", "\tif(ntrap>=32){\t/* rc is probably in a trap loop */\n", "\t\tpfmt(err, \"rc: Too many traps (trap %s), aborting\\n\", s);\n", "\t\tabort();\n", "\t}\n", "\tnoted(NCONT);\n", "}"]}, {"ghidra": ["\n", "void execcd(void)\n", "\n", "{\n", "  long lVar1;\n", "  word *w;\n", "  int iVar2;\n", "  var *pvVar3;\n", "  undefined2 *puVar4;\n", "  long lVar5;\n", "  word *pwVar6;\n", "  char *pcVar7;\n", "  char *pcVar8;\n", "  long in_FS_OFFSET;\n", "  bool bVar9;\n", "  byte bVar10;\n", "  char dir [512];\n", "  \n", "  bVar10 = 0;\n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  w = runq->argv->words;\n", "  setstatus(\"can\\'t cd\");\n", "  pvVar3 = vlook(\"cdpath\");\n", "  pwVar6 = pvVar3->val;\n", "  iVar2 = count(w);\n", "  if (iVar2 != 1) {\n", "    if (iVar2 == 2) {\n", "      if ((*w->next->word == '/') || (pwVar6 == (word *)0x0)) {\n", "        pwVar6 = &nullpath;\n", "      }\n", "      do {\n", "        puVar4 = (undefined2 *)__stpcpy_chk(dir,pwVar6->word,0x200);\n", "        if (dir[0] != '\\0') {\n", "          *puVar4 = 0x2f;\n", "        }\n", "        __strcat_chk(dir,w->next->word,0x200);\n", "        iVar2 = dochdir(dir);\n", "        if (-1 < iVar2) {\n", "          bVar9 = *pwVar6->word == '\\0';\n", "          if (bVar9) goto LAB_00409f3a;\n", "          lVar5 = 2;\n", "          pcVar7 = pwVar6->word;\n", "          pcVar8 = \".\";\n", "          goto code_r0x00409fa2;\n", "        }\n", "        pwVar6 = pwVar6->next;\n", "      } while (pwVar6 != (word *)0x0);\n", "      pfmt(rc_err,\"Can\\'t cd %s: %r\\n\",w->next->word);\n", "    }\n", "    else {\n", "      pfmt(rc_err,\"Usage: cd [directory]\\n\");\n", "    }\n", "    goto LAB_00409ee3;\n", "  }\n", "  pvVar3 = vlook(\"home\");\n", "  w = pvVar3->val;\n", "  iVar2 = count(w);\n", "  if (iVar2 < 1) {\n", "    pfmt(rc_err,\"Can\\'t cd -- $home empty\\n\");\n", "    goto LAB_00409ee3;\n", "  }\n", "  iVar2 = dochdir(w->word);\n", "  if (iVar2 < 0) {\n", "    pfmt(rc_err,\"Can\\'t cd %s: %r\\n\",w->word);\n", "    goto LAB_00409ee3;\n", "  }\n", "  goto LAB_00409f3a;\n", "  while( true ) {\n", "    lVar5 = lVar5 + -1;\n", "    bVar9 = *pcVar7 == *pcVar8;\n", "    pcVar7 = pcVar7 + (ulong)bVar10 * -2 + 1;\n", "    pcVar8 = pcVar8 + (ulong)bVar10 * -2 + 1;\n", "    if (!bVar9) break;\n", "code_r0x00409fa2:\n", "    if (lVar5 == 0) break;\n", "  }\n", "  if (!bVar9) {\n", "    pfmt(rc_err,\"%s\\n\",dir);\n", "  }\n", "LAB_00409f3a:\n", "  setstatus(\"\");\n", "LAB_00409ee3:\n", "  poplist();\n", "  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n", "                    /* WARNING: Subroutine does not return */\n", "    __stack_chk_fail();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execcd(void)\n", "{\n", "\tword *a = runq->argv->words;\n", "\tword *cdpath;\n", "\tchar dir[512];\n", "\tsetstatus(\"can't cd\");\n", "\tcdpath = vlook(\"cdpath\")->val;\n", "\tswitch(count(a)){\n", "\tdefault:\n", "\t\tpfmt(err, \"Usage: cd [directory]\\n\");\n", "\t\tbreak;\n", "\tcase 2:\n", "\t\tif(a->next->word[0]=='/' || cdpath==0)\n", "\t\t\tcdpath=&nullpath;\n", "\t\tfor(;cdpath;cdpath = cdpath->next){\n", "\t\t\tstrcpy(dir, cdpath->word);\n", "\t\t\tif(dir[0])\n", "\t\t\t\tstrcat(dir, \"/\");\n", "\t\t\tstrcat(dir, a->next->word);\n", "\t\t\tif(dochdir(dir)>=0){\n", "\t\t\t\tif(strlen(cdpath->word)\n", "\t\t\t\t&& strcmp(cdpath->word, \".\")!=0)\n", "\t\t\t\t\tpfmt(err, \"%s\\n\", dir);\n", "\t\t\t\tsetstatus(\"\");\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(cdpath==0)\n", "\t\t\tpfmt(err, \"Can't cd %s: %r\\n\", a->next->word);\n", "\t\tbreak;\n", "\tcase 1:\n", "\t\ta = vlook(\"home\")->val;\n", "\t\tif(count(a)>=1){\n", "\t\t\tif(dochdir(a->word)>=0)\n", "\t\t\t\tsetstatus(\"\");\n", "\t\t\telse\n", "\t\t\t\tpfmt(err, \"Can't cd %s: %r\\n\", a->word);\n", "\t\t}\n", "\t\telse\n", "\t\t\tpfmt(err, \"Can't cd -- $home empty\\n\");\n", "\t\tbreak;\n", "\t}\n", "\tpoplist();\n", "}"]}, {"ghidra": ["\n", "void execcmds(io *f)\n", "\n", "{\n", "  thread *ptVar1;\n", "  int first;\n", "  \n", "  if (first != 0) {\n", "    rdcmds[0]._0_4_ = 1;\n", "    rdcmds[1] = Xrdcmds;\n", "    rdcmds[2] = Xreturn;\n", "    first = 0;\n", "  }\n", "  start(rdcmds,1,runq->local);\n", "  ptVar1 = runq;\n", "  runq->cmdfd = f;\n", "  ptVar1->iflast = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execcmds(io *f)\n", "{\n", "\tstatic int first = 1;\n", "\tif(first){\n", "\t\trdcmds[0].i = 1;\n", "\t\trdcmds[1].f = Xrdcmds;\n", "\t\trdcmds[2].f = Xreturn;\n", "\t\tfirst = 0;\n", "\t}\n", "\tstart(rdcmds, 1, runq->local);\n", "\trunq->cmdfd = f;\n", "\trunq->iflast = 0;\n", "}"]}, {"ghidra": ["\n", "char * _p9sigstr(int sig,char *tmp)\n", "\n", "{\n", "  int iVar1;\n", "  anon_struct_conflict13 *paVar2;\n", "  \n", "  if (sig == 1) {\n", "    iVar1 = 0;\n", "  }\n", "  else {\n", "    paVar2 = tab;\n", "    iVar1 = 1;\n", "    while (paVar2 = paVar2 + 1, paVar2->sig != sig) {\n", "      iVar1 = iVar1 + 1;\n", "      if (iVar1 == 0x1c) {\n", "        if (tmp != (char *)0x0) {\n", "          sprint(tmp,\"sys: signal %d\",(ulong)(uint)sig);\n", "          return tmp;\n", "        }\n", "        return (char *)0x0;\n", "      }\n", "    }\n", "  }\n", "  return tab[iVar1].str;\n", "}\n", "\n"], "c": ["char*\n", "_p9sigstr(int sig, char *tmp)\n", "{\n", "\tint i;\n", "\n", "\tfor(i=0; i<nelem(tab); i++)\n", "\t\tif(tab[i].sig == sig)\n", "\t\t\treturn tab[i].str;\n", "\tif(tmp == nil)\n", "\t\treturn nil;\n", "\tsprint(tmp, \"sys: signal %d\", sig);\n", "\treturn tmp;\n", "}"]}, {"ghidra": ["\n", "tree * mung1(tree *t,tree *c0)\n", "\n", "{\n", "  t->child[0] = c0;\n", "  return t;\n", "}\n", "\n"], "c": ["tree*\n", "mung1(tree *t, tree *c0)\n", "{\n", "\tt->child[0] = c0;\n", "\treturn t;\n", "}"]}, {"ghidra": ["\n", "int notifyon(char *msg)\n", "\n", "{\n", "  int s;\n", "  \n", "  s = _p9strsig(msg);\n", "  s = notifyseton(s,1);\n", "  return s;\n", "}\n", "\n"], "c": ["int\n", "notifyon(char *msg)\n", "{\n", "\treturn notifyseton(_p9strsig(msg), 1);\n", "}"]}, {"ghidra": ["\n", "int canlock(Lock *l)\n", "\n", "{\n", "  anon_subr_int_Lock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  Lock *local_10;\n", "  \n", "  paVar1 = _lock;\n", "  if (_lock == (anon_subr_int_Lock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if (l->held == 0) {\n", "      l->held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canlock(Lock *l)\n", "{\n", "\tif(_lock)\n", "\t\treturn (*_lock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->held)\n", "\t\t\treturn 0;\n", "\t\tl->held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "long dirreadall(int fd,Dir **d)\n", "\n", "{\n", "  long lVar1;\n", "  __blksize_t _Var2;\n", "  int iVar3;\n", "  int iVar4;\n", "  __ssize_t _Var5;\n", "  char *buf;\n", "  char *__ptr;\n", "  long lVar6;\n", "  long in_FS_OFFSET;\n", "  off_t off;\n", "  stat st;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  iVar3 = __fxstat64(1,fd,(stat64 *)&st);\n", "  if (iVar3 < 0) {\n", "    lVar6 = -1;\n", "  }\n", "  else {\n", "    if (st.st_blksize < 0x2000) {\n", "      st.st_blksize = 0x2000;\n", "    }\n", "    lVar6 = 0;\n", "    __ptr = (char *)0x0;\n", "    while( true ) {\n", "      buf = (char *)realloc(__ptr,lVar6 + st.st_blksize);\n", "      _Var2 = st.st_blksize;\n", "      if (buf == (char *)0x0) break;\n", "      off = p9seek(fd,0,1);\n", "      _Var5 = getdirentries64(fd,buf + lVar6,(long)(int)_Var2,&off);\n", "      iVar3 = (int)_Var5;\n", "      if ((long)iVar3 < 1) {\n", "        iVar4 = dirpackage(fd,buf,(int)lVar6,d);\n", "        free(buf);\n", "        if (((long)iVar4 != 0) || (lVar6 = -1, iVar3 >> 7 == 0)) {\n", "          lVar6 = (long)iVar4;\n", "        }\n", "        goto LAB_0040ecb7;\n", "      }\n", "      lVar6 = lVar6 + (long)iVar3;\n", "      __ptr = buf;\n", "    }\n", "    free(__ptr);\n", "    lVar6 = -1;\n", "  }\n", "LAB_0040ecb7:\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return lVar6;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["long\n", "dirreadall(int fd, Dir **d)\n", "{\n", "\tuchar *buf, *nbuf;\n", "\tlong n, ts;\n", "\tstruct stat st;\n", "\n", "\tif(fstat(fd, &st) < 0)\n", "\t\treturn -1;\n", "\n", "\tif(st.st_blksize < 8192)\n", "\t\tst.st_blksize = 8192;\n", "\n", "\tbuf = nil;\n", "\tts = 0;\n", "\tfor(;;){\n", "\t\tnbuf = realloc(buf, ts+st.st_blksize);\n", "\t\tif(nbuf == nil){\n", "\t\t\tfree(buf);\n", "\t\t\treturn -1;\n", "\t\t}\n", "\t\tbuf = nbuf;\n", "\t\tn = mygetdents(fd, (void*)(buf+ts), st.st_blksize);\n", "\t\tif(n <= 0)\n", "\t\t\tbreak;\n", "\t\tts += n;\n", "\t}\n", "\tif(ts >= 0)\n", "\t\tts = dirpackage(fd, (char*)buf, ts, d);\n", "\tfree(buf);\n", "\tif(ts == 0 && n < 0)\n", "\t\treturn -1;\n", "\treturn ts;\n", "}"]}, {"ghidra": ["\n", "int Eintr(void)\n", "\n", "{\n", "  return interrupted;\n", "}\n", "\n"], "c": ["int Eintr(void){\n", "\treturn interrupted;\n", "}"]}, {"ghidra": ["\n", "int fullbuf(io *f,int c)\n", "\n", "{\n", "  char *pcVar1;\n", "  \n", "  flush(f);\n", "  pcVar1 = f->bufp;\n", "  f->bufp = pcVar1 + 1;\n", "  *pcVar1 = (char)c;\n", "  return (int)(char)c;\n", "}\n", "\n"], "c": ["int\n", "fullbuf(io *f, int c)\n", "{\n", "\tflush(f);\n", "\treturn *f->bufp++=c;\n", "}"]}, {"ghidra": ["\n", "void pcmd(io *f,tree *t)\n", "\n", "{\n", "  uint uVar1;\n", "  tree *ptVar2;\n", "  tree *ptVar3;\n", "  char *fmt;\n", "  \n", "  if (t == (tree *)0x0) {\n", "    return;\n", "  }\n", "  uVar1 = t->type;\n", "  if (uVar1 == 0xe00b) {\n", "    ptVar2 = t->child[1];\n", "    ptVar3 = t->child[0];\n", "    fmt = \"fn %t %t\";\n", "    goto LAB_004093eb;\n", "  }\n", "  if ((int)uVar1 < 0xe00c) {\n", "    if (uVar1 == 0xe002) {\n", "      pfmt(f,\"for(%t\",t->child[0]);\n", "      if (t->child[1] != (tree *)0x0) {\n", "        pfmt(f,\" in %t\");\n", "      }\n", "      ptVar2 = t->child[2];\n", "      fmt = \")%t\";\n", "      goto LAB_00409548;\n", "    }\n", "    if (0xe002 < (int)uVar1) {\n", "      if (uVar1 == 0xe007) {\n", "        ptVar2 = t->child[1];\n", "        ptVar3 = t->child[0];\n", "        fmt = \"~ %t %t\";\n", "      }\n", "      else {\n", "        if (0xe007 < (int)uVar1) {\n", "          if (uVar1 == 0xe009) {\n", "            ptVar2 = t->child[0];\n", "            fmt = \"@ %t\";\n", "          }\n", "          else {\n", "            if (0xe009 < (int)uVar1) {\n", "              ptVar2 = t->child[1];\n", "              ptVar3 = t->child[0];\n", "              fmt = \"switch %t %t\";\n", "              goto LAB_004093eb;\n", "            }\n", "            ptVar2 = t->child[0];\n", "            fmt = \"! %t\";\n", "          }\n", "          goto LAB_00409548;\n", "        }\n", "        if (uVar1 == 0xe005) {\n", "          ptVar2 = t->child[1];\n", "          ptVar3 = t->child[0];\n", "          fmt = \"if%t%t\";\n", "        }\n", "        else {\n", "          if (0xe005 < (int)uVar1) {\n", "            ptVar2 = t->child[0];\n", "            fmt = \"if not %t\";\n", "            goto LAB_00409548;\n", "          }\n", "          if (uVar1 != 0xe004) goto LAB_004094db;\n", "          ptVar2 = t->child[1];\n", "          ptVar3 = t->child[0];\n", "          fmt = \"while %t%t\";\n", "        }\n", "      }\n", "      goto LAB_004093eb;\n", "    }\n", "    if (uVar1 == 0x3b) {\n", "      ptVar3 = t->child[0];\n", "      if (ptVar3 != (tree *)0x0) {\n", "        if (t->child[1] != (tree *)0x0) {\n", "          pfmt(f,\"%t%c%t\",ptVar3,(ulong)(uint)(int)nl);\n", "          return;\n", "        }\n", "        goto LAB_00409580;\n", "      }\n", "      goto LAB_004095e0;\n", "    }\n", "    if ((int)uVar1 < 0x3c) {\n", "      if (uVar1 == 0x24) {\n", "        ptVar2 = t->child[0];\n", "        fmt = \"$%t\";\n", "      }\n", "      else {\n", "        if (uVar1 == 0x26) {\n", "          ptVar2 = t->child[0];\n", "          fmt = \"%t&\";\n", "        }\n", "        else {\n", "          if (uVar1 != 0x22) goto LAB_004094db;\n", "          ptVar2 = t->child[0];\n", "          fmt = \"$\\\"%t\";\n", "        }\n", "      }\n", "      goto LAB_00409548;\n", "    }\n", "    if (uVar1 == 0x5e) {\n", "      ptVar2 = t->child[1];\n", "      ptVar3 = t->child[0];\n", "      fmt = \"%t^%t\";\n", "      goto LAB_004093eb;\n", "    }\n", "    if (uVar1 == 0x60) {\n", "      ptVar2 = t->child[0];\n", "      fmt = \"`%t\";\n", "      goto LAB_00409548;\n", "    }\n", "    if (uVar1 != 0x3d) {\n", "LAB_004094db:\n", "      pfmt(f,\"bad %d %p %p %p\",(ulong)uVar1,t->child[0],t->child[1],t->child[2]);\n", "      return;\n", "    }\n", "    pfmt(f,\"%t=%t\",t->child[0],t->child[1]);\n", "    ptVar2 = t->child[2];\n", "    goto joined_r0x00409487;\n", "  }\n", "  if (uVar1 == 0xe013) {\n", "    if (t->child[0] != (tree *)0x0) {\n", "      pfmt(f,\"%t \");\n", "    }\n", "LAB_004095e0:\n", "    ptVar3 = t->child[1];\n", "LAB_00409580:\n", "    pfmt(f,\"%t\",ptVar3);\n", "    return;\n", "  }\n", "  if ((int)uVar1 < 0xe014) {\n", "    if (uVar1 == 0xe00f) {\n", "      pfmt(f,\"%t|\",t->child[0]);\n", "      if (t->fd1 == 0) {\n", "        if (t->fd0 != 1) {\n", "          pfmt(f,\"[%d]\");\n", "        }\n", "      }\n", "      else {\n", "        pfmt(f,\"[%d=%d]\");\n", "      }\n", "    }\n", "    else {\n", "      if ((int)uVar1 < 0xe010) {\n", "        if (uVar1 == 0xe00d) goto code_r0x00409732;\n", "        if ((int)uVar1 < 0xe00e) {\n", "          if (t->quoted == 0) {\n", "            pdeglob(f,t->str);\n", "            return;\n", "          }\n", "          ptVar2 = (tree *)t->str;\n", "          fmt = \"%Q\";\n", "          goto LAB_00409548;\n", "        }\n", "        if (t->rtype == 5) {\n", "          pfmt(f,\">[%d=%d]\",(ulong)(uint)t->fd1,(ulong)(uint)t->fd0);\n", "        }\n", "        else {\n", "          pfmt(f,\">[%d=]\",(ulong)(uint)t->fd0);\n", "        }\n", "      }\n", "      else {\n", "        if (uVar1 == 0xe011) {\n", "          ptVar3 = t->child[0];\n", "          goto LAB_00409580;\n", "        }\n", "        if ((int)uVar1 < 0xe012) {\n", "          ptVar2 = t->child[1];\n", "          ptVar3 = t->child[0];\n", "          fmt = \"$%t(%t)\";\n", "LAB_004093eb:\n", "          pfmt(f,fmt,ptVar3,ptVar2);\n", "          return;\n", "        }\n", "        ptVar3 = t->child[0];\n", "        if (ptVar3 != (tree *)0x0) {\n", "          ptVar2 = t->child[1];\n", "          fmt = \"%t %t\";\n", "          if (ptVar2 == (tree *)0x0) goto LAB_00409580;\n", "          goto LAB_004093eb;\n", "        }\n", "      }\n", "    }\n", "    goto LAB_004095e0;\n", "  }\n", "  if (uVar1 != 0xe017) {\n", "    if (0xe017 < (int)uVar1) {\n", "      if (uVar1 == 0xe019) {\n", "        ptVar2 = t->child[1];\n", "        ptVar3 = t->child[0];\n", "        fmt = \"%t || %t\";\n", "      }\n", "      else {\n", "        if (0xe018 < (int)uVar1) {\n", "          if (uVar1 != 0xe01a) goto LAB_004094db;\n", "          ptVar2 = t->child[0];\n", "          fmt = \"$#%t\";\n", "          goto LAB_00409548;\n", "        }\n", "        ptVar2 = t->child[1];\n", "        ptVar3 = t->child[0];\n", "        fmt = \"%t && %t\";\n", "      }\n", "      goto LAB_004093eb;\n", "    }\n", "    if (uVar1 == 0xe014) {\n", "      ptVar2 = t->child[0];\n", "      fmt = \"{%t}\";\n", "    }\n", "    else {\n", "      ptVar2 = t->child[0];\n", "      fmt = \"(%t)\";\n", "    }\n", "    goto LAB_00409548;\n", "  }\n", "code_r0x00409732:\n", "  switch(t->rtype) {\n", "  default:\n", "    break;\n", "  case 1:\n", "    pchr(f,0x3e);\n", "  case 2:\n", "    pchr(f,0x3e);\n", "    if (t->fd0 != 1) {\n", "LAB_00409762:\n", "      pfmt(f,\"[%d]\");\n", "    }\n", "    break;\n", "  case 3:\n", "  case 7:\n", "    goto switchD_00409735_caseD_3;\n", "  case 4:\n", "    pchr(f,0x3c);\n", "switchD_00409735_caseD_3:\n", "    pchr(f,0x3c);\n", "    if (t->rtype == 7) {\n", "      pchr(f,0x3e);\n", "    }\n", "    if (t->fd0 != 0) goto LAB_00409762;\n", "  }\n", "  pfmt(f,\"%t\",t->child[0]);\n", "  ptVar2 = t->child[1];\n", "joined_r0x00409487:\n", "  if (ptVar2 == (tree *)0x0) {\n", "    return;\n", "  }\n", "  fmt = \" %t\";\n", "LAB_00409548:\n", "  pfmt(f,fmt,ptVar2);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pcmd(io *f, tree *t)\n", "{\n", "\tif(t==0)\n", "\t\treturn;\n", "\tswitch(t->type){\n", "\tdefault:\tpfmt(f, \"bad %d %p %p %p\", t->type, c0, c1, c2);\n", "\tbreak;\n", "\tcase '$':\tpfmt(f, \"$%t\", c0);\n", "\tbreak;\n", "\tcase '\"':\tpfmt(f, \"$\\\"%t\", c0);\n", "\tbreak;\n", "\tcase '&':\tpfmt(f, \"%t&\", c0);\n", "\tbreak;\n", "\tcase '^':\tpfmt(f, \"%t^%t\", c0, c1);\n", "\tbreak;\n", "\tcase '`':\tpfmt(f, \"`%t\", c0);\n", "\tbreak;\n", "\tcase ANDAND:\tpfmt(f, \"%t && %t\", c0, c1);\n", "\tbreak;\n", "\tcase BANG:\tpfmt(f, \"! %t\", c0);\n", "\tbreak;\n", "\tcase BRACE:\tpfmt(f, \"{%t}\", c0);\n", "\tbreak;\n", "\tcase COUNT:\tpfmt(f, \"$#%t\", c0);\n", "\tbreak;\n", "\tcase FN:\tpfmt(f, \"fn %t %t\", c0, c1);\n", "\tbreak;\n", "\tcase IF:\tpfmt(f, \"if%t%t\", c0, c1);\n", "\tbreak;\n", "\tcase NOT:\tpfmt(f, \"if not %t\", c0);\n", "\tbreak;\n", "\tcase OROR:\tpfmt(f, \"%t || %t\", c0, c1);\n", "\tbreak;\n", "\tcase PCMD:\n", "\tcase PAREN:\tpfmt(f, \"(%t)\", c0);\n", "\tbreak;\n", "\tcase SUB:\tpfmt(f, \"$%t(%t)\", c0, c1);\n", "\tbreak;\n", "\tcase SIMPLE:\tpfmt(f, \"%t\", c0);\n", "\tbreak;\n", "\tcase SUBSHELL:\tpfmt(f, \"@ %t\", c0);\n", "\tbreak;\n", "\tcase SWITCH:\tpfmt(f, \"switch %t %t\", c0, c1);\n", "\tbreak;\n", "\tcase TWIDDLE:\tpfmt(f, \"~ %t %t\", c0, c1);\n", "\tbreak;\n", "\tcase WHILE:\tpfmt(f, \"while %t%t\", c0, c1);\n", "\tbreak;\n", "\tcase ARGLIST:\n", "\t\tif(c0==0)\n", "\t\t\tpfmt(f, \"%t\", c1);\n", "\t\telse if(c1==0)\n", "\t\t\tpfmt(f, \"%t\", c0);\n", "\t\telse\n", "\t\t\tpfmt(f, \"%t %t\", c0, c1);\n", "\t\tbreak;\n", "\tcase ';':\n", "\t\tif(c0){\n", "\t\t\tif(c1)\n", "\t\t\t\tpfmt(f, \"%t%c%t\", c0, nl, c1);\n", "\t\t\telse pfmt(f, \"%t\", c0);\n", "\t\t}\n", "\t\telse pfmt(f, \"%t\", c1);\n", "\t\tbreak;\n", "\tcase WORDS:\n", "\t\tif(c0)\n", "\t\t\tpfmt(f, \"%t \", c0);\n", "\t\tpfmt(f, \"%t\", c1);\n", "\t\tbreak;\n", "\tcase FOR:\n", "\t\tpfmt(f, \"for(%t\", c0);\n", "\t\tif(c1)\n", "\t\t\tpfmt(f, \" in %t\", c1);\n", "\t\tpfmt(f, \")%t\", c2);\n", "\t\tbreak;\n", "\tcase WORD:\n", "\t\tif(t->quoted)\n", "\t\t\tpfmt(f, \"%Q\", t->str);\n", "\t\telse pdeglob(f, t->str);\n", "\t\tbreak;\n", "\tcase DUP:\n", "\t\tif(t->rtype==DUPFD)\n", "\t\t\tpfmt(f, \">[%d=%d]\", t->fd1, t->fd0); /* yes, fd1, then fd0; read lex.c */\n", "\t\telse\n", "\t\t\tpfmt(f, \">[%d=]\", t->fd0);\n", "\t\tpfmt(f, \"%t\", c1);\n", "\t\tbreak;\n", "\tcase PIPEFD:\n", "\tcase REDIR:\n", "\t\tswitch(t->rtype){\n", "\t\tcase HERE:\n", "\t\t\tpchr(f, '<');\n", "\t\tcase READ:\n", "\t\tcase RDWR:\n", "\t\t\tpchr(f, '<');\n", "\t\t\tif(t->rtype==RDWR)\n", "\t\t\t\tpchr(f, '>');\n", "\t\t\tif(t->fd0!=0)\n", "\t\t\t\tpfmt(f, \"[%d]\", t->fd0);\n", "\t\t\tbreak;\n", "\t\tcase APPEND:\n", "\t\t\tpchr(f, '>');\n", "\t\tcase WRITE:\n", "\t\t\tpchr(f, '>');\n", "\t\t\tif(t->fd0!=1)\n", "\t\t\t\tpfmt(f, \"[%d]\", t->fd0);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tpfmt(f, \"%t\", c0);\n", "\t\tif(c1)\n", "\t\t\tpfmt(f, \" %t\", c1);\n", "\t\tbreak;\n", "\tcase '=':\n", "\t\tpfmt(f, \"%t=%t\", c0, c1);\n", "\t\tif(c2)\n", "\t\t\tpfmt(f, \" %t\", c2);\n", "\t\tbreak;\n", "\tcase PIPE:\n", "\t\tpfmt(f, \"%t|\", c0);\n", "\t\tif(t->fd1==0){\n", "\t\t\tif(t->fd0!=1)\n", "\t\t\t\tpfmt(f, \"[%d]\", t->fd0);\n", "\t\t}\n", "\t\telse pfmt(f, \"[%d=%d]\", t->fd0, t->fd1);\n", "\t\tpfmt(f, \"%t\", c1);\n", "\t\tbreak;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int globcmp(void *s,void *t)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = strcmp(*(char **)s,*(char **)t);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "globcmp(const void *s, const void *t)\n", "{\n", "\treturn strcmp(*(char**)s, *(char**)t);\n", "}"]}, {"ghidra": ["\n", "void skipnl(void)\n", "\n", "{\n", "  while( true ) {\n", "    skipwhite();\n", "    if (future == -1) {\n", "      future = getnext();\n", "    }\n", "    if (future != 10) break;\n", "    advance();\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "skipnl(void)\n", "{\n", "\tint c;\n", "\tfor(;;){\n", "\t\tskipwhite();\n", "\t\tc = nextc();\n", "\t\tif(c!='\\n')\n", "\t\t\treturn;\n", "\t\tadvance();\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int getflags(int argc,char **argv,char *flags,int stop)\n", "\n", "{\n", "  int iVar1;\n", "  uint uVar2;\n", "  char cVar3;\n", "  char *pcVar4;\n", "  char *pcVar5;\n", "  char **ppcVar6;\n", "  char *pcVar7;\n", "  int iVar8;\n", "  char cVar9;\n", "  char *pcVar10;\n", "  long lVar11;\n", "  long lVar12;\n", "  char **ppcVar13;\n", "  char **ppcVar14;\n", "  char **ppcVar15;\n", "  char **ppcVar16;\n", "  char **ppcVar17;\n", "  uint uVar18;\n", "  \n", "  if (cmdname == (char *)0x0) {\n", "    cmdname = *argv;\n", "  }\n", "  flagarg = flags;\n", "  if (argc == 0) {\n", "    cmdline[0] = '\\0';\n", "  }\n", "  else {\n", "    lVar12 = 0;\n", "    pcVar4 = cmdline;\n", "    do {\n", "      pcVar10 = argv[lVar12];\n", "      cVar3 = *pcVar10;\n", "      while (cVar3 != '\\0') {\n", "        if (pcVar4 != cmdline + 0x200) {\n", "          *pcVar4 = cVar3;\n", "          pcVar4 = pcVar4 + 1;\n", "        }\n", "        pcVar10 = pcVar10 + 1;\n", "        cVar3 = *pcVar10;\n", "      }\n", "      if ((argc + -1 != (int)lVar12) && (pcVar4 != cmdline + 0x200)) {\n", "        *pcVar4 = ' ';\n", "        pcVar4 = pcVar4 + 1;\n", "      }\n", "      lVar12 = lVar12 + 1;\n", "    } while (argc != (int)lVar12);\n", "    *pcVar4 = '\\0';\n", "    if (argc == 1) {\n", "      return 1;\n", "    }\n", "  }\n", "  uVar18 = 1;\n", "  while( true ) {\n", "    ppcVar15 = argv + (int)uVar18;\n", "    pcVar4 = *ppcVar15;\n", "    if ((*pcVar4 == '-') && (cVar3 = pcVar4[1], cVar3 != '\\0')) break;\n", "    if (stop != 0) {\n", "      return argc;\n", "    }\n", "    uVar18 = uVar18 + 1;\n", "LAB_00406710:\n", "    if (argc == uVar18) {\n", "      return argc;\n", "    }\n", "  }\n", "  iVar1 = uVar18 + 1;\n", "  pcVar10 = pcVar4 + 1;\n", "  pcVar4 = pcVar4 + 2;\n", "joined_r0x00406758:\n", "  uVar2 = SEXT14(cVar3);\n", "  pcVar5 = flags;\n", "  if (0x7f < uVar2) {\n", "    badflag = uVar2;\n", "    reason = 4;\n", "    return -1;\n", "  }\n", "  do {\n", "    while( true ) {\n", "      cVar3 = *pcVar5;\n", "      if (cVar3 == '\\0') {\n", "        badflag = uVar2;\n", "        reason = 4;\n", "        return -1;\n", "      }\n", "      if (cVar3 != ' ') break;\n", "      pcVar5 = pcVar5 + 1;\n", "    }\n", "    cVar9 = pcVar5[1];\n", "    if (cVar9 == ':') {\n", "      cVar9 = pcVar5[2];\n", "      pcVar5 = pcVar5 + 2;\n", "      if (9 < (byte)(cVar9 - 0x30U)) {\n", "        reason = 3;\n", "        return -1;\n", "      }\n", "      iVar8 = 0;\n", "      do {\n", "        pcVar5 = pcVar5 + 1;\n", "        iVar8 = (int)cVar9 + -0x30 + iVar8 * 10;\n", "        cVar9 = *pcVar5;\n", "      } while ((byte)(cVar9 - 0x30U) < 10);\n", "    }\n", "    else {\n", "      pcVar5 = pcVar5 + 1;\n", "      iVar8 = 0;\n", "    }\n", "    if (cVar9 == '[') {\n", "      do {\n", "        pcVar7 = pcVar5;\n", "        pcVar5 = pcVar7 + 1;\n", "        cVar9 = *pcVar5;\n", "        if (cVar9 == '\\0') {\n", "          reason = 3;\n", "          return -1;\n", "        }\n", "      } while (cVar9 != ']');\n", "      pcVar5 = pcVar7 + 2;\n", "    }\n", "  } while (uVar2 != (int)cVar3);\n", "  lVar12 = (long)(int)uVar2;\n", "  if (flag[lVar12] != (char **)0x0) {\n", "    badflag = uVar2;\n", "    reason = 1;\n", "    return -1;\n", "  }\n", "  if (iVar8 == 0) {\n", "    flag[lVar12] = (char **)0x61d2e8;\n", "    cVar3 = pcVar10[1];\n", "    if (cVar3 == '\\0') {\n", "      if (iVar1 <= argc) {\n", "        ppcVar6 = argv + (long)iVar1;\n", "        do {\n", "          ppcVar14 = ppcVar6 + 1;\n", "          ppcVar6[-1] = *ppcVar6;\n", "          ppcVar6 = ppcVar14;\n", "        } while (ppcVar14 != argv + (ulong)(~uVar18 + argc) + (long)iVar1 + 1);\n", "        cVar3 = pcVar10[1];\n", "      }\n", "      argc = argc - 1;\n", "    }\n", "    if (cVar3 != '\\0') goto code_r0x00406815;\n", "  }\n", "  else {\n", "    if (pcVar10[1] == '\\0') {\n", "      if (iVar1 <= argc) {\n", "        ppcVar6 = argv + (long)iVar1;\n", "        do {\n", "          ppcVar14 = ppcVar6 + 1;\n", "          ppcVar6[-1] = *ppcVar6;\n", "          ppcVar6 = ppcVar14;\n", "        } while (ppcVar14 != argv + (long)iVar1 + 1 + (ulong)(~uVar18 + argc));\n", "      }\n", "      pcVar4 = *ppcVar15;\n", "      argc = argc - 1;\n", "    }\n", "    if ((int)(argc - uVar18) < iVar8) {\n", "      badflag = uVar2;\n", "      reason = 2;\n", "      return -1;\n", "    }\n", "    ppcVar6 = argv + (long)argc;\n", "    ppcVar14 = ppcVar15;\n", "    ppcVar16 = ppcVar6;\n", "    if (ppcVar15 < ppcVar6) {\n", "      do {\n", "        pcVar10 = *ppcVar14;\n", "        ppcVar13 = ppcVar14 + 1;\n", "        ppcVar17 = ppcVar16 + -1;\n", "        *ppcVar14 = *ppcVar16;\n", "        *ppcVar16 = pcVar10;\n", "        ppcVar14 = ppcVar13;\n", "        ppcVar16 = ppcVar17;\n", "      } while (ppcVar13 < ppcVar17);\n", "    }\n", "    lVar11 = (long)argc - (long)iVar8;\n", "    ppcVar14 = argv + lVar11;\n", "    if (ppcVar15 < ppcVar14) {\n", "      do {\n", "        pcVar10 = *ppcVar15;\n", "        ppcVar13 = ppcVar15 + 1;\n", "        ppcVar16 = ppcVar14 + -1;\n", "        *ppcVar15 = *ppcVar14;\n", "        *ppcVar14 = pcVar10;\n", "        ppcVar14 = ppcVar16;\n", "        ppcVar15 = ppcVar13;\n", "      } while (ppcVar13 < ppcVar16);\n", "    }\n", "    ppcVar15 = argv + lVar11 + 1;\n", "    if (argv + lVar11 + 1 < ppcVar6) {\n", "      do {\n", "        pcVar10 = *ppcVar15;\n", "        ppcVar16 = ppcVar15 + 1;\n", "        ppcVar14 = ppcVar6 + -1;\n", "        *ppcVar15 = *ppcVar6;\n", "        *ppcVar6 = pcVar10;\n", "        ppcVar6 = ppcVar14;\n", "        ppcVar15 = ppcVar16;\n", "      } while (ppcVar16 < ppcVar14);\n", "    }\n", "    argc = argc - iVar8;\n", "    flag[lVar12] = argv + (long)argc + 1;\n", "    argv[(long)argc + 1] = pcVar4;\n", "  }\n", "  goto LAB_00406710;\n", "code_r0x00406815:\n", "  pcVar10 = pcVar4;\n", "  pcVar4 = pcVar4 + 1;\n", "  goto joined_r0x00406758;\n", "}\n", "\n"], "c": ["int\n", "getflags(int argc, char *argv[], char *flags, int stop)\n", "{\n", "\tchar *s, *t;\n", "\tint i, j, c, count;\n", "\tflagarg = flags;\n", "\tif(cmdname==0)\n", "\t\tcmdname = argv[0];\n", "\ts = cmdline;\n", "\tfor(i = 0;i!=argc;i++){\n", "\t\tfor(t = argv[i];*t;t++)\n", "\t\t\tif(s!=&cmdline[NCMDLINE])\n", "\t\t\t\t*s++=*t;\n", "\t\tif(i!=argc-1 && s!=&cmdline[NCMDLINE])\n", "\t\t\t*s++=' ';\n", "\t}\n", "\t*s='\\0';\n", "\ti = 1;\n", "\twhile(i!=argc){\n", "\t\tif(argv[i][0]!='-' || argv[i][1]=='\\0'){\n", "\t\t\tif(stop)\n", "\t\t\t\treturn argc;\n", "\t\t\ti++;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\ts = argv[i]+1;\n", "\t\twhile(*s){\n", "\t\t\tc=*s++;\n", "\t\t\tcount = scanflag(c, flags);\n", "\t\t\tif(count==-1)\n", "\t\t\t\treturn -1;\n", "\t\t\tif(flag[c]){ reason = RESET; badflag = c; return -1; }\n", "\t\t\tif(count==0){\n", "\t\t\t\tflag[c] = flagset;\n", "\t\t\t\tif(*s=='\\0'){\n", "\t\t\t\t\tfor(j = i+1;j<=argc;j++)\n", "\t\t\t\t\t\targv[j-1] = argv[j];\n", "\t\t\t\t\t--argc;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\telse{\n", "\t\t\t\tif(*s=='\\0'){\n", "\t\t\t\t\tfor(j = i+1;j<=argc;j++)\n", "\t\t\t\t\t\targv[j-1] = argv[j];\n", "\t\t\t\t\t--argc;\n", "\t\t\t\t\ts = argv[i];\n", "\t\t\t\t}\n", "\t\t\t\tif(argc-i<count){\n", "\t\t\t\t\treason = FEWARGS;\n", "\t\t\t\t\tbadflag = c;\n", "\t\t\t\t\treturn -1;\n", "\t\t\t\t}\n", "\t\t\t\treverse(argv+i, argv+argc);\n", "\t\t\t\treverse(argv+i, argv+argc-count);\n", "\t\t\t\treverse(argv+argc-count+1, argv+argc);\n", "\t\t\t\targc-=count;\n", "\t\t\t\tflag[c] = argv+argc+1;\n", "\t\t\t\tflag[c][0] = s;\n", "\t\t\t\ts=\"\";\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\treturn argc;\n", "}"]}, {"ghidra": ["\n", "void poct(io *f,uint n)\n", "\n", "{\n", "  if (7 < n) {\n", "    poct(f,n >> 3);\n", "  }\n", "  pchr(f,(n & 7) + 0x30);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "poct(io *f, unsigned n)\n", "{\n", "\tif(n>7)\n", "\t\tpoct(f, n>>3);\n", "\tpchr(f, (n&7)+'0');\n", "}"]}, {"ghidra": ["\n", "void Vinit(void)\n", "\n", "{\n", "  char cVar1;\n", "  word *val;\n", "  char *pcVar2;\n", "  char **ppcVar3;\n", "  \n", "  pcVar2 = *environ;\n", "  environp = environ;\n", "  ppcVar3 = environ;\n", "  do {\n", "    if (pcVar2 == (char *)0x0) {\n", "      return;\n", "    }\n", "    cVar1 = *pcVar2;\n", "    while ((cVar1 != '(' && (cVar1 != '\\0'))) {\n", "      if (cVar1 == '=') goto LAB_0040ccf3;\n", "      pcVar2 = pcVar2 + 1;\n", "      cVar1 = *pcVar2;\n", "    }\n", "    if (cVar1 == '=') {\n", "LAB_0040ccf3:\n", "      *pcVar2 = '\\0';\n", "      val = enval(pcVar2 + 1);\n", "      setvar(*ppcVar3,val);\n", "      *pcVar2 = '=';\n", "    }\n", "    ppcVar3 = ppcVar3 + 1;\n", "    pcVar2 = *ppcVar3;\n", "  } while( true );\n", "}\n", "\n"], "c": ["void Vinit(void){\n", "\textern char **environ;\n", "\tregister char *s;\n", "\tregister char **env=environ;\n", "\tenvironp=env;\n", "\tfor(;*env;env++){\n", "\t\tfor(s=*env;*s && *s!='(' && *s!='=';s++);\n", "\t\tswitch(*s){\n", "\t\tcase '\\0':\n", "\t\t/*\tpfmt(err, \"rc: odd environment %q?\\n\", *env); */\n", "\t\t\tbreak;\n", "\t\tcase '=':\n", "\t\t\t*s='\\0';\n", "\t\t\tsetvar(*env, enval(s+1));\n", "\t\t\t*s='=';\n", "\t\t\tbreak;\n", "\t\tcase '(':\t/* ignore functions for now */\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void execflag(void)\n", "\n", "{\n", "  word *pwVar1;\n", "  byte *__s;\n", "  int iVar2;\n", "  size_t sVar3;\n", "  long lVar4;\n", "  char *pcVar5;\n", "  char *s;\n", "  char *pcVar6;\n", "  bool bVar7;\n", "  byte bVar8;\n", "  \n", "  bVar8 = 0;\n", "  iVar2 = count(runq->argv->words);\n", "  if (iVar2 == 2) {\n", "    s = \"flag not set\";\n", "    if (flag[(byte)*runq->argv->words->next->word] != (char **)0x0) {\n", "      s = \"\";\n", "    }\n", "    setstatus(s);\n", "    goto LAB_0040a704;\n", "  }\n", "  if (iVar2 == 3) {\n", "    pwVar1 = runq->argv->words->next;\n", "    __s = (byte *)pwVar1->word;\n", "    s = pwVar1->next->word;\n", "    sVar3 = strlen((char *)__s);\n", "    bVar7 = sVar3 == 1;\n", "    if (bVar7) {\n", "      lVar4 = 2;\n", "      pcVar5 = s;\n", "      pcVar6 = \"+\";\n", "      do {\n", "        if (lVar4 == 0) break;\n", "        lVar4 = lVar4 + -1;\n", "        bVar7 = *pcVar5 == *pcVar6;\n", "        pcVar5 = pcVar5 + (ulong)bVar8 * -2 + 1;\n", "        pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n", "      } while (bVar7);\n", "      if (bVar7) {\n", "        flag[*__s] = (char **)0x61d2e8;\n", "      }\n", "      else {\n", "        lVar4 = 2;\n", "        pcVar5 = \"-\";\n", "        do {\n", "          if (lVar4 == 0) break;\n", "          lVar4 = lVar4 + -1;\n", "          bVar7 = *s == *pcVar5;\n", "          s = s + (ulong)bVar8 * -2 + 1;\n", "          pcVar5 = pcVar5 + (ulong)bVar8 * -2 + 1;\n", "        } while (bVar7);\n", "        if (!bVar7) goto LAB_0040a6bd;\n", "        flag[*__s] = (char **)0x0;\n", "      }\n", "LAB_0040a704:\n", "      poplist();\n", "      return;\n", "    }\n", "  }\n", "LAB_0040a6bd:\n", "  Xerror1(\"Usage: flag [letter] [+-]\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execflag(void)\n", "{\n", "\tchar *letter, *val;\n", "\tswitch(count(runq->argv->words)){\n", "\tcase 2:\n", "\t\tsetstatus(flag[(uchar)runq->argv->words->next->word[0]]?\"\":\"flag not set\");\n", "\t\tbreak;\n", "\tcase 3:\n", "\t\tletter = runq->argv->words->next->word;\n", "\t\tval = runq->argv->words->next->next->word;\n", "\t\tif(strlen(letter)==1){\n", "\t\t\tif(strcmp(val, \"+\")==0){\n", "\t\t\t\tflag[(uchar)letter[0]] = flagset;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tif(strcmp(val, \"-\")==0){\n", "\t\t\t\tflag[(uchar)letter[0]] = 0;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\tdefault:\n", "\t\tXerror1(\"Usage: flag [letter] [+-]\");\n", "\t\treturn;\n", "\t}\n", "\tpoplist();\n", "}"]}, {"ghidra": ["\n", "void pstrs(io *f,word *a)\n", "\n", "{\n", "  word *pwVar1;\n", "  \n", "  if (a != (word *)0x0) {\n", "    pwVar1 = a->next;\n", "    while ((pwVar1 != (word *)0x0 && (pwVar1->word != (char *)0x0))) {\n", "      pstr(f,a->word);\n", "      pchr(f,0x20);\n", "      a = a->next;\n", "      pwVar1 = a->next;\n", "    }\n", "    pstr(f,a->word);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pstrs(io *f, word *a)\n", "{\n", "\tif(a){\n", "\t\twhile(a->next && a->next->word){\n", "\t\t\tpstr(f, a->word);\n", "\t\t\tpchr(f, ' ');\n", "\t\t\ta = a->next;\n", "\t\t}\n", "\t\tpstr(f, a->word);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "var * vlook(char *name)\n", "\n", "{\n", "  int iVar1;\n", "  var *pvVar2;\n", "  \n", "  if (runq != (thread *)0x0) {\n", "    pvVar2 = runq->local;\n", "    while (pvVar2 != (var *)0x0) {\n", "      iVar1 = strcmp(pvVar2->name,name);\n", "      if (iVar1 == 0) {\n", "        return pvVar2;\n", "      }\n", "      pvVar2 = pvVar2->next;\n", "    }\n", "  }\n", "  pvVar2 = gvlook(name);\n", "  return pvVar2;\n", "}\n", "\n"], "c": ["var*\n", "vlook(char *name)\n", "{\n", "\tvar *v;\n", "\tif(runq)\n", "\t\tfor(v = runq->local;v;v = v->next)\n", "\t\t\tif(strcmp(v->name, name)==0) return v;\n", "\treturn gvlook(name);\n", "}"]}, {"ghidra": ["\n", "char * addutf(char *p,int c)\n", "\n", "{\n", "  char *pcVar1;\n", "  int iVar2;\n", "  \n", "  if (p != (char *)0x0) {\n", "    if (p != tok + 0x1fff) {\n", "      pcVar1 = p + 1;\n", "      *p = (char)c;\n", "      if ((c & 0xe0U) == 0xc0) {\n", "        iVar2 = advance();\n", "        if (pcVar1 == (char *)0x0) {\n", "          return (char *)0x0;\n", "        }\n", "        if (pcVar1 != tok + 0x1fff) {\n", "          p[1] = (char)iVar2;\n", "          return p + 2;\n", "        }\n", "LAB_00408b40:\n", "        tok[8191] = '\\0';\n", "        yyerror(\"token buffer too short\");\n", "        return (char *)0x0;\n", "      }\n", "      if ((c & 0xf0U) != 0xe0) {\n", "        return pcVar1;\n", "      }\n", "      iVar2 = advance();\n", "      if (pcVar1 != (char *)0x0) {\n", "        if (pcVar1 != tok + 0x1fff) {\n", "          p[1] = (char)iVar2;\n", "          iVar2 = advance();\n", "          if (p == (char *)0xfffffffffffffffe) {\n", "            return (char *)0x0;\n", "          }\n", "          if (p != tok + 0x1ffd) {\n", "            p[2] = (char)iVar2;\n", "            return p + 3;\n", "          }\n", "          goto LAB_00408b40;\n", "        }\n", "        tok[8191] = '\\0';\n", "        yyerror(\"token buffer too short\");\n", "      }\n", "      goto LAB_00408b30;\n", "    }\n", "    tok[8191] = '\\0';\n", "    yyerror(\"token buffer too short\");\n", "  }\n", "  if ((c & 0xe0U) != 0xc0) {\n", "    if ((c & 0xf0U) != 0xe0) {\n", "      return (char *)0x0;\n", "    }\n", "    advance();\n", "  }\n", "LAB_00408b30:\n", "  advance();\n", "  return (char *)0x0;\n", "}\n", "\n"], "c": ["char*\n", "addutf(char *p, int c)\n", "{\n", "\tp = addtok(p, c);\n", "\tif(twobyte(c))\t /* 2-byte escape */\n", "\t\treturn addtok(p, advance());\n", "\tif(threebyte(c)){\t/* 3-byte escape */\n", "\t\tp = addtok(p, advance());\n", "\t\treturn addtok(p, advance());\n", "\t}\n", "\treturn p;\n", "}"]}, {"ghidra": ["\n", "void yyerror(char *m)\n", "\n", "{\n", "  word *val;\n", "  \n", "  pfmt(rc_err,\"rc: \");\n", "  if (runq->cmdfile == (char *)0x0) {\n", "    if (runq->iflag == 0) {\n", "      pfmt(rc_err,\"line %d: \",(ulong)(uint)runq->lineno);\n", "    }\n", "  }\n", "  else {\n", "    if (runq->iflag == 0) {\n", "      pfmt(rc_err,\"%s:%d: \",runq->cmdfile,(ulong)(uint)runq->lineno);\n", "    }\n", "    else {\n", "      pfmt(rc_err,\"%s: \");\n", "    }\n", "  }\n", "  if ((tok[0] != '\\n') && (tok[0] != '\\0')) {\n", "    pfmt(rc_err,\"token %q: \",tok);\n", "  }\n", "  pfmt(rc_err,\"%s\\n\",m);\n", "  flush(rc_err);\n", "  lastword = 0;\n", "  lastdol = 0;\n", "  while ((lastc != -1 && (lastc != 10))) {\n", "    advance();\n", "  }\n", "  nerror = nerror + 1;\n", "  val = newword(m,(word *)0x0);\n", "  setvar(\"status\",val);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "yyerror(char *m)\n", "{\n", "\tpfmt(err, \"rc: \");\n", "\tif(runq->cmdfile && !runq->iflag)\n", "\t\tpfmt(err, \"%s:%d: \", runq->cmdfile, runq->lineno);\n", "\telse if(runq->cmdfile)\n", "\t\tpfmt(err, \"%s: \", runq->cmdfile);\n", "\telse if(!runq->iflag)\n", "\t\tpfmt(err, \"line %d: \", runq->lineno);\n", "\tif(tok[0] && tok[0]!='\\n')\n", "\t\tpfmt(err, \"token %q: \", tok);\n", "\tpfmt(err, \"%s\\n\", m);\n", "\tflush(err);\n", "\tlastword = 0;\n", "\tlastdol = 0;\n", "\twhile(lastc!='\\n' && lastc!=EOF) advance();\n", "\tnerror++;\n", "\tsetvar(\"status\", newword(m, (word *)0));\n", "}"]}, {"ghidra": ["\n", "int Dup1(int a)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  iVar1 = p9dup(a,-1);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int Dup1(int a){\n", "\treturn dup(a, -1);\n", "}"]}, {"ghidra": ["\n", "void flush(io *f)\n", "\n", "{\n", "  int iVar1;\n", "  char *av;\n", "  long lVar2;\n", "  int n;\n", "  \n", "  av = f->strp;\n", "  if (av == (char *)0x0) {\n", "    av = f->buf;\n", "    iVar1 = (int)f->bufp - (int)av;\n", "    if (iVar1 != 0) {\n", "      lVar2 = Write(f->fd,av,(long)iVar1);\n", "      if (lVar2 < 0) {\n", "        Write(3,\"Write error\\n\",0xc);\n", "        if (ntrap != 0) {\n", "          dotrap();\n", "        }\n", "      }\n", "    }\n", "    f->bufp = av;\n", "    *(io **)&f->ebuf = f + 1;\n", "    return;\n", "  }\n", "  iVar1 = (int)f->ebuf - (int)av;\n", "  n = iVar1 + 0x65;\n", "  av = (char *)p9realloc(av,(long)n);\n", "  f->strp = av;\n", "  if (av != (char *)0x0) {\n", "    av = av + iVar1;\n", "    f->bufp = av;\n", "    f->ebuf = av + 100;\n", "    do {\n", "      *av = '\\0';\n", "      av = av + 1;\n", "    } while (av <= f->ebuf);\n", "    return;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  panic(\"Can\\'t realloc %d bytes in flush!\",n);\n", "}\n", "\n"], "c": ["void\n", "flush(io *f)\n", "{\n", "\tint n;\n", "\tchar *s;\n", "\tif(f->strp){\n", "\t\tn = f->ebuf-f->strp;\n", "\t\tf->strp = realloc(f->strp, n+101);\n", "\t\tif(f->strp==0)\n", "\t\t\tpanic(\"Can't realloc %d bytes in flush!\", n+101);\n", "\t\tf->bufp = f->strp+n;\n", "\t\tf->ebuf = f->bufp+100;\n", "\t\tfor(s = f->bufp;s<=f->ebuf;s++) *s='\\0';\n", "\t}\n", "\telse{\n", "\t\tn = f->bufp-f->buf;\n", "\t\tif(n && Write(f->fd, f->buf, n) < 0){\n", "\t\t\tWrite(3, \"Write error\\n\", 12);\n", "\t\t\tif(ntrap)\n", "\t\t\t\tdotrap();\n", "\t\t}\n", "\t\tf->bufp = f->buf;\n", "\t\tf->ebuf = f->buf+NBUF;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "void pval(io *f,word *a)\n", "\n", "{\n", "  word *pwVar1;\n", "  \n", "  if (a != (word *)0x0) {\n", "    pwVar1 = a->next;\n", "    while ((pwVar1 != (word *)0x0 && (pwVar1->word != (char *)0x0))) {\n", "      pwrd(f,a->word);\n", "      pchr(f,0x20);\n", "      a = a->next;\n", "      pwVar1 = a->next;\n", "    }\n", "    pwrd(f,a->word);\n", "    return;\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "pval(io *f, word *a)\n", "{\n", "\tif(a){\n", "\t\twhile(a->next && a->next->word){\n", "\t\t\tpwrd(f, a->word);\n", "\t\t\tpchr(f, ' ');\n", "\t\t\ta = a->next;\n", "\t\t}\n", "\t\tpwrd(f, a->word);\n", "\t}\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "int execforkexec(void)\n", "\n", "{\n", "  long lVar1;\n", "  __pid_t pid;\n", "  long in_FS_OFFSET;\n", "  char buf [128];\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  pid = fork();\n", "  if (pid != -1) {\n", "    if (pid == 0) {\n", "      clearwaitpids();\n", "      pushword(\"exec\");\n", "      execexec();\n", "      buf._0_8_ = 0x78652074276e6163;\n", "      buf._8_4_ = 0x203a6365;\n", "      buf[12] = '\\0';\n", "      errstr(buf + 0xc,0x74);\n", "      Exit(buf);\n", "    }\n", "    addwaitpid(pid);\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return (int)pid;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "execforkexec(void)\n", "{\n", "\tint pid;\n", "\tint n;\n", "\tchar buf[ERRMAX];\n", "\n", "\tswitch(pid = fork()){\n", "\tcase -1:\n", "\t\treturn -1;\n", "\tcase 0:\n", "\t\tclearwaitpids();\n", "\t\tpushword(\"exec\");\n", "\t\texecexec();\n", "\t\tstrcpy(buf, \"can't exec: \");\n", "\t\tn = strlen(buf);\n", "\t\terrstr(buf+n, ERRMAX-n);\n", "\t\tExit(buf);\n", "\t}\n", "\taddwaitpid(pid);\n", "\treturn pid;\n", "}"]}, {"ghidra": ["\n", "int dochdir(char *word)\n", "\n", "{\n", "  int wdirfd;\n", "  int f;\n", "  size_t n;\n", "  \n", "  f = chdir(word);\n", "  if (f < 0) {\n", "    f = -1;\n", "  }\n", "  else {\n", "    if (flag[105] != (char **)0x0) {\n", "      if (wdirfd == -2) {\n", "        wdirfd = p9open(\"/dev/wdir\",0x21);\n", "      }\n", "      f = wdirfd;\n", "      if (-1 < wdirfd) {\n", "        n = strlen(word);\n", "        p9write(f,word,n);\n", "      }\n", "    }\n", "    f = 1;\n", "  }\n", "  return f;\n", "}\n", "\n"], "c": ["int\n", "dochdir(char *word)\n", "{\n", "\t/* report to /dev/wdir if it exists and we're interactive */\n", "\tstatic int wdirfd = -2;\n", "\tif(chdir(word)<0) return -1;\n", "\tif(flag['i']!=0){\n", "\t\tif(wdirfd==-2)\t/* try only once */\n", "\t\t\twdirfd = open(\"/dev/wdir\", OWRITE|OCEXEC);\n", "\t\tif(wdirfd>=0)\n", "\t\t\twrite(wdirfd, word, strlen(word));\n", "\t}\n", "\treturn 1;\n", "}"]}, {"ghidra": ["\n", "int notify(anon_subr_void_void_ptr_char_ptr *f)\n", "\n", "{\n", "  long lVar1;\n", "  int init;\n", "  Sig *pSVar2;\n", "  long in_FS_OFFSET;\n", "  sigaction sa;\n", "  \n", "  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n", "  notifyf = f;\n", "  if (init == 0) {\n", "    init = 1;\n", "    pSVar2 = sigs;\n", "    do {\n", "      sigaction(pSVar2->sig,(sigaction *)0x0,(sigaction *)&sa);\n", "      if (sa.__sigaction_handler == 0) {\n", "        notifyseton(pSVar2->sig,(uint)((*(byte *)&pSVar2->flags & 4) == 0));\n", "      }\n", "      pSVar2 = pSVar2 + 1;\n", "    } while (pSVar2 != (Sig *)&DAT_0061d958);\n", "  }\n", "  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n", "    return 0;\n", "  }\n", "                    /* WARNING: Subroutine does not return */\n", "  __stack_chk_fail();\n", "}\n", "\n"], "c": ["int\n", "notify(void (*f)(void*, char*))\n", "{\n", "\tstatic int init;\n", "\n", "\tnotifyf = f;\n", "\tif(!init){\n", "\t\tinit = 1;\n", "\t\tnoteinit();\n", "\t}\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "int getnext(void)\n", "\n", "{\n", "  int peekc;\n", "  int c;\n", "  int iVar1;\n", "  bool bVar2;\n", "  \n", "  if (peekc != -1) {\n", "    return peekc;\n", "  }\n", "  if (runq->eof != 0) {\n", "    return -1;\n", "  }\n", "  if (doprompt != 0) {\n", "    pprompt();\n", "  }\n", "  c = rchr(runq->cmdfd);\n", "  if ((c == 0x5c) && (inquote == 0)) {\n", "    iVar1 = rchr(runq->cmdfd);\n", "    if ((iVar1 == 10) && (incomm == 0)) {\n", "      c = 0x20;\n", "    }\n", "    else {\n", "      c = 0x5c;\n", "      peekc = iVar1;\n", "      if (doprompt == 0) goto joined_r0x004087a2;\n", "    }\n", "    doprompt = 1;\n", "  }\n", "  else {\n", "    bVar2 = doprompt == 0;\n", "    doprompt = 1;\n", "    if (bVar2) {\n", "      doprompt = (uint)(c == 10 || c == -1);\n", "    }\n", "joined_r0x004087a2:\n", "    if (c == -1) {\n", "      runq->eof = runq->eof + 1;\n", "      return -1;\n", "    }\n", "  }\n", "  if ((flag[86] == (char **)0x0) && ((ndot < 2 || (flag[118] == (char **)0x0)))) {\n", "    return c;\n", "  }\n", "  pchr(rc_err,c);\n", "  return c;\n", "}\n", "\n"], "c": ["int\n", "getnext(void)\n", "{\n", "\tint c;\n", "\tstatic int peekc = EOF;\n", "\tif(peekc!=EOF){\n", "\t\tc = peekc;\n", "\t\tpeekc = EOF;\n", "\t\treturn c;\n", "\t}\n", "\tif(runq->eof)\n", "\t\treturn EOF;\n", "\tif(doprompt)\n", "\t\tpprompt();\n", "\tc = rchr(runq->cmdfd);\n", "\tif(!inquote && c=='\\\\'){\n", "\t\tc = rchr(runq->cmdfd);\n", "\t\tif(c=='\\n' && !incomm){\t\t/* don't continue a comment */\n", "\t\t\tdoprompt = 1;\n", "\t\t\tc=' ';\n", "\t\t}\n", "\t\telse{\n", "\t\t\tpeekc = c;\n", "\t\t\tc='\\\\';\n", "\t\t}\n", "\t}\n", "\tdoprompt = doprompt || c=='\\n' || c==EOF;\n", "\tif(c==EOF)\n", "\t\trunq->eof++;\n", "\telse if(flag['V'] || ndot>=2 && flag['v']) pchr(err, c);\n", "\treturn c;\n", "}"]}, {"ghidra": ["\n", "char * p9getenv(char *s)\n", "\n", "{\n", "  char *pcVar1;\n", "  \n", "  pcVar1 = getenv(s);\n", "  if (pcVar1 != (char *)0x0) {\n", "    pcVar1 = (char *)__strdup(pcVar1);\n", "    return pcVar1;\n", "  }\n", "  return (char *)0x0;\n", "}\n", "\n"], "c": ["char*\n", "p9getenv(char *s)\n", "{\n", "\tchar *t;\n", "\n", "\tt = getenv(s);\n", "\tif(t == 0)\n", "\t\treturn 0;\n", "\treturn strdup(t);\n", "}"]}, {"ghidra": ["\n", "int match(char *s,char *p,int stop)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  int iVar3;\n", "  char *p_00;\n", "  char cVar4;\n", "  char cVar5;\n", "  int iVar6;\n", "  bool bVar7;\n", "  \n", "  cVar4 = *p;\n", "  do {\n", "    if (((int)cVar4 == stop) || (cVar4 == '\\0')) {\n", "      return (int)(uint)(*s == '\\0');\n", "    }\n", "    if (cVar4 == '\\x01') {\n", "      cVar4 = p[1];\n", "      p_00 = p + 1;\n", "      if (cVar4 == '*') {\n", "        p_00 = nextutf(p_00);\n", "        while( true ) {\n", "          iVar1 = match(s,p_00,stop);\n", "          if (iVar1 != 0) {\n", "            return 1;\n", "          }\n", "          if (*s == '\\0') break;\n", "          s = nextutf(s);\n", "        }\n", "        return 0;\n", "      }\n", "      if (cVar4 < '+') {\n", "        if ((cVar4 == '\\x01') && (*s != '\\x01')) {\n", "          return 0;\n", "        }\n", "      }\n", "      else {\n", "        if (cVar4 == '?') {\n", "          if (*s == '\\0') {\n", "            return 0;\n", "          }\n", "        }\n", "        else {\n", "          if (cVar4 == '[') {\n", "            if (*s == '\\0') {\n", "              return 0;\n", "            }\n", "            p_00 = p + 2;\n", "            iVar1 = unicode(s);\n", "            cVar4 = p[2];\n", "            bVar7 = cVar4 == '~';\n", "            if (bVar7) {\n", "              p_00 = p + 3;\n", "              cVar4 = p[3];\n", "            }\n", "            cVar5 = '\\0';\n", "            while (cVar4 != ']') {\n", "              while( true ) {\n", "                if (cVar4 == '\\0') {\n", "                  return 0;\n", "                }\n", "                iVar2 = unicode(p_00);\n", "                p_00 = nextutf(p_00);\n", "                cVar4 = *p_00;\n", "                iVar6 = iVar2;\n", "                iVar3 = iVar2;\n", "                if (cVar4 == '-') {\n", "                  if (p_00[1] == '\\0') {\n", "                    return 0;\n", "                  }\n", "                  iVar3 = unicode(p_00 + 1);\n", "                  p_00 = nextutf(p_00 + 1);\n", "                  cVar4 = *p_00;\n", "                  if (iVar3 < iVar2) {\n", "                    iVar6 = iVar3;\n", "                    iVar3 = iVar2;\n", "                  }\n", "                }\n", "                if (iVar3 < iVar1) break;\n", "                if (iVar6 <= iVar1) {\n", "                  cVar5 = '\\x01';\n", "                }\n", "                if (cVar4 == ']') goto LAB_004071f4;\n", "              }\n", "            }\n", "LAB_004071f4:\n", "            if (bVar7 == (bool)cVar5) {\n", "              return 0;\n", "            }\n", "          }\n", "        }\n", "      }\n", "    }\n", "    else {\n", "      iVar1 = equtf(p,s);\n", "      p_00 = p;\n", "      if (iVar1 == 0) {\n", "        return 0;\n", "      }\n", "    }\n", "    s = nextutf(s);\n", "    p = nextutf(p_00);\n", "    cVar4 = *p;\n", "  } while( true );\n", "}\n", "\n"], "c": ["int\n", "match(char *s, char *p, int stop)\n", "{\n", "\tint compl, hit, lo, hi, t, c;\n", "\tfor(;*p!=stop && *p!='\\0';s = nextutf(s),p = nextutf(p)){\n", "\t\tif(*p!=GLOB){\n", "\t\t\tif(!equtf(p, s)) return 0;\n", "\t\t}\n", "\t\telse switch(*++p){\n", "\t\tcase GLOB:\n", "\t\t\tif(*s!=GLOB)\n", "\t\t\t\treturn 0;\n", "\t\t\tbreak;\n", "\t\tcase '*':\n", "\t\t\tfor(;;){\n", "\t\t\t\tif(match(s, nextutf(p), stop)) return 1;\n", "\t\t\t\tif(!*s)\n", "\t\t\t\t\tbreak;\n", "\t\t\t\ts = nextutf(s);\n", "\t\t\t}\n", "\t\t\treturn 0;\n", "\t\tcase '?':\n", "\t\t\tif(*s=='\\0')\n", "\t\t\t\treturn 0;\n", "\t\t\tbreak;\n", "\t\tcase '[':\n", "\t\t\tif(*s=='\\0')\n", "\t\t\t\treturn 0;\n", "\t\t\tc = unicode(s);\n", "\t\t\tp++;\n", "\t\t\tcompl=*p=='~';\n", "\t\t\tif(compl)\n", "\t\t\t\tp++;\n", "\t\t\thit = 0;\n", "\t\t\twhile(*p!=']'){\n", "\t\t\t\tif(*p=='\\0')\n", "\t\t\t\t\treturn 0;\t\t/* syntax error */\n", "\t\t\t\tlo = unicode(p);\n", "\t\t\t\tp = nextutf(p);\n", "\t\t\t\tif(*p!='-')\n", "\t\t\t\t\thi = lo;\n", "\t\t\t\telse{\n", "\t\t\t\t\tp++;\n", "\t\t\t\t\tif(*p=='\\0')\n", "\t\t\t\t\t\treturn 0;\t/* syntax error */\n", "\t\t\t\t\thi = unicode(p);\n", "\t\t\t\t\tp = nextutf(p);\n", "\t\t\t\t\tif(hi<lo){ t = lo; lo = hi; hi = t; }\n", "\t\t\t\t}\n", "\t\t\t\tif(lo<=c && c<=hi)\n", "\t\t\t\t\thit = 1;\n", "\t\t\t}\n", "\t\t\tif(compl)\n", "\t\t\t\thit=!hit;\n", "\t\t\tif(!hit)\n", "\t\t\t\treturn 0;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\treturn *s=='\\0';\n", "}"]}, {"ghidra": ["\n", "io * openfd(int fd)\n", "\n", "{\n", "  io *piVar1;\n", "  \n", "  piVar1 = (io *)emalloc(0x220);\n", "  piVar1->fd = fd;\n", "  piVar1->strp = (char *)0x0;\n", "  piVar1->ebuf = piVar1->buf;\n", "  piVar1->bufp = piVar1->buf;\n", "  return piVar1;\n", "}\n", "\n"], "c": ["io*\n", "openfd(int fd)\n", "{\n", "\tio *f = new(struct io);\n", "\tf->fd = fd;\n", "\tf->bufp = f->ebuf = f->buf;\n", "\tf->strp = 0;\n", "\treturn f;\n", "}"]}, {"ghidra": ["\n", "void hexnum(char *p,int n)\n", "\n", "{\n", "  *p = hex[n >> 0xc & 0xf];\n", "  p[1] = hex[n >> 8 & 0xf];\n", "  p[2] = hex[n >> 4 & 0xf];\n", "  p[3] = hex[n & 0xf];\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "hexnum(char *p, int n)\n", "{\n", "\t*p++=hex[(n>>12)&0xF];\n", "\t*p++=hex[(n>>8)&0xF];\n", "\t*p++=hex[(n>>4)&0xF];\n", "\t*p = hex[n&0xF];\n", "}"]}, {"ghidra": ["\n", "void clearwaitpids(void)\n", "\n", "{\n", "  nwaitpids = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "clearwaitpids(void)\n", "{\n", "\tnwaitpids = 0;\n", "}"]}, {"ghidra": ["\n", "void usage(char *tail)\n", "\n", "{\n", "  char cVar1;\n", "  uint uVar2;\n", "  byte *pbVar3;\n", "  byte bVar4;\n", "  char *pcVar5;\n", "  ulong uVar6;\n", "  byte *pbVar7;\n", "  int c;\n", "  int c_00;\n", "  byte *pbVar8;\n", "  \n", "  if (reason == 2) {\n", "    cVar1 = 'F';\n", "    pcVar5 = \"Flag -\";\n", "    do {\n", "      pcVar5 = pcVar5 + 1;\n", "      errc((int)cVar1);\n", "      cVar1 = *pcVar5;\n", "    } while (cVar1 != '\\0');\n", "    pcVar5 = \": too few arguments\\n\";\n", "    errc(badflag);\n", "    cVar1 = ':';\n", "    do {\n", "      pcVar5 = pcVar5 + 1;\n", "      errc((int)cVar1);\n", "      cVar1 = *pcVar5;\n", "    } while (cVar1 != '\\0');\n", "  }\n", "  else {\n", "    if (reason < 3) {\n", "      cVar1 = 'F';\n", "      pcVar5 = \"Flag -\";\n", "      if (reason == 1) {\n", "        do {\n", "          pcVar5 = pcVar5 + 1;\n", "          errc((int)cVar1);\n", "          cVar1 = *pcVar5;\n", "        } while (cVar1 != '\\0');\n", "        pcVar5 = \": set twice\\n\";\n", "        errc(badflag);\n", "        cVar1 = ':';\n", "        do {\n", "          pcVar5 = pcVar5 + 1;\n", "          errc((int)cVar1);\n", "          cVar1 = *pcVar5;\n", "        } while (cVar1 != '\\0');\n", "      }\n", "    }\n", "    else {\n", "      if (reason == 3) {\n", "        cVar1 = 'B';\n", "        pcVar5 = \"Bad argument to getflags!\\n\";\n", "        do {\n", "          pcVar5 = pcVar5 + 1;\n", "          errc((int)cVar1);\n", "          cVar1 = *pcVar5;\n", "        } while (cVar1 != '\\0');\n", "      }\n", "      else {\n", "        cVar1 = 'I';\n", "        pcVar5 = \"Illegal flag -\";\n", "        if (reason == 4) {\n", "          do {\n", "            pcVar5 = pcVar5 + 1;\n", "            errc((int)cVar1);\n", "            cVar1 = *pcVar5;\n", "          } while (cVar1 != '\\0');\n", "          errc(badflag);\n", "          errc(10);\n", "        }\n", "      }\n", "    }\n", "  }\n", "  c = 0x55;\n", "  pcVar5 = \"Usage: \";\n", "  do {\n", "    pcVar5 = pcVar5 + 1;\n", "    errc(c);\n", "    c = (int)*pcVar5;\n", "  } while (*pcVar5 != '\\0');\n", "  cVar1 = *cmdname;\n", "  pbVar7 = (byte *)flagarg;\n", "  pcVar5 = cmdname;\n", "  while (flagarg = (char *)pbVar7, cVar1 != '\\0') {\n", "    pcVar5 = pcVar5 + 1;\n", "    errc((int)cVar1);\n", "    cVar1 = *pcVar5;\n", "    pbVar7 = (byte *)flagarg;\n", "  }\n", "  c = 0;\n", "  uVar6 = (ulong)*pbVar7;\n", "LAB_00406ac0:\n", "  bVar4 = (byte)uVar6;\n", "  pbVar3 = pbVar7;\n", "  do {\n", "    if (bVar4 == 0) {\n", "      if (c != 0) {\n", "        errc(0x5d);\n", "      }\n", "      uVar6 = (ulong)(byte)*flagarg;\n", "      pbVar7 = (byte *)flagarg;\n", "      break;\n", "    }\n", "    pbVar7 = pbVar3 + 1;\n", "    if ((char)uVar6 == ' ') {\n", "      uVar6 = (ulong)pbVar3[1];\n", "      goto LAB_00406ac0;\n", "    }\n", "    if (pbVar3[1] == 0x3a) {\n", "      uVar2 = SEXT14((char)pbVar3[2]);\n", "      pbVar7 = pbVar3 + 2;\n", "      if (9 < (byte)(pbVar3[2] - 0x30)) goto LAB_00406adf;\n", "      c_00 = 0;\n", "      do {\n", "        pbVar7 = pbVar7 + 1;\n", "        c_00 = (uVar2 - 0x30) + c_00 * 10;\n", "        uVar2 = SEXT14((char)*pbVar7);\n", "      } while ((byte)(*pbVar7 - 0x30) < 10);\n", "      if (c_00 == 0) goto LAB_00406adf;\n", "      uVar6 = (ulong)uVar2;\n", "    }\n", "    else {\n", "LAB_00406adf:\n", "      if (c == 0) {\n", "        c_00 = 0x20;\n", "        pcVar5 = \" [-\";\n", "        do {\n", "          pcVar5 = pcVar5 + 1;\n", "          errc(c_00);\n", "          c_00 = (int)*pcVar5;\n", "        } while (*pcVar5 != '\\0');\n", "      }\n", "      c = c + 1;\n", "      errc((int)(char)uVar6);\n", "      uVar6 = (ulong)*pbVar7;\n", "    }\n", "    if ((char)uVar6 != '[') goto LAB_00406ac0;\n", "    bVar4 = pbVar7[1];\n", "    pbVar3 = pbVar7 + 1;\n", "    while ((bVar4 != 0 && (bVar4 != 0x5d))) {\n", "      pbVar3 = pbVar3 + 1;\n", "      bVar4 = *pbVar3;\n", "    }\n", "    if (bVar4 == 0x5d) goto LAB_00406dee;\n", "    bVar4 = *pbVar3;\n", "    uVar6 = (ulong)bVar4;\n", "  } while( true );\n", "LAB_00406b70:\n", "  bVar4 = (byte)uVar6;\n", "  pbVar3 = pbVar7;\n", "  do {\n", "    if (bVar4 == 0) {\n", "      if (tail != (char *)0x0) {\n", "        errc(0x20);\n", "        cVar1 = *tail;\n", "        while (cVar1 != '\\0') {\n", "          tail = tail + 1;\n", "          errc((int)cVar1);\n", "          cVar1 = *tail;\n", "        }\n", "      }\n", "      errc(10);\n", "      Exit(\"bad flags\");\n", "      return;\n", "    }\n", "    pbVar7 = pbVar3 + 1;\n", "    if ((char)uVar6 == ' ') {\n", "      uVar6 = (ulong)pbVar3[1];\n", "      goto LAB_00406b70;\n", "    }\n", "    uVar2 = (uint)pbVar3[1];\n", "    if (pbVar3[1] == 0x3a) {\n", "      uVar2 = SEXT14((char)pbVar3[2]);\n", "      pbVar7 = pbVar3 + 2;\n", "      if (9 < (byte)(pbVar3[2] - 0x30)) goto LAB_00406b8f;\n", "      c = 0;\n", "      do {\n", "        pbVar3 = pbVar7;\n", "        pbVar7 = pbVar3 + 1;\n", "        c = (uVar2 - 0x30) + c * 10;\n", "        uVar2 = SEXT14((char)*pbVar7);\n", "      } while ((byte)(*pbVar7 - 0x30) < 10);\n", "      if (c == 0) goto LAB_00406b8f;\n", "      cVar1 = ' ';\n", "      pcVar5 = \" [-\";\n", "      do {\n", "        pcVar5 = pcVar5 + 1;\n", "        errc((int)cVar1);\n", "        cVar1 = *pcVar5;\n", "      } while (cVar1 != '\\0');\n", "      errc((int)(char)uVar6);\n", "      if (*pbVar7 == 0x5b) {\n", "        pbVar8 = pbVar3 + 2;\n", "        if ((pbVar3[2] == 0) || (pbVar7 = pbVar8, pbVar3[2] == 0x5d)) {\n", "          errc(0x20);\n", "          pbVar7 = pbVar8 + (*pbVar8 == 0x5d);\n", "        }\n", "        else {\n", "          do {\n", "            pbVar7 = pbVar7 + 1;\n", "            if (*pbVar7 == 0) break;\n", "          } while (*pbVar7 != 0x5d);\n", "          c = (int)pbVar7 - (int)pbVar8;\n", "          errc(0x20);\n", "          if (c != 0) {\n", "            do {\n", "              pbVar8 = pbVar8 + 1;\n", "              errc((int)(char)*pbVar8);\n", "              pbVar8 = pbVar8;\n", "            } while (pbVar8 != pbVar3 + (ulong)(c - 1) + 3);\n", "          }\n", "          pbVar7 = pbVar7 + (*pbVar7 == 0x5d);\n", "        }\n", "        errc(0x5d);\n", "      }\n", "      else {\n", "        do {\n", "          cVar1 = ' ';\n", "          pcVar5 = \" arg\";\n", "          do {\n", "            pcVar5 = pcVar5 + 1;\n", "            errc((int)cVar1);\n", "            cVar1 = *pcVar5;\n", "          } while (cVar1 != '\\0');\n", "          c = c + -1;\n", "        } while (c != 0);\n", "        errc(0x5d);\n", "      }\n", "    }\n", "    else {\n", "LAB_00406b8f:\n", "      uVar6 = (ulong)uVar2;\n", "      if ((char)uVar2 != '[') goto LAB_00406b70;\n", "      bVar4 = pbVar7[1];\n", "      pbVar7 = pbVar7 + 1;\n", "      while ((bVar4 != 0 && (bVar4 != 0x5d))) {\n", "        pbVar7 = pbVar7 + 1;\n", "        bVar4 = *pbVar7;\n", "      }\n", "      if (bVar4 == 0x5d) break;\n", "    }\n", "    bVar4 = *pbVar7;\n", "    uVar6 = (ulong)bVar4;\n", "    pbVar3 = pbVar7;\n", "  } while( true );\n", "  uVar6 = (ulong)pbVar7[1];\n", "  pbVar7 = pbVar7 + 1;\n", "  goto LAB_00406b70;\n", "LAB_00406dee:\n", "  pbVar7 = pbVar3 + 1;\n", "  uVar6 = (ulong)pbVar3[1];\n", "  goto LAB_00406ac0;\n", "}\n", "\n"], "c": ["void\n", "usage(char *tail)\n", "{\n", "\tchar *s, *t, c;\n", "\tint count, nflag = 0;\n", "\tswitch(reason){\n", "\tcase RESET:\n", "\t\terrs(\"Flag -\");\n", "\t\terrc(badflag);\n", "\t\terrs(\": set twice\\n\");\n", "\t\tbreak;\n", "\tcase FEWARGS:\n", "\t\terrs(\"Flag -\");\n", "\t\terrc(badflag);\n", "\t\terrs(\": too few arguments\\n\");\n", "\t\tbreak;\n", "\tcase FLAGSYN:\n", "\t\terrs(\"Bad argument to getflags!\\n\");\n", "\t\tbreak;\n", "\tcase BADFLAG:\n", "\t\terrs(\"Illegal flag -\");\n", "\t\terrc(badflag);\n", "\t\terrc('\\n');\n", "\t\tbreak;\n", "\t}\n", "\terrs(\"Usage: \");\n", "\terrs(cmdname);\n", "\tfor(s = flagarg;*s;){\n", "\t\tc=*s;\n", "\t\tif(*s++==' ')\n", "\t\t\tcontinue;\n", "\t\tif(*s==':'){\n", "\t\t\ts++;\n", "\t\t\tcount = 0;\n", "\t\t\twhile('0'<=*s && *s<='9') count = count*10+*s++-'0';\n", "\t\t}\n", "\t\telse count = 0;\n", "\t\tif(count==0){\n", "\t\t\tif(nflag==0)\n", "\t\t\t\terrs(\" [-\");\n", "\t\t\tnflag++;\n", "\t\t\terrc(c);\n", "\t\t}\n", "\t\tif(*s=='['){\n", "\t\t\ts++;\n", "\t\t\twhile(*s!=']' && *s!='\\0') s++;\n", "\t\t\tif(*s==']')\n", "\t\t\t\ts++;\n", "\t\t}\n", "\t}\n", "\tif(nflag)\n", "\t\terrs(\"]\");\n", "\tfor(s = flagarg;*s;){\n", "\t\tc=*s;\n", "\t\tif(*s++==' ')\n", "\t\t\tcontinue;\n", "\t\tif(*s==':'){\n", "\t\t\ts++;\n", "\t\t\tcount = 0;\n", "\t\t\twhile('0'<=*s && *s<='9') count = count*10+*s++-'0';\n", "\t\t}\n", "\t\telse count = 0;\n", "\t\tif(count!=0){\n", "\t\t\terrs(\" [-\");\n", "\t\t\terrc(c);\n", "\t\t\tif(*s=='['){\n", "\t\t\t\ts++;\n", "\t\t\t\tt = s;\n", "\t\t\t\twhile(*s!=']' && *s!='\\0') s++;\n", "\t\t\t\terrs(\" \");\n", "\t\t\t\terrn(t, s-t);\n", "\t\t\t\tif(*s==']')\n", "\t\t\t\t\ts++;\n", "\t\t\t}\n", "\t\t\telse\n", "\t\t\t\twhile(count--) errs(\" arg\");\n", "\t\t\terrs(\"]\");\n", "\t\t}\n", "\t\telse if(*s=='['){\n", "\t\t\ts++;\n", "\t\t\twhile(*s!=']' && *s!='\\0') s++;\n", "\t\t\tif(*s==']')\n", "\t\t\t\ts++;\n", "\t\t}\n", "\t}\n", "\tif(tail){\n", "\t\terrs(\" \");\n", "\t\terrs(tail);\n", "\t}\n", "\terrs(\"\\n\");\n", "\tExit(\"bad flags\");\n", "}"]}, {"ghidra": ["\n", "void execeval(void)\n", "\n", "{\n", "  char *pcVar1;\n", "  char cVar2;\n", "  int len;\n", "  size_t sVar3;\n", "  char *s;\n", "  io *f;\n", "  char *pcVar4;\n", "  word *pwVar5;\n", "  long n;\n", "  \n", "  len = count(runq->argv->words);\n", "  if (len < 2) {\n", "    Xerror1(\"Usage: eval cmd ...\");\n", "    return;\n", "  }\n", "  eflagok = 1;\n", "  pwVar5 = runq->argv->words->next;\n", "  if (pwVar5 == (word *)0x0) {\n", "    n = 0;\n", "    len = 0;\n", "  }\n", "  else {\n", "    len = 0;\n", "    do {\n", "      sVar3 = strlen(pwVar5->word);\n", "      pwVar5 = pwVar5->next;\n", "      len = len + 1 + (int)sVar3;\n", "    } while (pwVar5 != (word *)0x0);\n", "    n = (long)len;\n", "  }\n", "  s = emalloc(n);\n", "  pwVar5 = runq->argv->words->next;\n", "  pcVar1 = s;\n", "  while (pwVar5 != (word *)0x0) {\n", "    pcVar4 = pwVar5->word;\n", "    cVar2 = *pcVar4;\n", "    while (cVar2 != '\\0') {\n", "      pcVar4 = pcVar4 + 1;\n", "      *pcVar1 = cVar2;\n", "      cVar2 = *pcVar4;\n", "      pcVar1 = pcVar1 + 1;\n", "    }\n", "    *pcVar1 = ' ';\n", "    pwVar5 = pwVar5->next;\n", "    pcVar1 = pcVar1 + 1;\n", "  }\n", "  pcVar1[-1] = '\\n';\n", "  poplist();\n", "  f = opencore(s,len);\n", "  execcmds(f);\n", "  efree(s);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "execeval(void)\n", "{\n", "\tchar *cmdline, *s, *t;\n", "\tint len = 0;\n", "\tword *ap;\n", "\tif(count(runq->argv->words)<=1){\n", "\t\tXerror1(\"Usage: eval cmd ...\");\n", "\t\treturn;\n", "\t}\n", "\teflagok = 1;\n", "\tfor(ap = runq->argv->words->next;ap;ap = ap->next)\n", "\t\tlen+=1+strlen(ap->word);\n", "\tcmdline = emalloc(len);\n", "\ts = cmdline;\n", "\tfor(ap = runq->argv->words->next;ap;ap = ap->next){\n", "\t\tfor(t = ap->word;*t;) *s++=*t++;\n", "\t\t*s++=' ';\n", "\t}\n", "\ts[-1]='\\n';\n", "\tpoplist();\n", "\texeccmds(opencore(cmdline, len));\n", "\tefree(cmdline);\n", "}"]}, {"ghidra": ["\n", "void Noerror(void)\n", "\n", "{\n", "  interrupted = 0;\n", "  return;\n", "}\n", "\n"], "c": ["void Noerror(void){\n", "\tinterrupted=0;\n", "}"]}, {"ghidra": ["\n", "int matchfn(char *s,char *p)\n", "\n", "{\n", "  int iVar1;\n", "  \n", "  if ((*s == '.') && (((s[1] == '\\0' || ((s[1] == '.' && (s[2] == '\\0')))) && (*p != '.')))) {\n", "    return 0;\n", "  }\n", "  iVar1 = match(s,p,0x2f);\n", "  return iVar1;\n", "}\n", "\n"], "c": ["int\n", "matchfn(char *s, char *p)\n", "{\n", "\tif(s[0]=='.' && (s[1]=='\\0' || s[1]=='.' && s[2]=='\\0') && p[0]!='.')\n", "\t\treturn 0;\n", "\treturn match(s, p, '/');\n", "}"]}, {"ghidra": ["\n", "int yylex(void)\n", "\n", "{\n", "  int c;\n", "  int iVar1;\n", "  char *p;\n", "  tree *ptVar2;\n", "  char *pcVar3;\n", "  char *p_00;\n", "  bool bVar4;\n", "  bool bVar5;\n", "  \n", "  if (future == -1) {\n", "    future = getnext();\n", "  }\n", "  c = future;\n", "  yylval = (tree *)0x0;\n", "  if (lastword != 0) {\n", "    lastword = 0;\n", "    if (future == 0x28) {\n", "      advance();\n", "      tok._0_8_ = 0x5d4255535b2028;\n", "      return 0xe010;\n", "    }\n", "    p = strchr(\"\\n \\t#;&|^$=`\\'{}()<>\",future);\n", "    if ((((p == (char *)0x0) && (c != -1)) || (c == 0x27)) ||\n", "       ((c == 0x60 || ((c - 0x22U & 0xfffffffd) == 0)))) {\n", "      tok._0_8_ = CONCAT62(tok._2_6_,0x5e);\n", "      return 0x5e;\n", "    }\n", "  }\n", "  inquote = 0;\n", "  skipwhite();\n", "  c = advance();\n", "  if (c == 0x27) {\n", "    lastdol = 0;\n", "    lastword = 1;\n", "    p = tok;\n", "    inquote = 1;\n", "    while (c = advance(), c != -1) {\n", "      if (c == 0x27) {\n", "        if (future == -1) {\n", "          future = getnext();\n", "        }\n", "        if (future != 0x27) break;\n", "        advance();\n", "      }\n", "      p = addutf(p,c);\n", "    }\n", "    if (p != (char *)0x0) {\n", "      *p = '\\0';\n", "    }\n", "    yylval = token(tok,0xe00c);\n", "    yylval->quoted = 1;\n", "    return yylval->type;\n", "  }\n", "  if (c < 0x28) {\n", "    if (c == 0x24) {\n", "      lastdol = 1;\n", "      c = nextis(0x23);\n", "      if (c != 0) {\n", "        tok._0_8_ = CONCAT62((uint6)(tok._0_8_ >> 0x10) & 0xffffffffff00,0x2324);\n", "        return 0xe01a;\n", "      }\n", "      c = nextis(0x22);\n", "      if (c != 0) {\n", "        tok._0_8_ = CONCAT62(tok._2_6_ & 0xffffffffff00,0x2224);\n", "        return 0x22;\n", "      }\n", "      tok._0_8_ = CONCAT62(tok._2_6_,0x24);\n", "      return 0x24;\n", "    }\n", "    if (c == 0x26) {\n", "      lastdol = 0;\n", "      c = nextis(0x26);\n", "      if (c != 0) {\n", "        skipnl();\n", "        tok._0_8_ = CONCAT62((uint6)(tok._0_8_ >> 0x10) & 0xffffffffff00,0x2626);\n", "        return 0xe018;\n", "      }\n", "      tok._0_8_ = CONCAT62(tok._2_6_,0x26);\n", "      return 0x26;\n", "    }\n", "    if (c == -1) {\n", "      tok._0_8_ = CONCAT44(tok._4_4_,0x464f45);\n", "      lastdol = 0;\n", "      return -1;\n", "    }\n", "LAB_00408d51:\n", "    p = strchr(\"\\n \\t#;&|^$=`\\'{}()<>\",c);\n", "    bVar4 = c != -1;\n", "    if (p == (char *)0x0 && bVar4) {\n", "      p_00 = tok;\n", "      while( true ) {\n", "        if ((((c == 0x2a) || (c == 0x5b)) || ((c == 0x3f || (c == 1)))) && (p_00 != (char *)0x0)) {\n", "          if (p_00 == tok + 0x1fff) {\n", "            tok[8191] = '\\0';\n", "            p_00 = (char *)0x0;\n", "            yyerror(\"token buffer too short\");\n", "          }\n", "          else {\n", "            *p_00 = '\\x01';\n", "            p_00 = p_00 + 1;\n", "          }\n", "        }\n", "        p_00 = addutf(p_00,c);\n", "        if (future == -1) {\n", "          future = getnext();\n", "        }\n", "        c = future;\n", "        if (lastdol == 0) {\n", "          pcVar3 = strchr(\"\\n \\t#;&|^$=`\\'{}()<>\",future);\n", "          bVar5 = c == -1 || pcVar3 != (char *)0x0;\n", "        }\n", "        else {\n", "          bVar5 = p == (char *)0x0 && bVar4;\n", "          if (0x20 < future) {\n", "            pcVar3 = strchr(\"!\\\"#$%&\\'()+,-./:;<=>?@[\\\\]^`{|}~\",future);\n", "            bVar5 = pcVar3 != (char *)0x0;\n", "          }\n", "        }\n", "        if (bVar5) break;\n", "        advance();\n", "      }\n", "      lastword = 1;\n", "      lastdol = 0;\n", "      if (p_00 != (char *)0x0) {\n", "        *p_00 = '\\0';\n", "      }\n", "      yylval = klook(tok);\n", "      if (yylval->type != 0xe00c) {\n", "        lastword = 0;\n", "      }\n", "      yylval->quoted = 0;\n", "      return yylval->type;\n", "    }\n", "    tok._0_8_ = tok._0_8_ & 0xffffffffffff0000 | (ulong)(byte)c;\n", "    lastdol = 0;\n", "    return c;\n", "  }\n", "  if (c == 0x3e) {\n", "LAB_00408e20:\n", "    lastdol = 0;\n", "    tok._0_8_ = tok._0_8_ & 0xffffffffffffff00 | (ulong)(byte)c;\n", "    ptVar2 = newtree();\n", "    if (c == 0x3c) {\n", "      ptVar2->type = 0xe00d;\n", "      c = nextis(0x3c);\n", "      if (c == 0) {\n", "        c = nextis(0x3e);\n", "        if (c == 0) {\n", "          ptVar2->rtype = 3;\n", "          p = tok + 1;\n", "        }\n", "        else {\n", "          ptVar2->rtype = 7;\n", "          tok._0_2_ = CONCAT11(0x3c,tok[0]);\n", "          tok._0_8_ = tok._0_8_ & 0xffffffffffff0000 | (ulong)tok._0_2_;\n", "          p = tok + 2;\n", "        }\n", "      }\n", "      else {\n", "        ptVar2->rtype = 4;\n", "        tok._0_2_ = CONCAT11(0x3c,tok[0]);\n", "        tok._0_8_ = tok._0_8_ & 0xffffffffffff0000 | (ulong)tok._0_2_;\n", "        p = tok + 2;\n", "      }\n", "      ptVar2->fd0 = 0;\n", "    }\n", "    else {\n", "      p = tok + 1;\n", "      if (c == 0x3e) {\n", "        ptVar2->type = 0xe00d;\n", "        c = nextis(0x3e);\n", "        if (c == 0) {\n", "          ptVar2->rtype = 2;\n", "          p = tok + 1;\n", "        }\n", "        else {\n", "          ptVar2->rtype = 1;\n", "          tok._0_2_ = CONCAT11(0x3e,tok[0]);\n", "          tok._0_8_ = tok._0_8_ & 0xffffffffffff0000 | (ulong)tok._0_2_;\n", "          p = tok + 2;\n", "        }\n", "        ptVar2->fd0 = 1;\n", "      }\n", "    }\n", "  }\n", "  else {\n", "    if (c != 0x7c) {\n", "      if (c != 0x3c) goto LAB_00408d51;\n", "      goto LAB_00408e20;\n", "    }\n", "    lastdol = 0;\n", "    c = nextis(0x7c);\n", "    if (c != 0) {\n", "      skipnl();\n", "      tok._0_8_ = CONCAT62((uint6)(tok._0_8_ >> 0x10) & 0xffffffffff00,0x7c7c);\n", "      return 0xe019;\n", "    }\n", "    lastdol = 0;\n", "    tok._0_8_ = CONCAT71(tok._1_7_,0x7c);\n", "    p = tok + 1;\n", "    ptVar2 = newtree();\n", "    ptVar2->type = 0xe00f;\n", "    ptVar2->fd0 = 1;\n", "    ptVar2->fd1 = 0;\n", "  }\n", "  c = nextis(0x5b);\n", "  if (c == 0) {\n", "LAB_00408cd3:\n", "    *p = '\\0';\n", "    c = ptVar2->type;\n", "    yylval = ptVar2;\n", "    if (c == 0xe00f) {\n", "      skipnl();\n", "      c = ptVar2->type;\n", "    }\n", "  }\n", "  else {\n", "    *p = '[';\n", "    p_00 = p + 2;\n", "    iVar1 = advance();\n", "    p[1] = (char)iVar1;\n", "    c = 0;\n", "    p = p_00;\n", "    if (iVar1 - 0x30U < 10) {\n", "      while( true ) {\n", "        p_00 = p + 1;\n", "        ptVar2->fd0 = iVar1 + -0x30 + c * 10;\n", "        *p = (char)iVar1;\n", "        iVar1 = advance();\n", "        if (9 < iVar1 - 0x30U) break;\n", "        c = ptVar2->fd0;\n", "        p = p_00;\n", "      }\n", "      if (iVar1 == 0x3d) {\n", "        p[1] = '=';\n", "        p_00 = p + 2;\n", "        if (ptVar2->type == 0xe00d) {\n", "          ptVar2->type = 0xe00e;\n", "        }\n", "        iVar1 = advance();\n", "        if (iVar1 - 0x30U < 10) {\n", "          ptVar2->rtype = 5;\n", "          ptVar2->fd1 = ptVar2->fd0;\n", "          c = 0;\n", "          p = p_00;\n", "          while( true ) {\n", "            p_00 = p + 1;\n", "            ptVar2->fd0 = iVar1 + -0x30 + c * 10;\n", "            *p = (char)iVar1;\n", "            iVar1 = advance();\n", "            if (9 < iVar1 - 0x30U) break;\n", "            c = ptVar2->fd0;\n", "            p = p_00;\n", "          }\n", "        }\n", "        else {\n", "          if (ptVar2->type == 0xe00f) goto RedirErr;\n", "          ptVar2->rtype = 6;\n", "        }\n", "      }\n", "      if ((iVar1 == 0x5d) &&\n", "         ((ptVar2->type != 0xe00e || ((ptVar2->rtype != 1 && (ptVar2->rtype != 4)))))) {\n", "        p = p_00 + 1;\n", "        *p_00 = ']';\n", "        goto LAB_00408cd3;\n", "      }\n", "    }\n", "RedirErr:\n", "    *p_00 = '\\0';\n", "    p = \"redirection syntax\";\n", "    if (ptVar2->type == 0xe00f) {\n", "      p = \"pipe syntax\";\n", "    }\n", "    yyerror(p);\n", "    c = -1;\n", "  }\n", "  return c;\n", "}\n", "\n"], "c": ["int\n", "yylex(void)\n", "{\n", "\tint c, d = nextc();\n", "\tchar *w = tok;\n", "\tstruct tree *t;\n", "\tyylval.tree = 0;\n", "\t/*\n", "\t * Embarassing sneakiness:  if the last token read was a quoted or unquoted\n", "\t * WORD then we alter the meaning of what follows.  If the next character\n", "\t * is `(', we return SUB (a subscript paren) and consume the `('.  Otherwise,\n", "\t * if the next character is the first character of a simple or compound word,\n", "\t * we insert a `^' before it.\n", "\t */\n", "\tif(lastword){\n", "\t\tlastword = 0;\n", "\t\tif(d=='('){\n", "\t\t\tadvance();\n", "\t\t\tstrcpy(tok, \"( [SUB]\");\n", "\t\t\treturn SUB;\n", "\t\t}\n", "\t\tif(wordchr(d) || d=='\\'' || d=='`' || d=='$' || d=='\"'){\n", "\t\t\tstrcpy(tok, \"^\");\n", "\t\t\treturn '^';\n", "\t\t}\n", "\t}\n", "\tinquote = 0;\n", "\tskipwhite();\n", "\tswitch(c = advance()){\n", "\tcase EOF:\n", "\t\tlastdol = 0;\n", "\t\tstrcpy(tok, \"EOF\");\n", "\t\treturn EOF;\n", "\tcase '$':\n", "\t\tlastdol = 1;\n", "\t\tif(nextis('#')){\n", "\t\t\tstrcpy(tok, \"$#\");\n", "\t\t\treturn COUNT;\n", "\t\t}\n", "\t\tif(nextis('\"')){\n", "\t\t\tstrcpy(tok, \"$\\\"\");\n", "\t\t\treturn '\"';\n", "\t\t}\n", "\t\tstrcpy(tok, \"$\");\n", "\t\treturn '$';\n", "\tcase '&':\n", "\t\tlastdol = 0;\n", "\t\tif(nextis('&')){\n", "\t\t\tskipnl();\n", "\t\t\tstrcpy(tok, \"&&\");\n", "\t\t\treturn ANDAND;\n", "\t\t}\n", "\t\tstrcpy(tok, \"&\");\n", "\t\treturn '&';\n", "\tcase '|':\n", "\t\tlastdol = 0;\n", "\t\tif(nextis(c)){\n", "\t\t\tskipnl();\n", "\t\t\tstrcpy(tok, \"||\");\n", "\t\t\treturn OROR;\n", "\t\t}\n", "\tcase '<':\n", "\tcase '>':\n", "\t\tlastdol = 0;\n", "\t\t/*\n", "\t\t * funny redirection tokens:\n", "\t\t *\tredir:\tarrow | arrow '[' fd ']'\n", "\t\t *\tarrow:\t'<' | '<<' | '>' | '>>' | '|'\n", "\t\t *\tfd:\tdigit | digit '=' | digit '=' digit\n", "\t\t *\tdigit:\t'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'\n", "\t\t * some possibilities are nonsensical and get a message.\n", "\t\t */\n", "\t\t*w++=c;\n", "\t\tt = newtree();\n", "\t\tswitch(c){\n", "\t\tcase '|':\n", "\t\t\tt->type = PIPE;\n", "\t\t\tt->fd0 = 1;\n", "\t\t\tt->fd1 = 0;\n", "\t\t\tbreak;\n", "\t\tcase '>':\n", "\t\t\tt->type = REDIR;\n", "\t\t\tif(nextis(c)){\n", "\t\t\t\tt->rtype = APPEND;\n", "\t\t\t\t*w++=c;\n", "\t\t\t}\n", "\t\t\telse t->rtype = WRITE;\n", "\t\t\tt->fd0 = 1;\n", "\t\t\tbreak;\n", "\t\tcase '<':\n", "\t\t\tt->type = REDIR;\n", "\t\t\tif(nextis(c)){\n", "\t\t\t\tt->rtype = HERE;\n", "\t\t\t\t*w++=c;\n", "\t\t\t} else if (nextis('>')){\n", "\t\t\t\tt->rtype = RDWR;\n", "\t\t\t\t*w++=c;\n", "\t\t\t} else t->rtype = READ;\n", "\t\t\tt->fd0 = 0;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tif(nextis('[')){\n", "\t\t\t*w++='[';\n", "\t\t\tc = advance();\n", "\t\t\t*w++=c;\n", "\t\t\tif(c<'0' || '9'<c){\n", "\t\t\tRedirErr:\n", "\t\t\t\t*w = 0;\n", "\t\t\t\tyyerror(t->type==PIPE?\"pipe syntax\"\n", "\t\t\t\t\t\t:\"redirection syntax\");\n", "\t\t\t\treturn EOF;\n", "\t\t\t}\n", "\t\t\tt->fd0 = 0;\n", "\t\t\tdo{\n", "\t\t\t\tt->fd0 = t->fd0*10+c-'0';\n", "\t\t\t\t*w++=c;\n", "\t\t\t\tc = advance();\n", "\t\t\t}while('0'<=c && c<='9');\n", "\t\t\tif(c=='='){\n", "\t\t\t\t*w++='=';\n", "\t\t\t\tif(t->type==REDIR)\n", "\t\t\t\t\tt->type = DUP;\n", "\t\t\t\tc = advance();\n", "\t\t\t\tif('0'<=c && c<='9'){\n", "\t\t\t\t\tt->rtype = DUPFD;\n", "\t\t\t\t\tt->fd1 = t->fd0;\n", "\t\t\t\t\tt->fd0 = 0;\n", "\t\t\t\t\tdo{\n", "\t\t\t\t\t\tt->fd0 = t->fd0*10+c-'0';\n", "\t\t\t\t\t\t*w++=c;\n", "\t\t\t\t\t\tc = advance();\n", "\t\t\t\t\t}while('0'<=c && c<='9');\n", "\t\t\t\t}\n", "\t\t\t\telse{\n", "\t\t\t\t\tif(t->type==PIPE)\n", "\t\t\t\t\t\tgoto RedirErr;\n", "\t\t\t\t\tt->rtype = CLOSE;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif(c!=']'\n", "\t\t\t|| t->type==DUP && (t->rtype==HERE || t->rtype==APPEND))\n", "\t\t\t\tgoto RedirErr;\n", "\t\t\t*w++=']';\n", "\t\t}\n", "\t\t*w='\\0';\n", "\t\tyylval.tree = t;\n", "\t\tif(t->type==PIPE)\n", "\t\t\tskipnl();\n", "\t\treturn t->type;\n", "\tcase '\\'':\n", "\t\tlastdol = 0;\n", "\t\tlastword = 1;\n", "\t\tinquote = 1;\n", "\t\tfor(;;){\n", "\t\t\tc = advance();\n", "\t\t\tif(c==EOF)\n", "\t\t\t\tbreak;\n", "\t\t\tif(c=='\\''){\n", "\t\t\t\tif(nextc()!='\\'')\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tadvance();\n", "\t\t\t}\n", "\t\t\tw = addutf(w, c);\n", "\t\t}\n", "\t\tif(w!=0)\n", "\t\t\t*w='\\0';\n", "\t\tt = token(tok, WORD);\n", "\t\tt->quoted = 1;\n", "\t\tyylval.tree = t;\n", "\t\treturn t->type;\n", "\t}\n", "\tif(!wordchr(c)){\n", "\t\tlastdol = 0;\n", "\t\ttok[0] = c;\n", "\t\ttok[1]='\\0';\n", "\t\treturn c;\n", "\t}\n", "\tfor(;;){\n", "\t\t/* next line should have (char)c==GLOB, but ken's compiler is broken */\n", "\t\tif(c=='*' || c=='[' || c=='?' || c==(unsigned char)GLOB)\n", "\t\t\tw = addtok(w, GLOB);\n", "\t\tw = addutf(w, c);\n", "\t\tc = nextc();\n", "\t\tif(lastdol?!idchr(c):!wordchr(c)) break;\n", "\t\tadvance();\n", "\t}\n", "\n", "\tlastword = 1;\n", "\tlastdol = 0;\n", "\tif(w!=0)\n", "\t\t*w='\\0';\n", "\tt = klook(tok);\n", "\tif(t->type!=WORD)\n", "\t\tlastword = 0;\n", "\tt->quoted = 0;\n", "\tyylval.tree = t;\n", "\treturn t->type;\n", "}"]}, {"ghidra": ["\n", "int canqlock(QLock *l)\n", "\n", "{\n", "  anon_subr_int_QLock_ptr_int_ulong *paVar1;\n", "  int iVar2;\n", "  ulong uVar3;\n", "  QLock *local_10;\n", "  \n", "  paVar1 = _qlock;\n", "  if (_qlock == (anon_subr_int_QLock_ptr_int_ulong *)0x0) {\n", "    iVar2 = 0;\n", "    if ((l->l).held == 0) {\n", "      (l->l).held = 1;\n", "      return 1;\n", "    }\n", "  }\n", "  else {\n", "    local_10 = l;\n", "    uVar3 = getcallerpc(&local_10);\n", "    iVar2 = (*paVar1)(local_10,0,uVar3);\n", "  }\n", "  return iVar2;\n", "}\n", "\n"], "c": ["int\n", "canqlock(QLock *l)\n", "{\n", "\tif(_qlock)\n", "\t\treturn (*_qlock)(l, 0, getcallerpc(&l));\n", "\telse{\n", "\t\tif(l->l.held)\n", "\t\t\treturn 0;\n", "\t\tl->l.held = 1;\n", "\t\treturn 1;\n", "\t}\n", "}"]}, {"ghidra": ["\n", "int _p9strsig(char *s)\n", "\n", "{\n", "  int iVar1;\n", "  int iVar2;\n", "  char **ppcVar3;\n", "  \n", "  ppcVar3 = &tab[0].str;\n", "  iVar2 = 0;\n", "  do {\n", "    iVar1 = strcmp(s,*ppcVar3);\n", "    if (iVar1 == 0) {\n", "      return tab[iVar2].sig;\n", "    }\n", "    iVar2 = iVar2 + 1;\n", "    ppcVar3 = ppcVar3 + 2;\n", "  } while (iVar2 != 0x1c);\n", "  return 0;\n", "}\n", "\n"], "c": ["int\n", "_p9strsig(char *s)\n", "{\n", "\tint i;\n", "\n", "\tfor(i=0; i<nelem(tab); i++)\n", "\t\tif(strcmp(s, tab[i].str) == 0)\n", "\t\t\treturn tab[i].sig;\n", "\treturn 0;\n", "}"]}, {"ghidra": ["\n", "void kinit(void)\n", "\n", "{\n", "  kenter(0xe002,\"for\");\n", "  kenter(0xe003,\"in\");\n", "  kenter(0xe004,\"while\");\n", "  kenter(0xe005,\"if\");\n", "  kenter(0xe006,\"not\");\n", "  kenter(0xe007,\"~\");\n", "  kenter(0xe008,\"!\");\n", "  kenter(0xe009,\"@\");\n", "  kenter(0xe00a,\"switch\");\n", "  kenter(0xe00b,\"fn\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "kinit(void)\n", "{\n", "\tkenter(FOR, \"for\");\n", "\tkenter(IN, \"in\");\n", "\tkenter(WHILE, \"while\");\n", "\tkenter(IF, \"if\");\n", "\tkenter(NOT, \"not\");\n", "\tkenter(TWIDDLE, \"~\");\n", "\tkenter(BANG, \"!\");\n", "\tkenter(SUBSHELL, \"@\");\n", "\tkenter(SWITCH, \"switch\");\n", "\tkenter(FN, \"fn\");\n", "}"]}, {"ghidra": ["\n", "void closeio(io *io)\n", "\n", "{\n", "  if (-1 < io->fd) {\n", "    close(io->fd);\n", "  }\n", "  if (io->strp != (char *)0x0) {\n", "    efree(io->strp);\n", "  }\n", "  efree((char *)io);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "closeio(io *io)\n", "{\n", "\tif(io->fd>=0)\n", "\t\tclose(io->fd);\n", "\tif(io->strp)\n", "\t\tefree(io->strp);\n", "\tefree((char *)io);\n", "}"]}, {"ghidra": ["\n", "void cleanup(EVP_PKEY_CTX *ctx)\n", "\n", "{\n", "  Client *pCVar1;\n", "  Client *pCVar2;\n", "  ulong uVar3;\n", "  Client *c;\n", "  Time TVar4;\n", "  int iVar5;\n", "  XWindowChanges *pXVar6;\n", "  long lVar7;\n", "  ScreenInfo *s;\n", "  Client *cc [2];\n", "  XWindowChanges wc;\n", "  \n", "  pXVar6 = (XWindowChanges *)cc;\n", "  cc[1] = (Client *)0x0;\n", "  cc[0] = (Client *)0x0;\n", "  c = clients;\n", "  if (clients != (Client *)0x0) {\n", "    do {\n", "      pCVar1 = c->next;\n", "      uVar3 = (ulong)(c->state == 1);\n", "      pCVar2 = cc[uVar3];\n", "      cc[uVar3] = c;\n", "      c->next = pCVar2;\n", "      c = pCVar1;\n", "    } while (pCVar1 != (Client *)0x0);\n", "  }\n", "  c = cc[0];\n", "  while( true ) {\n", "    while (c != (Client *)0x0) {\n", "      if (c->state != 0) {\n", "        gravitate(c,1);\n", "        XReparentWindow(dpy,c->window,c->screen->root,(ulong)(uint)c->x,(ulong)(uint)c->y);\n", "      }\n", "      wc.border_width = c->border;\n", "      XConfigureWindow(dpy,c->window,0x10);\n", "      c = c->next;\n", "    }\n", "    pXVar6 = (XWindowChanges *)&pXVar6->width;\n", "    if (pXVar6 == &wc) break;\n", "    c = *(Client **)pXVar6;\n", "  }\n", "  lVar7 = 0;\n", "  iVar5 = 0;\n", "  TVar4 = timestamp();\n", "  XSetInputFocus(dpy,1,1,TVar4);\n", "  if (0 < num_screens) {\n", "    do {\n", "      s = (ScreenInfo *)((long)&screens->num + lVar7);\n", "      iVar5 = iVar5 + 1;\n", "      lVar7 = lVar7 + 0x168;\n", "      cmapnofocus(s);\n", "    } while (iVar5 < num_screens);\n", "  }\n", "  XCloseDisplay(dpy);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "cleanup()\n", "{\n", "\tClient *c, *cc[2], *next;\n", "\tXWindowChanges wc;\n", "\tint i;\n", "\n", "\t/* order of un-reparenting determines final stacking order... */\n", "\tcc[0] = cc[1] = 0;\n", "\tfor (c = clients; c; c = next) {\n", "\t\tnext = c->next;\n", "\t\ti = normal(c);\n", "\t\tc->next = cc[i];\n", "\t\tcc[i] = c;\n", "\t}\n", "\n", "\tfor (i = 0; i < 2; i++) {\n", "\t\tfor (c = cc[i]; c; c = c->next) {\n", "\t\t\tif (!withdrawn(c)) {\n", "\t\t\t\tgravitate(c, 1);\n", "\t\t\t\tXReparentWindow(dpy, c->window, c->screen->root,\n", "\t\t\t\t\t\tc->x, c->y);\n", "\t\t\t}\n", "\t\t\twc.border_width = c->border;\n", "\t\t\tXConfigureWindow(dpy, c->window, CWBorderWidth, &wc);\n", "\t\t}\n", "\t}\n", "\n", "\tXSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, timestamp());\n", "\tfor (i = 0; i < num_screens; i++)\n", "\t\tcmapnofocus(&screens[i]);\n", "\tXCloseDisplay(dpy);\n", "}"]}, {"ghidra": ["\n", "Cursor getcursor(Cursordata *c,ScreenInfo *s)\n", "\n", "{\n", "  undefined8 uVar1;\n", "  undefined8 uVar2;\n", "  Cursor CVar3;\n", "  \n", "  uVar1 = XCreatePixmapFromBitmapData\n", "                    (dpy,s->root,c->fore,(ulong)(uint)c->width,(ulong)(uint)c->width,1,0,1);\n", "  uVar2 = XCreatePixmapFromBitmapData\n", "                    (dpy,s->root,c->mask,(ulong)(uint)c->width,(ulong)(uint)c->width,1,0,1);\n", "  CVar3 = XCreatePixmapCursor(dpy,uVar1,uVar2,&bl,&wh,(ulong)(uint)c->hot[0],(ulong)(uint)c->hot[1])\n", "  ;\n", "  return CVar3;\n", "}\n", "\n"], "c": ["Cursor\n", "getcursor(c, s)"]}, {"ghidra": ["\n", "void unhide(int n,int map)\n", "\n", "{\n", "  Client *c;\n", "  int iVar1;\n", "  int iVar2;\n", "  long lVar3;\n", "  int iVar4;\n", "  \n", "  if (numhidden <= n) {\n", "    fprintf(stderr,\"9wm: unhide: n %d numhidden %d\\n\",(ulong)(uint)n);\n", "    return;\n", "  }\n", "  c = hiddenc[(long)n];\n", "  if (c->state != 3) {\n", "    fprintf(stderr,\"9wm: unhide: not hidden: %s(0x%x)\\n\",c->label,c->window);\n", "    return;\n", "  }\n", "  iVar1 = numhidden;\n", "  if (map != 0) {\n", "    XMapWindow(dpy,c->window);\n", "    XMapRaised(dpy,c->parent);\n", "    setwinstate(c,1);\n", "    active(c);\n", "    top(c);\n", "    iVar1 = numhidden;\n", "  }\n", "  iVar4 = iVar1 + -1;\n", "  lVar3 = (long)n;\n", "  numhidden = iVar4;\n", "  if (n < iVar4) {\n", "    do {\n", "      iVar2 = n + 1;\n", "      hiddenc[lVar3] = hiddenc[(long)iVar2];\n", "      b3items[n + 5] = b3items[n + 6];\n", "      lVar3 = (long)iVar2;\n", "      n = iVar2;\n", "    } while (iVar2 != iVar4);\n", "  }\n", "  b3items[iVar1 + 4] = (char *)0x0;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "unhide(n, map)"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "Time timestamp(void)\n", "\n", "{\n", "  XEvent ev;\n", "  \n", "  if (curtime != 0) {\n", "    return (long)curtime;\n", "  }\n", "  XChangeProperty(dpy,screens->root,_9wm_running,_9wm_running,8,2,0x40724f,0);\n", "  XMaskEvent(dpy,0x400000,ev);\n", "  curtime = ev._48_4_;\n", "  return (long)ev._48_4_;\n", "}\n", "\n"], "c": ["Time\n", "timestamp()\n", "{\n", "\tXEvent ev;\n", "\n", "\tif (curtime == CurrentTime) {\n", "\t\tXChangeProperty(dpy, screens[0].root, _9wm_running, _9wm_running, 8,\n", "\t\t\t\tPropModeAppend, (unsigned char *)\"\", 0);\n", "\t\tXMaskEvent(dpy, PropertyChangeMask, &ev);\n", "\t\tcurtime = ev.xproperty.time;\n", "\t}\n", "\treturn curtime;\n", "}"]}, {"ghidra": ["\n", "void graberror(char *f,int err)\n", "\n", "{\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "graberror(f, err)"]}, {"ghidra": ["\n", "void nofocus(void)\n", "\n", "{\n", "  Client *c;\n", "  Window w;\n", "  Time TVar1;\n", "  XSetWindowAttributes attr;\n", "  \n", "  if (current != (Client *)0x0) {\n", "    setactive(current,0);\n", "    c = current->revert;\n", "    while (c != (Client *)0x0) {\n", "      if (c->state == 1) {\n", "        active(c);\n", "        return;\n", "      }\n", "      c = c->revert;\n", "    }\n", "    cmapnofocus(current->screen);\n", "  }\n", "  current = (Client *)0x0;\n", "  if (w == 0) {\n", "    attr.override_redirect = 1;\n", "    w = XCreateWindow(dpy,screens->root,0,0,1,1,0,0,2,0,0x200,&attr);\n", "    XMapWindow(dpy,w);\n", "  }\n", "  TVar1 = timestamp();\n", "  XSetInputFocus(dpy,w,1,TVar1);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "nofocus()\n", "{\n", "\tstatic Window w = 0;\n", "\tint mask;\n", "\tXSetWindowAttributes attr;\n", "\tClient *c;\n", "\n", "\tif (current) {\n", "\t\tsetactive(current, 0);\n", "\t\tfor (c = current->revert; c; c = c->revert)\n", "\t\t\tif (normal(c)) {\n", "\t\t\t\tactive(c);\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\tcmapnofocus(current->screen);\n", "\t\t/* if no candidates to revert to, fall through */\n", "\t}\n", "\tcurrent = 0;\n", "\tif (w == 0) {\n", "\t\tmask = CWOverrideRedirect;\n", "\t\tattr.override_redirect = 1;\n", "\t\tw = XCreateWindow(dpy, screens[0].root, 0, 0, 1, 1, 0,\n", "\t\t\tCopyFromParent, InputOnly, CopyFromParent, mask, &attr);\n", "\t\tXMapWindow(dpy, w);\n", "\t}\n", "\tXSetInputFocus(dpy, w, RevertToPointerRoot, timestamp());\n", "}"]}, {"ghidra": ["\n", "void fatal(char *s)\n", "\n", "{\n", "  fwrite(\"9wm: \",1,5,stderr);\n", "  perror(s);\n", "  fputc(10,stderr);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(1);\n", "}\n", "\n"], "c": ["void\n", "fatal(s)"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  int i;\n", "  __sighandler_t p_Var1;\n", "  Time TVar2;\n", "  long lVar3;\n", "  int background;\n", "  int iVar4;\n", "  char **ppcVar5;\n", "  char *pcVar6;\n", "  char *pcVar7;\n", "  Atom a;\n", "  ScreenInfo *s;\n", "  char *pcVar8;\n", "  Window w;\n", "  long lVar9;\n", "  int iVar10;\n", "  bool bVar11;\n", "  bool bVar12;\n", "  char *local_40;\n", "  \n", "  background = 0;\n", "  bVar11 = argc == 1;\n", "  font = (XFontStruct *)0x0;\n", "  local_40 = (char *)0x0;\n", "  myargv = argv;\n", "  if (1 < argc) {\n", "    i = 1;\n", "LAB_0040215f:\n", "    do {\n", "      lVar9 = (long)i;\n", "      lVar3 = 0xb;\n", "      pcVar7 = argv[lVar9];\n", "      pcVar6 = pcVar7;\n", "      pcVar8 = \"-nostalgia\";\n", "      do {\n", "        if (lVar3 == 0) break;\n", "        lVar3 = lVar3 + -1;\n", "        bVar11 = *pcVar6 == *pcVar8;\n", "        pcVar6 = pcVar6 + 1;\n", "        pcVar8 = pcVar8 + 1;\n", "      } while (bVar11);\n", "      if (bVar11) {\n", "        nostalgia = nostalgia + 1;\n", "LAB_00402157:\n", "        i = i + 1;\n", "        bVar11 = argc == i;\n", "        if (argc <= i) break;\n", "        goto LAB_0040215f;\n", "      }\n", "      lVar3 = 6;\n", "      pcVar6 = pcVar7;\n", "      pcVar8 = \"-grey\";\n", "      do {\n", "        if (lVar3 == 0) break;\n", "        lVar3 = lVar3 + -1;\n", "        bVar11 = *pcVar6 == *pcVar8;\n", "        pcVar6 = pcVar6 + 1;\n", "        pcVar8 = pcVar8 + 1;\n", "      } while (bVar11);\n", "      if (bVar11) {\n", "        background = 1;\n", "        goto LAB_00402157;\n", "      }\n", "      lVar3 = 7;\n", "      pcVar6 = pcVar7;\n", "      pcVar8 = \"-debug\";\n", "      do {\n", "        if (lVar3 == 0) break;\n", "        lVar3 = lVar3 + -1;\n", "        bVar11 = *pcVar6 == *pcVar8;\n", "        pcVar6 = pcVar6 + 1;\n", "        pcVar8 = pcVar8 + 1;\n", "      } while (bVar11);\n", "      if (!bVar11) {\n", "        lVar3 = 6;\n", "        pcVar6 = pcVar7;\n", "        pcVar8 = \"-font\";\n", "        do {\n", "          if (lVar3 == 0) break;\n", "          lVar3 = lVar3 + -1;\n", "          bVar11 = *pcVar6 == *pcVar8;\n", "          pcVar6 = pcVar6 + 1;\n", "          pcVar8 = pcVar8 + 1;\n", "        } while (bVar11);\n", "        if (bVar11) {\n", "          iVar4 = i + 1;\n", "          bVar11 = argc == iVar4;\n", "          if (iVar4 < argc) {\n", "            local_40 = argv[lVar9 + 1];\n", "            i = iVar4;\n", "            goto LAB_00402157;\n", "          }\n", "        }\n", "        else {\n", "          lVar3 = 6;\n", "          pcVar6 = pcVar7;\n", "          pcVar8 = \"-term\";\n", "          do {\n", "            if (lVar3 == 0) break;\n", "            lVar3 = lVar3 + -1;\n", "            bVar11 = *pcVar6 == *pcVar8;\n", "            pcVar6 = pcVar6 + 1;\n", "            pcVar8 = pcVar8 + 1;\n", "          } while (bVar11);\n", "          if (bVar11) {\n", "            iVar4 = i + 1;\n", "            bVar11 = argc == iVar4;\n", "            if (iVar4 < argc) {\n", "              termprog = argv[lVar9 + 1];\n", "              i = iVar4;\n", "              goto LAB_00402157;\n", "            }\n", "          }\n", "        }\n", "        lVar3 = 9;\n", "        pcVar6 = pcVar7;\n", "        pcVar8 = \"-version\";\n", "        goto code_r0x0040252d;\n", "      }\n", "      i = i + 1;\n", "      debug = debug + 1;\n", "      bVar11 = argc == i;\n", "    } while (i < argc);\n", "  }\n", "LAB_004021b0:\n", "  bVar12 = false;\n", "  bVar11 = false;\n", "LAB_004021b5:\n", "  shell = getenv(\"SHELL\");\n", "  if (shell == (char *)0x0) {\n", "    shell = \"/bin/sh\";\n", "  }\n", "  dpy = (Display *)XOpenDisplay(0x40724f);\n", "  if (dpy == (Display *)0x0) {\n", "    fatal(\"can\\'t open display\");\n", "  }\n", "  initting = 1;\n", "  XSetErrorHandler(handler);\n", "  p_Var1 = signal(0xf,sighandler);\n", "  if (p_Var1 == (__sighandler_t)0x1) {\n", "    signal(0xf,(__sighandler_t)0x1);\n", "  }\n", "  p_Var1 = signal(2,sighandler);\n", "  if (p_Var1 == (__sighandler_t)0x1) {\n", "    signal(2,(__sighandler_t)0x1);\n", "  }\n", "  p_Var1 = signal(1,sighandler);\n", "  if (p_Var1 == (__sighandler_t)0x1) {\n", "    signal(1,(__sighandler_t)0x1);\n", "  }\n", "  exit_9wm = XInternAtom(dpy,\"9WM_EXIT\",0);\n", "  restart_9wm = XInternAtom(dpy,\"9WM_RESTART\",0);\n", "  curtime = -1;\n", "  if (bVar11) {\n", "    w = *(Window *)((long)*(int *)(dpy + 0xe0) * 0x80 + *(long *)(dpy + 0xe8) + 0x10);\n", "    a = exit_9wm;\n", "LAB_004026d5:\n", "    sendcmessage(w,a,0,1);\n", "    XSync(dpy,0);\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(0);\n", "  }\n", "  if (bVar12) {\n", "    w = *(Window *)((long)*(int *)(dpy + 0xe0) * 0x80 + *(long *)(dpy + 0xe8) + 0x10);\n", "    a = restart_9wm;\n", "    goto LAB_004026d5;\n", "  }\n", "  wm_state = XInternAtom(dpy,\"WM_STATE\",0);\n", "  wm_change_state = XInternAtom(dpy,\"WM_CHANGE_STATE\",0);\n", "  wm_protocols = XInternAtom(dpy,\"WM_PROTOCOLS\",0);\n", "  wm_delete = XInternAtom(dpy,\"WM_DELETE_WINDOW\",0);\n", "  wm_take_focus = XInternAtom(dpy,\"WM_TAKE_FOCUS\",0);\n", "  wm_colormaps = XInternAtom(dpy,\"WM_COLORMAP_WINDOWS\",0);\n", "  _9wm_running = XInternAtom(dpy,\"_9WM_RUNNING\",0);\n", "  _9wm_hold_mode = XInternAtom(dpy,\"_9WM_HOLD_MODE\",0);\n", "  if (local_40 == (char *)0x0) {\n", "LAB_004025fe:\n", "    if (font == (XFontStruct *)0x0) {\n", "      ppcVar5 = fontlist;\n", "      do {\n", "        if (*ppcVar5 == (char *)0x0) {\n", "          fwrite(\"9wm: warning: can\\'t find a font\\n\",1,0x20,stderr);\n", "          break;\n", "        }\n", "        ppcVar5 = ppcVar5 + 1;\n", "        font = (XFontStruct *)XLoadQueryFont(dpy);\n", "      } while (font == (XFontStruct *)0x0);\n", "    }\n", "  }\n", "  else {\n", "    font = (XFontStruct *)XLoadQueryFont(dpy);\n", "    if (font == (XFontStruct *)0x0) {\n", "      fprintf(stderr,\"9wm: warning: can\\'t load font %s\\n\",local_40);\n", "      goto LAB_004025fe;\n", "    }\n", "  }\n", "  if (nostalgia == 0) goto LAB_004023a6;\n", "  goto LAB_004025d5;\n", "  while( true ) {\n", "    lVar3 = lVar3 + -1;\n", "    bVar11 = *pcVar6 == *pcVar8;\n", "    pcVar6 = pcVar6 + 1;\n", "    pcVar8 = pcVar8 + 1;\n", "    if (!bVar11) break;\n", "code_r0x0040252d:\n", "    if (lVar3 == 0) break;\n", "  }\n", "  if (bVar11) {\n", "    fputs(version[0],stderr);\n", "    fputc(10,stderr);\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(0);\n", "  }\n", "  if (*pcVar7 != '-') {\n", "    if (argc <= i) goto LAB_004021b0;\n", "    ppcVar5 = argv + lVar9;\n", "    iVar10 = 0;\n", "    iVar4 = 0;\n", "    bVar11 = true;\n", "LAB_00402585:\n", "    do {\n", "      lVar3 = 5;\n", "      pcVar7 = *ppcVar5;\n", "      pcVar6 = \"exit\";\n", "      do {\n", "        if (lVar3 == 0) break;\n", "        lVar3 = lVar3 + -1;\n", "        bVar11 = *pcVar7 == *pcVar6;\n", "        pcVar7 = pcVar7 + 1;\n", "        pcVar6 = pcVar6 + 1;\n", "      } while (bVar11);\n", "      if (bVar11) {\n", "        ppcVar5 = ppcVar5 + 1;\n", "        iVar10 = iVar10 + 1;\n", "        bVar11 = ppcVar5 == argv + (ulong)(uint)((argc + -1) - i) + 1 + lVar9;\n", "        if (bVar11) break;\n", "        goto LAB_00402585;\n", "      }\n", "      lVar3 = 8;\n", "      pcVar7 = *ppcVar5;\n", "      pcVar6 = \"restart\";\n", "      do {\n", "        if (lVar3 == 0) break;\n", "        lVar3 = lVar3 + -1;\n", "        bVar11 = *pcVar7 == *pcVar6;\n", "        pcVar7 = pcVar7 + 1;\n", "        pcVar6 = pcVar6 + 1;\n", "      } while (bVar11);\n", "      if (!bVar11) goto LAB_004025ce;\n", "      ppcVar5 = ppcVar5 + 1;\n", "      iVar4 = iVar4 + 1;\n", "      bVar11 = ppcVar5 == argv + (ulong)(uint)((argc + -1) - i) + 1 + lVar9;\n", "    } while (!bVar11);\n", "    bVar11 = iVar10 != 0;\n", "    bVar12 = iVar4 != 0;\n", "    if ((bVar12) && (bVar11)) goto LAB_004025ce;\n", "    goto LAB_004021b5;\n", "  }\n", "LAB_004025ce:\n", "  usage();\n", "LAB_004025d5:\n", "  _border = _border + -1;\n", "  _inset = _inset + -1;\n", "LAB_004023a6:\n", "  i = *(int *)(dpy + 0xe4);\n", "  num_screens = i;\n", "  screens = (ScreenInfo *)malloc((long)i * 0x168);\n", "  if (0 < i) {\n", "    lVar3 = 0;\n", "    i = 0;\n", "    do {\n", "      s = (ScreenInfo *)((long)&screens->num + lVar3);\n", "      iVar4 = i + 1;\n", "      lVar3 = lVar3 + 0x168;\n", "      initscreen(s,i,background);\n", "      i = iVar4;\n", "    } while (iVar4 < num_screens);\n", "  }\n", "  curtime = 0;\n", "  lVar3 = 0;\n", "  TVar2 = timestamp();\n", "  background = 0;\n", "  XSetSelectionOwner(dpy,_9wm_running,screens->menuwin,TVar2);\n", "  XSync(dpy,0);\n", "  initting = 0;\n", "  nofocus();\n", "  if (0 < num_screens) {\n", "    do {\n", "      s = (ScreenInfo *)((long)&screens->num + lVar3);\n", "      background = background + 1;\n", "      lVar3 = lVar3 + 0x168;\n", "      scanwins(s);\n", "    } while (background < num_screens);\n", "  }\n", "  mainloop(0);\n", "  return 0;\n", "}\n", "\n"], "c": ["int\n", "main(argc, argv)"]}, {"ghidra": ["\n", "void sighandler(void)\n", "\n", "{\n", "  signalled = 1;\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "sighandler()\n", "{\n", "\tsignalled = 1;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "void mainloop(int shape_event)\n", "\n", "{\n", "  XEvent ev;\n", "  \n", "  do {\n", "    getevent((XEvent *)ev);\n", "    switch(ev._0_4_) {\n", "    case 4:\n", "      button((XButtonEvent *)ev);\n", "      break;\n", "    case 5:\n", "    case 6:\n", "    case 10:\n", "    case 0xc:\n", "    case 0x13:\n", "    case 0x16:\n", "    case 0x22:\n", "      break;\n", "    case 7:\n", "      curtime = (int)ev._56_8_;\n", "      if (ev._80_8_ == 0x400000001) {\n", "        enter((XCrossingEvent *)ev);\n", "      }\n", "      break;\n", "    default:\n", "      fprintf(stderr,\"9wm: unknown ev.type %d\\n\");\n", "      break;\n", "    case 9:\n", "      curtime = 0;\n", "      if (ev._44_4_ == 4) {\n", "        focusin((XFocusChangeEvent *)ev);\n", "      }\n", "      break;\n", "    case 0x10:\n", "      if (ev._68_4_ == 0) {\n", "        newwindow((XCreateWindowEvent *)ev);\n", "      }\n", "      break;\n", "    case 0x11:\n", "      destroy(CONCAT44(ev._44_4_,ev._40_4_));\n", "      break;\n", "    case 0x12:\n", "      unmap((XUnmapEvent *)ev);\n", "      break;\n", "    case 0x14:\n", "      mapreq((XMapRequestEvent *)ev);\n", "      break;\n", "    case 0x15:\n", "      reparent((XReparentEvent *)ev);\n", "      break;\n", "    case 0x17:\n", "      configurereq((XConfigureRequestEvent *)ev);\n", "      break;\n", "    case 0x1b:\n", "      fwrite(\"It must be the warlock Krill!\\n\",1,0x1e,stderr);\n", "      break;\n", "    case 0x1c:\n", "      property((XPropertyEvent *)ev);\n", "      break;\n", "    case 0x1d:\n", "      fwrite(\"9wm: SelectionClear (this should not happen)\\n\",1,0x2d,stderr);\n", "      break;\n", "    case 0x1e:\n", "      fwrite(\"9wm: SelectionRequest (this should not happen)\\n\",1,0x2f,stderr);\n", "      break;\n", "    case 0x1f:\n", "      fwrite(\"9wm: SelectionNotify (this should not happen)\\n\",1,0x2e,stderr);\n", "      break;\n", "    case 0x20:\n", "      cmap((XColormapEvent *)ev);\n", "      break;\n", "    case 0x21:\n", "      clientmesg((XClientMessageEvent *)ev);\n", "    }\n", "  } while( true );\n", "}\n", "\n"], "c": ["void\n", "mainloop(shape_event)"]}, {"ghidra": ["\n", "void misleep(int msec)\n", "\n", "{\n", "  timeval t;\n", "  \n", "  t.tv_sec = (__time_t)(msec / 1000);\n", "  t.tv_usec = (__suseconds_t)((msec % 1000) * 1000);\n", "  select(0,(fd_set *)0x0,(fd_set *)0x0,(fd_set *)0x0,(timeval *)&t);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "misleep(msec)"]}, {"ghidra": ["\n", "void usage(void)\n", "\n", "{\n", "  fwrite(\"usage: 9wm [-grey] [-version] [-font fname] [-term prog] [exit|restart]\\n\",1,0x48,stderr);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(1);\n", "}\n", "\n"], "c": ["void\n", "usage()\n", "{\n", "\tfprintf(stderr, \"usage: 9wm [-grey] [-version] [-font fname] [-term prog] [exit|restart]\\n\");\n", "\texit(1);\n", "}"]}, {"ghidra": ["\n", "void arp_cache_alrm(int sig)\n", "\n", "{\n", "  arp_cache_mgr('\\x01',pkt_d);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "arp_cache_alrm(int sig)\n", "{\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: arp_cache_alrm(%d)\\n\", sig);\n", "#endif\n", "\n", "//    pthread_mutex_lock(&conn_mutex);\n", "    arp_cache_mgr(1, pkt_d);\n", "//    pthread_mutex_unlock(&conn_mutex);\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "void injection_stats(void)\n", "\n", "{\n", "  fputc(10,stdout);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "injection_stats()\n", "{\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "void clean_exit(int sig)\n", "\n", "{\n", "  fwrite(&DAT_0040475f,1,2,stdout);\n", "  arp_cache_mgr('\\0',pkt_d);\n", "  capture_stats();\n", "  pcap_close(pkt);\n", "  fputc(10,stdout);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(1);\n", "}\n", "\n"], "c": ["void\n", "clean_exit(int sig)\n", "{\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: clean_exit(%d)\\n\", sig);\n", "#endif\n", "\n", "    fprintf(stdout, \"\\n\\n\");\n", "\n", "    arp_cache_mgr(0, pkt_d);\n", "    capture_stats();\n", "    pcap_close(pkt);\n", "\n", "    fprintf(stdout, \"\\n\");\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: Good-Bye\\n\");\n", "#endif\n", "\n", "    exit(SUCCESS);\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "void ipv4_hdr(libnet_ipv4_hdr *iphdr,u_int16_t prv_opts)\n", "\n", "{\n", "  int iVar1;\n", "  undefined8 uVar2;\n", "  undefined8 uVar3;\n", "  \n", "  uVar2 = libnet_addr2name4((ulong)(iphdr->ip_src).s_addr,0);\n", "  uVar3 = libnet_addr2name4((ulong)(iphdr->ip_dst).s_addr,0);\n", "  fprintf(stdout,\"IP header:   Src Address: %s  Dst Address: %s\\n\",uVar2,uVar3);\n", "  fprintf(stdout,\"\\t     TTL: %d  ID: %d  TOS: 0x%X  Len: %d  \",(ulong)iphdr->ip_ttl,\n", "          (ulong)(ushort)(iphdr->ip_id >> 8 | iphdr->ip_id << 8),(ulong)iphdr->ip_tos,\n", "          (ulong)(ushort)(iphdr->ip_len >> 8 | iphdr->ip_len << 8));\n", "  if ((iphdr->ip_off & 0x40) != 0) {\n", "    fwrite(\"(DF)  \",1,6,stdout);\n", "  }\n", "  uVar2 = 0x40371c;\n", "  fputc(10,stdout);\n", "  iVar1 = libnet_build_ipv4((ulong)(ushort)((iphdr->ip_len >> 8 | iphdr->ip_len << 8) - prv_opts),\n", "                            (ulong)iphdr->ip_tos,\n", "                            (ulong)(ushort)(iphdr->ip_id >> 8 | iphdr->ip_id << 8),\n", "                            (ulong)(ushort)(iphdr->ip_off >> 8 | iphdr->ip_off << 8),\n", "                            (ulong)iphdr->ip_ttl,(ulong)iphdr->ip_p,0,(ulong)(iphdr->ip_src).s_addr,\n", "                            (ulong)(iphdr->ip_dst).s_addr,0,0,pkt_d,0,uVar2);\n", "  if (iVar1 != -1) {\n", "    return;\n", "  }\n", "  uVar2 = libnet_geterror(pkt_d);\n", "  fatal_error((u_int8_t *)\"Unable to build IP header: %s\",uVar2);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "ipv4_hdr(struct libnet_ipv4_hdr *iphdr, u_int16_t prv_opts)\n", "{\n", "    u_int8_t *s_addr, *d_addr;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: ipv4_hdr()\\n\");\n", "#endif\n", "\n", "    s_addr = malloc(sizeof(u_int8_t *));\n", "    d_addr = malloc(sizeof(u_int8_t *));\n", "\n", "    s_addr = libnet_addr2name4(iphdr->ip_src.s_addr, 0);\n", "    d_addr = libnet_addr2name4(iphdr->ip_dst.s_addr, 0);\n", "\n", "    fprintf(stdout, \"IP header:   Src Address: %s  Dst Address: %s\\n\", s_addr, d_addr); \n", "\n", "    fprintf(stdout, \"\\t     TTL: %d  ID: %d  TOS: 0x%X  Len: %d  \", \n", "        iphdr->ip_ttl, \n", "\tntohs(iphdr->ip_id), \n", "\tiphdr->ip_tos, \n", "\tntohs(iphdr->ip_len));\n", "\n", "    if(ntohs(iphdr->ip_off) & IP_DF)\n", "        fprintf(stdout, \"(DF)  \");\n", "\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    if(libnet_build_ipv4(\n", "        ntohs(iphdr->ip_len) - prv_opts,\n", "        iphdr->ip_tos,\n", "        ntohs(iphdr->ip_id),\n", "        ntohs(iphdr->ip_off),\n", "        iphdr->ip_ttl,\n", "        iphdr->ip_p,\n", "        0,\n", "        iphdr->ip_src.s_addr,\n", "        iphdr->ip_dst.s_addr,\n", "        NULL,\n", "        0,\n", "        pkt_d,\n", "        0) == -1)\n", "    {\n", "        fatal_error(\"Unable to build IP header: %s\", libnet_geterror(pkt_d));\n", "    }\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "void fatal_error(u_int8_t *err,...)\n", "\n", "{\n", "  char in_AL;\n", "  undefined8 in_RCX;\n", "  undefined8 in_RDX;\n", "  undefined8 in_RSI;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list va;\n", "  undefined local_b8 [8];\n", "  undefined8 local_b0;\n", "  undefined8 local_a8;\n", "  undefined8 local_a0;\n", "  undefined8 local_98;\n", "  undefined8 local_90;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  undefined4 local_28;\n", "  undefined4 local_18;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_88 = in_XMM0_Da;\n", "    local_78 = in_XMM1_Da;\n", "    local_68 = in_XMM2_Da;\n", "    local_58 = in_XMM3_Da;\n", "    local_48 = in_XMM4_Da;\n", "    local_38 = in_XMM5_Da;\n", "    local_28 = in_XMM6_Da;\n", "    local_18 = in_XMM7_Da;\n", "  }\n", "  va[0].overflow_arg_area = &stack0x00000008;\n", "  va[0].reg_save_area = local_b8;\n", "  va[0].gp_offset = 8;\n", "  va[0].fp_offset = 0x30;\n", "  local_b0 = in_RSI;\n", "  local_a8 = in_RDX;\n", "  local_a0 = in_RCX;\n", "  local_98 = in_R8;\n", "  local_90 = in_R9;\n", "  vsnprintf(error_buf,0x200,(char *)err,va);\n", "  fprintf(stderr,\"\\nError: %s\\n\",error_buf);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(-1);\n", "}\n", "\n"], "c": ["void\n", "fatal_error(u_int8_t *err,...)\n", "{\n", "    va_list va;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: fatal_error()\\n\");\n", "#endif\n", "\n", "    va_start(va, err);\n", "    vsnprintf(error_buf, ERRBUF_MAXLEN, err, va);\n", "\n", "    fprintf(stderr, \"\\nError: %s\\n\", error_buf);\n", "    exit(FAILURE);\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "u_int32_t retrieve_rand_int(u_int32_t r_size)\n", "\n", "{\n", "  u_int32_t r_int;\n", "  __pid_t _Var1;\n", "  uint uVar2;\n", "  time_t tVar3;\n", "  \n", "  tVar3 = time((time_t *)0x0);\n", "  _Var1 = getpid();\n", "  srand((r_int + 1) * _Var1 ^ (uint)tVar3);\n", "  uVar2 = rand();\n", "  return uVar2 % r_size;\n", "}\n", "\n"], "c": ["u_int32_t\n", "retrieve_rand_int(u_int32_t r_size)\n", "{\n", "    static u_int32_t r_int;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: retrieve_rand_int()\\n\");\n", "#endif\n", "\n", "    r_int++;\n", "\n", "    srand(time(0) ^ getpid() * r_int);\n", "    r_int = rand() % r_size;\n", "\n", "    return r_int;\n", "}"]}, {"ghidra": ["\n", "void process_packets(pcap_pkthdr *pkthdr,u_int8_t *packet)\n", "\n", "{\n", "  uint8_t uVar1;\n", "  u_int16_t prv_opts;\n", "  long lVar2;\n", "  libnet_ipv4_hdr *iphdr;\n", "  undefined8 *puVar3;\n", "  u_int8_t pl [1500];\n", "  \n", "  lVar2 = 0xbb;\n", "  puVar3 = (undefined8 *)pl;\n", "  while (lVar2 != 0) {\n", "    lVar2 = lVar2 + -1;\n", "    *puVar3 = 0;\n", "    puVar3 = puVar3 + 1;\n", "  }\n", "  iphdr = (libnet_ipv4_hdr *)(packet + hdr_len);\n", "  *(undefined4 *)puVar3 = 0;\n", "  fwrite(\"\\n----------------------------------------------------------------------------\\n\",1,0x4e,\n", "         stdout);\n", "  uVar1 = iphdr->ip_p;\n", "  if (uVar1 == '\\x06') {\n", "    prv_opts = tcp_hdr(packet,(iphdr->ip_len >> 8 | iphdr->ip_len << 8) -\n", "                              (short)(((uint)*(byte *)iphdr & 0xf) << 2));\n", "  }\n", "  else {\n", "    if (uVar1 == '\\x11') {\n", "      udp_hdr(packet,(iphdr->ip_len >> 8 | iphdr->ip_len << 8) -\n", "                     (short)(((uint)*(byte *)iphdr & 0xf) << 2));\n", "      prv_opts = 0;\n", "    }\n", "    else {\n", "      prv_opts = 0;\n", "      if (uVar1 == '\\x01') {\n", "        icmpv4_hdr(packet,(iphdr->ip_len >> 8 | iphdr->ip_len << 8) -\n", "                          (short)(((uint)*(byte *)iphdr & 0xf) << 2));\n", "        prv_opts = 0;\n", "      }\n", "    }\n", "  }\n", "  ipv4_hdr(iphdr,prv_opts);\n", "  ethernet_hdr((libnet_ethernet_hdr *)packet);\n", "  if (dump_pkt == '\\0') {\n", "    return;\n", "  }\n", "  dump_packet(packet + (uint)hdr_len,pkthdr->caplen - (uint)hdr_len);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "process_packets(struct pcap_pkthdr *pkthdr, u_int8_t *packet)\n", "{\n", "    u_int8_t pl[1500];\n", "    u_int16_t n = 0; \n", "    struct libnet_ipv4_hdr *iphdr;\n", "    struct libnet_ethernet_hdr *ehdr;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: process_packets()\\n\");\n", "#endif\n", "\n", "    memset(pl, 0, sizeof(pl));\n", "\n", "    iphdr = (struct libnet_ipv4_hdr *)(packet + hdr_len);\n", "    ehdr = (struct libnet_ethernet_hdr *)(packet);\n", "\n", "    fprintf(stdout, \"\\n----------------------------------------------------------------------------\\n\");\n", "\n", "    switch(iphdr->ip_p)\n", "    {\n", "        case IPPROTO_TCP: \n", "            n = tcp_hdr(packet, ntohs(iphdr->ip_len) - (iphdr->ip_hl * 4));\n", "            break;\n", "\n", "        case IPPROTO_UDP: \n", "            udp_hdr(packet, ntohs(iphdr->ip_len) - (iphdr->ip_hl * 4));\n", "            break;\n", "\n", "        case IPPROTO_ICMP: \n", "            icmpv4_hdr(packet, ntohs(iphdr->ip_len) - (iphdr->ip_hl * 4));\n", "            break;\n", "    }\n", "\n", "    ipv4_hdr(iphdr, n);\n", "    ethernet_hdr(ehdr);\n", "\n", "    if(dump_pkt)\n", "        dump_packet(packet + hdr_len, pkthdr->caplen - hdr_len);    \n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "u_int16_t inject_packet(void)\n", "\n", "{\n", "  int iVar1;\n", "  u_int16_t uVar2;\n", "  \n", "  iVar1 = libnet_write(pkt_d);\n", "  uVar2 = 0xffff;\n", "  if (iVar1 != -1) {\n", "    libnet_clear_packet(pkt_d);\n", "    uVar2 = 1;\n", "  }\n", "  return uVar2;\n", "}\n", "\n"], "c": ["u_int16_t\n", "inject_packet()\n", "{\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: inject_packet()\\n\");\n", "#endif\n", "\n", "    if(libnet_write(pkt_d) == -1)\n", "        return FAILURE;\n", "\n", "    libnet_clear_packet(pkt_d);\n", "\n", "    return SUCCESS;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "int init(EVP_PKEY_CTX *ctx)\n", "\n", "{\n", "  long lVar1;\n", "  int iVar2;\n", "  u_int32_t d_link;\n", "  int extraout_EAX;\n", "  long lVar3;\n", "  undefined8 uVar4;\n", "  code *pcVar5;\n", "  u_int32_t localnet;\n", "  u_int32_t netmask;\n", "  bpf_program bpf;\n", "  itimerval oval;\n", "  u_int8_t filter [256];\n", "  \n", "  oval.it_interval.tv_sec = 0;\n", "  oval.it_interval.tv_usec = 0;\n", "  oval.it_value.tv_sec = 0;\n", "  oval.it_value.tv_usec = 0;\n", "  bpf._0_8_ = 0;\n", "  bpf.bf_insns = (bpf_insn *)0x0;\n", "  signal(0xf,clean_exit);\n", "  signal(2,clean_exit);\n", "  signal(3,clean_exit);\n", "  signal(1,clean_exit);\n", "  signal(0xe,arp_cache_alrm);\n", "  pkt_d = (libnet_t *)libnet_init(0,device,error_buf);\n", "  if (pkt_d == (libnet_t *)0x0) {\n", "    fatal_error((u_int8_t *)\"Unable to initialize packet injection\");\n", "  }\n", "  if ((device == (u_int8_t *)0x0) &&\n", "     (device = (u_int8_t *)pcap_lookupdev(error_buf), device == (u_int8_t *)0x0)) {\n", "    fatal_error((u_int8_t *)\"%s: Check device permissions\",error_buf);\n", "  }\n", "  pkt = (pcap_t *)pcap_open_live(device,0x5dc,1,500);\n", "  if (pkt == (pcap_t *)0x0) {\n", "    fatal_error((u_int8_t *)\"Unable to open device: %s\",error_buf);\n", "  }\n", "  lVar3 = 0;\n", "  if (w_file[0] != '\\0') {\n", "    lVar3 = pcap_dump_open(pkt,w_file);\n", "    if (lVar3 == 0) {\n", "      uVar4 = pcap_geterr(pkt);\n", "      fatal_error((u_int8_t *)\"Unable to initialize packet capture: %s\",uVar4);\n", "    }\n", "    display = display + -1;\n", "  }\n", "  iVar2 = pcap_lookupnet(device,&localnet,&netmask,error_buf);\n", "  if (iVar2 < 0) {\n", "    fprintf(stderr,\"\\nWarning: Unable to lookup network: %s\\n\",error_buf);\n", "  }\n", "  libnet_get_hwaddr();\n", "  snprintf((char *)filter,0xff,\n", "                      \n", "           \"(ip src host %s and ether dst %0x:%0x:%0x:%0x:%0x:%0x) or (ip dst host %s and ether dst %0x:%0x:%0x:%0x:%0x:%0x)\"\n", "          );\n", "  fprintf(stdout,\"GW: %s\\n\",filter);\n", "  iVar2 = pcap_compile(pkt,&bpf,filter,0,(ulong)netmask);\n", "  if (iVar2 < 0) {\n", "    uVar4 = pcap_geterr(pkt);\n", "    fatal_error((u_int8_t *)\"Unable to compile packet filters: %s\\n\",uVar4);\n", "  }\n", "  iVar2 = pcap_setfilter(pkt,&bpf);\n", "  if (iVar2 < 0) {\n", "    uVar4 = pcap_geterr(pkt);\n", "    fatal_error((u_int8_t *)\"Unable to set packet filters: %s\",uVar4);\n", "  }\n", "  d_link = pcap_datalink();\n", "  hdr_len = retrieve_datalink_hdr_len(d_link);\n", "  fprintf(stdout,\"4g8: Lets see what %s is up to. (Device: %s)\\n\",host_ip,device);\n", "  oval.it_interval.tv_sec = 2;\n", "  oval.it_value.tv_sec = 1;\n", "  setitimer(ITIMER_REAL,(itimerval *)&oval,(itimerval *)0x0);\n", "  pcVar5 = capture_loop;\n", "  lVar1 = 0;\n", "  if (display != '\\x01') {\n", "    pcVar5 = pcap_dump;\n", "    lVar1 = lVar3;\n", "  }\n", "  iVar2 = pcap_loop(pkt,0,pcVar5,lVar1);\n", "  if (iVar2 < 0) {\n", "    uVar4 = pcap_geterr(pkt);\n", "    fatal_error((u_int8_t *)\"Unable to initialize pcap_loop: %s\",uVar4);\n", "  }\n", "  clean_exit(1);\n", "  return extraout_EAX;\n", "}\n", "\n"], "c": ["void\n", "init()\n", "{\n", "    u_int8_t filter[255+1];\n", "    u_int32_t data_link, localnet, netmask;\n", "    pcap_dumper_t *p_dumper = NULL;\n", "\n", "    struct bpf_program bpf;\n", "    struct itimerval oval;\n", "    struct libnet_ether_addr *hw_addr;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: init()\\n\");\n", "#endif\n", "\n", "    memset(&oval, 0, sizeof(struct itimerval));\n", "    memset(&bpf, 0, sizeof(struct bpf_program));\n", "\n", "    signal(SIGTERM, clean_exit);\n", "    signal(SIGINT, clean_exit);\n", "    signal(SIGQUIT, clean_exit);\n", "    signal(SIGHUP, clean_exit);\n", "    signal(SIGALRM, arp_cache_alrm);\n", "\n", "    if((pkt_d = libnet_init(0, device, error_buf)) == NULL)\n", "        fatal_error(\"Unable to initialize packet injection\");\n", "\n", "    if(device == NULL)\n", "        if((device = pcap_lookupdev(error_buf)) == NULL)\n", "            fatal_error(\"%s: Check device permissions\", error_buf);\n", "\n", "    if((pkt = pcap_open_live(device, 1500, 1, 500, error_buf)) == NULL)\n", "        fatal_error(\"Unable to open device: %s\", error_buf);\n", "\n", "    if(strlen(w_file) > 0)\n", "    {\n", "#ifdef DEBUG\n", "        fprintf(stdout, \"DEBUG: Writing to capture file: %s\\n\", w_file);\n", "#endif\n", "\n", "        if((p_dumper = pcap_dump_open(pkt, w_file)) == NULL)\n", "            fatal_error(\"Unable to initialize packet capture: %s\", pcap_geterr(pkt));\n", "\n", "        display--;\n", "    }\n", "\n", "    if(pcap_lookupnet(device, &localnet, &netmask, error_buf) < 0)\n", "\tfprintf(stderr, \"\\nWarning: Unable to lookup network: %s\\n\", error_buf);\n", "\n", "    hw_addr = libnet_get_hwaddr(pkt_d);\n", "    snprintf(filter, 255, \"(ip src host %s and ether dst %0x:%0x:%0x:%0x:%0x:%0x) or (ip dst host %s and ether dst %0x:%0x:%0x:%0x:%0x:%0x)\", \n", "        host_ip, \n", "        hw_addr->ether_addr_octet[0], \n", "        hw_addr->ether_addr_octet[1], \n", "        hw_addr->ether_addr_octet[2], \n", "        hw_addr->ether_addr_octet[3], \n", "        hw_addr->ether_addr_octet[4], \n", "        hw_addr->ether_addr_octet[5], \n", "        host_ip,\n", "        hw_addr->ether_addr_octet[0],\n", "        hw_addr->ether_addr_octet[1],\n", "        hw_addr->ether_addr_octet[2],\n", "        hw_addr->ether_addr_octet[3],\n", "        hw_addr->ether_addr_octet[4],\n", "        hw_addr->ether_addr_octet[5]);\n", "\n", "    fprintf(stdout, \"GW: %s\\n\", filter);\n", "\n", "    if(pcap_compile(pkt, &bpf, filter, 0, netmask) < 0)\n", "        fatal_error(\"Unable to compile packet filters: %s\\n\", pcap_geterr(pkt));\n", "\n", "    if(pcap_setfilter(pkt, &bpf) < 0)\n", "        fatal_error(\"Unable to set packet filters: %s\", pcap_geterr(pkt));\n", "\n", "#ifdef HAVE_FREECODE\n", "    pcap_freecode(&bpf); \n", "#endif /* HAVE_FREECODE */\n", "\n", "    if((data_link = pcap_datalink(pkt)) < 0)\n", "        fatal_error(\"Unable to determine datalink type: %s\", pcap_geterr(pkt));\n", "\n", "    hdr_len = retrieve_datalink_hdr_len(data_link);\n", "\n", "    fprintf(stdout, \"4g8: Lets see what %s is up to. (Device: %s)\\n\", host_ip, device);\n", "\n", "    oval.it_interval.tv_sec = 2;\n", "    oval.it_value.tv_sec = 1;\n", "    setitimer(ITIMER_REAL, &oval, 0);\n", "\n", "    if(pcap_loop(pkt, 0, \n", "        (display == 1) ? (pcap_handler)capture_loop : (pcap_handler)pcap_dump, \n", "        (display == 1) ? NULL : (u_int8_t *)p_dumper) < 0)\n", "    {\n", "        fatal_error(\"Unable to initialize pcap_loop: %s\", pcap_geterr(pkt));\n", "    }\n", "\n", "    clean_exit(SUCCESS);\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "void ethernet_hdr(libnet_ethernet_hdr *ehdr)\n", "\n", "{\n", "  int iVar1;\n", "  u_int8_t *puVar2;\n", "  u_int8_t mac1_array [6];\n", "  u_int8_t mac2_array [6];\n", "  \n", "  fprintf(stdout,\n", "          \"Eth header:  Src Address: %0X:%0X:%0X:%0X:%0X:%0X  Dst Address: %0X:%0X:%0X:%0X:%0X:%0X\",\n", "          (ulong)ehdr->ether_shost[0],(ulong)ehdr->ether_shost[1],(ulong)ehdr->ether_shost[2],\n", "          (ulong)ehdr->ether_shost[3],(ulong)ehdr->ether_shost[4],(ulong)ehdr->ether_shost[5],\n", "          (ulong)ehdr->ether_dhost[0],(ulong)ehdr->ether_dhost[1],(ulong)ehdr->ether_dhost[2],\n", "          (ulong)ehdr->ether_dhost[3],(ulong)ehdr->ether_dhost[4],(ulong)ehdr->ether_dhost[5]);\n", "  puVar2 = mac1_array;\n", "  fputc(10,stdout);\n", "  format_ethernet_addr(host_mac,mac1_array);\n", "  format_ethernet_addr(gw_mac,mac2_array);\n", "  if (((mac1_array[3] == ehdr->ether_shost[3]) && (mac1_array[4] == ehdr->ether_shost[4])) &&\n", "     (mac1_array[5] == ehdr->ether_shost[5])) {\n", "    outbound = '\\0';\n", "    puVar2 = mac2_array;\n", "  }\n", "  else {\n", "    outbound = '\\x01';\n", "  }\n", "  iVar1 = libnet_autobuild_ethernet(puVar2,0x800,pkt_d);\n", "  if (iVar1 != -1) {\n", "    return;\n", "  }\n", "  fatal_error((u_int8_t *)\"Unable to build ethernet header\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "ethernet_hdr(struct libnet_ethernet_hdr *ehdr)\n", "{\n", "    u_int8_t mac1_array[6];\n", "    u_int8_t mac2_array[6];\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: ethernet_hdr()\\n\");\n", "#endif\n", "\n", "    fprintf(stdout, \"Eth header:  Src Address: %0X:%0X:%0X:%0X:%0X:%0X  Dst Address: %0X:%0X:%0X:%0X:%0X:%0X\",\n", "        ehdr->ether_shost[0],\n", "        ehdr->ether_shost[1],\n", "        ehdr->ether_shost[2],\n", "        ehdr->ether_shost[3],\n", "        ehdr->ether_shost[4],\n", "        ehdr->ether_shost[5],\n", "\n", "        ehdr->ether_dhost[0],\n", "        ehdr->ether_dhost[1],\n", "        ehdr->ether_dhost[2],\n", "        ehdr->ether_dhost[3],\n", "        ehdr->ether_dhost[4],\n", "        ehdr->ether_dhost[5]);\n", "\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    format_ethernet_addr(host_mac, mac1_array);\n", "    format_ethernet_addr(gw_mac, mac2_array);\n", "\n", "    if(mac1_array[3] == ehdr->ether_shost[3] && \n", "       mac1_array[4] == ehdr->ether_shost[4] && \n", "       mac1_array[5] == ehdr->ether_shost[5])\n", "    {\n", "        outbound = 0;\n", "    }\n", "    else\n", "        outbound = 1;\n", "\n", "    if(libnet_autobuild_ethernet(\n", "        (outbound == 1) ? mac1_array : mac2_array,\n", "        ETHERTYPE_IP,\n", "        pkt_d) == -1)\n", "    {\n", "        fatal_error(\"Unable to build ethernet header\");\n", "    }\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "void icmpv4_hdr(u_int8_t *packet,u_int16_t diff)\n", "\n", "{\n", "  byte *pbVar1;\n", "  byte bVar2;\n", "  byte bVar3;\n", "  ushort uVar4;\n", "  uint uVar5;\n", "  uint uVar6;\n", "  uint uVar7;\n", "  int iVar8;\n", "  u_int8_t *puVar9;\n", "  u_int8_t *puVar10;\n", "  undefined8 uVar11;\n", "  undefined8 uVar12;\n", "  ushort uVar13;\n", "  ushort uVar14;\n", "  \n", "  pbVar1 = packet + (ulong)hdr_len + 0x14;\n", "  puVar9 = retrieve_icmp_type((ushort)*pbVar1);\n", "  puVar10 = retrieve_icmp_code((ushort)*pbVar1,(ushort)pbVar1[1]);\n", "  fprintf(stdout,\"ICMP header: Type: %s(%d)  \",puVar9);\n", "  switch(*pbVar1) {\n", "  case 0:\n", "  case 8:\n", "    if (pbVar1[1] != 0) {\n", "      fprintf(stdout,\"Code: %s(%d)  \",puVar10);\n", "    }\n", "    uVar14 = diff - 8;\n", "    uVar12 = 0x40320b;\n", "    fprintf(stdout,\"ID: %d  Seqn: %d\",(ulong)*(ushort *)(pbVar1 + 4),(ulong)*(ushort *)(pbVar1 + 6))\n", "    ;\n", "    puVar9 = (u_int8_t *)0x0;\n", "    if (uVar14 != 0) {\n", "      puVar9 = packet + (ulong)hdr_len + 0x1c;\n", "    }\n", "    payload_len = uVar14;\n", "    iVar8 = libnet_build_icmpv4_echo\n", "                      ((ulong)*pbVar1,(ulong)pbVar1[1],(ulong)*(ushort *)(pbVar1 + 2),\n", "                       (ulong)*(ushort *)(pbVar1 + 4),(ulong)*(ushort *)(pbVar1 + 6),puVar9,\n", "                       (ulong)uVar14,pkt_d,0,uVar12);\n", "    if (iVar8 == -1) {\n", "      uVar12 = libnet_geterror(pkt_d);\n", "      fatal_error((u_int8_t *)\"Unable to build ICMPv4 echo header: %s\",uVar12);\n", "    }\n", "    break;\n", "  case 3:\n", "    fprintf(stdout,\"Code: %s(%d)  \",puVar10,(ulong)pbVar1[1]);\n", "    if (pbVar1[1] == 4) {\n", "      fprintf(stdout,\"MTU: %d  Pad: %d  \",\n", "              (ulong)(ushort)(*(ushort *)(pbVar1 + 6) >> 8 | *(ushort *)(pbVar1 + 6) << 8),\n", "              (ulong)(ushort)(*(ushort *)(pbVar1 + 4) >> 8 | *(ushort *)(pbVar1 + 4) << 8));\n", "    }\n", "    uVar12 = libnet_addr2name4((ulong)*(uint *)(pbVar1 + 0x14),0);\n", "    libnet_addr2name4((ulong)*(uint *)(pbVar1 + 0x18),0);\n", "    fputc(10,stdout);\n", "    fwrite(\"\\t     Original IP header:\\n\",1,0x1a,stdout);\n", "    fprintf(stdout,\"\\t     Src Address: %s  Dst Address: %s\\n\",uVar12);\n", "    fprintf(stdout,\"\\t     TTL: %d  ID: %d  TOS: 0x%X  Len: %d  \",(ulong)pbVar1[0x10],\n", "            (ulong)(ushort)(*(ushort *)(pbVar1 + 0xc) >> 8 | *(ushort *)(pbVar1 + 0xc) << 8),\n", "            (ulong)pbVar1[9],\n", "            (ulong)(ushort)(*(ushort *)(pbVar1 + 10) >> 8 | *(ushort *)(pbVar1 + 10) << 8));\n", "    uVar14 = *(ushort *)(pbVar1 + 0xe);\n", "    if ((uVar14 & 0x40) != 0) {\n", "      fwrite(&DAT_00404a5a,1,4,stdout);\n", "      uVar14 = *(ushort *)(pbVar1 + 0xe);\n", "    }\n", "    if (payload_len == 0) {\n", "      uVar7 = *(uint *)(pbVar1 + 0x18);\n", "      uVar5 = *(uint *)(pbVar1 + 0x14);\n", "      packet = (u_int8_t *)0x0;\n", "      uVar4 = *(ushort *)(pbVar1 + 0x12);\n", "      bVar2 = pbVar1[0x11];\n", "      bVar3 = pbVar1[0x10];\n", "      uVar13 = *(ushort *)(pbVar1 + 0xc);\n", "    }\n", "    else {\n", "      uVar4 = *(ushort *)(pbVar1 + 0x12);\n", "      bVar2 = pbVar1[0x11];\n", "      packet = packet + 10;\n", "      bVar3 = pbVar1[0x10];\n", "      uVar13 = *(ushort *)(pbVar1 + 0xc);\n", "      uVar7 = *(uint *)(pbVar1 + 0x18);\n", "      uVar5 = *(uint *)(pbVar1 + 0x14);\n", "    }\n", "    iVar8 = libnet_build_ipv4((ulong)(ushort)(*(ushort *)(pbVar1 + 10) >> 8 |\n", "                                             *(ushort *)(pbVar1 + 10) << 8),(ulong)pbVar1[9],\n", "                              (ulong)(ushort)(uVar13 >> 8 | uVar13 << 8),(ulong)uVar14,(ulong)bVar3,\n", "                              (ulong)bVar2,(ulong)uVar4,(ulong)uVar5,(ulong)uVar7,packet,\n", "                              (ulong)payload_len,pkt_d,0);\n", "    if (iVar8 == -1) {\n", "      uVar12 = libnet_geterror(pkt_d);\n", "      fatal_error((u_int8_t *)\"Unable to build original IP header: %s\",uVar12);\n", "    }\n", "    iVar8 = libnet_build_icmpv4_unreach\n", "                      ((ulong)*pbVar1,(ulong)pbVar1[1],(ulong)*(ushort *)(pbVar1 + 2),0,0,pkt_d);\n", "    if (iVar8 == -1) {\n", "      uVar12 = libnet_geterror(pkt_d);\n", "      fatal_error((u_int8_t *)\"Unable to build ICMPv4 unreach header: %s\",uVar12);\n", "    }\n", "    break;\n", "  case 5:\n", "    uVar7 = *(uint *)(pbVar1 + 4);\n", "    uVar12 = libnet_addr2name4((ulong)(uVar7 >> 0x18 | (uVar7 & 0xff0000) >> 8 |\n", "                                       (uVar7 & 0xff00) << 8 | uVar7 << 0x18),0);\n", "    fprintf(stdout,\"Code: %s(%d)  Gateway: %s  \",puVar10,(ulong)pbVar1[1],uVar12);\n", "    goto LAB_004030d9;\n", "  case 0xb:\n", "  case 0xc:\n", "    fprintf(stdout,\"Code: %s(%d)  \",puVar10,(ulong)pbVar1[1]);\n", "LAB_004030d9:\n", "    uVar12 = libnet_addr2name4((ulong)*(uint *)(pbVar1 + 0x14),0);\n", "    uVar11 = libnet_addr2name4((ulong)*(uint *)(pbVar1 + 0x18),0);\n", "    fputc(10,stdout);\n", "    fwrite(\"\\t     Original IP header:\\n\",1,0x1a,stdout);\n", "    fprintf(stdout,\"\\t     Src Address: %s  Dst Address: %s\\n\",uVar12,uVar11);\n", "    fprintf(stdout,\"\\t     TTL: %d  ID: %d  TOS: 0x%X  Len: %d  \",(ulong)pbVar1[0x10],\n", "            (ulong)(ushort)(*(ushort *)(pbVar1 + 0xc) >> 8 | *(ushort *)(pbVar1 + 0xc) << 8),\n", "            (ulong)pbVar1[9],\n", "            (ulong)(ushort)(*(ushort *)(pbVar1 + 10) >> 8 | *(ushort *)(pbVar1 + 10) << 8));\n", "    if ((*(ushort *)(pbVar1 + 0xe) & 0x40) != 0) {\n", "      fwrite(&DAT_00404a5a,1,4,stdout);\n", "    }\n", "    break;\n", "  case 0xd:\n", "  case 0x11:\n", "    if (pbVar1[1] != 0) {\n", "      fprintf(stdout,\"Code: %s(%d)  \",puVar10);\n", "    }\n", "    fprintf(stdout,\"ID: %d  Seqn: %d\",(ulong)*(ushort *)(pbVar1 + 4),(ulong)*(ushort *)(pbVar1 + 6))\n", "    ;\n", "    goto LAB_00403457;\n", "  case 0xe:\n", "    if (pbVar1[1] != 0) {\n", "      fprintf(stdout,\"Code: %s(%d)  \",puVar10);\n", "    }\n", "    fprintf(stdout,\"ID: %d  Seqn: %d\\n\",(ulong)*(ushort *)(pbVar1 + 4),\n", "            (ulong)*(ushort *)(pbVar1 + 6));\n", "    uVar7 = *(uint *)(pbVar1 + 0x10);\n", "    uVar5 = *(uint *)(pbVar1 + 0xc);\n", "    uVar6 = *(uint *)(pbVar1 + 8);\n", "    fprintf(stdout,\"\\t     Original: %lu  Received: %lu  Transmit: %lu\",\n", "            (ulong)(uVar6 >> 0x18 | (uVar6 & 0xff0000) >> 8 | (uVar6 & 0xff00) << 8 | uVar6 << 0x18)\n", "            ,(ulong)(uVar5 >> 0x18 | (uVar5 & 0xff0000) >> 8 | (uVar5 & 0xff00) << 8 | uVar5 << 0x18\n", "                    ),\n", "            (ulong)(uVar7 >> 0x18 | (uVar7 & 0xff0000) >> 8 | (uVar7 & 0xff00) << 8 | uVar7 << 0x18)\n", "           );\n", "    break;\n", "  case 0x12:\n", "    if (pbVar1[1] != 0) {\n", "      fprintf(stdout,\"Code: %s(%d)  \",puVar10);\n", "    }\n", "    fprintf(stdout,\"ID: %d  Seqn: %d\\n\",(ulong)*(ushort *)(pbVar1 + 4),\n", "            (ulong)*(ushort *)(pbVar1 + 6));\n", "    uVar7 = *(uint *)(pbVar1 + 8);\n", "    uVar12 = libnet_addr2name4((ulong)(uVar7 >> 0x18 | (uVar7 & 0xff0000) >> 8 |\n", "                                       (uVar7 & 0xff00) << 8 | uVar7 << 0x18),0);\n", "    fprintf(stdout,\"\\t     Mask: %s  \",uVar12);\n", "LAB_00403457:\n", "    uVar7 = *(uint *)(pbVar1 + 8);\n", "    if (payload_len == 0) {\n", "      packet = (u_int8_t *)0x0;\n", "    }\n", "    iVar8 = libnet_build_icmpv4_mask\n", "                      ((ulong)*pbVar1,(ulong)pbVar1[1],(ulong)*(ushort *)(pbVar1 + 2),\n", "                       (ulong)*(ushort *)(pbVar1 + 4),(ulong)*(ushort *)(pbVar1 + 6),\n", "                       (ulong)(uVar7 >> 0x18 | (uVar7 & 0xff0000) >> 8 | (uVar7 & 0xff00) << 8 |\n", "                              uVar7 << 0x18),packet,(ulong)payload_len,pkt_d,0);\n", "    if (iVar8 == -1) {\n", "      uVar12 = libnet_geterror(pkt_d);\n", "      fatal_error((u_int8_t *)\"Unable to build ICMPv4 mask header: %s\",uVar12);\n", "    }\n", "    break;\n", "  case 0x1e:\n", "    if (pbVar1[1] != 0) {\n", "      fprintf(stdout,\"Code: %s(%d)  \",puVar10);\n", "    }\n", "  }\n", "  fputc(10,stdout);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "icmpv4_hdr(u_int8_t *packet, u_int16_t diff)\n", "{\n", "    u_int8_t *s_addr, *d_addr;\n", "    u_int8_t *icmp_t, *icmp_c;\n", "    \n", "    struct libnet_icmpv4_hdr *icmphdr;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: icmpv4_hdr()\\n\"); \n", "#endif\n", "\n", "#ifndef icmp_iphdr\n", "#define icmp_iphdr icmphdr->dun.ip.idi_ip\n", "#endif\n", "\n", "    icmphdr = (struct libnet_icmpv4_hdr *)(packet + IPV4_H + hdr_len);\n", "\n", "    s_addr = (u_int8_t *)malloc(sizeof(s_addr));\n", "    d_addr = (u_int8_t *)malloc(sizeof(d_addr));\n", "\n", "    icmp_t = retrieve_icmp_type(icmphdr->icmp_type);\n", "    icmp_c = retrieve_icmp_code(icmphdr->icmp_type, icmphdr->icmp_code);\n", "\n", "    fprintf(stdout, \"ICMP header: Type: %s(%d)  \", icmp_t, icmphdr->icmp_type);\n", "\n", "    switch(icmphdr->icmp_type) \n", "    {\n", "        case ICMP_REDIRECT: \n", "            fprintf(stdout, \"Code: %s(%d)  Gateway: %s  \", \n", "                icmp_c, icmphdr->icmp_code, \n", "                libnet_addr2name4(ntohl(icmphdr->hun.gateway), 0));\n", "\n", "            s_addr = libnet_addr2name4(icmp_iphdr.ip_src.s_addr, 0);\n", "            d_addr = libnet_addr2name4(icmp_iphdr.ip_dst.s_addr, 0);\n", "\n", "            fprintf(stdout, \"\\n\");\n", "            fprintf(stdout, \"\\t     Original IP header:\\n\");\n", "            fprintf(stdout, \"\\t     Src Address: %s  Dst Address: %s\\n\", s_addr, d_addr);\n", "            fprintf(stdout, \"\\t     TTL: %d  ID: %d  TOS: 0x%X  Len: %d  \",\n", "                icmp_iphdr.ip_ttl,\n", "                ntohs(icmp_iphdr.ip_id),\n", "                icmp_iphdr.ip_tos,\n", "                ntohs(icmp_iphdr.ip_len));\n", "\n", "            if(ntohs(icmp_iphdr.ip_off) & IP_DF)\n", "                fprintf(stdout, \"(DF)\");\n", "\n", "            break;\n", "\n", "        case ICMP_UNREACH: \n", "            fprintf(stdout, \"Code: %s(%d)  \", icmp_c, icmphdr->icmp_code);\n", "\n", "            if(icmphdr->icmp_code == ICMP_UNREACH_NEEDFRAG)\n", "                fprintf(stdout, \"MTU: %d  Pad: %d  \", ntohs(icmphdr->hun.frag.mtu), ntohs(icmphdr->hun.frag.pad)); \n", "\n", "            s_addr = libnet_addr2name4(icmp_iphdr.ip_src.s_addr, 0);\n", "            d_addr = libnet_addr2name4(icmp_iphdr.ip_dst.s_addr, 0);\n", "\n", "            fprintf(stdout, \"\\n\");\n", "            fprintf(stdout, \"\\t     Original IP header:\\n\");\n", "            fprintf(stdout, \"\\t     Src Address: %s  Dst Address: %s\\n\", s_addr, d_addr);\n", "            fprintf(stdout, \"\\t     TTL: %d  ID: %d  TOS: 0x%X  Len: %d  \",\n", "                icmp_iphdr.ip_ttl,\n", "                ntohs(icmp_iphdr.ip_id),\n", "                icmp_iphdr.ip_tos,\n", "                ntohs(icmp_iphdr.ip_len));\n", "\n", "            if(ntohs(icmp_iphdr.ip_off) & IP_DF)\n", "                fprintf(stdout, \"(DF)\");\n", "  \n", "            if(libnet_build_ipv4(\n", "                ntohs(icmp_iphdr.ip_len),\n", "                icmp_iphdr.ip_tos,\n", "                ntohs(icmp_iphdr.ip_id),\n", "                icmp_iphdr.ip_off,\n", "                icmp_iphdr.ip_ttl,\n", "                icmp_iphdr.ip_p,\n", "                icmp_iphdr.ip_sum,\n", "                icmp_iphdr.ip_src.s_addr,\n", "                icmp_iphdr.ip_dst.s_addr,\n", "                (payload_len == 0) ? NULL : packet + 10,\n", "                payload_len,\n", "                pkt_d,\n", "                0) == -1)\n", "            {\n", "                fatal_error(\"Unable to build original IP header: %s\", libnet_geterror(pkt_d)); \n", "            } \n", "\n", "            if(libnet_build_icmpv4_unreach(\n", "                icmphdr->icmp_type,\n", "                icmphdr->icmp_code,\n", "                icmphdr->icmp_sum,\n", "                NULL,\n", "                0,\n", "                pkt_d,\n", "                0) == -1)\n", "            {\n", "                fatal_error(\"Unable to build ICMPv4 unreach header: %s\", libnet_geterror(pkt_d));\n", "            }\n", "\n", "            break;\n", "\n", "        case ICMP_TIMXCEED: case ICMP_PARAMPROB:\n", "            fprintf(stdout, \"Code: %s(%d)  \", icmp_c, icmphdr->icmp_code);\n", "\n", "            s_addr = libnet_addr2name4(icmp_iphdr.ip_src.s_addr, 0);\n", "            d_addr = libnet_addr2name4(icmp_iphdr.ip_dst.s_addr, 0);\n", "\n", "            fprintf(stdout, \"\\n\");\n", "            fprintf(stdout, \"\\t     Original IP header:\\n\");\n", "            fprintf(stdout, \"\\t     Src Address: %s  Dst Address: %s\\n\", s_addr, d_addr);\n", "            fprintf(stdout, \"\\t     TTL: %d  ID: %d  TOS: 0x%X  Len: %d  \",\n", "                icmp_iphdr.ip_ttl,\n", "                ntohs(icmp_iphdr.ip_id),\n", "                icmp_iphdr.ip_tos,\n", "                ntohs(icmp_iphdr.ip_len));\n", "\n", "            if(ntohs(icmp_iphdr.ip_off) & IP_DF)\n", "                fprintf(stdout, \"(DF)\");\n", "\n", "            break;\n", "\n", "        case ICMP_TSTAMPREPLY:\n", "            if(icmphdr->icmp_code > 0)\n", "                fprintf(stdout, \"Code: %s(%d)  \", icmp_c, icmphdr->icmp_code);\n", "\n", "            fprintf(stdout, \"ID: %d  Seqn: %d\\n\", icmphdr->icmp_id, icmphdr->icmp_seq);\n", "            fprintf(stdout, \"\\t     Original: %lu  Received: %lu  Transmit: %lu\", \n", "                (u_long)ntohl(icmphdr->icmp_otime), \n", "                (u_long)ntohl(icmphdr->icmp_rtime), \n", "                (u_long)ntohl(icmphdr->icmp_ttime));    \n", "\n", "            break;\n", "\n", "        case ICMP_MASKREPLY:\n", "            if(icmphdr->icmp_code > 0)\n", "                fprintf(stdout, \"Code: %s(%d)  \", icmp_c, icmphdr->icmp_code);\n", "\n", "            fprintf(stdout, \"ID: %d  Seqn: %d\\n\", icmphdr->icmp_id, icmphdr->icmp_seq);\n", "            fprintf(stdout, \"\\t     Mask: %s  \", libnet_addr2name4(ntohl(icmphdr->dun.mask), 0));\n", "\n", "            if(libnet_build_icmpv4_mask(\n", "                icmphdr->icmp_type,\n", "                icmphdr->icmp_code,\n", "                icmphdr->icmp_sum,\n", "                icmphdr->icmp_id,\n", "                icmphdr->icmp_seq,\n", "                ntohl(icmphdr->dun.mask),\n", "                (payload_len == 0) ? NULL : packet,\n", "                payload_len,\n", "                pkt_d,\n", "                0) == -1)\n", "            {\n", "                fatal_error(\"Unable to build ICMPv4 mask header: %s\", libnet_geterror(pkt_d));\n", "            }\n", "\n", "            break;\n", "\n", "        case ICMP_ECHOREPLY: case ICMP_ECHO: \n", "            if(icmphdr->icmp_code > 0)\n", "                fprintf(stdout, \"Code: %s(%d)  \", icmp_c, icmphdr->icmp_code);\n", "\n", "            fprintf(stdout, \"ID: %d  Seqn: %d\", icmphdr->icmp_id, icmphdr->icmp_seq);\n", "\n", "            payload_len = diff - 8;\n", "\n", "            if(libnet_build_icmpv4_echo(\n", "                icmphdr->icmp_type,\n", "                icmphdr->icmp_code,\n", "                icmphdr->icmp_sum,\n", "                icmphdr->icmp_id,\n", "                icmphdr->icmp_seq,\n", "                (payload_len == 0) ? NULL : packet + hdr_len + IPV4_H + 8,\n", "                payload_len,\n", "                pkt_d,\n", "                0) == -1)\n", "            {\n", "                fatal_error(\"Unable to build ICMPv4 echo header: %s\", libnet_geterror(pkt_d));\n", "            }\n", "\n", "            break;\n", "\n", "        case ICMP_MASKREQ: case ICMP_TSTAMP:\n", "            if(icmphdr->icmp_code > 0)\n", "                fprintf(stdout, \"Code: %s(%d)  \", icmp_c, icmphdr->icmp_code);\n", "\n", "            fprintf(stdout, \"ID: %d  Seqn: %d\", icmphdr->icmp_id, icmphdr->icmp_seq);\n", "\n", "            if(libnet_build_icmpv4_mask(\n", "                icmphdr->icmp_type,\n", "                icmphdr->icmp_code,\n", "                icmphdr->icmp_sum,\n", "                icmphdr->icmp_id,\n", "                icmphdr->icmp_seq,\n", "                ntohl(icmphdr->dun.mask),\n", "                (payload_len == 0) ? NULL : packet,\n", "                payload_len,\n", "                pkt_d,\n", "                0) == -1)\n", "            {\n", "                fatal_error(\"Unable to build ICMPv4 mask header: %s\", libnet_geterror(pkt_d));\n", "            }\n", "\n", "\t    break;\n", "\n", "        case ICMP_TRACEROUTE:\n", "            if(icmphdr->icmp_code > 0)\n", "                fprintf(stdout, \"Code: %s(%d)  \", icmp_c, icmphdr->icmp_code);\n", "\n", "            break;\n", "    }\n", "    \n", "    fprintf(stdout, \"\\n\");\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "u_int16_t retrieve_datalink_hdr_len(u_int32_t d_link)\n", "\n", "{\n", "  return (u_int16_t)((-(ushort)(d_link == 0) & 0xfff6) + 0xe);\n", "}\n", "\n"], "c": ["u_int16_t\n", "retrieve_datalink_hdr_len(u_int32_t d_link)\n", "{\n", "    u_int16_t len = 0;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: retrieve_datalink_hdr_len()\\n\");\n", "#endif\n", "\n", "    switch(d_link)\n", "    {   \n", "        case DLT_NULL:\n", "            len = 4;\n", "            break;\n", "\n", "        case DLT_EN10MB:\n", "            len = ETH_H;\n", "            break;\n", "\n", "        default:\n", "            len = ETH_H;\n", "            break;\n", "    }\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: hdr_len: %d\\n\", len);\n", "#endif\n", "\n", "    return len;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "u_int32_t format_ethernet_addr(u_int8_t *ethstr,u_int8_t *u_eaddr)\n", "\n", "{\n", "  int iVar1;\n", "  char *__nptr;\n", "  long lVar2;\n", "  int iVar3;\n", "  u_int32_t uVar4;\n", "  u_int8_t o_ethstr [18];\n", "  \n", "  uVar4 = 1;\n", "  o_ethstr._0_8_ = 0;\n", "  o_ethstr._8_8_ = 0;\n", "  o_ethstr._16_2_ = 0;\n", "  if (ethstr != (u_int8_t *)0x0) {\n", "    strncpy((char *)o_ethstr,(char *)ethstr,0x12);\n", "    __nptr = strtok((char *)o_ethstr,\":\");\n", "    if (__nptr != (char *)0x0) {\n", "      iVar3 = (int)u_eaddr;\n", "      while( true ) {\n", "        lVar2 = strtol(__nptr,(char **)0x0,0x10);\n", "        if (0xff < lVar2) break;\n", "        *u_eaddr = (u_int8_t)lVar2;\n", "        iVar1 = (int)u_eaddr;\n", "        u_eaddr = u_eaddr + 1;\n", "        __nptr = strtok((char *)0x0,\":\");\n", "        if (__nptr == (char *)0x0) {\n", "          return (u_int32_t)(uint)((1 - iVar3) + iVar1 == 6);\n", "        }\n", "      }\n", "    }\n", "    uVar4 = 0;\n", "  }\n", "  return uVar4;\n", "}\n", "\n"], "c": ["u_int32_t\n", "format_ethernet_addr(u_int8_t *ethstr, u_int8_t u_eaddr[6])\n", "{\n", "    int i = 0;\n", "    long base16;\n", "    u_int8_t *eptr, *delim = \":\";\n", "    u_int8_t o_ethstr[18] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: format_ethernet_addr()\\n\");\n", "#endif\n", "\n", "    if(ethstr)\n", "        strncpy(o_ethstr, ethstr, 18);\n", "    else\n", "    {\n", "        u_eaddr = o_ethstr;\n", "        return 1;\n", "    }\n", "\n", "    for(eptr = strtok(o_ethstr, delim);\n", "         eptr;\n", "         eptr = strtok(NULL, delim))\n", "    {\n", "        if((base16 = strtol(eptr, 0, 16)) > 0xff)\n", "            return 0;\n", "\n", "        u_eaddr[i] = base16;\n", "        i++;\n", "    }\n", "\n", "    if(i != 6)\n", "        return 0;\n", "\n", "    ethstr = o_ethstr;\n", "\n", "    return 1;\n", "}"]}, {"ghidra": ["\n", "void print_version(void)\n", "\n", "{\n", "  fprintf(stdout,\"Version: %s\\n\",&DAT_00404734);\n", "  fprintf(stdout,\"Author:  %s\\n\",\"Darren Bounds <dbounds@intrusense.com>\");\n", "  fprintf(stdout,\"Website: %s\\n\",\"http://forgate.sourceforge.net\");\n", "  fputc(10,stdout);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(1);\n", "}\n", "\n"], "c": ["void\n", "print_version()\n", "{\n", "    fprintf(stdout, \"Version: %s\\n\", FG_VERSION);\n", "    fprintf(stdout, \"Author:  %s\\n\", FG_AUTHOR);\n", "    fprintf(stdout, \"Website: %s\\n\", FG_SITE);\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    exit(SUCCESS);\n", "}"]}, {"ghidra": ["\n", "int main(int argc,char **argv)\n", "\n", "{\n", "  u_int8_t *puVar1;\n", "  \n", "  display = '\\x01';\n", "  dump_pkt = '\\0';\n", "  opterr = 0;\n", "switchD_00401569_caseD_48:\n", "  opt = getopt(argc,argv,\"G:g:hi:S:s:vw:X\");\n", "  if (opt == 0xffffffff) {\n", "    if ((((host_ip == (u_int8_t *)0x0) || (host_mac == (u_int8_t *)0x0)) ||\n", "        (gw_ip == (u_int8_t *)0x0)) || (gw_mac == (u_int8_t *)0x0)) {\n", "      print_usage();\n", "    }\n", "    init((EVP_PKEY_CTX *)argv[optind]);\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(1);\n", "  }\n", "  switch(opt) {\n", "  case 0x47:\n", "    gw_mac = (u_int8_t *)__strdup();\n", "    puVar1 = gw_mac;\n", "    break;\n", "  default:\n", "    goto switchD_00401569_caseD_48;\n", "  case 0x53:\n", "    host_mac = (u_int8_t *)__strdup();\n", "    puVar1 = host_mac;\n", "    break;\n", "  case 0x58:\n", "  case 0x78:\n", "    dump_pkt = '\\x01';\n", "    goto switchD_00401569_caseD_48;\n", "  case 0x67:\n", "    gw_ip = (u_int8_t *)__strdup();\n", "    puVar1 = gw_ip;\n", "    break;\n", "  case 0x68:\n", "    goto switchD_00401569_caseD_68;\n", "  case 0x69:\n", "    device = (u_int8_t *)__strdup();\n", "    puVar1 = device;\n", "    break;\n", "  case 0x73:\n", "    host_ip = (u_int8_t *)__strdup();\n", "    puVar1 = host_ip;\n", "    break;\n", "  case 0x76:\n", "    print_version();\n", "                    /* WARNING: Subroutine does not return */\n", "    exit(-1);\n", "  case 0x77:\n", "    strncpy(w_file,optarg,0x20);\n", "    goto switchD_00401569_caseD_48;\n", "  }\n", "  if (puVar1 == (u_int8_t *)0x0) {\n", "    fatal_error((u_int8_t *)\"Memory unavailable for: %s\",optarg);\n", "  }\n", "  goto switchD_00401569_caseD_48;\n", "switchD_00401569_caseD_68:\n", "  print_usage();\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(-1);\n", "}\n", "\n"], "c": ["int\n", "main(int argc, char *argv[])\n", "{\n", "    display = 1;\n", "    dump_pkt = 0;\n", "    opterr = 0;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: main()\\n\");\n", "#endif\n", "\n", "    while((opt = getopt(argc, argv, \"G:g:hi:S:s:vw:X\")) != -1)\n", "    {\n", "        switch(opt)\n", "        {\n", "            case 'g':\n", "                if(!(gw_ip = strdup(optarg)))\n", "                    fatal_error(\"Memory unavailable for: %s\", optarg);\n", "             \n", "                break;\n", "\n", "            case 'G':\n", "                if(!(gw_mac = strdup(optarg)))\n", "                    fatal_error(\"Memory unavailable for: %s\", optarg);\n", "\n", "                break;\n", "\n", "            case 'h':\n", "                print_usage();\n", "                exit(FAILURE);\n", "                break;\n", "\n", "            case 'i':\n", "                if(!(device = strdup(optarg)))\n", "                    fatal_error(\"Memory unavailable for: %s\", optarg);\n", "\n", "                break;\n", "\n", "            case 's':\n", "                if(!(host_ip = strdup(optarg)))\n", "                    fatal_error(\"Memory unavailable for: %s\", optarg);\n", "\n", "                break;\n", "\n", "            case 'S':\n", "                if(!(host_mac = strdup(optarg)))\n", "                    fatal_error(\"Memory unavailable for: %s\", optarg);\n", "\n", "                break;\n", "\n", "            case 'v':\n", "                print_version();\n", "                exit(FAILURE);\n", "                break;\n", "\n", "            case 'w':\n", "                strncpy(w_file, optarg, OPT_MAXLEN);\n", "                break;\n", "\n", "            case 'x': case 'X':\n", "                dump_pkt = 1;\n", "                break;\n", "        }\n", "    }\n", "\n", "    if(!host_ip || !host_mac || !gw_ip || !gw_mac)\n", "        print_usage();\n", "\n", "    init(argv[optind], 0);\n", "\n", "    exit(SUCCESS);\n", "}        "]}, {"ghidra": ["\n", "void capture_loop(u_int8_t *user,pcap_pkthdr *pkthdr,u_int8_t *packet)\n", "\n", "{\n", "  u_int16_t uVar1;\n", "  \n", "  if (display != '\\0') {\n", "    process_packets(pkthdr,packet);\n", "  }\n", "  uVar1 = inject_packet();\n", "  if (uVar1 != 0) {\n", "    return;\n", "  }\n", "  fatal_error((u_int8_t *)\"Unable to inject packet\");\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "capture_loop(u_int8_t *user, struct pcap_pkthdr *pkthdr, u_int8_t *packet)\n", "{\n", "    if(display)\n", "        process_packets(pkthdr, packet);\n", "\n", "    if(!inject_packet())\n", "        fatal_error(\"Unable to inject packet\");\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "void dump_packet(u_int8_t *cp,int len)\n", "\n", "{\n", "  ushort *puVar1;\n", "  ushort **ppuVar2;\n", "  byte bVar3;\n", "  byte *pbVar4;\n", "  byte bVar5;\n", "  char *__s;\n", "  char *pcVar6;\n", "  byte *pbVar7;\n", "  int iVar8;\n", "  ulong local_a8;\n", "  uint local_90;\n", "  char ascii_data [17];\n", "  char hex_data [41];\n", "  undefined auStack63 [15];\n", "  \n", "  local_a8 = (ulong)(long)len >> 1;\n", "  local_90 = 0;\n", "LAB_00403905:\n", "  pbVar7 = (byte *)ascii_data;\n", "  __s = hex_data;\n", "  iVar8 = 0;\n", "  pbVar4 = cp;\n", "  do {\n", "    local_a8._0_4_ = (uint)local_a8 - 1;\n", "    local_a8 = (ulong)(uint)local_a8;\n", "    if ((int)(uint)local_a8 < 0) {\n", "      if ((len & 1U) == 0) {\n", "        pbVar4 = pbVar7;\n", "        pcVar6 = __s;\n", "        if (iVar8 == 0) goto LAB_00403994;\n", "      }\n", "      else {\n", "        bVar5 = *pbVar4;\n", "        pbVar4 = pbVar7 + 1;\n", "        pcVar6 = __s + 3;\n", "        snprintf(__s,(size_t)(auStack63 + -(long)__s),\" %02x\");\n", "        ppuVar2 = __ctype_b_loc();\n", "        if (-1 < (short)(*ppuVar2)[bVar5]) {\n", "          bVar5 = 0x2d;\n", "        }\n", "        *pbVar7 = bVar5;\n", "      }\n", "      *pbVar4 = 0;\n", "      *pcVar6 = '\\0';\n", "      fprintf(stdout,\"\\n0x%04x\\t    %-*s\\t   %s\",(ulong)local_90,0x28,hex_data,ascii_data);\n", "LAB_00403994:\n", "      fputc(10,stdout);\n", "      return;\n", "    }\n", "    bVar5 = *pbVar4;\n", "    cp = pbVar4 + 2;\n", "    bVar3 = pbVar4[1];\n", "    snprintf(__s,(size_t)(auStack63 + -(long)__s),\" %02x%02x\");\n", "    ppuVar2 = __ctype_b_loc();\n", "    puVar1 = *ppuVar2;\n", "    if (-1 < (short)puVar1[bVar5]) {\n", "      bVar5 = 0x2d;\n", "    }\n", "    *pbVar7 = bVar5;\n", "    if (-1 < (short)puVar1[bVar3]) {\n", "      bVar3 = 0x2d;\n", "    }\n", "    iVar8 = iVar8 + 1;\n", "    pbVar7[1] = bVar3;\n", "    if (7 < iVar8) break;\n", "    __s = __s + 5;\n", "    pbVar7 = pbVar7 + 2;\n", "    pbVar4 = cp;\n", "  } while( true );\n", "  pbVar7[2] = 0;\n", "  __s[5] = '\\0';\n", "  fprintf(stdout,\"\\n0x%04x\\t    %-*s\\t   %s\",(ulong)local_90,0x28,hex_data,ascii_data);\n", "  local_90 = local_90 + 0x10;\n", "  goto LAB_00403905;\n", "}\n", "\n"], "c": ["void\n", "dump_packet(u_int8_t *cp, int len)\n", "{\n", "    int i, offset, nshorts, s1, s2;\n", "    char hex_data[HEXDUMP_SHORTS_PER_LINE*HEXDUMP_HEXSTUFF_PER_SHORT+1], *hsp;\n", "    char ascii_data[HEXDUMP_BYTES_PER_LINE+1], *asp;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: dump_packet()\\n\");\n", "#endif\n", "\n", "    offset = i = 0;\n", "    hsp = hex_data; \n", "    asp = ascii_data;\n", "    nshorts = len / sizeof(u_int16_t);\n", "\n", "    while (--nshorts >= 0) \n", "    {\n", "        s1 = *cp++;\n", "        s2 = *cp++;\n", "\n", "        snprintf(hsp,\n", "            sizeof(hex_data) - (hsp - hex_data),\n", "            \" %02x%02x\", \n", "            s1, \n", "            s2);\n", "        \n", "        hsp += HEXDUMP_HEXSTUFF_PER_SHORT;\n", "        \n", "        *(asp++) = (isgraph(s1) ? s1 : '-');\n", "        *(asp++) = (isgraph(s2) ? s2 : '-');\n", "        \n", "        if(++i >= HEXDUMP_SHORTS_PER_LINE) \n", "        {\n", "            *hsp = *asp = '\\0';\n", "            \n", "            fprintf(stdout, \"\\n0x%04x\\t    %-*s\\t   %s\",\n", "                offset, \n", "                HEXDUMP_HEXSTUFF_PER_LINE,\n", "                hex_data, \n", "                ascii_data);\n", "            \n", "            i = 0; \n", "            hsp = hex_data; \n", "            asp = ascii_data;\n", "            offset += HEXDUMP_BYTES_PER_LINE;\n", "        }\n", "    }\n", "\n", "    if(len & 1) \n", "    {\n", "        s1 = *cp++;\n", "            \n", "        snprintf(hsp, \n", "            sizeof(hex_data) - (hsp - hex_data),\n", "            \" %02x\", \n", "            s1);\n", "\t\n", "        hsp += 3;\n", "        *(asp++) = (isgraph(s1) ? s1 : '-');\n", "        ++i;\n", "    }\n", "    \n", "    if(i > 0) \n", "    {\n", "        *hsp = *asp = '\\0';\n", "        \n", "        fprintf(stdout, \"\\n0x%04x\\t    %-*s\\t   %s\",\n", "            offset, \n", "            HEXDUMP_HEXSTUFF_PER_LINE,\n", "            hex_data, \n", "            ascii_data);\n", "    }\n", "\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "void capture_stats(void)\n", "\n", "{\n", "  pcap_stat p_stats;\n", "  \n", "  p_stats._0_8_ = 0;\n", "  p_stats.ps_ifdrop = 0;\n", "  pcap_stats(pkt,&p_stats);\n", "  print_separator(0,1,(u_int8_t *)\"4g8 Capture Statistics\");\n", "  fprintf(stdout,\"Received: %u  Dropped: %u\",p_stats._0_8_ & 0xffffffff,p_stats._0_8_ >> 0x20);\n", "  fputc(10,stdout);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "capture_stats()\n", "{\n", "    struct pcap_stat p_stats;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: capture_stats()\\n\");\n", "#endif\n", "\n", "    memset(&p_stats, 0, sizeof(struct pcap_stat));\n", "\n", "    pcap_stats(pkt, &p_stats);\n", "\n", "    print_separator(0, 1, \"4g8 Capture Statistics\");\n", "\n", "    fprintf(stdout, \"Received: %u  Dropped: %u\",\n", "        p_stats.ps_recv, p_stats.ps_drop);\n", "\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "void print_separator(int bnl,int anl,u_int8_t *msgp,...)\n", "\n", "{\n", "  uint *puVar1;\n", "  char in_AL;\n", "  uint *puVar2;\n", "  undefined8 in_RCX;\n", "  byte bVar3;\n", "  uint uVar4;\n", "  undefined8 in_R8;\n", "  undefined8 in_R9;\n", "  int iVar5;\n", "  bool bVar6;\n", "  undefined4 in_XMM0_Da;\n", "  undefined4 in_XMM1_Da;\n", "  undefined4 in_XMM2_Da;\n", "  undefined4 in_XMM3_Da;\n", "  undefined4 in_XMM4_Da;\n", "  undefined4 in_XMM5_Da;\n", "  undefined4 in_XMM6_Da;\n", "  undefined4 in_XMM7_Da;\n", "  va_list va;\n", "  u_int8_t msg [255];\n", "  undefined local_d8 [24];\n", "  undefined8 local_c0;\n", "  undefined8 local_b8;\n", "  undefined8 local_b0;\n", "  undefined4 local_a8;\n", "  undefined4 local_98;\n", "  undefined4 local_88;\n", "  undefined4 local_78;\n", "  undefined4 local_68;\n", "  undefined4 local_58;\n", "  undefined4 local_48;\n", "  undefined4 local_38;\n", "  \n", "  if (in_AL != '\\0') {\n", "    local_a8 = in_XMM0_Da;\n", "    local_98 = in_XMM1_Da;\n", "    local_88 = in_XMM2_Da;\n", "    local_78 = in_XMM3_Da;\n", "    local_68 = in_XMM4_Da;\n", "    local_58 = in_XMM5_Da;\n", "    local_48 = in_XMM6_Da;\n", "    local_38 = in_XMM7_Da;\n", "  }\n", "  va[0].overflow_arg_area = &stack0x00000008;\n", "  va[0].reg_save_area = local_d8;\n", "  va[0].gp_offset = 0x18;\n", "  va[0].fp_offset = 0x30;\n", "  local_c0 = in_RCX;\n", "  local_b8 = in_R8;\n", "  local_b0 = in_R9;\n", "  vsnprintf((char *)msg,0x100,(char *)msgp,va);\n", "  puVar1 = (uint *)msg;\n", "  do {\n", "    puVar2 = puVar1;\n", "    uVar4 = *puVar2 + 0xfefefeff & ~*puVar2;\n", "    _bVar3 = uVar4 & 0x80808080;\n", "    bVar3 = (byte)_bVar3;\n", "    puVar1 = puVar2 + 1;\n", "  } while (_bVar3 == 0);\n", "  bVar6 = (uVar4 & 0x8080) == 0;\n", "  if (bVar6) {\n", "    bVar3 = (byte)(_bVar3 >> 0x10);\n", "  }\n", "  iVar5 = (int)(puVar2 + 1);\n", "  if (bVar6) {\n", "    iVar5 = (int)puVar2 + 6;\n", "  }\n", "  uVar4 = 0;\n", "  if (0 < bnl) {\n", "    do {\n", "      uVar4 = uVar4 + 1;\n", "      fputc(10,stdout);\n", "    } while ((int)(uVar4 & 0xffff) < bnl);\n", "  }\n", "  uVar4 = 0;\n", "  fprintf(stdout,\"-| %s |-\",msg);\n", "  iVar5 = 0x46 - (((iVar5 + -3) - (uint)CARRY1(bVar3,bVar3)) - (int)msg & 0xffff);\n", "  if (0 < iVar5) {\n", "    do {\n", "      uVar4 = uVar4 + 1;\n", "      fputc(0x2d,stdout);\n", "    } while ((int)(uVar4 & 0xffff) < iVar5);\n", "  }\n", "  uVar4 = 0;\n", "  if (0 < anl) {\n", "    do {\n", "      uVar4 = uVar4 + 1;\n", "      fputc(10,stdout);\n", "    } while ((int)(uVar4 & 0xffff) < anl);\n", "  }\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "print_separator(int bnl, int anl, u_int8_t *msgp, ...)\n", "{\n", "    u_int16_t i;\n", "    u_int16_t max_len = 76;\n", "    u_int16_t msg_len = 0;\n", "    u_int8_t msg[255];\n", "\n", "    va_list va;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: print_separator()\\n\");\n", "#endif\n", "\n", "    va_start(va, msgp);\n", "    vsnprintf(msg, 256, msgp, va);\n", "\n", "    msg_len = strlen(msg);\n", "\n", "    for(i = 0; i < bnl; i++)\n", "        fprintf(stdout, \"\\n\");\n", "\n", "    fprintf(stdout, \"-| %s |-\", msg);\n", "\n", "    for(i = 0; i < (max_len - msg_len - 6); i++)\n", "        fprintf(stdout, \"-\");\n", "\n", "    for(i = 0; i < anl; i++)\n", "        fprintf(stdout, \"\\n\");\n", "\n", "    return;\n", "}"]}, {"ghidra": ["\n", "/* WARNING: Could not reconcile some variable overlaps */\n", "\n", "u_int16_t tcp_hdr(u_int8_t *packet,u_int16_t diff)\n", "\n", "{\n", "  ushort *puVar1;\n", "  uint uVar2;\n", "  byte bVar3;\n", "  ushort uVar4;\n", "  int iVar5;\n", "  undefined8 *puVar6;\n", "  undefined8 *puVar7;\n", "  uint *puVar8;\n", "  uint *puVar9;\n", "  byte bVar10;\n", "  uint uVar11;\n", "  ulong uVar12;\n", "  bool bVar13;\n", "  undefined8 uVar14;\n", "  u_int8_t flags [7];\n", "  \n", "  puVar6 = (undefined8 *)malloc(0x20);\n", "  puVar7 = (undefined8 *)malloc(0x20);\n", "  *puVar7 = 0;\n", "  puVar7[1] = 0;\n", "  puVar7[2] = 0;\n", "  puVar7[3] = 0;\n", "  uVar12 = (ulong)hdr_len;\n", "  puVar6[1] = 0;\n", "  *puVar6 = 0;\n", "  puVar6[2] = 0;\n", "  puVar6[3] = 0;\n", "  flags._0_4_ = 0;\n", "  flags._4_2_ = 0;\n", "  flags[6] = '\\0';\n", "  puVar1 = (ushort *)(packet + uVar12 + 0x14);\n", "  bVar3 = *(byte *)((long)puVar1 + 0xd);\n", "  puVar9 = (uint *)flags;\n", "  if ((bVar3 & 0x20) != 0) {\n", "    do {\n", "      puVar8 = puVar9;\n", "      uVar11 = *puVar8 + 0xfefefeff & ~*puVar8;\n", "      _bVar3 = uVar11 & 0x80808080;\n", "      bVar10 = (byte)_bVar3;\n", "      puVar9 = puVar8 + 1;\n", "    } while (_bVar3 == 0);\n", "    bVar13 = (uVar11 & 0x8080) == 0;\n", "    if (bVar13) {\n", "      bVar10 = (byte)(_bVar3 >> 0x10);\n", "    }\n", "    if (bVar13) {\n", "      puVar9 = (uint *)((long)puVar8 + 6);\n", "    }\n", "    *(undefined2 *)((long)puVar9 + (-3 - (ulong)CARRY1(bVar10,bVar10))) = 0x55;\n", "  }\n", "  puVar9 = (uint *)flags;\n", "  if ((bVar3 & 0x10) != 0) {\n", "    do {\n", "      puVar8 = puVar9;\n", "      uVar11 = *puVar8 + 0xfefefeff & ~*puVar8;\n", "      _bVar3 = uVar11 & 0x80808080;\n", "      bVar10 = (byte)_bVar3;\n", "      puVar9 = puVar8 + 1;\n", "    } while (_bVar3 == 0);\n", "    bVar13 = (uVar11 & 0x8080) == 0;\n", "    if (bVar13) {\n", "      bVar10 = (byte)(_bVar3 >> 0x10);\n", "    }\n", "    if (bVar13) {\n", "      puVar9 = (uint *)((long)puVar8 + 6);\n", "    }\n", "    *(undefined2 *)((long)puVar9 + (-3 - (ulong)CARRY1(bVar10,bVar10))) = 0x41;\n", "  }\n", "  puVar9 = (uint *)flags;\n", "  if ((bVar3 & 8) != 0) {\n", "    do {\n", "      puVar8 = puVar9;\n", "      uVar11 = *puVar8 + 0xfefefeff & ~*puVar8;\n", "      _bVar3 = uVar11 & 0x80808080;\n", "      bVar10 = (byte)_bVar3;\n", "      puVar9 = puVar8 + 1;\n", "    } while (_bVar3 == 0);\n", "    bVar13 = (uVar11 & 0x8080) == 0;\n", "    if (bVar13) {\n", "      bVar10 = (byte)(_bVar3 >> 0x10);\n", "    }\n", "    if (bVar13) {\n", "      puVar9 = (uint *)((long)puVar8 + 6);\n", "    }\n", "    *(undefined2 *)((long)puVar9 + (-3 - (ulong)CARRY1(bVar10,bVar10))) = 0x50;\n", "  }\n", "  puVar9 = (uint *)flags;\n", "  if ((bVar3 & 4) != 0) {\n", "    do {\n", "      puVar8 = puVar9;\n", "      uVar11 = *puVar8 + 0xfefefeff & ~*puVar8;\n", "      _bVar3 = uVar11 & 0x80808080;\n", "      bVar10 = (byte)_bVar3;\n", "      puVar9 = puVar8 + 1;\n", "    } while (_bVar3 == 0);\n", "    bVar13 = (uVar11 & 0x8080) == 0;\n", "    if (bVar13) {\n", "      bVar10 = (byte)(_bVar3 >> 0x10);\n", "    }\n", "    if (bVar13) {\n", "      puVar9 = (uint *)((long)puVar8 + 6);\n", "    }\n", "    *(undefined2 *)((long)puVar9 + (-3 - (ulong)CARRY1(bVar10,bVar10))) = 0x52;\n", "  }\n", "  puVar9 = (uint *)flags;\n", "  if ((bVar3 & 2) != 0) {\n", "    do {\n", "      puVar8 = puVar9;\n", "      uVar11 = *puVar8 + 0xfefefeff & ~*puVar8;\n", "      _bVar3 = uVar11 & 0x80808080;\n", "      bVar10 = (byte)_bVar3;\n", "      puVar9 = puVar8 + 1;\n", "    } while (_bVar3 == 0);\n", "    bVar13 = (uVar11 & 0x8080) == 0;\n", "    if (bVar13) {\n", "      bVar10 = (byte)(_bVar3 >> 0x10);\n", "    }\n", "    if (bVar13) {\n", "      puVar9 = (uint *)((long)puVar8 + 6);\n", "    }\n", "    *(undefined2 *)((long)puVar9 + (-3 - (ulong)CARRY1(bVar10,bVar10))) = 0x53;\n", "  }\n", "  puVar9 = (uint *)flags;\n", "  if ((bVar3 & 1) != 0) {\n", "    do {\n", "      puVar8 = puVar9;\n", "      uVar11 = *puVar8 + 0xfefefeff & ~*puVar8;\n", "      _bVar3 = uVar11 & 0x80808080;\n", "      bVar3 = (byte)_bVar3;\n", "      puVar9 = puVar8 + 1;\n", "    } while (_bVar3 == 0);\n", "    bVar13 = (uVar11 & 0x8080) == 0;\n", "    if (bVar13) {\n", "      bVar3 = (byte)(_bVar3 >> 0x10);\n", "    }\n", "    if (bVar13) {\n", "      puVar9 = (uint *)((long)puVar8 + 6);\n", "    }\n", "    *(undefined2 *)((long)puVar9 + (-3 - (ulong)CARRY1(bVar3,bVar3))) = 0x46;\n", "  }\n", "  flags._4_2_ = flags._4_2_ & 0xff00;\n", "  flags._0_4_ = 0x656e6f4e;\n", "  fprintf(stdout,\"TCP header:  Src Port: %d  Dst Port: %d  Flag(s): %s\\n\",\n", "          (ulong)(ushort)(*puVar1 >> 8 | *puVar1 << 8),\n", "          (ulong)(ushort)(puVar1[1] >> 8 | puVar1[1] << 8),flags);\n", "  fprintf(stdout,\"\\t     Window: %d  \",(ulong)(ushort)(puVar1[7] >> 8 | puVar1[7] << 8));\n", "  uVar11 = *(uint *)(puVar1 + 2);\n", "  if (uVar11 != 0) {\n", "    fprintf(stdout,\"Seqn: %lu  \",\n", "            (ulong)(uVar11 >> 0x18 | (uVar11 & 0xff0000) >> 8 | (uVar11 & 0xff00) << 8 |\n", "                   uVar11 << 0x18));\n", "  }\n", "  uVar11 = *(uint *)(puVar1 + 4);\n", "  if (uVar11 != 0) {\n", "    fprintf(stdout,\"Ackn: %lu  \",\n", "            (ulong)(uVar11 >> 0x18 | (uVar11 & 0xff0000) >> 8 | (uVar11 & 0xff00) << 8 |\n", "                   uVar11 << 0x18));\n", "  }\n", "  uVar4 = puVar1[9];\n", "  if (uVar4 != 0) {\n", "    fprintf(stdout,\"Urg: %d  \",(ulong)(ushort)(uVar4 >> 8 | uVar4 << 8));\n", "  }\n", "  uVar14 = 0x402c35;\n", "  fputc(10,stdout);\n", "  uVar11 = (uint)diff + (uint)(*(byte *)(puVar1 + 6) >> 4) * -4;\n", "  payload_len = (u_int16_t)uVar11;\n", "  if (payload_len == 0) {\n", "    uVar4 = puVar1[9];\n", "    uVar12 = 0x14;\n", "    packet = (u_int8_t *)0x0;\n", "  }\n", "  else {\n", "    uVar12 = (ulong)(ushort)(payload_len + 0x14);\n", "    packet = packet + (ulong)hdr_len + 0x14 + (ulong)(*(byte *)(puVar1 + 6) >> 4) * 4;\n", "    uVar4 = puVar1[9];\n", "  }\n", "  _bVar3 = *(uint *)(puVar1 + 4);\n", "  uVar2 = *(uint *)(puVar1 + 2);\n", "  iVar5 = libnet_build_tcp((ulong)(ushort)(*puVar1 >> 8 | *puVar1 << 8),\n", "                           (ulong)(ushort)(puVar1[1] >> 8 | puVar1[1] << 8),\n", "                           (ulong)(uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 |\n", "                                  uVar2 << 0x18),\n", "                           (ulong)(_bVar3 >> 0x18 | (_bVar3 & 0xff0000) >> 8 |\n", "                                   (_bVar3 & 0xff00) << 8 | _bVar3 << 0x18),\n", "                           (ulong)*(byte *)((long)puVar1 + 0xd),\n", "                           (ulong)(ushort)(puVar1[7] >> 8 | puVar1[7] << 8),0,\n", "                           (ulong)(ushort)(uVar4 >> 8 | uVar4 << 8),uVar12,packet,\n", "                           (ulong)(uVar11 & 0xffff),pkt_d,0,uVar14);\n", "  if (iVar5 == -1) {\n", "    uVar14 = libnet_geterror(pkt_d);\n", "    fatal_error((u_int8_t *)\"Unable to build TCP header: %s\",uVar14);\n", "  }\n", "  return (u_int16_t)((ushort)(*(byte *)(puVar1 + 6) >> 4) * 4 - 0x14);\n", "}\n", "\n"], "c": ["u_int16_t\n", "tcp_hdr(u_int8_t *packet, u_int16_t diff)\n", "{\n", "    u_int8_t flags[7];\n", "\n", "    struct libnet_tcp_hdr *tcphdr;\n", "    struct servent *port_src, *port_dst;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: tcp_hdr()\\n\");\n", "#endif\n", "\n", "    port_src = malloc(sizeof(struct servent));\n", "    port_dst = malloc(sizeof(struct servent));\n", "\n", "    memset(port_src, 0, sizeof(struct servent));\n", "    memset(port_dst, 0, sizeof(struct servent));\n", "    memset(flags, 0, sizeof(flags));\n", "\n", "    tcphdr = (struct libnet_tcp_hdr *)(packet + IPV4_H + hdr_len);\n", "\n", "    if(tcphdr->th_flags & TH_URG)\n", "        strcat(flags, \"U\");\n", "\n", "    if(tcphdr->th_flags & TH_ACK)\n", "        strcat(flags, \"A\");\n", "\n", "    if(tcphdr->th_flags & TH_PUSH)\n", "        strcat(flags, \"P\");\n", "\n", "    if(tcphdr->th_flags & TH_RST)\n", "        strcat(flags, \"R\");\n", "\n", "    if(tcphdr->th_flags & TH_SYN)\n", "        strcat(flags, \"S\");\n", "\n", "    if(tcphdr->th_flags & TH_FIN)\n", "        strcat(flags, \"F\");\n", "\n", "    if(strlen(flags) == 0)\n", "        strcpy(flags, \"None\");\n", "\n", "    fprintf(stdout, \"TCP header:  Src Port: %d  Dst Port: %d  Flag(s): %s\\n\",\n", "        htons(tcphdr->th_sport),\n", "        htons(tcphdr->th_dport),\n", "        flags);\n", "\n", "    fprintf(stdout, \"\\t     Window: %d  \", htons(tcphdr->th_win));\n", "\n", "    if(tcphdr->th_seq > 0)\n", "        fprintf(stdout, \"Seqn: %lu  \", (u_long)ntohl(tcphdr->th_seq));\n", "\n", "    if(tcphdr->th_ack > 0)\n", "        fprintf(stdout, \"Ackn: %lu  \", (u_long)ntohl(tcphdr->th_ack));\n", "\n", "    if(tcphdr->th_urp)\n", "        fprintf(stdout, \"Urg: %d  \", ntohs(tcphdr->th_urp));\n", "\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    payload_len = diff - (tcphdr->th_off * 4);\n", "\n", "    if(libnet_build_tcp(\n", "        htons(tcphdr->th_sport),\n", "        htons(tcphdr->th_dport),\n", "        (u_long)ntohl(tcphdr->th_seq),\n", "        (u_long)ntohl(tcphdr->th_ack),\n", "        tcphdr->th_flags,\n", "        htons(tcphdr->th_win),\n", "        0,\n", "        ntohs(tcphdr->th_urp),\n", "        TCP_H + payload_len, \n", "        (payload_len == 0) ? NULL : packet + hdr_len + IPV4_H + (tcphdr->th_off * 4),\n", "        payload_len, \n", "        pkt_d,\n", "        0) == -1)\n", "    {\n", "        fatal_error(\"Unable to build TCP header: %s\", libnet_geterror(pkt_d));\n", "    }\n", "\n", "\n", "    return (tcphdr->th_off * 4) - TCP_H;\n", "}"]}, {"ghidra": ["\n", "void print_usage(void)\n", "\n", "{\n", "  fwrite(\n", "         \"Usage: 4g8 -i <device> -g <gw_ip> -G <gw_mac> -s <host_ip> -S <host_mac> [-w file] [-Xh]\\n\\n\"\n", "         ,1,0x5a,stdout);\n", "  fwrite(\"Required:\\n\",1,10,stdout);\n", "  fwrite(\"  -g gw_ip    IP address of gateway to impersonate\\n\",1,0x33,stdout);\n", "  fwrite(\"  -G gw_mac   MAC address of gateway to impersonate\\n\",1,0x34,stdout);\n", "  fwrite(\"  -s host_ip  IP address of victim host\\n\",1,0x28,stdout);\n", "  fwrite(\"  -S host_mac MAC address of victim host\\n\",1,0x29,stdout);\n", "  fputc(10,stdout);\n", "  fwrite(\"Options:\\n\",1,9,stdout);\n", "  fwrite(\"  -h          Display this message\\n\",1,0x23,stdout);\n", "  fwrite(\"  -i device   Device to listen on\\n\",1,0x22,stdout);\n", "  fwrite(\"  -w file     Write captured data to file\\n\",1,0x2a,stdout);\n", "  fwrite(\"  -X          Dump the packet in hex and ascii\\n\",1,0x2f,stdout);\n", "  fputc(10,stdout);\n", "  fprintf(stdout,\"Version: %s\\n\",&DAT_00404734);\n", "  fprintf(stdout,\"Author:  %s\\n\",\"Darren Bounds <dbounds@intrusense.com>\");\n", "  fprintf(stdout,\"Website: %s\\n\",\"http://forgate.sourceforge.net\");\n", "  fputc(10,stdout);\n", "                    /* WARNING: Subroutine does not return */\n", "  exit(1);\n", "}\n", "\n"], "c": ["void\n", "print_usage()\n", "{\n", "    fprintf(stdout, \"Usage: 4g8 -i <device> -g <gw_ip> -G <gw_mac> -s <host_ip> -S <host_mac> [-w file] [-Xh]\\n\\n\");\n", "\n", "    fprintf(stdout, \"Required:\\n\");\n", "    fprintf(stdout, \"  -g gw_ip    IP address of gateway to impersonate\\n\");\n", "    fprintf(stdout, \"  -G gw_mac   MAC address of gateway to impersonate\\n\");\n", "    fprintf(stdout, \"  -s host_ip  IP address of victim host\\n\");\n", "    fprintf(stdout, \"  -S host_mac MAC address of victim host\\n\");\n", "    fprintf(stdout, \"\\n\");\n", "\n", "    fprintf(stdout, \"Options:\\n\");    \n", "    fprintf(stdout, \"  -h          Display this message\\n\");\n", "    fprintf(stdout, \"  -i device   Device to listen on\\n\");\n", "    fprintf(stdout, \"  -w file     Write captured data to file\\n\");\n", "    fprintf(stdout, \"  -X          Dump the packet in hex and ascii\\n\");\n", "    fprintf(stdout, \"\\n\");\n", "    \n", "    fprintf(stdout, \"Version: %s\\n\", FG_VERSION); \n", "    fprintf(stdout, \"Author:  %s\\n\", FG_AUTHOR);\n", "    fprintf(stdout, \"Website: %s\\n\", FG_SITE);\n", "    fprintf(stdout, \"\\n\");\n", "   \n", "    exit(SUCCESS);\n", "}"]}, {"ghidra": ["\n", "void udp_hdr(u_int8_t *packet,u_int16_t diff)\n", "\n", "{\n", "  ushort *puVar1;\n", "  ushort uVar2;\n", "  int iVar3;\n", "  undefined8 uVar4;\n", "  u_int8_t *puVar5;\n", "  \n", "  puVar1 = (ushort *)(packet + (ulong)hdr_len + 0x14);\n", "  fprintf(stdout,\"UDP header:  Src Port: %d  Dst Port: %d  Len: %d  \",\n", "          (ulong)(ushort)(*puVar1 >> 8 | *puVar1 << 8),\n", "          (ulong)(ushort)(puVar1[1] >> 8 | puVar1[1] << 8),\n", "          (ulong)(ushort)(puVar1[2] >> 8 | puVar1[2] << 8));\n", "  fputc(10,stdout);\n", "  uVar2 = puVar1[2];\n", "  puVar5 = (u_int8_t *)0x0;\n", "  payload_len = (uVar2 >> 8 | uVar2 << 8) - 8;\n", "  if (payload_len != 0) {\n", "    puVar5 = packet + (ulong)hdr_len + 0x1c;\n", "  }\n", "  iVar3 = libnet_build_udp((ulong)(ushort)(*puVar1 >> 8 | *puVar1 << 8),\n", "                           (ulong)(ushort)(puVar1[1] >> 8 | puVar1[1] << 8),\n", "                           (ulong)(ushort)(uVar2 >> 8 | uVar2 << 8),(ulong)puVar1[3],puVar5,\n", "                           (ulong)payload_len);\n", "  if (iVar3 != -1) {\n", "    return;\n", "  }\n", "  uVar4 = libnet_geterror(pkt_d);\n", "  fatal_error((u_int8_t *)\"Unable to build UDP header: %s\",uVar4);\n", "  return;\n", "}\n", "\n"], "c": ["void\n", "udp_hdr(u_int8_t *packet, u_int16_t diff)\n", "{\n", "    struct libnet_udp_hdr *udphdr;\n", "\n", "#ifdef DEBUG\n", "    fprintf(stdout, \"DEBUG: udp_hdr()\\n\");\n", "#endif\n", "\n", "    udphdr = (struct libnet_udp_hdr *)(packet + IPV4_H + hdr_len);\n", "\n", "    fprintf(stdout, \"UDP header:  Src Port: %d  Dst Port: %d  Len: %d  \",\n", "        htons(udphdr->uh_sport),\n", "        htons(udphdr->uh_dport),\n", "        ntohs(udphdr->uh_ulen)); \n", "    \n", "    fprintf(stdout, \"\\n\");\n", "\n", "    payload_len = ntohs(udphdr->uh_ulen) - 8;\n", "\n", "    if(libnet_build_udp(\n", "        htons(udphdr->uh_sport),\n", "        htons(udphdr->uh_dport),\n", "        ntohs(udphdr->uh_ulen),\n", "        udphdr->uh_sum,\n", "        (payload_len == 0) ? NULL : packet + hdr_len + IPV4_H + 8,\n", "        payload_len, \n", "        pkt_d,\n", "        0) == -1)\n", "    {\n", "        fatal_error(\"Unable to build UDP header: %s\", libnet_geterror(pkt_d));\n", "    }\n", "\n", "    return;\n", "}"]}]}